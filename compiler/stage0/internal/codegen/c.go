package codegen

import (
	"bytes"
	"fmt"
	"sort"

	"voxlang/internal/ir"
)

type EmitOptions struct {
	// When true, emit a C entrypoint main() that calls vox main and prints its return value.
	EmitDriverMain bool
}

func EmitC(p *ir.Program, opts EmitOptions) (string, error) {
	if p == nil {
		return "", fmt.Errorf("nil program")
	}

	var out bytes.Buffer
	out.WriteString("// generated by vox stage0\n")
	out.WriteString("#include <stdint.h>\n")
	out.WriteString("#include <stdbool.h>\n")
	out.WriteString("#include <inttypes.h>\n")
	out.WriteString("#include <stdio.h>\n")
	out.WriteString("#include <stdlib.h>\n\n")
	out.WriteString("#include <string.h>\n\n")

	// Minimal Vec runtime (stage0): by-value elements, no drop glue.
	out.WriteString("typedef struct { uint8_t* data; int32_t len; int32_t cap; int32_t elem_size; } vox_vec;\n")
	out.WriteString("static vox_vec vox_vec_new(int32_t elem_size) {\n")
	out.WriteString("  vox_vec v; v.data = NULL; v.len = 0; v.cap = 0; v.elem_size = elem_size; return v;\n")
	out.WriteString("}\n")
	out.WriteString("static void vox_vec_grow(vox_vec* v, int32_t new_cap) {\n")
	out.WriteString("  if (new_cap <= v->cap) return;\n")
	out.WriteString("  if (new_cap < 4) new_cap = 4;\n")
	out.WriteString("  size_t bytes = (size_t)new_cap * (size_t)v->elem_size;\n")
	out.WriteString("  uint8_t* p = (uint8_t*)realloc(v->data, bytes);\n")
	out.WriteString("  if (!p) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  v->data = p; v->cap = new_cap;\n")
	out.WriteString("}\n")
	out.WriteString("static void vox_vec_push(vox_vec* v, const void* elem) {\n")
	out.WriteString("  if (v->len == v->cap) { int32_t nc = v->cap == 0 ? 4 : v->cap * 2; vox_vec_grow(v, nc); }\n")
	out.WriteString("  memcpy(v->data + (size_t)v->len * (size_t)v->elem_size, elem, (size_t)v->elem_size);\n")
	out.WriteString("  v->len++;\n")
	out.WriteString("}\n")
	out.WriteString("static int32_t vox_vec_len(const vox_vec* v) { return v->len; }\n")
	out.WriteString("static void vox_vec_get(const vox_vec* v, int32_t idx, void* out) {\n")
	out.WriteString("  if (idx < 0 || idx >= v->len) { fprintf(stderr, \"vec index out of bounds\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, v->data + (size_t)idx * (size_t)v->elem_size, (size_t)v->elem_size);\n")
	out.WriteString("}\n\n")

	// Runtime builtins
	out.WriteString("static void vox_builtin_panic(const char* msg) {\n")
	out.WriteString("  if (!msg) msg = \"\";\n")
	out.WriteString("  fprintf(stderr, \"%s\\n\", msg);\n")
	out.WriteString("  exit(1);\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_print(const char* msg) {\n")
	out.WriteString("  if (!msg) msg = \"\";\n")
	out.WriteString("  fputs(msg, stdout);\n")
	out.WriteString("  fflush(stdout);\n")
	out.WriteString("}\n\n")

	// Nominal type defs (struct/enum) must come before function decls.
	// Enums are lowered to tagged unions.
	if err := emitNominalTypes(&out, p); err != nil {
		return "", err
	}

	// Forward decls
	names := make([]string, 0, len(p.Funcs))
	for name := range p.Funcs {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		f := p.Funcs[name]
		out.WriteString("static ")
		out.WriteString(cType(f.Ret))
		out.WriteByte(' ')
		out.WriteString(cFnName(f.Name))
		out.WriteByte('(')
		for i, pa := range f.Params {
			if i > 0 {
				out.WriteString(", ")
			}
			out.WriteString(cType(pa.Ty))
			out.WriteByte(' ')
			out.WriteString(cParamName(i, pa.Name))
		}
		out.WriteString(");\n")
	}
	out.WriteString("\n")

	for _, name := range names {
		f := p.Funcs[name]
		if err := emitFunc(&out, p, f); err != nil {
			return "", err
		}
		out.WriteString("\n")
	}

	if opts.EmitDriverMain {
		mainFn, ok := p.Funcs["main"]
		if !ok {
			return "", fmt.Errorf("missing function main")
		}
		out.WriteString("int main(void) {\n")
		switch mainFn.Ret.K {
		case ir.TUnit:
			out.WriteString("  ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
		case ir.TBool:
			out.WriteString("  bool v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%s\\n\", v ? \"true\" : \"false\");\n")
		case ir.TI32:
			out.WriteString("  int32_t v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%\" PRId32 \"\\n\", v);\n")
		case ir.TI64:
			out.WriteString("  int64_t v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%\" PRId64 \"\\n\", v);\n")
		case ir.TString:
			out.WriteString("  const char* v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%s\\n\", v ? v : \"\");\n")
		default:
			return "", fmt.Errorf("unsupported main return type in driver")
		}
		out.WriteString("  return 0;\n")
		out.WriteString("}\n")
	}

	return out.String(), nil
}

// C naming/value helpers live in c_names.go/c_values.go.
