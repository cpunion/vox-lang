package codegen

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"voxlang/internal/ir"
)

type EmitOptions struct {
	// When true, emit a C entrypoint main() that calls vox main and prints its return value.
	EmitDriverMain bool
}

func EmitC(p *ir.Program, opts EmitOptions) (string, error) {
	if p == nil {
		return "", fmt.Errorf("nil program")
	}

	var out bytes.Buffer
	out.WriteString("// generated by vox stage0\n")
	out.WriteString("#include <stdint.h>\n")
	out.WriteString("#include <stdbool.h>\n")
	out.WriteString("#include <inttypes.h>\n")
	out.WriteString("#include <stdio.h>\n")
	out.WriteString("#include <stdlib.h>\n\n")
	out.WriteString("#include <string.h>\n\n")

	// Minimal Vec runtime (stage0): by-value elements, no drop glue.
	out.WriteString("typedef struct { uint8_t* data; int32_t len; int32_t cap; int32_t elem_size; } vox_vec;\n")
	out.WriteString("static vox_vec vox_vec_new(int32_t elem_size) {\n")
	out.WriteString("  vox_vec v; v.data = NULL; v.len = 0; v.cap = 0; v.elem_size = elem_size; return v;\n")
	out.WriteString("}\n")
	out.WriteString("static void vox_vec_grow(vox_vec* v, int32_t new_cap) {\n")
	out.WriteString("  if (new_cap <= v->cap) return;\n")
	out.WriteString("  if (new_cap < 4) new_cap = 4;\n")
	out.WriteString("  size_t bytes = (size_t)new_cap * (size_t)v->elem_size;\n")
	out.WriteString("  uint8_t* p = (uint8_t*)realloc(v->data, bytes);\n")
	out.WriteString("  if (!p) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  v->data = p; v->cap = new_cap;\n")
	out.WriteString("}\n")
	out.WriteString("static void vox_vec_push(vox_vec* v, const void* elem) {\n")
	out.WriteString("  if (v->len == v->cap) { int32_t nc = v->cap == 0 ? 4 : v->cap * 2; vox_vec_grow(v, nc); }\n")
	out.WriteString("  memcpy(v->data + (size_t)v->len * (size_t)v->elem_size, elem, (size_t)v->elem_size);\n")
	out.WriteString("  v->len++;\n")
	out.WriteString("}\n")
	out.WriteString("static int32_t vox_vec_len(const vox_vec* v) { return v->len; }\n")
	out.WriteString("static void vox_vec_get(const vox_vec* v, int32_t idx, void* out) {\n")
	out.WriteString("  if (idx < 0 || idx >= v->len) { fprintf(stderr, \"vec index out of bounds\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, v->data + (size_t)idx * (size_t)v->elem_size, (size_t)v->elem_size);\n")
	out.WriteString("}\n\n")

	// Runtime builtins
	out.WriteString("static void vox_builtin_assert(bool cond) {\n")
	out.WriteString("  if (!cond) { fprintf(stderr, \"assertion failed\\n\"); exit(1); }\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_fail(const char* msg) {\n")
	out.WriteString("  if (!msg) msg = \"\";\n")
	out.WriteString("  fprintf(stderr, \"%s\\n\", msg);\n")
	out.WriteString("  exit(1);\n")
	out.WriteString("}\n\n")

	// Nominal type defs (struct/enum) must come before function decls.
	// Enums are lowered to tagged unions.
	if err := emitNominalTypes(&out, p); err != nil {
		return "", err
	}

	// Forward decls
	names := make([]string, 0, len(p.Funcs))
	for name := range p.Funcs {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		f := p.Funcs[name]
		out.WriteString("static ")
		out.WriteString(cType(f.Ret))
		out.WriteByte(' ')
		out.WriteString(cFnName(f.Name))
		out.WriteByte('(')
		for i, pa := range f.Params {
			if i > 0 {
				out.WriteString(", ")
			}
			out.WriteString(cType(pa.Ty))
			out.WriteByte(' ')
			out.WriteString(cParamName(i, pa.Name))
		}
		out.WriteString(");\n")
	}
	out.WriteString("\n")

	for _, name := range names {
		f := p.Funcs[name]
		if err := emitFunc(&out, p, f); err != nil {
			return "", err
		}
		out.WriteString("\n")
	}

	if opts.EmitDriverMain {
		mainFn, ok := p.Funcs["main"]
		if !ok {
			return "", fmt.Errorf("missing function main")
		}
		out.WriteString("int main(void) {\n")
		switch mainFn.Ret.K {
		case ir.TUnit:
			out.WriteString("  ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
		case ir.TBool:
			out.WriteString("  bool v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%s\\n\", v ? \"true\" : \"false\");\n")
		case ir.TI32:
			out.WriteString("  int32_t v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%\" PRId32 \"\\n\", v);\n")
		case ir.TI64:
			out.WriteString("  int64_t v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%\" PRId64 \"\\n\", v);\n")
		case ir.TString:
			out.WriteString("  const char* v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%s\\n\", v ? v : \"\");\n")
		default:
			return "", fmt.Errorf("unsupported main return type in driver")
		}
		out.WriteString("  return 0;\n")
		out.WriteString("}\n")
	}

	return out.String(), nil
}

func emitFunc(out *bytes.Buffer, p *ir.Program, f *ir.Func) error {
	// Collect locals (slots + temps)
	slotTypes := map[int]ir.Type{}
	tempTypes := map[int]ir.Type{}
	for _, b := range f.Blocks {
		for _, ins := range b.Instr {
			switch i := ins.(type) {
			case *ir.SlotDecl:
				slotTypes[i.Slot.ID] = i.Ty
			case *ir.Const:
				tempTypes[i.Dst.ID] = i.Ty
			case *ir.BinOp:
				tempTypes[i.Dst.ID] = i.Ty
			case *ir.Cmp:
				tempTypes[i.Dst.ID] = ir.Type{K: ir.TBool}
			case *ir.And:
				tempTypes[i.Dst.ID] = ir.Type{K: ir.TBool}
			case *ir.Or:
				tempTypes[i.Dst.ID] = ir.Type{K: ir.TBool}
			case *ir.Not:
				tempTypes[i.Dst.ID] = ir.Type{K: ir.TBool}
			case *ir.Load:
				tempTypes[i.Dst.ID] = i.Ty
			case *ir.StructInit:
				tempTypes[i.Dst.ID] = i.Ty
			case *ir.FieldGet:
				tempTypes[i.Dst.ID] = i.Ty
			case *ir.EnumInit:
				tempTypes[i.Dst.ID] = i.Ty
			case *ir.EnumTag:
				tempTypes[i.Dst.ID] = ir.Type{K: ir.TI32}
			case *ir.EnumPayload:
				tempTypes[i.Dst.ID] = i.Ty
			case *ir.VecNew:
				tempTypes[i.Dst.ID] = i.Ty
			case *ir.VecLen:
				tempTypes[i.Dst.ID] = ir.Type{K: ir.TI32}
			case *ir.VecGet:
				tempTypes[i.Dst.ID] = i.Ty
			case *ir.Call:
				if i.Ret.K != ir.TUnit && i.Dst != nil {
					tempTypes[i.Dst.ID] = i.Ret
				}
			}
		}
	}

	out.WriteString("static ")
	out.WriteString(cType(f.Ret))
	out.WriteByte(' ')
	out.WriteString(cFnName(f.Name))
	out.WriteByte('(')
	for i, pa := range f.Params {
		if i > 0 {
			out.WriteString(", ")
		}
		out.WriteString(cType(pa.Ty))
		out.WriteByte(' ')
		out.WriteString(cParamName(i, pa.Name))
	}
	out.WriteString(") {\n")

	// Declare slots
	slotIDs := make([]int, 0, len(slotTypes))
	for id := range slotTypes {
		slotIDs = append(slotIDs, id)
	}
	sort.Ints(slotIDs)
	for _, id := range slotIDs {
		out.WriteString("  ")
		out.WriteString(cType(slotTypes[id]))
		out.WriteByte(' ')
		out.WriteString(cSlotName(id))
		out.WriteString(";\n")
	}

	// Declare temps
	tempIDs := make([]int, 0, len(tempTypes))
	for id := range tempTypes {
		tempIDs = append(tempIDs, id)
	}
	sort.Ints(tempIDs)
	for _, id := range tempIDs {
		out.WriteString("  ")
		out.WriteString(cType(tempTypes[id]))
		out.WriteByte(' ')
		out.WriteString(cTempName(id))
		out.WriteString(";\n")
	}

	if len(slotIDs) > 0 || len(tempIDs) > 0 {
		out.WriteString("\n")
	}

	// Emit blocks
	for _, b := range f.Blocks {
		out.WriteString(cLabelName(b.Name))
		out.WriteString(":\n")
		for _, ins := range b.Instr {
			if err := emitInstr(out, p, ins); err != nil {
				return err
			}
		}
		if b.Term == nil {
			return fmt.Errorf("block %s missing terminator", b.Name)
		}
		if err := emitTerm(out, b.Term); err != nil {
			return err
		}
		out.WriteString("\n")
	}

	out.WriteString("}\n")
	return nil
}

func emitInstr(out *bytes.Buffer, p *ir.Program, ins ir.Instr) error {
	switch i := ins.(type) {
	case *ir.SlotDecl:
		// already declared as a C local
		return nil
	case *ir.Const:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = ")
		out.WriteString(cValue(i.Val))
		out.WriteString(";\n")
		return nil
	case *ir.BinOp:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = ")
		out.WriteString(cValue(i.A))
		out.WriteByte(' ')
		out.WriteString(stringToCOp(string(i.Op)))
		out.WriteByte(' ')
		out.WriteString(cValue(i.B))
		out.WriteString(";\n")
		return nil
	case *ir.Cmp:
		if i.Ty.K == ir.TString {
			// Only equality is supported for strings in stage0 backend.
			if i.Op != ir.CmpEq && i.Op != ir.CmpNe {
				return fmt.Errorf("unsupported string comparison")
			}
			out.WriteString("  ")
			out.WriteString(cTempName(i.Dst.ID))
			out.WriteString(" = (strcmp(")
			out.WriteString(cValue(i.A))
			out.WriteString(", ")
			out.WriteString(cValue(i.B))
			out.WriteString(") ")
			if i.Op == ir.CmpEq {
				out.WriteString("==")
			} else {
				out.WriteString("!=")
			}
			out.WriteString(" 0);\n")
			return nil
		}
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = (")
		out.WriteString(cValue(i.A))
		out.WriteByte(' ')
		out.WriteString(cCmpOp(i.Op))
		out.WriteByte(' ')
		out.WriteString(cValue(i.B))
		out.WriteString(");\n")
		return nil
	case *ir.And:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = (")
		out.WriteString(cValue(i.A))
		out.WriteString(" && ")
		out.WriteString(cValue(i.B))
		out.WriteString(");\n")
		return nil
	case *ir.Or:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = (")
		out.WriteString(cValue(i.A))
		out.WriteString(" || ")
		out.WriteString(cValue(i.B))
		out.WriteString(");\n")
		return nil
	case *ir.Not:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = (!")
		out.WriteString(cValue(i.A))
		out.WriteString(");\n")
		return nil
	case *ir.Store:
		out.WriteString("  ")
		out.WriteString(cSlotName(i.Slot.ID))
		out.WriteString(" = ")
		out.WriteString(cValue(i.Val))
		out.WriteString(";\n")
		return nil
	case *ir.Load:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = ")
		out.WriteString(cSlotName(i.Slot.ID))
		out.WriteString(";\n")
		return nil
	case *ir.StructInit:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = (")
		out.WriteString(cType(i.Ty))
		out.WriteString("){")
		for j, f := range i.Fields {
			if j > 0 {
				out.WriteString(", ")
			}
			out.WriteByte('.')
			out.WriteString(cIdent(f.Name))
			out.WriteString(" = ")
			out.WriteString(cValue(f.Val))
		}
		out.WriteString("};\n")
		return nil
	case *ir.FieldGet:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = ")
		out.WriteString(cValue(i.Recv))
		out.WriteByte('.')
		out.WriteString(cIdent(i.Field))
		out.WriteString(";\n")
		return nil
	case *ir.StoreField:
		out.WriteString("  ")
		out.WriteString(cSlotName(i.Slot.ID))
		out.WriteByte('.')
		out.WriteString(cIdent(i.Field))
		out.WriteString(" = ")
		out.WriteString(cValue(i.Val))
		out.WriteString(";\n")
		return nil
	case *ir.EnumInit:
		en, ok := p.Enums[i.Ty.Name]
		if !ok || en == nil {
			return fmt.Errorf("unknown enum: %s", i.Ty.Name)
		}
		tag, ok := en.VariantIndex[i.Variant]
		if !ok {
			return fmt.Errorf("unknown enum variant: %s.%s", i.Ty.Name, i.Variant)
		}
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = (")
		out.WriteString(cType(i.Ty))
		out.WriteString("){.tag = ")
		out.WriteString(fmt.Sprintf("%d", tag))
		// payload
		hasPayloadUnion := false
		for _, v := range en.Variants {
			if v.Payload != nil {
				hasPayloadUnion = true
				break
			}
		}
		if hasPayloadUnion {
			out.WriteString(", .payload.")
			out.WriteString(cIdent(i.Variant))
			out.WriteString(" = {")
			if i.Payload != nil {
				out.WriteString("._0 = ")
				out.WriteString(cValue(i.Payload))
			} else {
				out.WriteString("._ = 0")
			}
			out.WriteString("}")
		}
		out.WriteString("};\n")
		return nil
	case *ir.EnumTag:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = ")
		out.WriteString(cValue(i.Recv))
		out.WriteString(".tag;\n")
		return nil
	case *ir.EnumPayload:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = ")
		out.WriteString(cValue(i.Recv))
		out.WriteString(".payload.")
		out.WriteString(cIdent(i.Variant))
		out.WriteString("._0;\n")
		return nil
	case *ir.VecNew:
		if i.Ty.K != ir.TVec || i.Ty.Elem == nil {
			return fmt.Errorf("vec_new expects vec type")
		}
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = vox_vec_new((int32_t)sizeof(")
		out.WriteString(cType(*i.Ty.Elem))
		out.WriteString("));\n")
		return nil
	case *ir.VecPush:
		out.WriteString("  vox_vec_push(&")
		out.WriteString(cSlotName(i.Recv.ID))
		out.WriteString(", &")
		out.WriteString(cValue(i.Val))
		out.WriteString(");\n")
		return nil
	case *ir.VecLen:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = vox_vec_len(&")
		out.WriteString(cSlotName(i.Recv.ID))
		out.WriteString(");\n")
		return nil
	case *ir.VecGet:
		out.WriteString("  vox_vec_get(&")
		out.WriteString(cSlotName(i.Recv.ID))
		out.WriteString(", ")
		out.WriteString(cValue(i.Idx))
		out.WriteString(", &")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(");\n")
		return nil
	case *ir.Call:
		// builtin assert
		if i.Name == "assert" || i.Name == "std.testing::assert" {
			if len(i.Args) != 1 {
				return fmt.Errorf("assert expects 1 arg")
			}
			out.WriteString("  vox_builtin_assert(")
			out.WriteString(cValue(i.Args[0]))
			out.WriteString(");\n")
			return nil
		}
		if i.Name == "std.testing::fail" {
			if len(i.Args) != 1 {
				return fmt.Errorf("std.testing::fail expects 1 arg")
			}
			out.WriteString("  vox_builtin_fail(")
			out.WriteString(cValue(i.Args[0]))
			out.WriteString(");\n")
			return nil
		}
		if i.Name == "std.testing::assert_eq_i32" || i.Name == "std.testing::assert_eq_i64" || i.Name == "std.testing::assert_eq_bool" {
			if len(i.Args) != 2 {
				return fmt.Errorf("%s expects 2 args", i.Name)
			}
			out.WriteString("  vox_builtin_assert((")
			out.WriteString(cValue(i.Args[0]))
			out.WriteString(") == (")
			out.WriteString(cValue(i.Args[1]))
			out.WriteString("));\n")
			return nil
		}
		if i.Name == "std.testing::assert_eq_str" {
			if len(i.Args) != 2 {
				return fmt.Errorf("%s expects 2 args", i.Name)
			}
			out.WriteString("  vox_builtin_assert(strcmp(")
			out.WriteString(cValue(i.Args[0]))
			out.WriteString(", ")
			out.WriteString(cValue(i.Args[1]))
			out.WriteString(") == 0);\n")
			return nil
		}
		out.WriteString("  ")
		if i.Ret.K != ir.TUnit {
			out.WriteString(cTempName(i.Dst.ID))
			out.WriteString(" = ")
		}
		out.WriteString(cFnName(i.Name))
		out.WriteByte('(')
		for j, a := range i.Args {
			if j > 0 {
				out.WriteString(", ")
			}
			out.WriteString(cValue(a))
		}
		out.WriteString(");\n")
		return nil
	default:
		return fmt.Errorf("unsupported instr in codegen")
	}
}

func emitTerm(out *bytes.Buffer, t ir.Term) error {
	switch tt := t.(type) {
	case *ir.Ret:
		out.WriteString("  return")
		if tt.Val != nil {
			out.WriteByte(' ')
			out.WriteString(cValue(tt.Val))
		}
		out.WriteString(";\n")
		return nil
	case *ir.Br:
		out.WriteString("  goto ")
		out.WriteString(cLabelName(tt.Target))
		out.WriteString(";\n")
		return nil
	case *ir.CondBr:
		out.WriteString("  if (")
		out.WriteString(cValue(tt.Cond))
		out.WriteString(") goto ")
		out.WriteString(cLabelName(tt.Then))
		out.WriteString("; else goto ")
		out.WriteString(cLabelName(tt.Else))
		out.WriteString(";\n")
		return nil
	default:
		return fmt.Errorf("unsupported terminator")
	}
}

func emitNominalTypes(out *bytes.Buffer, p *ir.Program) error {
	if p == nil {
		return nil
	}

	// Collect all nominal type names. In stage0 these are always by-value.
	// That means we must be able to emit them as plain C typedefs in a strict
	// dependency order (no cycles).
	all := map[string]string{} // name -> "struct"|"enum"
	if p.Structs != nil {
		for name := range p.Structs {
			all[name] = "struct"
		}
	}
	if p.Enums != nil {
		for name := range p.Enums {
			if prev, ok := all[name]; ok && prev != "enum" {
				return fmt.Errorf("nominal name collision: %s is both %s and enum", name, prev)
			}
			all[name] = "enum"
		}
	}
	if len(all) == 0 {
		return nil
	}

	deps := map[string]map[string]struct{}{}
	indeg := map[string]int{}
	for name := range all {
		deps[name] = map[string]struct{}{}
		indeg[name] = 0
	}

	addDep := func(from, to string) error {
		if from == to {
			return fmt.Errorf("cyclic nominal type by-value dependency: %s depends on itself", from)
		}
		if _, ok := all[to]; !ok {
			return fmt.Errorf("unknown nominal type reference: %s -> %s", from, to)
		}
		if _, ok := deps[from][to]; ok {
			return nil
		}
		deps[from][to] = struct{}{}
		indeg[to]++
		return nil
	}

	// struct deps
	for name, st := range p.Structs {
		if st == nil {
			continue
		}
		for _, f := range st.Fields {
			switch f.Ty.K {
			case ir.TStruct, ir.TEnum:
				if err := addDep(name, f.Ty.Name); err != nil {
					return err
				}
			}
		}
	}

	// enum deps (payload types)
	for name, en := range p.Enums {
		if en == nil {
			continue
		}
		for _, v := range en.Variants {
			if v.Payload == nil {
				continue
			}
			switch v.Payload.K {
			case ir.TStruct, ir.TEnum:
				if err := addDep(name, v.Payload.Name); err != nil {
					return err
				}
			}
		}
	}

	// Kahn topo sort with deterministic selection.
	var ready []string
	for name, d := range indeg {
		if d == 0 {
			ready = append(ready, name)
		}
	}
	sort.Strings(ready)

	order := make([]string, 0, len(all))
	for len(ready) > 0 {
		n := ready[0]
		ready = ready[1:]
		order = append(order, n)

		targets := make([]string, 0, len(deps[n]))
		for m := range deps[n] {
			targets = append(targets, m)
		}
		sort.Strings(targets)
		for _, m := range targets {
			indeg[m]--
			if indeg[m] == 0 {
				ready = append(ready, m)
			}
		}
		sort.Strings(ready)
	}

	if len(order) != len(all) {
		var remain []string
		for name, d := range indeg {
			if d > 0 {
				remain = append(remain, name)
			}
		}
		sort.Strings(remain)
		return fmt.Errorf("cyclic nominal types by-value dependency: %s", strings.Join(remain, ", "))
	}

	for _, name := range order {
		switch all[name] {
		case "struct":
			st := p.Structs[name]
			if st == nil {
				return fmt.Errorf("nil struct def: %s", name)
			}
			emitStructTypedef(out, st)
		case "enum":
			en := p.Enums[name]
			if en == nil {
				return fmt.Errorf("nil enum def: %s", name)
			}
			emitEnumTypedef(out, en)
		default:
			return fmt.Errorf("unknown nominal kind: %s", all[name])
		}
		out.WriteString("\n")
	}
	return nil
}

func emitStructTypedef(out *bytes.Buffer, st *ir.Struct) {
	out.WriteString("typedef struct {\n")
	for _, f := range st.Fields {
		out.WriteString("  ")
		out.WriteString(cType(f.Ty))
		out.WriteByte(' ')
		out.WriteString(cIdent(f.Name))
		out.WriteString(";\n")
	}
	out.WriteString("} ")
	out.WriteString(cStructTypeName(st.Name))
	out.WriteString(";\n")
}

func emitEnumTypedef(out *bytes.Buffer, en *ir.Enum) {
	hasPayload := false
	for _, v := range en.Variants {
		if v.Payload != nil {
			hasPayload = true
			break
		}
	}

	// Tagged-union layout:
	//   { int32_t tag; union { struct { T _0; } Variant; struct { uint8_t _; } Unit; ... } payload; }
	// Using per-variant structs keeps the emitted initializers and payload reads simple.
	out.WriteString("typedef struct {\n")
	out.WriteString("  int32_t tag;\n")
	if hasPayload {
		out.WriteString("  union {\n")
		for _, v := range en.Variants {
			out.WriteString("    struct {\n")
			out.WriteString("      ")
			if v.Payload != nil {
				out.WriteString(cType(*v.Payload))
				out.WriteString(" _0;\n")
			} else {
				// Dummy field for unit variants so `.payload.V = { ._ = 0 }` is always valid C.
				out.WriteString("uint8_t _;\n")
			}
			out.WriteString("    } ")
			out.WriteString(cIdent(v.Name))
			out.WriteString(";\n")
		}
		out.WriteString("  } payload;\n")
	}
	out.WriteString("} ")
	out.WriteString(cEnumTypeName(en.Name))
	out.WriteString(";\n")
}

func cType(t ir.Type) string {
	switch t.K {
	case ir.TUnit:
		return "void"
	case ir.TBool:
		return "bool"
	case ir.TI32:
		return "int32_t"
	case ir.TI64:
		return "int64_t"
	case ir.TString:
		return "const char*"
	case ir.TStruct:
		return cStructTypeName(t.Name)
	case ir.TEnum:
		return cEnumTypeName(t.Name)
	case ir.TVec:
		return "vox_vec"
	default:
		return "void"
	}
}

func cFnName(name string) string { return "vox_fn_" + cMangle(name) }

func cLabelName(name string) string { return "vox_blk_" + cIdent(name) }

func cStructTypeName(name string) string { return "vox_struct_" + cMangle(name) }

func cEnumTypeName(name string) string { return "vox_enum_" + cMangle(name) }

func cIdent(s string) string {
	// Best-effort sanitization: keep [A-Za-z0-9_], map others to '_'.
	// This keeps IR readable (may contain "::") while emitting valid C symbols.
	var b strings.Builder
	b.Grow(len(s))
	for i := 0; i < len(s); i++ {
		ch := s[i]
		ok := (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_'
		if !ok {
			ch = '_'
		}
		if i == 0 && (ch >= '0' && ch <= '9') {
			b.WriteByte('_')
		}
		b.WriteByte(ch)
	}
	out := b.String()
	if out == "" {
		return "_"
	}
	return out
}

func cMangle(s string) string {
	// Collision-free mangling for qualified names.
	//
	// We keep [A-Za-z0-9] as-is for readability, and hex-escape everything else,
	// including '_' so that separators like "::" and "." cannot collide with user
	// identifiers that contain underscores.
	//
	// Always prefix with 'm' so the result is a valid C identifier.
	var b strings.Builder
	b.Grow(len(s) + 8)
	b.WriteByte('m')
	for i := 0; i < len(s); i++ {
		ch := s[i]
		ok := (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')
		if ok {
			b.WriteByte(ch)
			continue
		}
		fmt.Fprintf(&b, "_%02x", ch)
	}
	return b.String()
}

func cParamName(i int, name string) string {
	_ = name
	return fmt.Sprintf("p%d", i)
}

func cTempName(id int) string { return fmt.Sprintf("t%d", id) }

func cSlotName(id int) string { return fmt.Sprintf("v%d", id) }

func cValue(v ir.Value) string {
	switch x := v.(type) {
	case *ir.Temp:
		return cTempName(x.ID)
	case *ir.ParamRef:
		return fmt.Sprintf("p%d", x.Index)
	case *ir.Slot:
		return cSlotName(x.ID)
	case *ir.ConstInt:
		return fmt.Sprintf("%d", x.V)
	case *ir.ConstBool:
		if x.V {
			return "true"
		}
		return "false"
	case *ir.ConstStr:
		return cStringLit(x.S)
	default:
		return "0"
	}
}

func cStringLit(s string) string {
	// Emit a valid C string literal.
	// Keep it ASCII-ish; escape control chars and quotes/backslashes.
	var b strings.Builder
	b.WriteByte('"')
	for i := 0; i < len(s); i++ {
		ch := s[i]
		switch ch {
		case '\\':
			b.WriteString("\\\\")
		case '"':
			b.WriteString("\\\"")
		case '\n':
			b.WriteString("\\n")
		case '\r':
			b.WriteString("\\r")
		case '\t':
			b.WriteString("\\t")
		default:
			if ch < 0x20 {
				// generic hex escape
				fmt.Fprintf(&b, "\\x%02x", ch)
			} else {
				b.WriteByte(ch)
			}
		}
	}
	b.WriteByte('"')
	return b.String()
}

func stringToCOp(op string) string {
	switch op {
	case "add":
		return "+"
	case "sub":
		return "-"
	case "mul":
		return "*"
	case "div":
		return "/"
	case "mod":
		return "%"
	default:
		return op
	}
}

func cCmpOp(op ir.CmpKind) string {
	switch op {
	case ir.CmpLt:
		return "<"
	case ir.CmpLe:
		return "<="
	case ir.CmpGt:
		return ">"
	case ir.CmpGe:
		return ">="
	case ir.CmpEq:
		return "=="
	case ir.CmpNe:
		return "!="
	default:
		return "=="
	}
}
