package codegen

import (
	"bytes"
	"fmt"
	"sort"

	"voxlang/internal/ir"
)

type EmitOptions struct {
	// When true, emit a C entrypoint main() that calls vox main and prints its return value.
	EmitDriverMain bool
	// DriverMainKind controls the semantics of the generated C entrypoint when
	// EmitDriverMain is true.
	//
	// Default (zero) is DriverMainUser.
	DriverMainKind DriverMainKind
	// When true, emit a C entrypoint main(argc, argv) that dispatches to vox test_* functions.
	EmitTestMain bool
	// TestFuncs is the ordered list of test function qualified names (e.g. "pkg::mod::test_x").
	// Each test must have signature `fn() -> ()`.
	TestFuncs []TestFunc
}

type DriverMainKind int

const (
	// DriverMainUser prints the return value of vox `main()` (for user programs).
	DriverMainUser DriverMainKind = iota
	// DriverMainTool is quiet and uses the return value of vox `main()` as the process exit code.
	DriverMainTool
)

type TestFunc struct {
	// Name is the IR function name (qualified).
	Name string
}

func EmitC(p *ir.Program, opts EmitOptions) (string, error) {
	if p == nil {
		return "", fmt.Errorf("nil program")
	}
	if opts.EmitDriverMain && opts.EmitTestMain {
		return "", fmt.Errorf("cannot emit both driver main and test main")
	}

	var out bytes.Buffer
	out.WriteString("// generated by vox stage0\n")
	out.WriteString("#include <stdint.h>\n")
	out.WriteString("#include <stdbool.h>\n")
	out.WriteString("#include <inttypes.h>\n")
	out.WriteString("#include <stdio.h>\n")
	out.WriteString("#include <stdlib.h>\n\n")
	out.WriteString("#include <string.h>\n\n")
	out.WriteString("#include <limits.h>\n\n")
	out.WriteString("#include <stddef.h>\n\n")
	out.WriteString("#include <stdatomic.h>\n\n")
	out.WriteString("#include <time.h>\n\n")
	out.WriteString("#include <dirent.h>\n\n")
	out.WriteString("#include <sys/stat.h>\n\n")
	out.WriteString("#if !defined(_WIN32)\n")
	out.WriteString("#include <unistd.h>\n")
	out.WriteString("#include <sys/types.h>\n")
	out.WriteString("#include <sys/socket.h>\n")
	out.WriteString("#include <netdb.h>\n")
	out.WriteString("#endif\n\n")
	out.WriteString("#if defined(_WIN32)\n")
	out.WriteString("#include <direct.h>\n")
	out.WriteString("#endif\n\n")

	// Minimal Vec runtime (stage0): by-value elements, no drop glue.
	out.WriteString("typedef struct { uint8_t* data; int32_t len; int32_t cap; int32_t elem_size; } vox_vec;\n")
	out.WriteString("static vox_vec vox_vec_new(int32_t elem_size) {\n")
	out.WriteString("  vox_vec v; v.data = NULL; v.len = 0; v.cap = 0; v.elem_size = elem_size; return v;\n")
	out.WriteString("}\n")
	out.WriteString("static void vox_vec_grow(vox_vec* v, int32_t new_cap) {\n")
	out.WriteString("  if (new_cap <= v->cap) return;\n")
	out.WriteString("  if (new_cap < 4) new_cap = 4;\n")
	out.WriteString("  size_t bytes = (size_t)new_cap * (size_t)v->elem_size;\n")
	// Stage0 intentionally leaks Vec buffers so plain struct copies of `vox_vec`
	// behave like persistent values (no realloc/free of the old buffer).
	out.WriteString("  uint8_t* p = (uint8_t*)malloc(bytes);\n")
	out.WriteString("  if (!p) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  if (v->data && v->len != 0) {\n")
	out.WriteString("    memcpy(p, v->data, (size_t)v->len * (size_t)v->elem_size);\n")
	out.WriteString("  }\n")
	out.WriteString("  v->data = p; v->cap = new_cap;\n")
	out.WriteString("}\n")
	out.WriteString("static void vox_vec_push(vox_vec* v, const void* elem) {\n")
	out.WriteString("  if (v->len == v->cap) { int32_t nc = v->cap == 0 ? 4 : v->cap * 2; vox_vec_grow(v, nc); }\n")
	out.WriteString("  memcpy(v->data + (size_t)v->len * (size_t)v->elem_size, elem, (size_t)v->elem_size);\n")
	out.WriteString("  v->len++;\n")
	out.WriteString("}\n")
	out.WriteString("static int32_t vox_vec_len(const vox_vec* v) { return v->len; }\n")
	out.WriteString("static void vox_vec_get(const vox_vec* v, int32_t idx, void* out) {\n")
	out.WriteString("  if (idx < 0 || idx >= v->len) { fprintf(stderr, \"vec index out of bounds: idx=%\" PRId32 \" len=%\" PRId32 \"\\n\", idx, v->len); exit(1); }\n")
	out.WriteString("  memcpy(out, v->data + (size_t)idx * (size_t)v->elem_size, (size_t)v->elem_size);\n")
	out.WriteString("}\n\n")

	// Minimal string runtime helpers (stage0).
	out.WriteString("static int32_t vox_str_len(const char* s) {\n")
	out.WriteString("  if (!s) return 0;\n")
	out.WriteString("  size_t n = strlen(s);\n")
	out.WriteString("  if (n > INT32_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }\n")
	out.WriteString("  return (int32_t)n;\n")
	out.WriteString("}\n")
	out.WriteString("static int32_t vox_str_byte_at(const char* s, int32_t idx) {\n")
	out.WriteString("  int32_t n = vox_str_len(s);\n")
	out.WriteString("  if (idx < 0 || idx >= n) { fprintf(stderr, \"string index out of bounds\\n\"); exit(1); }\n")
	out.WriteString("  return (int32_t)(uint8_t)s[idx];\n")
	out.WriteString("}\n\n")
	out.WriteString("static const char* vox_str_slice(const char* s, int32_t start, int32_t end) {\n")
	out.WriteString("  int32_t n = vox_str_len(s);\n")
	out.WriteString("  if (start < 0 || end < start || end > n) { fprintf(stderr, \"string slice out of bounds\\n\"); exit(1); }\n")
	out.WriteString("  int32_t m = end - start;\n")
	out.WriteString("  char* out = (char*)malloc((size_t)m + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, s + start, (size_t)m);\n")
	out.WriteString("  out[m] = '\\0';\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_str_concat(const char* a, const char* b) {\n")
	out.WriteString("  if (!a) a = \"\";\n")
	out.WriteString("  if (!b) b = \"\";\n")
	out.WriteString("  size_t na = strlen(a);\n")
	out.WriteString("  size_t nb = strlen(b);\n")
	out.WriteString("  if (na + nb + 1 > SIZE_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }\n")
	out.WriteString("  char* out = (char*)malloc(na + nb + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, a, na);\n")
	out.WriteString("  memcpy(out + na, b, nb);\n")
	out.WriteString("  out[na + nb] = '\\0';\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_i32_to_string(int32_t v) {\n")
	out.WriteString("  char buf[32];\n")
	out.WriteString("  int n = snprintf(buf, sizeof(buf), \"%\" PRId32, v);\n")
	out.WriteString("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }\n")
	out.WriteString("  char* out = (char*)malloc((size_t)n + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, buf, (size_t)n + 1);\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_i64_to_string(int64_t v) {\n")
	out.WriteString("  char buf[32];\n")
	out.WriteString("  int n = snprintf(buf, sizeof(buf), \"%\" PRId64, v);\n")
	out.WriteString("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }\n")
	out.WriteString("  char* out = (char*)malloc((size_t)n + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, buf, (size_t)n + 1);\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_u64_to_string(uint64_t v) {\n")
	out.WriteString("  char buf[32];\n")
	out.WriteString("  int n = snprintf(buf, sizeof(buf), \"%\" PRIu64, v);\n")
	out.WriteString("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }\n")
	out.WriteString("  char* out = (char*)malloc((size_t)n + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, buf, (size_t)n + 1);\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_bool_to_string(bool v) {\n")
	out.WriteString("  return v ? \"true\" : \"false\";\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_str_escape_c(const char* s) {\n")
	out.WriteString("  if (!s) s = \"\";\n")
	out.WriteString("  size_t n = strlen(s);\n")
	out.WriteString("  // First pass: compute output length.\n")
	out.WriteString("  size_t out_n = 0;\n")
	out.WriteString("  for (size_t i = 0; i < n; i++) {\n")
	out.WriteString("    unsigned char ch = (unsigned char)s[i];\n")
	out.WriteString("    switch (ch) {\n")
	out.WriteString("    case '\\\\':\n")
	out.WriteString("    case '\"':\n")
	out.WriteString("    case '\\n':\n")
	out.WriteString("    case '\\r':\n")
	out.WriteString("    case '\\t':\n")
	out.WriteString("      out_n += 2;\n")
	out.WriteString("      break;\n")
	out.WriteString("    default:\n")
	out.WriteString("      if (ch >= 0x20 && ch <= 0x7e) out_n += 1; else out_n += 4; // \\\\xHH\n")
	out.WriteString("      break;\n")
	out.WriteString("    }\n")
	out.WriteString("  }\n")
	out.WriteString("  char* out = (char*)malloc(out_n + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  size_t j = 0;\n")
	out.WriteString("  for (size_t i = 0; i < n; i++) {\n")
	out.WriteString("    unsigned char ch = (unsigned char)s[i];\n")
	out.WriteString("    switch (ch) {\n")
	out.WriteString("    case '\\\\': out[j++] = '\\\\'; out[j++] = '\\\\'; break;\n")
	out.WriteString("    case '\"': out[j++] = '\\\\'; out[j++] = '\"'; break;\n")
	out.WriteString("    case '\\n': out[j++] = '\\\\'; out[j++] = 'n'; break;\n")
	out.WriteString("    case '\\r': out[j++] = '\\\\'; out[j++] = 'r'; break;\n")
	out.WriteString("    case '\\t': out[j++] = '\\\\'; out[j++] = 't'; break;\n")
	out.WriteString("    default:\n")
	out.WriteString("      if (ch >= 0x20 && ch <= 0x7e) { out[j++] = (char)ch; }\n")
	out.WriteString("      else {\n")
	out.WriteString("        static const char* hex = \"0123456789abcdef\";\n")
	out.WriteString("        out[j++] = '\\\\'; out[j++] = 'x';\n")
	out.WriteString("        out[j++] = hex[(ch >> 4) & 0xf];\n")
	out.WriteString("        out[j++] = hex[ch & 0xf];\n")
	out.WriteString("      }\n")
	out.WriteString("      break;\n")
	out.WriteString("    }\n")
	out.WriteString("  }\n")
	out.WriteString("  out[j] = '\\0';\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_vec_str_join(const vox_vec* v, const char* sep) {\n")
	out.WriteString("  if (!sep) sep = \"\";\n")
	out.WriteString("  if (!v || v->elem_size != (int32_t)sizeof(const char*)) { fprintf(stderr, \"vec_str_join expects Vec[String]\\n\"); exit(1); }\n")
	out.WriteString("  int32_t n = v->len;\n")
	out.WriteString("  const char* const* items = (const char* const*)v->data;\n")
	out.WriteString("  size_t sep_n = strlen(sep);\n")
	out.WriteString("  size_t total = 0;\n")
	out.WriteString("  for (int32_t i = 0; i < n; i++) {\n")
	out.WriteString("    const char* s = items[i];\n")
	out.WriteString("    if (!s) s = \"\";\n")
	out.WriteString("    total += strlen(s);\n")
	out.WriteString("    if (i + 1 < n) total += sep_n;\n")
	out.WriteString("  }\n")
	out.WriteString("  if (total + 1 > SIZE_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }\n")
	out.WriteString("  char* out = (char*)malloc(total + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  size_t j = 0;\n")
	out.WriteString("  for (int32_t i = 0; i < n; i++) {\n")
	out.WriteString("    const char* s = items[i];\n")
	out.WriteString("    if (!s) s = \"\";\n")
	out.WriteString("    size_t m = strlen(s);\n")
	out.WriteString("    memcpy(out + j, s, m);\n")
	out.WriteString("    j += m;\n")
	out.WriteString("    if (i + 1 < n && sep_n != 0) {\n")
	out.WriteString("      memcpy(out + j, sep, sep_n);\n")
	out.WriteString("      j += sep_n;\n")
	out.WriteString("    }\n")
	out.WriteString("  }\n")
	out.WriteString("  out[j] = '\\0';\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	// Runtime builtins
	out.WriteString("static int vox__argc = 0;\n")
	out.WriteString("static char** vox__argv = NULL;\n\n")
	out.WriteString("static void vox_builtin_panic(const char* msg) {\n")
	out.WriteString("  if (!msg) msg = \"\";\n")
	out.WriteString("  fprintf(stderr, \"%s\\n\", msg);\n")
	out.WriteString("  exit(1);\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_print(const char* msg) {\n")
	out.WriteString("  if (!msg) msg = \"\";\n")
	out.WriteString("  fputs(msg, stdout);\n")
	out.WriteString("  fflush(stdout);\n")
	out.WriteString("}\n\n")
	out.WriteString("static vox_vec vox_builtin_args(void) {\n")
	out.WriteString("  vox_vec v = vox_vec_new((int32_t)sizeof(const char*));\n")
	out.WriteString("  for (int i = 1; i < vox__argc; i++) {\n")
	out.WriteString("    const char* s = vox__argv[i];\n")
	out.WriteString("    vox_vec_push(&v, &s);\n")
	out.WriteString("  }\n")
	out.WriteString("  return v;\n")
	out.WriteString("}\n\n")
	out.WriteString("static const char* vox_builtin_exe_path(void) {\n")
	out.WriteString("  if (!vox__argv || vox__argc <= 0 || !vox__argv[0]) return \"\";\n")
	out.WriteString("  return vox__argv[0];\n")
	out.WriteString("}\n\n")
	out.WriteString("static const char* vox_builtin_getenv(const char* key) {\n")
	out.WriteString("  if (!key) key = \"\";\n")
	out.WriteString("  const char* v = getenv(key);\n")
	out.WriteString("  if (!v) return \"\";\n")
	out.WriteString("  return v;\n")
	out.WriteString("}\n\n")
	out.WriteString("static int64_t vox_builtin_now_ns(void) {\n")
	out.WriteString("  struct timespec ts;\n")
	out.WriteString("#if defined(_WIN32)\n")
	out.WriteString("  if (timespec_get(&ts, TIME_UTC) == 0) return 0;\n")
	out.WriteString("#else\n")
	out.WriteString("  if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0) {\n")
	out.WriteString("    if (timespec_get(&ts, TIME_UTC) == 0) return 0;\n")
	out.WriteString("  }\n")
	out.WriteString("#endif\n")
	out.WriteString("  return (int64_t)ts.tv_sec * (int64_t)1000000000 + (int64_t)ts.tv_nsec;\n")
	out.WriteString("}\n\n")
	out.WriteString("static const char* vox_builtin_read_file(const char* path) {\n")
	out.WriteString("  if (!path) path = \"\";\n")
	out.WriteString("  FILE* f = fopen(path, \"rb\");\n")
	out.WriteString("  if (!f) { fprintf(stderr, \"read_file failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  if (fseek(f, 0, SEEK_END) != 0) { fprintf(stderr, \"read_file fseek failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  long n = ftell(f);\n")
	out.WriteString("  if (n < 0) { fprintf(stderr, \"read_file ftell failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  if (fseek(f, 0, SEEK_SET) != 0) { fprintf(stderr, \"read_file fseek failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  char* out = (char*)malloc((size_t)n + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  size_t got = fread(out, 1, (size_t)n, f);\n")
	out.WriteString("  if (got != (size_t)n) { fprintf(stderr, \"read_file fread failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  out[n] = '\\0';\n")
	out.WriteString("  fclose(f);\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_write_file(const char* path, const char* text) {\n")
	out.WriteString("  if (!path) path = \"\";\n")
	out.WriteString("  if (!text) text = \"\";\n")
	out.WriteString("  FILE* f = fopen(path, \"wb\");\n")
	out.WriteString("  if (!f) { fprintf(stderr, \"write_file failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  size_t n = strlen(text);\n")
	out.WriteString("  if (n != 0) {\n")
	out.WriteString("    size_t put = fwrite(text, 1, n, f);\n")
	out.WriteString("    if (put != n) { fprintf(stderr, \"write_file fwrite failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  }\n")
	out.WriteString("  fclose(f);\n")
	out.WriteString("}\n\n")
	out.WriteString("static bool vox_builtin_path_exists(const char* path) {\n")
	out.WriteString("  if (!path || path[0] == '\\0') return false;\n")
	out.WriteString("  struct stat st;\n")
	out.WriteString("  return stat(path, &st) == 0;\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_mkdir_p(const char* path) {\n")
	out.WriteString("  if (!path || path[0] == '\\0') return;\n")
	out.WriteString("  size_t n = strlen(path);\n")
	out.WriteString("  char* tmp = (char*)malloc(n + 1);\n")
	out.WriteString("  if (!tmp) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(tmp, path, n + 1);\n")
	out.WriteString("  for (size_t i = 1; i < n; i++) {\n")
	out.WriteString("    char ch = tmp[i];\n")
	out.WriteString("    if (ch != '/' && ch != '\\\\') continue;\n")
	out.WriteString("    tmp[i] = '\\0';\n")
	out.WriteString("    if (tmp[0] != '\\0' && !vox_builtin_path_exists(tmp)) {\n")
	out.WriteString("#if defined(_WIN32)\n")
	out.WriteString("      if (_mkdir(tmp) != 0) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }\n")
	out.WriteString("#else\n")
	out.WriteString("      if (mkdir(tmp, 0755) != 0) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }\n")
	out.WriteString("#endif\n")
	out.WriteString("    }\n")
	out.WriteString("    tmp[i] = ch;\n")
	out.WriteString("  }\n")
	out.WriteString("  if (!vox_builtin_path_exists(tmp)) {\n")
	out.WriteString("#if defined(_WIN32)\n")
	out.WriteString("    if (_mkdir(tmp) != 0) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }\n")
	out.WriteString("#else\n")
	out.WriteString("    if (mkdir(tmp, 0755) != 0) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }\n")
	out.WriteString("#endif\n")
	out.WriteString("  }\n")
	out.WriteString("  free(tmp);\n")
	out.WriteString("}\n\n")
	out.WriteString("static int32_t vox_builtin_exec(const char* cmd) {\n")
	out.WriteString("  if (!cmd) cmd = \"\";\n")
	out.WriteString("  int r = system(cmd);\n")
	out.WriteString("  return (int32_t)r;\n")
	out.WriteString("}\n\n")
	out.WriteString("static bool vox_str_has_suffix(const char* s, const char* suf) {\n")
	out.WriteString("  if (!s || !suf) return false;\n")
	out.WriteString("  size_t n = strlen(s);\n")
	out.WriteString("  size_t m = strlen(suf);\n")
	out.WriteString("  if (m > n) return false;\n")
	out.WriteString("  return memcmp(s + (n - m), suf, m) == 0;\n")
	out.WriteString("}\n\n")
	out.WriteString("static char* vox_path_join2(const char* a, const char* b) {\n")
	out.WriteString("  if (!a) a = \"\";\n")
	out.WriteString("  if (!b) b = \"\";\n")
	out.WriteString("  size_t na = strlen(a);\n")
	out.WriteString("  size_t nb = strlen(b);\n")
	out.WriteString("  bool slash = (na != 0 && a[na - 1] != '/');\n")
	out.WriteString("  size_t n = na + (slash ? 1 : 0) + nb;\n")
	out.WriteString("  char* out = (char*)malloc(n + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, a, na);\n")
	out.WriteString("  size_t j = na;\n")
	out.WriteString("  if (slash) out[j++] = '/';\n")
	out.WriteString("  memcpy(out + j, b, nb);\n")
	out.WriteString("  out[n] = '\\0';\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_walk_dir(vox_vec* out, const char* root, const char* rel) {\n")
	out.WriteString("  char* full = rel && rel[0] ? vox_path_join2(root, rel) : vox_path_join2(root, \"\");\n")
	out.WriteString("  DIR* d = opendir(full);\n")
	out.WriteString("  if (!d) { free(full); return; }\n")
	out.WriteString("  struct dirent* ent;\n")
	out.WriteString("  while ((ent = readdir(d)) != NULL) {\n")
	out.WriteString("    const char* name = ent->d_name;\n")
	out.WriteString("    if (!name || name[0] == '\\0') continue;\n")
	out.WriteString("    if (strcmp(name, \".\") == 0 || strcmp(name, \"..\") == 0) continue;\n")
	out.WriteString("    char* child_rel = rel && rel[0] ? vox_path_join2(rel, name) : vox_path_join2(\"\", name);\n")
	out.WriteString("    char* child_full = vox_path_join2(root, child_rel);\n")
	out.WriteString("    struct stat st;\n")
	out.WriteString("    if (stat(child_full, &st) == 0 && S_ISDIR(st.st_mode)) {\n")
	out.WriteString("      vox_walk_dir(out, root, child_rel);\n")
	out.WriteString("      free(child_rel);\n")
	out.WriteString("      free(child_full);\n")
	out.WriteString("      continue;\n")
	out.WriteString("    }\n")
	out.WriteString("    if (vox_str_has_suffix(child_rel, \".vox\")) {\n")
	out.WriteString("      const char* s = child_rel;\n")
	out.WriteString("      vox_vec_push(out, &s);\n")
	out.WriteString("    } else {\n")
	out.WriteString("      free(child_rel);\n")
	out.WriteString("    }\n")
	out.WriteString("    free(child_full);\n")
	out.WriteString("  }\n")
	out.WriteString("  closedir(d);\n")
	out.WriteString("  free(full);\n")
	out.WriteString("}\n\n")
	out.WriteString("static vox_vec vox_builtin_walk_vox_files(const char* root) {\n")
	out.WriteString("  if (!root || root[0] == '\\0') root = \".\";\n")
	out.WriteString("  vox_vec out = vox_vec_new((int32_t)sizeof(const char*));\n")
	out.WriteString("  vox_walk_dir(&out, root, \"src\");\n")
	out.WriteString("  vox_walk_dir(&out, root, \"tests\");\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")
	out.WriteString("typedef struct { atomic_flag lock; int32_t value; } vox_mutex_i32;\n")
	out.WriteString("typedef struct { _Atomic int32_t value; } vox_atomic_i32;\n\n")
	out.WriteString("static int64_t vox_builtin_mutex_i32_new(int32_t init) {\n")
	out.WriteString("  vox_mutex_i32* m = (vox_mutex_i32*)malloc(sizeof(vox_mutex_i32));\n")
	out.WriteString("  if (!m) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  atomic_flag_clear(&m->lock);\n")
	out.WriteString("  m->value = init;\n")
	out.WriteString("  return (int64_t)(intptr_t)m;\n")
	out.WriteString("}\n\n")
	out.WriteString("static int32_t vox_builtin_mutex_i32_load(int64_t h) {\n")
	out.WriteString("  vox_mutex_i32* m = (vox_mutex_i32*)(intptr_t)h;\n")
	out.WriteString("  if (!m) { vox_builtin_panic(\"invalid mutex handle\"); }\n")
	out.WriteString("  while (atomic_flag_test_and_set(&m->lock)) {}\n")
	out.WriteString("  int32_t v = m->value;\n")
	out.WriteString("  atomic_flag_clear(&m->lock);\n")
	out.WriteString("  return v;\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_mutex_i32_store(int64_t h, int32_t v) {\n")
	out.WriteString("  vox_mutex_i32* m = (vox_mutex_i32*)(intptr_t)h;\n")
	out.WriteString("  if (!m) { vox_builtin_panic(\"invalid mutex handle\"); }\n")
	out.WriteString("  while (atomic_flag_test_and_set(&m->lock)) {}\n")
	out.WriteString("  m->value = v;\n")
	out.WriteString("  atomic_flag_clear(&m->lock);\n")
	out.WriteString("}\n\n")
	out.WriteString("static int64_t vox_builtin_atomic_i32_new(int32_t init) {\n")
	out.WriteString("  vox_atomic_i32* a = (vox_atomic_i32*)malloc(sizeof(vox_atomic_i32));\n")
	out.WriteString("  if (!a) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  atomic_store_explicit(&a->value, init, memory_order_seq_cst);\n")
	out.WriteString("  return (int64_t)(intptr_t)a;\n")
	out.WriteString("}\n\n")
	out.WriteString("static int32_t vox_builtin_atomic_i32_load(int64_t h) {\n")
	out.WriteString("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;\n")
	out.WriteString("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }\n")
	out.WriteString("  return atomic_load_explicit(&a->value, memory_order_seq_cst);\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_atomic_i32_store(int64_t h, int32_t v) {\n")
	out.WriteString("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;\n")
	out.WriteString("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }\n")
	out.WriteString("  atomic_store_explicit(&a->value, v, memory_order_seq_cst);\n")
	out.WriteString("}\n\n")
	out.WriteString("static int32_t vox_builtin_atomic_i32_fetch_add(int64_t h, int32_t delta) {\n")
	out.WriteString("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;\n")
	out.WriteString("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }\n")
	out.WriteString("  return atomic_fetch_add_explicit(&a->value, delta, memory_order_seq_cst);\n")
	out.WriteString("}\n\n")
	out.WriteString("static int32_t vox_builtin_atomic_i32_swap(int64_t h, int32_t v) {\n")
	out.WriteString("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;\n")
	out.WriteString("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }\n")
	out.WriteString("  return atomic_exchange_explicit(&a->value, v, memory_order_seq_cst);\n")
	out.WriteString("}\n\n")
	out.WriteString("typedef struct { atomic_flag lock; int64_t value; } vox_mutex_i64;\n")
	out.WriteString("typedef struct { _Atomic int64_t value; } vox_atomic_i64;\n\n")
	out.WriteString("static int64_t vox_builtin_mutex_i64_new(int64_t init) {\n")
	out.WriteString("  vox_mutex_i64* m = (vox_mutex_i64*)malloc(sizeof(vox_mutex_i64));\n")
	out.WriteString("  if (!m) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  atomic_flag_clear(&m->lock);\n")
	out.WriteString("  m->value = init;\n")
	out.WriteString("  return (int64_t)(intptr_t)m;\n")
	out.WriteString("}\n\n")
	out.WriteString("static int64_t vox_builtin_mutex_i64_load(int64_t h) {\n")
	out.WriteString("  vox_mutex_i64* m = (vox_mutex_i64*)(intptr_t)h;\n")
	out.WriteString("  if (!m) { vox_builtin_panic(\"invalid mutex handle\"); }\n")
	out.WriteString("  while (atomic_flag_test_and_set(&m->lock)) {}\n")
	out.WriteString("  int64_t v = m->value;\n")
	out.WriteString("  atomic_flag_clear(&m->lock);\n")
	out.WriteString("  return v;\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_mutex_i64_store(int64_t h, int64_t v) {\n")
	out.WriteString("  vox_mutex_i64* m = (vox_mutex_i64*)(intptr_t)h;\n")
	out.WriteString("  if (!m) { vox_builtin_panic(\"invalid mutex handle\"); }\n")
	out.WriteString("  while (atomic_flag_test_and_set(&m->lock)) {}\n")
	out.WriteString("  m->value = v;\n")
	out.WriteString("  atomic_flag_clear(&m->lock);\n")
	out.WriteString("}\n\n")
	out.WriteString("static int64_t vox_builtin_atomic_i64_new(int64_t init) {\n")
	out.WriteString("  vox_atomic_i64* a = (vox_atomic_i64*)malloc(sizeof(vox_atomic_i64));\n")
	out.WriteString("  if (!a) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  atomic_store_explicit(&a->value, init, memory_order_seq_cst);\n")
	out.WriteString("  return (int64_t)(intptr_t)a;\n")
	out.WriteString("}\n\n")
	out.WriteString("static int64_t vox_builtin_atomic_i64_load(int64_t h) {\n")
	out.WriteString("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;\n")
	out.WriteString("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }\n")
	out.WriteString("  return atomic_load_explicit(&a->value, memory_order_seq_cst);\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_atomic_i64_store(int64_t h, int64_t v) {\n")
	out.WriteString("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;\n")
	out.WriteString("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }\n")
	out.WriteString("  atomic_store_explicit(&a->value, v, memory_order_seq_cst);\n")
	out.WriteString("}\n\n")
	out.WriteString("static int64_t vox_builtin_atomic_i64_fetch_add(int64_t h, int64_t delta) {\n")
	out.WriteString("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;\n")
	out.WriteString("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }\n")
	out.WriteString("  return atomic_fetch_add_explicit(&a->value, delta, memory_order_seq_cst);\n")
	out.WriteString("}\n\n")
	out.WriteString("static int64_t vox_builtin_atomic_i64_swap(int64_t h, int64_t v) {\n")
	out.WriteString("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;\n")
	out.WriteString("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }\n")
	out.WriteString("  return atomic_exchange_explicit(&a->value, v, memory_order_seq_cst);\n")
	out.WriteString("}\n\n")
	out.WriteString("#if defined(_WIN32)\n")
	out.WriteString("static int64_t vox_builtin_tcp_connect(const char* host, int32_t port) {\n")
	out.WriteString("  (void)host; (void)port;\n")
	out.WriteString("  vox_builtin_panic(\"tcp is not supported on windows in stage1 yet\");\n")
	out.WriteString("}\n\n")
	out.WriteString("static int32_t vox_builtin_tcp_send(int64_t h, const char* text) {\n")
	out.WriteString("  (void)h; (void)text;\n")
	out.WriteString("  vox_builtin_panic(\"tcp is not supported on windows in stage1 yet\");\n")
	out.WriteString("}\n\n")
	out.WriteString("static const char* vox_builtin_tcp_recv(int64_t h, int32_t max_n) {\n")
	out.WriteString("  (void)h; (void)max_n;\n")
	out.WriteString("  vox_builtin_panic(\"tcp is not supported on windows in stage1 yet\");\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_tcp_close(int64_t h) {\n")
	out.WriteString("  (void)h;\n")
	out.WriteString("  vox_builtin_panic(\"tcp is not supported on windows in stage1 yet\");\n")
	out.WriteString("}\n")
	out.WriteString("#else\n")
	out.WriteString("static int64_t vox_builtin_tcp_connect(const char* host, int32_t port) {\n")
	out.WriteString("  if (!host) host = \"\";\n")
	out.WriteString("  if (port <= 0 || port > 65535) { vox_builtin_panic(\"invalid tcp port\"); }\n")
	out.WriteString("  char port_buf[16];\n")
	out.WriteString("  snprintf(port_buf, sizeof(port_buf), \"%\" PRId32, port);\n")
	out.WriteString("  struct addrinfo hints;\n")
	out.WriteString("  memset(&hints, 0, sizeof(hints));\n")
	out.WriteString("  hints.ai_family = AF_UNSPEC;\n")
	out.WriteString("  hints.ai_socktype = SOCK_STREAM;\n")
	out.WriteString("  struct addrinfo* res = NULL;\n")
	out.WriteString("  int rc = getaddrinfo(host, port_buf, &hints, &res);\n")
	out.WriteString("  if (rc != 0 || !res) { vox_builtin_panic(\"tcp connect resolve failed\"); }\n")
	out.WriteString("  int fd = -1;\n")
	out.WriteString("  for (struct addrinfo* p = res; p != NULL; p = p->ai_next) {\n")
	out.WriteString("    fd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n")
	out.WriteString("    if (fd < 0) continue;\n")
	out.WriteString("    if (connect(fd, p->ai_addr, p->ai_addrlen) == 0) { break; }\n")
	out.WriteString("    close(fd);\n")
	out.WriteString("    fd = -1;\n")
	out.WriteString("  }\n")
	out.WriteString("  freeaddrinfo(res);\n")
	out.WriteString("  if (fd < 0) { vox_builtin_panic(\"tcp connect failed\"); }\n")
	out.WriteString("  return (int64_t)fd;\n")
	out.WriteString("}\n\n")
	out.WriteString("static int32_t vox_builtin_tcp_send(int64_t h, const char* text) {\n")
	out.WriteString("  int fd = (int)h;\n")
	out.WriteString("  if (fd < 0) { vox_builtin_panic(\"invalid tcp handle\"); }\n")
	out.WriteString("  if (!text) text = \"\";\n")
	out.WriteString("  size_t n = strlen(text);\n")
	out.WriteString("  ssize_t sent = send(fd, text, n, 0);\n")
	out.WriteString("  if (sent < 0) { vox_builtin_panic(\"tcp send failed\"); }\n")
	out.WriteString("  if ((uint64_t)sent > (uint64_t)INT32_MAX) { vox_builtin_panic(\"tcp send too large\"); }\n")
	out.WriteString("  return (int32_t)sent;\n")
	out.WriteString("}\n\n")
	out.WriteString("static const char* vox_builtin_tcp_recv(int64_t h, int32_t max_n) {\n")
	out.WriteString("  int fd = (int)h;\n")
	out.WriteString("  if (fd < 0) { vox_builtin_panic(\"invalid tcp handle\"); }\n")
	out.WriteString("  if (max_n <= 0) return \"\";\n")
	out.WriteString("  char* buf = (char*)malloc((size_t)max_n + 1);\n")
	out.WriteString("  if (!buf) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  ssize_t n = recv(fd, buf, (size_t)max_n, 0);\n")
	out.WriteString("  if (n < 0) { free(buf); vox_builtin_panic(\"tcp recv failed\"); }\n")
	out.WriteString("  if (n == 0) { free(buf); return \"\"; }\n")
	out.WriteString("  buf[n] = '\\0';\n")
	out.WriteString("  return buf;\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_tcp_close(int64_t h) {\n")
	out.WriteString("  int fd = (int)h;\n")
	out.WriteString("  if (fd < 0) return;\n")
	out.WriteString("  close(fd);\n")
	out.WriteString("}\n")
	out.WriteString("#endif\n\n")

	// Nominal type defs (struct/enum) must come before function decls.
	// Enums are lowered to tagged unions.
	if err := emitNominalTypes(&out, p); err != nil {
		return "", err
	}

	// Forward decls
	names := make([]string, 0, len(p.Funcs))
	for name := range p.Funcs {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		f := p.Funcs[name]
		out.WriteString("static ")
		out.WriteString(cType(f.Ret))
		out.WriteByte(' ')
		out.WriteString(cFnName(f.Name))
		out.WriteByte('(')
		for i, pa := range f.Params {
			if i > 0 {
				out.WriteString(", ")
			}
			out.WriteString(cType(pa.Ty))
			out.WriteByte(' ')
			out.WriteString(cParamName(i, pa.Name))
		}
		out.WriteString(");\n")
	}
	out.WriteString("\n")

	for _, name := range names {
		f := p.Funcs[name]
		if err := emitFunc(&out, p, f); err != nil {
			return "", err
		}
		out.WriteString("\n")
	}

	if opts.EmitDriverMain {
		mainFn, ok := p.Funcs["main"]
		if !ok {
			return "", fmt.Errorf("missing function main")
		}
		out.WriteString("int main(int argc, char** argv) {\n")
		out.WriteString("  vox__argc = argc;\n")
		out.WriteString("  vox__argv = argv;\n")
		switch opts.DriverMainKind {
		case DriverMainUser:
			switch mainFn.Ret.K {
			case ir.TUnit:
				out.WriteString("  ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
			case ir.TBool:
				out.WriteString("  bool v = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  printf(\"%s\\n\", v ? \"true\" : \"false\");\n")
			case ir.TI8, ir.TI16, ir.TI32:
				out.WriteString("  int32_t v = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  printf(\"%\" PRId32 \"\\n\", v);\n")
			case ir.TU8, ir.TU16, ir.TU32:
				out.WriteString("  uint32_t v = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  printf(\"%\" PRIu32 \"\\n\", v);\n")
			case ir.TI64:
				out.WriteString("  int64_t v = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  printf(\"%\" PRId64 \"\\n\", v);\n")
			case ir.TU64:
				out.WriteString("  uint64_t v = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  printf(\"%\" PRIu64 \"\\n\", v);\n")
			case ir.TISize:
				out.WriteString("  int64_t v = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  printf(\"%\" PRId64 \"\\n\", v);\n")
			case ir.TUSize:
				out.WriteString("  uint64_t v = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  printf(\"%\" PRIu64 \"\\n\", v);\n")
			case ir.TString:
				out.WriteString("  const char* v = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  printf(\"%s\\n\", v ? v : \"\");\n")
			default:
				return "", fmt.Errorf("unsupported main return type in driver")
			}
			out.WriteString("  return 0;\n")
			out.WriteString("}\n")
		case DriverMainTool:
			switch mainFn.Ret.K {
			case ir.TUnit:
				out.WriteString("  ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  return 0;\n")
			case ir.TBool:
				out.WriteString("  bool rc = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  return rc ? 1 : 0;\n")
			case ir.TI8, ir.TI16, ir.TI32:
				out.WriteString("  int32_t rc = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  return (int)rc;\n")
			case ir.TU8, ir.TU16, ir.TU32:
				out.WriteString("  uint32_t rc = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  return (int)rc;\n")
			case ir.TI64, ir.TISize:
				out.WriteString("  int64_t rc = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  return (int)rc;\n")
			case ir.TU64, ir.TUSize:
				out.WriteString("  uint64_t rc = ")
				out.WriteString(cFnName("main"))
				out.WriteString("();\n")
				out.WriteString("  return (int)rc;\n")
			default:
				return "", fmt.Errorf("unsupported main return type in tool driver (expected ()/bool/<int>)")
			}
			out.WriteString("}\n")
		default:
			return "", fmt.Errorf("unknown driver main kind: %d", opts.DriverMainKind)
		}
	}

	if opts.EmitTestMain {
		out.WriteString("int main(int argc, char** argv) {\n")
		out.WriteString("  vox__argc = argc;\n")
		out.WriteString("  vox__argv = argv;\n")
		out.WriteString("  const char* want = argc >= 2 ? argv[1] : NULL;\n")
		out.WriteString("  if (want && want[0] == '\\0') want = NULL;\n")
		out.WriteString("  int ran = 0;\n")
		for _, tf := range opts.TestFuncs {
			f, ok := p.Funcs[tf.Name]
			if !ok {
				return "", fmt.Errorf("missing test function: %s", tf.Name)
			}
			if len(f.Params) != 0 || f.Ret.K != ir.TUnit {
				return "", fmt.Errorf("invalid test signature: %s (expected fn() -> ())", tf.Name)
			}
			// if (!want || strcmp(want, "name") == 0) { ran=1; fn(); }
			out.WriteString("  if (!want || strcmp(want, ")
			out.WriteString(cStringLit(tf.Name))
			out.WriteString(") == 0) { ran = 1; ")
			out.WriteString(cFnName(tf.Name))
			out.WriteString("(); }\n")
		}
		out.WriteString("  if (want && !ran) {\n")
		out.WriteString("    fprintf(stderr, \"unknown test: %s\\n\", want);\n")
		out.WriteString("    return 2;\n")
		out.WriteString("  }\n")
		out.WriteString("  return 0;\n")
		out.WriteString("}\n")
	}

	return out.String(), nil
}

// C naming/value helpers live in c_names.go/c_values.go.
