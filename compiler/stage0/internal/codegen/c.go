package codegen

import (
	"bytes"
	"fmt"
	"sort"

	"voxlang/internal/ir"
)

type EmitOptions struct {
	// When true, emit a C entrypoint main() that calls vox main and prints its return value.
	EmitDriverMain bool
}

func EmitC(p *ir.Program, opts EmitOptions) (string, error) {
	if p == nil {
		return "", fmt.Errorf("nil program")
	}

	var out bytes.Buffer
	out.WriteString("// generated by vox stage0\n")
	out.WriteString("#include <stdint.h>\n")
	out.WriteString("#include <stdbool.h>\n")
	out.WriteString("#include <inttypes.h>\n")
	out.WriteString("#include <stdio.h>\n")
	out.WriteString("#include <stdlib.h>\n\n")

	// Runtime builtins
	out.WriteString("static void vox_builtin_assert(bool cond) {\n")
	out.WriteString("  if (!cond) { fprintf(stderr, \"assertion failed\\n\"); exit(1); }\n")
	out.WriteString("}\n\n")

	// Forward decls
	names := make([]string, 0, len(p.Funcs))
	for name := range p.Funcs {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		f := p.Funcs[name]
		out.WriteString("static ")
		out.WriteString(cType(f.Ret))
		out.WriteByte(' ')
		out.WriteString(cFnName(f.Name))
		out.WriteByte('(')
		for i, pa := range f.Params {
			if i > 0 {
				out.WriteString(", ")
			}
			out.WriteString(cType(pa.Ty))
			out.WriteByte(' ')
			out.WriteString(cParamName(i, pa.Name))
		}
		out.WriteString(");\n")
	}
	out.WriteString("\n")

	for _, name := range names {
		f := p.Funcs[name]
		if err := emitFunc(&out, f); err != nil {
			return "", err
		}
		out.WriteString("\n")
	}

	if opts.EmitDriverMain {
		mainFn, ok := p.Funcs["main"]
		if !ok {
			return "", fmt.Errorf("missing function main")
		}
		out.WriteString("int main(void) {\n")
		switch mainFn.Ret.K {
		case ir.TUnit:
			out.WriteString("  ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
		case ir.TBool:
			out.WriteString("  bool v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%s\\n\", v ? \"true\" : \"false\");\n")
		case ir.TI32:
			out.WriteString("  int32_t v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%\" PRId32 \"\\n\", v);\n")
		case ir.TI64:
			out.WriteString("  int64_t v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%\" PRId64 \"\\n\", v);\n")
		default:
			return "", fmt.Errorf("unsupported main return type in driver")
		}
		out.WriteString("  return 0;\n")
		out.WriteString("}\n")
	}

	return out.String(), nil
}

func emitFunc(out *bytes.Buffer, f *ir.Func) error {
	// Collect locals (slots + temps)
	slotTypes := map[int]ir.Type{}
	tempTypes := map[int]ir.Type{}
	for _, b := range f.Blocks {
		for _, ins := range b.Instr {
			switch i := ins.(type) {
			case *ir.SlotDecl:
				slotTypes[i.Slot.ID] = i.Ty
			case *ir.Const:
				tempTypes[i.Dst.ID] = i.Ty
			case *ir.BinOp:
				tempTypes[i.Dst.ID] = i.Ty
			case *ir.Cmp:
				tempTypes[i.Dst.ID] = ir.Type{K: ir.TBool}
			case *ir.And:
				tempTypes[i.Dst.ID] = ir.Type{K: ir.TBool}
			case *ir.Or:
				tempTypes[i.Dst.ID] = ir.Type{K: ir.TBool}
			case *ir.Not:
				tempTypes[i.Dst.ID] = ir.Type{K: ir.TBool}
			case *ir.Load:
				tempTypes[i.Dst.ID] = i.Ty
			case *ir.Call:
				if i.Ret.K != ir.TUnit && i.Dst != nil {
					tempTypes[i.Dst.ID] = i.Ret
				}
			}
		}
	}

	out.WriteString("static ")
	out.WriteString(cType(f.Ret))
	out.WriteByte(' ')
	out.WriteString(cFnName(f.Name))
	out.WriteByte('(')
	for i, pa := range f.Params {
		if i > 0 {
			out.WriteString(", ")
		}
		out.WriteString(cType(pa.Ty))
		out.WriteByte(' ')
		out.WriteString(cParamName(i, pa.Name))
	}
	out.WriteString(") {\n")

	// Declare slots
	slotIDs := make([]int, 0, len(slotTypes))
	for id := range slotTypes {
		slotIDs = append(slotIDs, id)
	}
	sort.Ints(slotIDs)
	for _, id := range slotIDs {
		out.WriteString("  ")
		out.WriteString(cType(slotTypes[id]))
		out.WriteByte(' ')
		out.WriteString(cSlotName(id))
		out.WriteString(";\n")
	}

	// Declare temps
	tempIDs := make([]int, 0, len(tempTypes))
	for id := range tempTypes {
		tempIDs = append(tempIDs, id)
	}
	sort.Ints(tempIDs)
	for _, id := range tempIDs {
		out.WriteString("  ")
		out.WriteString(cType(tempTypes[id]))
		out.WriteByte(' ')
		out.WriteString(cTempName(id))
		out.WriteString(";\n")
	}

	if len(slotIDs) > 0 || len(tempIDs) > 0 {
		out.WriteString("\n")
	}

	// Emit blocks
	for _, b := range f.Blocks {
		out.WriteString(b.Name)
		out.WriteString(":\n")
		for _, ins := range b.Instr {
			if err := emitInstr(out, ins); err != nil {
				return err
			}
		}
		if b.Term == nil {
			return fmt.Errorf("block %s missing terminator", b.Name)
		}
		if err := emitTerm(out, b.Term); err != nil {
			return err
		}
		out.WriteString("\n")
	}

	out.WriteString("}\n")
	return nil
}

func emitInstr(out *bytes.Buffer, ins ir.Instr) error {
	switch i := ins.(type) {
	case *ir.SlotDecl:
		// already declared as a C local
		return nil
	case *ir.Const:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = ")
		out.WriteString(cValue(i.Val))
		out.WriteString(";\n")
		return nil
	case *ir.BinOp:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = ")
		out.WriteString(cValue(i.A))
		out.WriteByte(' ')
		out.WriteString(stringToCOp(string(i.Op)))
		out.WriteByte(' ')
		out.WriteString(cValue(i.B))
		out.WriteString(";\n")
		return nil
	case *ir.Cmp:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = (")
		out.WriteString(cValue(i.A))
		out.WriteByte(' ')
		out.WriteString(cCmpOp(i.Op))
		out.WriteByte(' ')
		out.WriteString(cValue(i.B))
		out.WriteString(");\n")
		return nil
	case *ir.And:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = (")
		out.WriteString(cValue(i.A))
		out.WriteString(" && ")
		out.WriteString(cValue(i.B))
		out.WriteString(");\n")
		return nil
	case *ir.Or:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = (")
		out.WriteString(cValue(i.A))
		out.WriteString(" || ")
		out.WriteString(cValue(i.B))
		out.WriteString(");\n")
		return nil
	case *ir.Not:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = (!")
		out.WriteString(cValue(i.A))
		out.WriteString(");\n")
		return nil
	case *ir.Store:
		out.WriteString("  ")
		out.WriteString(cSlotName(i.Slot.ID))
		out.WriteString(" = ")
		out.WriteString(cValue(i.Val))
		out.WriteString(";\n")
		return nil
	case *ir.Load:
		out.WriteString("  ")
		out.WriteString(cTempName(i.Dst.ID))
		out.WriteString(" = ")
		out.WriteString(cSlotName(i.Slot.ID))
		out.WriteString(";\n")
		return nil
	case *ir.Call:
		// builtin assert
		if i.Name == "assert" {
			if len(i.Args) != 1 {
				return fmt.Errorf("assert expects 1 arg")
			}
			out.WriteString("  vox_builtin_assert(")
			out.WriteString(cValue(i.Args[0]))
			out.WriteString(");\n")
			return nil
		}
		out.WriteString("  ")
		if i.Ret.K != ir.TUnit {
			out.WriteString(cTempName(i.Dst.ID))
			out.WriteString(" = ")
		}
		out.WriteString(cFnName(i.Name))
		out.WriteByte('(')
		for j, a := range i.Args {
			if j > 0 {
				out.WriteString(", ")
			}
			out.WriteString(cValue(a))
		}
		out.WriteString(");\n")
		return nil
	default:
		return fmt.Errorf("unsupported instr in codegen")
	}
}

func emitTerm(out *bytes.Buffer, t ir.Term) error {
	switch tt := t.(type) {
	case *ir.Ret:
		out.WriteString("  return")
		if tt.Val != nil {
			out.WriteByte(' ')
			out.WriteString(cValue(tt.Val))
		}
		out.WriteString(";\n")
		return nil
	case *ir.Br:
		out.WriteString("  goto ")
		out.WriteString(tt.Target)
		out.WriteString(";\n")
		return nil
	case *ir.CondBr:
		out.WriteString("  if (")
		out.WriteString(cValue(tt.Cond))
		out.WriteString(") goto ")
		out.WriteString(tt.Then)
		out.WriteString("; else goto ")
		out.WriteString(tt.Else)
		out.WriteString(";\n")
		return nil
	default:
		return fmt.Errorf("unsupported terminator")
	}
}

func cType(t ir.Type) string {
	switch t.K {
	case ir.TUnit:
		return "void"
	case ir.TBool:
		return "bool"
	case ir.TI32:
		return "int32_t"
	case ir.TI64:
		return "int64_t"
	default:
		return "void"
	}
}

func cFnName(name string) string { return "vox_fn_" + name }

func cParamName(i int, name string) string {
	_ = name
	return fmt.Sprintf("p%d", i)
}

func cTempName(id int) string { return fmt.Sprintf("t%d", id) }

func cSlotName(id int) string { return fmt.Sprintf("v%d", id) }

func cValue(v ir.Value) string {
	switch x := v.(type) {
	case *ir.Temp:
		return cTempName(x.ID)
	case *ir.ParamRef:
		return fmt.Sprintf("p%d", x.Index)
	case *ir.Slot:
		return cSlotName(x.ID)
	case *ir.ConstInt:
		return fmt.Sprintf("%d", x.V)
	case *ir.ConstBool:
		if x.V {
			return "true"
		}
		return "false"
	default:
		return "0"
	}
}

func stringToCOp(op string) string {
	switch op {
	case "add":
		return "+"
	case "sub":
		return "-"
	case "mul":
		return "*"
	case "div":
		return "/"
	case "mod":
		return "%"
	default:
		return op
	}
}

func cCmpOp(op ir.CmpKind) string {
	switch op {
	case ir.CmpLt:
		return "<"
	case ir.CmpLe:
		return "<="
	case ir.CmpGt:
		return ">"
	case ir.CmpGe:
		return ">="
	case ir.CmpEq:
		return "=="
	case ir.CmpNe:
		return "!="
	default:
		return "=="
	}
}
