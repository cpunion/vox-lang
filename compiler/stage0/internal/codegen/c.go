package codegen

import (
	"bytes"
	"fmt"
	"sort"

	"voxlang/internal/ir"
)

type EmitOptions struct {
	// When true, emit a C entrypoint main() that calls vox main and prints its return value.
	EmitDriverMain bool
	// When true, emit a C entrypoint main(argc, argv) that dispatches to vox test_* functions.
	EmitTestMain bool
	// TestFuncs is the ordered list of test function qualified names (e.g. "pkg::mod::test_x").
	// Each test must have signature `fn() -> ()`.
	TestFuncs []TestFunc
}

type TestFunc struct {
	// Name is the IR function name (qualified).
	Name string
}

func EmitC(p *ir.Program, opts EmitOptions) (string, error) {
	if p == nil {
		return "", fmt.Errorf("nil program")
	}
	if opts.EmitDriverMain && opts.EmitTestMain {
		return "", fmt.Errorf("cannot emit both driver main and test main")
	}

	var out bytes.Buffer
	out.WriteString("// generated by vox stage0\n")
	out.WriteString("#include <stdint.h>\n")
	out.WriteString("#include <stdbool.h>\n")
	out.WriteString("#include <inttypes.h>\n")
	out.WriteString("#include <stdio.h>\n")
	out.WriteString("#include <stdlib.h>\n\n")
	out.WriteString("#include <string.h>\n\n")
	out.WriteString("#include <limits.h>\n\n")
	out.WriteString("#include <stddef.h>\n\n")
	out.WriteString("#include <dirent.h>\n\n")
	out.WriteString("#include <sys/stat.h>\n\n")

	// Minimal Vec runtime (stage0): by-value elements, no drop glue.
	out.WriteString("typedef struct { uint8_t* data; int32_t len; int32_t cap; int32_t elem_size; } vox_vec;\n")
	out.WriteString("static vox_vec vox_vec_new(int32_t elem_size) {\n")
	out.WriteString("  vox_vec v; v.data = NULL; v.len = 0; v.cap = 0; v.elem_size = elem_size; return v;\n")
	out.WriteString("}\n")
	out.WriteString("static void vox_vec_grow(vox_vec* v, int32_t new_cap) {\n")
	out.WriteString("  if (new_cap <= v->cap) return;\n")
	out.WriteString("  if (new_cap < 4) new_cap = 4;\n")
	out.WriteString("  size_t bytes = (size_t)new_cap * (size_t)v->elem_size;\n")
	out.WriteString("  uint8_t* p = (uint8_t*)realloc(v->data, bytes);\n")
	out.WriteString("  if (!p) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  v->data = p; v->cap = new_cap;\n")
	out.WriteString("}\n")
	out.WriteString("static void vox_vec_push(vox_vec* v, const void* elem) {\n")
	out.WriteString("  if (v->len == v->cap) { int32_t nc = v->cap == 0 ? 4 : v->cap * 2; vox_vec_grow(v, nc); }\n")
	out.WriteString("  memcpy(v->data + (size_t)v->len * (size_t)v->elem_size, elem, (size_t)v->elem_size);\n")
	out.WriteString("  v->len++;\n")
	out.WriteString("}\n")
	out.WriteString("static int32_t vox_vec_len(const vox_vec* v) { return v->len; }\n")
	out.WriteString("static void vox_vec_get(const vox_vec* v, int32_t idx, void* out) {\n")
	out.WriteString("  if (idx < 0 || idx >= v->len) { fprintf(stderr, \"vec index out of bounds\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, v->data + (size_t)idx * (size_t)v->elem_size, (size_t)v->elem_size);\n")
	out.WriteString("}\n\n")

	// Minimal string runtime helpers (stage0).
	out.WriteString("static int32_t vox_str_len(const char* s) {\n")
	out.WriteString("  if (!s) return 0;\n")
	out.WriteString("  size_t n = strlen(s);\n")
	out.WriteString("  if (n > INT32_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }\n")
	out.WriteString("  return (int32_t)n;\n")
	out.WriteString("}\n")
	out.WriteString("static int32_t vox_str_byte_at(const char* s, int32_t idx) {\n")
	out.WriteString("  int32_t n = vox_str_len(s);\n")
	out.WriteString("  if (idx < 0 || idx >= n) { fprintf(stderr, \"string index out of bounds\\n\"); exit(1); }\n")
	out.WriteString("  return (int32_t)(uint8_t)s[idx];\n")
	out.WriteString("}\n\n")
	out.WriteString("static const char* vox_str_slice(const char* s, int32_t start, int32_t end) {\n")
	out.WriteString("  int32_t n = vox_str_len(s);\n")
	out.WriteString("  if (start < 0 || end < start || end > n) { fprintf(stderr, \"string slice out of bounds\\n\"); exit(1); }\n")
	out.WriteString("  int32_t m = end - start;\n")
	out.WriteString("  char* out = (char*)malloc((size_t)m + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, s + start, (size_t)m);\n")
	out.WriteString("  out[m] = '\\0';\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_str_concat(const char* a, const char* b) {\n")
	out.WriteString("  if (!a) a = \"\";\n")
	out.WriteString("  if (!b) b = \"\";\n")
	out.WriteString("  size_t na = strlen(a);\n")
	out.WriteString("  size_t nb = strlen(b);\n")
	out.WriteString("  if (na + nb + 1 > SIZE_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }\n")
	out.WriteString("  char* out = (char*)malloc(na + nb + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, a, na);\n")
	out.WriteString("  memcpy(out + na, b, nb);\n")
	out.WriteString("  out[na + nb] = '\\0';\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_i32_to_string(int32_t v) {\n")
	out.WriteString("  char buf[32];\n")
	out.WriteString("  int n = snprintf(buf, sizeof(buf), \"%\" PRId32, v);\n")
	out.WriteString("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }\n")
	out.WriteString("  char* out = (char*)malloc((size_t)n + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, buf, (size_t)n + 1);\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_i64_to_string(int64_t v) {\n")
	out.WriteString("  char buf[32];\n")
	out.WriteString("  int n = snprintf(buf, sizeof(buf), \"%\" PRId64, v);\n")
	out.WriteString("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }\n")
	out.WriteString("  char* out = (char*)malloc((size_t)n + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, buf, (size_t)n + 1);\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_bool_to_string(bool v) {\n")
	out.WriteString("  return v ? \"true\" : \"false\";\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_str_escape_c(const char* s) {\n")
	out.WriteString("  if (!s) s = \"\";\n")
	out.WriteString("  size_t n = strlen(s);\n")
	out.WriteString("  // First pass: compute output length.\n")
	out.WriteString("  size_t out_n = 0;\n")
	out.WriteString("  for (size_t i = 0; i < n; i++) {\n")
	out.WriteString("    unsigned char ch = (unsigned char)s[i];\n")
	out.WriteString("    switch (ch) {\n")
	out.WriteString("    case '\\\\':\n")
	out.WriteString("    case '\"':\n")
	out.WriteString("    case '\\n':\n")
	out.WriteString("    case '\\r':\n")
	out.WriteString("    case '\\t':\n")
	out.WriteString("      out_n += 2;\n")
	out.WriteString("      break;\n")
	out.WriteString("    default:\n")
	out.WriteString("      if (ch >= 0x20 && ch <= 0x7e) out_n += 1; else out_n += 4; // \\\\xHH\n")
	out.WriteString("      break;\n")
	out.WriteString("    }\n")
	out.WriteString("  }\n")
	out.WriteString("  char* out = (char*)malloc(out_n + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  size_t j = 0;\n")
	out.WriteString("  for (size_t i = 0; i < n; i++) {\n")
	out.WriteString("    unsigned char ch = (unsigned char)s[i];\n")
	out.WriteString("    switch (ch) {\n")
	out.WriteString("    case '\\\\': out[j++] = '\\\\'; out[j++] = '\\\\'; break;\n")
	out.WriteString("    case '\"': out[j++] = '\\\\'; out[j++] = '\"'; break;\n")
	out.WriteString("    case '\\n': out[j++] = '\\\\'; out[j++] = 'n'; break;\n")
	out.WriteString("    case '\\r': out[j++] = '\\\\'; out[j++] = 'r'; break;\n")
	out.WriteString("    case '\\t': out[j++] = '\\\\'; out[j++] = 't'; break;\n")
	out.WriteString("    default:\n")
	out.WriteString("      if (ch >= 0x20 && ch <= 0x7e) { out[j++] = (char)ch; }\n")
	out.WriteString("      else {\n")
	out.WriteString("        static const char* hex = \"0123456789abcdef\";\n")
	out.WriteString("        out[j++] = '\\\\'; out[j++] = 'x';\n")
	out.WriteString("        out[j++] = hex[(ch >> 4) & 0xf];\n")
	out.WriteString("        out[j++] = hex[ch & 0xf];\n")
	out.WriteString("      }\n")
	out.WriteString("      break;\n")
	out.WriteString("    }\n")
	out.WriteString("  }\n")
	out.WriteString("  out[j] = '\\0';\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	out.WriteString("static const char* vox_vec_str_join(const vox_vec* v, const char* sep) {\n")
	out.WriteString("  if (!sep) sep = \"\";\n")
	out.WriteString("  if (!v || v->elem_size != (int32_t)sizeof(const char*)) { fprintf(stderr, \"vec_str_join expects Vec[String]\\n\"); exit(1); }\n")
	out.WriteString("  int32_t n = v->len;\n")
	out.WriteString("  const char* const* items = (const char* const*)v->data;\n")
	out.WriteString("  size_t sep_n = strlen(sep);\n")
	out.WriteString("  size_t total = 0;\n")
	out.WriteString("  for (int32_t i = 0; i < n; i++) {\n")
	out.WriteString("    const char* s = items[i];\n")
	out.WriteString("    if (!s) s = \"\";\n")
	out.WriteString("    total += strlen(s);\n")
	out.WriteString("    if (i + 1 < n) total += sep_n;\n")
	out.WriteString("  }\n")
	out.WriteString("  if (total + 1 > SIZE_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }\n")
	out.WriteString("  char* out = (char*)malloc(total + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  size_t j = 0;\n")
	out.WriteString("  for (int32_t i = 0; i < n; i++) {\n")
	out.WriteString("    const char* s = items[i];\n")
	out.WriteString("    if (!s) s = \"\";\n")
	out.WriteString("    size_t m = strlen(s);\n")
	out.WriteString("    memcpy(out + j, s, m);\n")
	out.WriteString("    j += m;\n")
	out.WriteString("    if (i + 1 < n && sep_n != 0) {\n")
	out.WriteString("      memcpy(out + j, sep, sep_n);\n")
	out.WriteString("      j += sep_n;\n")
	out.WriteString("    }\n")
	out.WriteString("  }\n")
	out.WriteString("  out[j] = '\\0';\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	// Runtime builtins
	out.WriteString("static int vox__argc = 0;\n")
	out.WriteString("static char** vox__argv = NULL;\n\n")
	out.WriteString("static void vox_builtin_panic(const char* msg) {\n")
	out.WriteString("  if (!msg) msg = \"\";\n")
	out.WriteString("  fprintf(stderr, \"%s\\n\", msg);\n")
	out.WriteString("  exit(1);\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_print(const char* msg) {\n")
	out.WriteString("  if (!msg) msg = \"\";\n")
	out.WriteString("  fputs(msg, stdout);\n")
	out.WriteString("  fflush(stdout);\n")
	out.WriteString("}\n\n")
	out.WriteString("static vox_vec vox_builtin_args(void) {\n")
	out.WriteString("  vox_vec v = vox_vec_new((int32_t)sizeof(const char*));\n")
	out.WriteString("  for (int i = 1; i < vox__argc; i++) {\n")
	out.WriteString("    const char* s = vox__argv[i];\n")
	out.WriteString("    vox_vec_push(&v, &s);\n")
	out.WriteString("  }\n")
	out.WriteString("  return v;\n")
	out.WriteString("}\n\n")
	out.WriteString("static const char* vox_builtin_exe_path(void) {\n")
	out.WriteString("  if (!vox__argv || vox__argc <= 0 || !vox__argv[0]) return \"\";\n")
	out.WriteString("  return vox__argv[0];\n")
	out.WriteString("}\n\n")
	out.WriteString("static const char* vox_builtin_read_file(const char* path) {\n")
	out.WriteString("  if (!path) path = \"\";\n")
	out.WriteString("  FILE* f = fopen(path, \"rb\");\n")
	out.WriteString("  if (!f) { fprintf(stderr, \"read_file failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  if (fseek(f, 0, SEEK_END) != 0) { fprintf(stderr, \"read_file fseek failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  long n = ftell(f);\n")
	out.WriteString("  if (n < 0) { fprintf(stderr, \"read_file ftell failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  if (fseek(f, 0, SEEK_SET) != 0) { fprintf(stderr, \"read_file fseek failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  char* out = (char*)malloc((size_t)n + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  size_t got = fread(out, 1, (size_t)n, f);\n")
	out.WriteString("  if (got != (size_t)n) { fprintf(stderr, \"read_file fread failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  out[n] = '\\0';\n")
	out.WriteString("  fclose(f);\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_builtin_write_file(const char* path, const char* text) {\n")
	out.WriteString("  if (!path) path = \"\";\n")
	out.WriteString("  if (!text) text = \"\";\n")
	out.WriteString("  FILE* f = fopen(path, \"wb\");\n")
	out.WriteString("  if (!f) { fprintf(stderr, \"write_file failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  size_t n = strlen(text);\n")
	out.WriteString("  if (n != 0) {\n")
	out.WriteString("    size_t put = fwrite(text, 1, n, f);\n")
	out.WriteString("    if (put != n) { fprintf(stderr, \"write_file fwrite failed: %s\\n\", path); exit(1); }\n")
	out.WriteString("  }\n")
	out.WriteString("  fclose(f);\n")
	out.WriteString("}\n\n")
	out.WriteString("static int32_t vox_builtin_exec(const char* cmd) {\n")
	out.WriteString("  if (!cmd) cmd = \"\";\n")
	out.WriteString("  int r = system(cmd);\n")
	out.WriteString("  return (int32_t)r;\n")
	out.WriteString("}\n\n")
	out.WriteString("static bool vox_str_has_suffix(const char* s, const char* suf) {\n")
	out.WriteString("  if (!s || !suf) return false;\n")
	out.WriteString("  size_t n = strlen(s);\n")
	out.WriteString("  size_t m = strlen(suf);\n")
	out.WriteString("  if (m > n) return false;\n")
	out.WriteString("  return memcmp(s + (n - m), suf, m) == 0;\n")
	out.WriteString("}\n\n")
	out.WriteString("static char* vox_path_join2(const char* a, const char* b) {\n")
	out.WriteString("  if (!a) a = \"\";\n")
	out.WriteString("  if (!b) b = \"\";\n")
	out.WriteString("  size_t na = strlen(a);\n")
	out.WriteString("  size_t nb = strlen(b);\n")
	out.WriteString("  bool slash = (na != 0 && a[na - 1] != '/');\n")
	out.WriteString("  size_t n = na + (slash ? 1 : 0) + nb;\n")
	out.WriteString("  char* out = (char*)malloc(n + 1);\n")
	out.WriteString("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }\n")
	out.WriteString("  memcpy(out, a, na);\n")
	out.WriteString("  size_t j = na;\n")
	out.WriteString("  if (slash) out[j++] = '/';\n")
	out.WriteString("  memcpy(out + j, b, nb);\n")
	out.WriteString("  out[n] = '\\0';\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")
	out.WriteString("static void vox_walk_dir(vox_vec* out, const char* root, const char* rel) {\n")
	out.WriteString("  char* full = rel && rel[0] ? vox_path_join2(root, rel) : vox_path_join2(root, \"\");\n")
	out.WriteString("  DIR* d = opendir(full);\n")
	out.WriteString("  if (!d) { free(full); return; }\n")
	out.WriteString("  struct dirent* ent;\n")
	out.WriteString("  while ((ent = readdir(d)) != NULL) {\n")
	out.WriteString("    const char* name = ent->d_name;\n")
	out.WriteString("    if (!name || name[0] == '\\0') continue;\n")
	out.WriteString("    if (strcmp(name, \".\") == 0 || strcmp(name, \"..\") == 0) continue;\n")
	out.WriteString("    char* child_rel = rel && rel[0] ? vox_path_join2(rel, name) : vox_path_join2(\"\", name);\n")
	out.WriteString("    char* child_full = vox_path_join2(root, child_rel);\n")
	out.WriteString("    struct stat st;\n")
	out.WriteString("    if (stat(child_full, &st) == 0 && S_ISDIR(st.st_mode)) {\n")
	out.WriteString("      vox_walk_dir(out, root, child_rel);\n")
	out.WriteString("      free(child_rel);\n")
	out.WriteString("      free(child_full);\n")
	out.WriteString("      continue;\n")
	out.WriteString("    }\n")
	out.WriteString("    if (vox_str_has_suffix(child_rel, \".vox\")) {\n")
	out.WriteString("      const char* s = child_rel;\n")
	out.WriteString("      vox_vec_push(out, &s);\n")
	out.WriteString("    } else {\n")
	out.WriteString("      free(child_rel);\n")
	out.WriteString("    }\n")
	out.WriteString("    free(child_full);\n")
	out.WriteString("  }\n")
	out.WriteString("  closedir(d);\n")
	out.WriteString("  free(full);\n")
	out.WriteString("}\n\n")
	out.WriteString("static vox_vec vox_builtin_walk_vox_files(const char* root) {\n")
	out.WriteString("  if (!root || root[0] == '\\0') root = \".\";\n")
	out.WriteString("  vox_vec out = vox_vec_new((int32_t)sizeof(const char*));\n")
	out.WriteString("  vox_walk_dir(&out, root, \"src\");\n")
	out.WriteString("  vox_walk_dir(&out, root, \"tests\");\n")
	out.WriteString("  return out;\n")
	out.WriteString("}\n\n")

	// Nominal type defs (struct/enum) must come before function decls.
	// Enums are lowered to tagged unions.
	if err := emitNominalTypes(&out, p); err != nil {
		return "", err
	}

	// Forward decls
	names := make([]string, 0, len(p.Funcs))
	for name := range p.Funcs {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		f := p.Funcs[name]
		out.WriteString("static ")
		out.WriteString(cType(f.Ret))
		out.WriteByte(' ')
		out.WriteString(cFnName(f.Name))
		out.WriteByte('(')
		for i, pa := range f.Params {
			if i > 0 {
				out.WriteString(", ")
			}
			out.WriteString(cType(pa.Ty))
			out.WriteByte(' ')
			out.WriteString(cParamName(i, pa.Name))
		}
		out.WriteString(");\n")
	}
	out.WriteString("\n")

	for _, name := range names {
		f := p.Funcs[name]
		if err := emitFunc(&out, p, f); err != nil {
			return "", err
		}
		out.WriteString("\n")
	}

	if opts.EmitDriverMain {
		mainFn, ok := p.Funcs["main"]
		if !ok {
			return "", fmt.Errorf("missing function main")
		}
		out.WriteString("int main(int argc, char** argv) {\n")
		out.WriteString("  vox__argc = argc;\n")
		out.WriteString("  vox__argv = argv;\n")
		switch mainFn.Ret.K {
		case ir.TUnit:
			out.WriteString("  ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
		case ir.TBool:
			out.WriteString("  bool v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%s\\n\", v ? \"true\" : \"false\");\n")
		case ir.TI32:
			out.WriteString("  int32_t v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%\" PRId32 \"\\n\", v);\n")
		case ir.TI64:
			out.WriteString("  int64_t v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%\" PRId64 \"\\n\", v);\n")
		case ir.TString:
			out.WriteString("  const char* v = ")
			out.WriteString(cFnName("main"))
			out.WriteString("();\n")
			out.WriteString("  printf(\"%s\\n\", v ? v : \"\");\n")
		default:
			return "", fmt.Errorf("unsupported main return type in driver")
		}
		out.WriteString("  return 0;\n")
		out.WriteString("}\n")
	}

	if opts.EmitTestMain {
		out.WriteString("int main(int argc, char** argv) {\n")
		out.WriteString("  vox__argc = argc;\n")
		out.WriteString("  vox__argv = argv;\n")
		out.WriteString("  const char* want = argc >= 2 ? argv[1] : NULL;\n")
		out.WriteString("  if (want && want[0] == '\\0') want = NULL;\n")
		out.WriteString("  int ran = 0;\n")
		for _, tf := range opts.TestFuncs {
			f, ok := p.Funcs[tf.Name]
			if !ok {
				return "", fmt.Errorf("missing test function: %s", tf.Name)
			}
			if len(f.Params) != 0 || f.Ret.K != ir.TUnit {
				return "", fmt.Errorf("invalid test signature: %s (expected fn() -> ())", tf.Name)
			}
			// if (!want || strcmp(want, "name") == 0) { ran=1; fn(); }
			out.WriteString("  if (!want || strcmp(want, ")
			out.WriteString(cStringLit(tf.Name))
			out.WriteString(") == 0) { ran = 1; ")
			out.WriteString(cFnName(tf.Name))
			out.WriteString("(); }\n")
		}
		out.WriteString("  if (want && !ran) {\n")
		out.WriteString("    fprintf(stderr, \"unknown test: %s\\n\", want);\n")
		out.WriteString("    return 2;\n")
		out.WriteString("  }\n")
		out.WriteString("  return 0;\n")
		out.WriteString("}\n")
	}

	return out.String(), nil
}

// C naming/value helpers live in c_names.go/c_values.go.
