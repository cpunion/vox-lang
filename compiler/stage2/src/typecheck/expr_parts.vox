import "ast" as ast

pub struct ExprPartsResult { pub ok: bool, pub parts: Vec[String] }
pub struct ExprTypePathResult { pub ok: bool, pub parts: Vec[String], pub targs: Vec[ast.TypeName] }

pub fn expr_parts_ident(s: String) -> ExprPartsResult {
  let mut v: Vec[String] = Vec();
  v.push(s);
  return ExprPartsResult { ok: true, parts: v };
}

pub fn expr_parts_member(exprs: ast.ExprPool, recv: i32, name: String) -> ExprPartsResult {
  let r0: ExprPartsResult = expr_parts(exprs, recv);
  if !r0.ok { return ExprPartsResult { ok: false, parts: Vec() }; }
  let mut ps: Vec[String] = r0.parts;
  ps.push(name);
  return ExprPartsResult { ok: true, parts: ps };
}

pub fn expr_parts(exprs: ast.ExprPool, id: i32) -> ExprPartsResult {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);
  return match n {
    ast.ExprNode.Ident(s) => expr_parts_ident(s),
    ast.ExprNode.Member(r, name) => expr_parts_member(exprs, r, name),
    ast.ExprNode.Call(callee, _targs, args) => if args.len() == 0 { expr_parts(exprs, callee) } else { ExprPartsResult { ok: false, parts: Vec() } },
    ast.ExprNode.If(_, _, _) => ExprPartsResult { ok: false, parts: Vec() },
    _ => ExprPartsResult { ok: false, parts: Vec() },
  };
}

fn expr_type_path_ident(s: String) -> ExprTypePathResult {
  let mut v: Vec[String] = Vec();
  v.push(s);
  return ExprTypePathResult { ok: true, parts: v, targs: Vec() };
}

fn expr_type_path_member(exprs: ast.ExprPool, recv: i32, name: String) -> ExprTypePathResult {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, recv);
  if match n { ast.ExprNode.Call(_c, _targs, _args) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(c, _targs, _args) => c, _ => -1 };
    let targs: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_c, ts, _args) => ts, _ => Vec() };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _ts, as0) => as0, _ => Vec() };
    if args.len() != 0 { return ExprTypePathResult { ok: false, parts: Vec(), targs: Vec() }; }
    let pr0: ExprPartsResult = expr_parts(exprs, callee);
    if !pr0.ok { return ExprTypePathResult { ok: false, parts: Vec(), targs: Vec() }; }
    let mut ps0: Vec[String] = pr0.parts;
    ps0.push(name);
    return ExprTypePathResult { ok: true, parts: ps0, targs: targs };
  }

  let pr: ExprPartsResult = expr_parts(exprs, recv);
  if !pr.ok { return ExprTypePathResult { ok: false, parts: Vec(), targs: Vec() }; }
  let mut ps: Vec[String] = pr.parts;
  ps.push(name);
  return ExprTypePathResult { ok: true, parts: ps, targs: Vec() };
}

fn expr_type_path_call(exprs: ast.ExprPool, callee: i32, targs: Vec[ast.TypeName], args: Vec[i32]) -> ExprTypePathResult {
  if args.len() != 0 { return ExprTypePathResult { ok: false, parts: Vec(), targs: Vec() }; }
  let pr: ExprPartsResult = expr_parts(exprs, callee);
  if !pr.ok { return ExprTypePathResult { ok: false, parts: Vec(), targs: Vec() }; }
  return ExprTypePathResult { ok: true, parts: pr.parts, targs: targs };
}

pub fn expr_type_path(exprs: ast.ExprPool, id: i32) -> ExprTypePathResult {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);
  return match n {
    ast.ExprNode.Ident(s) => expr_type_path_ident(s),
    ast.ExprNode.Member(r, name) => expr_type_path_member(exprs, r, name),
    ast.ExprNode.Call(callee, targs, args) => expr_type_path_call(exprs, callee, targs, args),
    _ => ExprTypePathResult { ok: false, parts: Vec(), targs: Vec() },
  };
}
