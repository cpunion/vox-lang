import "ast" as ast
import "ir" as ir

pub struct TySub { pub name: String, pub ty: i32 }
pub struct ConstSub { pub name: String, pub ty: i32, pub iv: i64, pub text: String }
pub struct ConstWhereCheckResult { pub ok: bool, pub err: String }

pub struct UnifyResult { pub ok: bool, pub subs: Vec[TySub] }
pub struct ParseConstGenericArgResult { pub ok: bool, pub iv: i64, pub text: String }
pub struct ParseConstGenericArgWithLocalsResult { pub ok: bool, pub unresolved: bool, pub iv: i64, pub text: String }

pub fn is_const_generic_arg_tn(tn: ast.TypeName) -> bool {
  return tn.parts.len() == 2 && tn.parts.get(0) == "@const" && tn.args.len() == 0;
}

fn is_bare_ident_tn(tn: ast.TypeName) -> bool {
  return tn.parts.len() == 1 && tn.args.len() == 0;
}

pub fn is_const_generic_arg_tn_or_local(l0: Locals, tn: ast.TypeName) -> bool {
  if is_const_generic_arg_tn(tn) { return true; }
  if !is_bare_ident_tn(tn) { return false; }
  let lr: LookupConstResult = locals_lookup_const(l0, tn.parts.get(0));
  return lr.found;
}

pub fn const_generic_arg_text(tn: ast.TypeName) -> String {
  if !is_const_generic_arg_tn(tn) { return ""; }
  return tn.parts.get(1);
}

fn is_unsigned_int_kind_gen(k: ir.TyKind) -> bool {
  return match k {
    ir.TyKind.U8 => true,
    ir.TyKind.U16 => true,
    ir.TyKind.U32 => true,
    ir.TyKind.U64 => true,
    ir.TyKind.USize => true,
    _ => false,
  };
}

fn const_i64_in_range_for_kind(iv: i64, k: ir.TyKind) -> bool {
  if k == ir.TyKind.I8 { return iv >= -128 && iv <= 127; }
  if k == ir.TyKind.U8 { return iv >= 0 && iv <= 255; }
  if k == ir.TyKind.I16 { return iv >= -32768 && iv <= 32767; }
  if k == ir.TyKind.U16 { return iv >= 0 && iv <= 65535; }
  if k == ir.TyKind.I32 { return iv >= -2147483648 && iv <= 2147483647; }
  if k == ir.TyKind.U32 { return iv >= 0 && iv <= 4294967295; }
  if k == ir.TyKind.I64 { return true; }
  if k == ir.TyKind.ISize { return true; }
  if k == ir.TyKind.U64 { return true; }
  if k == ir.TyKind.USize { return true; }
  return false;
}

pub fn parse_const_generic_arg(ctx: Ctx, tn: ast.TypeName, want_ty: i32) -> ParseConstGenericArgResult {
  let text: String = const_generic_arg_text(tn);
  if text == "" { return ParseConstGenericArgResult { ok: false, iv: 0, text: "" }; }
  let bty: i32 = strip_range(ctx, want_ty);
  let bt: ir.Ty = ir.ty_pool_get(ctx.pool, bty);
  let kind: ir.TyKind = bt.kind;
  if !is_int_like_ty(ctx, bty) { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }

  if is_unsigned_int_kind_gen(kind) {
    if text.len() > 0 && text.byte_at(0) == 45 { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
    let pu: ParseU64DecResult = parse_u64_dec(text);
    if !pu.ok { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
    if !const_i64_in_range_for_kind(pu.val, kind) { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
    return ParseConstGenericArgResult { ok: true, iv: pu.val, text: text };
  }

  let ps: ParseI64DecResult = parse_i64_dec(text);
  if !ps.ok { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
  if !const_i64_in_range_for_kind(ps.val, kind) { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
  return ParseConstGenericArgResult { ok: true, iv: ps.val, text: text };
}

pub fn parse_const_generic_arg_with_locals(
  ctx: Ctx,
  l0: Locals,
  tn: ast.TypeName,
  want_ty: i32
) -> ParseConstGenericArgWithLocalsResult {
  let pr: ParseConstGenericArgResult = parse_const_generic_arg(ctx, tn, want_ty);
  if pr.ok {
    return ParseConstGenericArgWithLocalsResult { ok: true, unresolved: false, iv: pr.iv, text: pr.text };
  }

  if !is_bare_ident_tn(tn) {
    return ParseConstGenericArgWithLocalsResult { ok: false, unresolved: false, iv: 0, text: "" };
  }
  let name: String = tn.parts.get(0);
  let lr: LookupConstResult = locals_lookup_const(l0, name);
  if !lr.found {
    return ParseConstGenericArgWithLocalsResult { ok: false, unresolved: false, iv: 0, text: name };
  }
  let bty: i32 = strip_range(ctx, want_ty);
  if !is_int_like_ty(ctx, bty) {
    return ParseConstGenericArgWithLocalsResult { ok: false, unresolved: false, iv: 0, text: name };
  }
  if !assignable_to(ctx, want_ty, lr.ty) {
    return ParseConstGenericArgWithLocalsResult { ok: false, unresolved: false, iv: 0, text: name };
  }
  if !lr.has_val {
    return ParseConstGenericArgWithLocalsResult { ok: true, unresolved: true, iv: 0, text: name };
  }
  let kind: ir.TyKind = ir.ty_pool_get(ctx.pool, bty).kind;
  if !const_i64_in_range_for_kind(lr.iv, kind) {
    return ParseConstGenericArgWithLocalsResult { ok: false, unresolved: false, iv: 0, text: name };
  }
  return ParseConstGenericArgWithLocalsResult { ok: true, unresolved: false, iv: lr.iv, text: lr.iv.to_string() };
}

fn subs_lookup(subs: Vec[TySub], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < subs.len() {
    let s: TySub = subs.get(i);
    if s.name == name { return s.ty; }
    i = i + 1;
  }
  return -1;
}

fn subs_add(subs0: Vec[TySub], name: String, ty: i32) -> Vec[TySub] {
  let mut subs: Vec[TySub] = subs0;
  subs.push(TySub { name: name, ty: ty });
  return subs;
}

fn is_param_ty(t: ir.Ty) -> bool { return match t.kind { ir.TyKind.Param => true, _ => false }; }
fn is_vec_ty2(t: ir.Ty) -> bool { return match t.kind { ir.TyKind.Vec => true, _ => false }; }
fn is_struct_ty2(t: ir.Ty) -> bool { return match t.kind { ir.TyKind.Struct => true, _ => false }; }
fn is_enum_ty2(t: ir.Ty) -> bool { return match t.kind { ir.TyKind.Enum => true, _ => false }; }

fn find_nominal_ty_idx_subst(ctx: Ctx, kind: ir.TyKind, mod_path: String, name: String) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    let kind_ok: bool =
      match kind {
        ir.TyKind.Struct => t.kind == ir.TyKind.Struct,
        ir.TyKind.Enum => t.kind == ir.TyKind.Enum,
        _ => false,
      };
    if kind_ok && t.mod_path == mod_path && t.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn subst_struct_nominal_ty(ctx: Ctx, ty_idx: i32, subs: Vec[TySub]) -> i32 {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  let fs: FindStructResult = find_struct(ctx, t.mod_path, t.name);
  if !fs.found { return ty_idx; }

  let mut changed: bool = false;
  let mut want_tys: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < fs.sig.fields.len() {
    let f: StructFieldSig = fs.sig.fields.get(i);
    let st: i32 = subst_ty(ctx, f.ty, subs);
    if st == ctx.ty_bad { return ctx.ty_bad; }
    if st != f.ty { changed = true; }
    want_tys.push(st);
    i = i + 1;
  }
  if !changed { return ty_idx; }

  let mut si: i32 = 0;
  while si < ctx.structs.len() {
    let s: StructSig = ctx.structs.get(si);
    if s.mod_path == fs.sig.mod_path && s.base_name == fs.sig.base_name && s.fields.len() == fs.sig.fields.len() {
      let mut ok: bool = true;
      let mut fi: i32 = 0;
      while fi < s.fields.len() {
        let sf: StructFieldSig = s.fields.get(fi);
        let pf: StructFieldSig = fs.sig.fields.get(fi);
        if sf.name != pf.name || sf.ty != want_tys.get(fi) {
          ok = false;
          fi = s.fields.len();
        } else {
          fi = fi + 1;
        }
      }
      if ok {
        let idx: i32 = find_nominal_ty_idx_subst(ctx, ir.TyKind.Struct, s.mod_path, s.name);
        if idx != -1 { return idx; }
      }
    }
    si = si + 1;
  }
  return ctx.ty_bad;
}

fn subst_enum_nominal_ty(ctx: Ctx, ty_idx: i32, subs: Vec[TySub]) -> i32 {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  let fe: FindEnumResult = find_enum(ctx, t.mod_path, t.name);
  if !fe.found { return ty_idx; }

  let mut changed: bool = false;
  let mut want_vars: Vec[EnumVariantSig] = Vec();
  let mut vi: i32 = 0;
  while vi < fe.sig.vars.len() {
    let v: EnumVariantSig = fe.sig.vars.get(vi);
    let mut ftys: Vec[i32] = Vec();
    let mut fi: i32 = 0;
    while fi < v.fields.len() {
      let st: i32 = subst_ty(ctx, v.fields.get(fi), subs);
      if st == ctx.ty_bad { return ctx.ty_bad; }
      if st != v.fields.get(fi) { changed = true; }
      ftys.push(st);
      fi = fi + 1;
    }
    want_vars.push(EnumVariantSig { name: v.name, fields: ftys });
    vi = vi + 1;
  }
  if !changed { return ty_idx; }

  let mut ei: i32 = 0;
  while ei < ctx.enums.len() {
    let e: EnumSig = ctx.enums.get(ei);
    if e.mod_path == fe.sig.mod_path && e.base_name == fe.sig.base_name && e.vars.len() == fe.sig.vars.len() {
      let mut ok: bool = true;
      let mut i2: i32 = 0;
      while i2 < e.vars.len() {
        let ev: EnumVariantSig = e.vars.get(i2);
        let wv: EnumVariantSig = want_vars.get(i2);
        if ev.name != wv.name || ev.fields.len() != wv.fields.len() {
          ok = false;
          i2 = e.vars.len();
        } else {
          let mut j: i32 = 0;
          while j < ev.fields.len() {
            if ev.fields.get(j) != wv.fields.get(j) {
              ok = false;
              j = ev.fields.len();
            } else {
              j = j + 1;
            }
          }
          i2 = i2 + 1;
        }
      }
      if ok {
        let idx: i32 = find_nominal_ty_idx_subst(ctx, ir.TyKind.Enum, e.mod_path, e.name);
        if idx != -1 { return idx; }
      }
    }
    ei = ei + 1;
  }
  return ctx.ty_bad;
}

pub fn ty_has_param(ctx: Ctx, ty_idx: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  if t.kind == ir.TyKind.Param { return true; }
  if t.kind == ir.TyKind.Vec { return ty_has_param(ctx, t.elem); }
  if t.kind == ir.TyKind.Range { return ty_has_param(ctx, t.elem); }
  if t.kind == ir.TyKind.Struct {
    let fs: FindStructResult = find_struct(ctx, t.mod_path, t.name);
    if !fs.found { return false; }
    let mut i: i32 = 0;
    while i < fs.sig.fields.len() {
      if ty_has_param(ctx, fs.sig.fields.get(i).ty) { return true; }
      i = i + 1;
    }
    return false;
  }
  if t.kind == ir.TyKind.Enum {
    let fe: FindEnumResult = find_enum(ctx, t.mod_path, t.name);
    if !fe.found { return false; }
    let mut vi: i32 = 0;
    while vi < fe.sig.vars.len() {
      let v: EnumVariantSig = fe.sig.vars.get(vi);
      let mut fi: i32 = 0;
      while fi < v.fields.len() {
        if ty_has_param(ctx, v.fields.get(fi)) { return true; }
        fi = fi + 1;
      }
      vi = vi + 1;
    }
    return false;
  }
  return false;
}

pub fn unify_ty(ctx: Ctx, pattern: i32, got: i32, subs0: Vec[TySub]) -> UnifyResult {
  let pt: ir.Ty = ir.ty_pool_get(ctx.pool, pattern);
  if is_param_ty(pt) {
    let cur: i32 = subs_lookup(subs0, pt.name);
    if cur == -1 { return UnifyResult { ok: true, subs: subs_add(subs0, pt.name, got) }; }
    if cur == got { return UnifyResult { ok: true, subs: subs0 }; }
    // Allow a refined int type to satisfy an already-bound base int param (widening).
    if assignable_to(ctx, cur, got) { return UnifyResult { ok: true, subs: subs0 }; }
    return UnifyResult { ok: false, subs: subs0 };
  }

  if is_vec_ty2(pt) {
    let gt: ir.Ty = ir.ty_pool_get(ctx.pool, got);
    if !is_vec_ty2(gt) { return UnifyResult { ok: false, subs: subs0 }; }
    return unify_ty(ctx, pt.elem, gt.elem, subs0);
  }

  if pattern == got { return UnifyResult { ok: true, subs: subs0 }; }

  if is_struct_ty2(pt) {
    let gt: ir.Ty = ir.ty_pool_get(ctx.pool, got);
    if !is_struct_ty2(gt) { return UnifyResult { ok: false, subs: subs0 }; }
    if pt.mod_path != gt.mod_path { return UnifyResult { ok: false, subs: subs0 }; }

    let fs0: FindStructResult = find_struct(ctx, pt.mod_path, pt.name);
    let fs1: FindStructResult = find_struct(ctx, gt.mod_path, gt.name);
    if !fs0.found || !fs1.found { return UnifyResult { ok: false, subs: subs0 }; }
    if fs0.sig.base_name != fs1.sig.base_name { return UnifyResult { ok: false, subs: subs0 }; }
    if fs0.sig.fields.len() != fs1.sig.fields.len() { return UnifyResult { ok: false, subs: subs0 }; }

    let mut subs: Vec[TySub] = subs0;
    let mut i: i32 = 0;
    while i < fs0.sig.fields.len() {
      let f0: StructFieldSig = fs0.sig.fields.get(i);
      let f1: StructFieldSig = fs1.sig.fields.get(i);
      if f0.name != f1.name { return UnifyResult { ok: false, subs: subs0 }; }
      let ur: UnifyResult = unify_ty(ctx, f0.ty, f1.ty, subs);
      if !ur.ok { return UnifyResult { ok: false, subs: subs0 }; }
      subs = ur.subs;
      i = i + 1;
    }
    return UnifyResult { ok: true, subs: subs };
  }

  if is_enum_ty2(pt) {
    let gt: ir.Ty = ir.ty_pool_get(ctx.pool, got);
    if !is_enum_ty2(gt) { return UnifyResult { ok: false, subs: subs0 }; }
    if pt.mod_path != gt.mod_path { return UnifyResult { ok: false, subs: subs0 }; }

    let fe0: FindEnumResult = find_enum(ctx, pt.mod_path, pt.name);
    let fe1: FindEnumResult = find_enum(ctx, gt.mod_path, gt.name);
    if !fe0.found || !fe1.found { return UnifyResult { ok: false, subs: subs0 }; }
    if fe0.sig.base_name != fe1.sig.base_name { return UnifyResult { ok: false, subs: subs0 }; }
    if fe0.sig.vars.len() != fe1.sig.vars.len() { return UnifyResult { ok: false, subs: subs0 }; }

    let mut subs2: Vec[TySub] = subs0;
    let mut vi: i32 = 0;
    while vi < fe0.sig.vars.len() {
      let v0: EnumVariantSig = fe0.sig.vars.get(vi);
      let v1: EnumVariantSig = fe1.sig.vars.get(vi);
      if v0.name != v1.name || v0.fields.len() != v1.fields.len() {
        return UnifyResult { ok: false, subs: subs0 };
      }
      let mut fi: i32 = 0;
      while fi < v0.fields.len() {
        let ur2: UnifyResult = unify_ty(ctx, v0.fields.get(fi), v1.fields.get(fi), subs2);
        if !ur2.ok { return UnifyResult { ok: false, subs: subs0 }; }
        subs2 = ur2.subs;
        fi = fi + 1;
      }
      vi = vi + 1;
    }
    return UnifyResult { ok: true, subs: subs2 };
  }

  return UnifyResult { ok: false, subs: subs0 };
}

fn find_vec_ty_idx(ctx: Ctx, elem: i32) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    if t.kind == ir.TyKind.Vec && t.elem == elem { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_range_ty_idx_subst(ctx: Ctx, elem: i32, lo: i64, hi: i64) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    if t.kind == ir.TyKind.Range && t.elem == elem && t.lo == lo && t.hi == hi { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_dot_pos_subst(s: String) -> i32 {
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 46 { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_param_ty_idx_subst(ctx: Ctx, name: String) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    if t.kind == ir.TyKind.Param && t.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn subst_proj_param(ctx: Ctx, name: String, subs: Vec[TySub]) -> i32 {
  // Projection-like type parameter names are represented as flat params:
  //   "U.Item", "U.Item.Sub", ...
  // If base `U` is substituted to param `T`, rewrite to `T.Item...`.
  let dot: i32 = find_dot_pos_subst(name);
  if dot <= 0 { return -1; }
  let base: String = name.slice(0, dot);
  let suffix: String = name.slice(dot, name.len());

  let bty: i32 = subs_lookup(subs, base);
  if bty == -1 { return -1; }
  let bt: ir.Ty = ir.ty_pool_get(ctx.pool, bty);
  if bt.kind != ir.TyKind.Param { return -1; }

  let want: String = bt.name.concat(suffix);
  let sub2: i32 = subs_lookup(subs, want);
  if sub2 != -1 { return sub2; }

  return find_param_ty_idx_subst(ctx, want);
}

pub fn subst_ty(ctx: Ctx, ty_idx: i32, subs: Vec[TySub]) -> i32 {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  if t.kind == ir.TyKind.Param {
    let r: i32 = subs_lookup(subs, t.name);
    if r != -1 { return r; }
    let rp: i32 = subst_proj_param(ctx, t.name, subs);
    if rp != -1 { return rp; }
    return ty_idx;
  }
  if t.kind == ir.TyKind.Vec {
    let e: i32 = subst_ty(ctx, t.elem, subs);
    if e == t.elem { return ty_idx; }
    let vidx: i32 = find_vec_ty_idx(ctx, e);
    if vidx == -1 { return ctx.ty_bad; }
    return vidx;
  }
  if t.kind == ir.TyKind.Range {
    let e2: i32 = subst_ty(ctx, t.elem, subs);
    if e2 == t.elem { return ty_idx; }
    let ridx: i32 = find_range_ty_idx_subst(ctx, e2, t.lo, t.hi);
    if ridx == -1 { return ctx.ty_bad; }
    return ridx;
  }
  if t.kind == ir.TyKind.Struct {
    return subst_struct_nominal_ty(ctx, ty_idx, subs);
  }
  if t.kind == ir.TyKind.Enum {
    return subst_enum_nominal_ty(ctx, ty_idx, subs);
  }
  return ty_idx;
}

pub fn ty_inst_str(ctx: Ctx, ty_idx: i32) -> String {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  if t.kind == ir.TyKind.Unit { return "()"; }
  if t.kind == ir.TyKind.Bool { return "bool"; }
  if t.kind == ir.TyKind.I8 { return "i8"; }
  if t.kind == ir.TyKind.U8 { return "u8"; }
  if t.kind == ir.TyKind.I16 { return "i16"; }
  if t.kind == ir.TyKind.U16 { return "u16"; }
  if t.kind == ir.TyKind.I32 { return "i32"; }
  if t.kind == ir.TyKind.U32 { return "u32"; }
  if t.kind == ir.TyKind.I64 { return "i64"; }
  if t.kind == ir.TyKind.U64 { return "u64"; }
  if t.kind == ir.TyKind.ISize { return "isize"; }
  if t.kind == ir.TyKind.USize { return "usize"; }
  if t.kind == ir.TyKind.F32 { return "f32"; }
  if t.kind == ir.TyKind.F64 { return "f64"; }
  if t.kind == ir.TyKind.String { return "String"; }
  if t.kind == ir.TyKind.Param { return t.name; }
  if t.kind == ir.TyKind.Vec { return "Vec[".concat(ty_inst_str(ctx, t.elem)).concat("]"); }
  if t.kind == ir.TyKind.Range {
    return "@range(".
      concat(t.lo.to_string()).
      concat("..=").
      concat(t.hi.to_string()).
      concat(") ").
      concat(ty_inst_str(ctx, t.elem));
  }
  if t.kind == ir.TyKind.Struct || t.kind == ir.TyKind.Enum {
    // Use `mod::Name` with '/' normalized to '.' for readability.
    if t.mod_path == "" || t.mod_path == "main" { return t.name; }
    let mut s: String = t.mod_path;
    let mut i: i32 = 0;
    while i < s.len() {
      if s.byte_at(i) == 47 { s = s.slice(0, i).concat(".").concat(s.slice(i + 1, s.len())); }
      i = i + 1;
    }
    return s.concat("::").concat(t.name);
  }
  return "<bad>";
}

fn hex2(b: i32) -> String {
  let hex: String = "0123456789abcdef";
  let hi: i32 = b / 16;
  let lo: i32 = b % 16;
  return hex.slice(hi, hi + 1).concat(hex.slice(lo, lo + 1));
}

pub fn mangle_ident(s: String) -> String {
  // Keep [A-Za-z0-9], hex-escape everything else. Prefix with 'g'.
  let mut out: String = "g";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    let ok: bool = (ch >= 97 && ch <= 122) || (ch >= 65 && ch <= 90) || (ch >= 48 && ch <= 57);
    if ok {
      out = out.concat(s.slice(i, i + 1));
    } else {
      out = out.concat("_").concat(hex2(ch));
    }
    i = i + 1;
  }
  return out;
}

pub fn inst_suffix(ctx: Ctx, type_params: Vec[String], subs: Vec[TySub]) -> String {
  return inst_suffix_ex(ctx, type_params, Vec(), subs, Vec());
}

fn const_sub_lookup(csubs: Vec[ConstSub], name: String) -> ConstSub {
  let mut i: i32 = 0;
  while i < csubs.len() {
    let cs: ConstSub = csubs.get(i);
    if cs.name == name { return cs; }
    i = i + 1;
  }
  return ConstSub { name: "", ty: -1, iv: 0, text: "" };
}

fn const_where_ty_lookup(subs: Vec[TySub], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < subs.len() {
    let s: TySub = subs.get(i);
    if s.name == name { return s.ty; }
    i = i + 1;
  }
  return -1;
}

fn const_where_op_text(op: ast.BinaryOp) -> String {
  if match op { ast.BinaryOp.Eq => true, _ => false } { return "=="; }
  if match op { ast.BinaryOp.Ne => true, _ => false } { return "!="; }
  if match op { ast.BinaryOp.Lt => true, _ => false } { return "<"; }
  if match op { ast.BinaryOp.Le => true, _ => false } { return "<="; }
  if match op { ast.BinaryOp.Gt => true, _ => false } { return ">"; }
  if match op { ast.BinaryOp.Ge => true, _ => false } { return ">="; }
  return "?";
}

fn const_where_eval_i64(op: ast.BinaryOp, a: i64, b: i64) -> bool {
  if match op { ast.BinaryOp.Eq => true, _ => false } { return a == b; }
  if match op { ast.BinaryOp.Ne => true, _ => false } { return a != b; }
  if match op { ast.BinaryOp.Lt => true, _ => false } { return a < b; }
  if match op { ast.BinaryOp.Le => true, _ => false } { return a <= b; }
  if match op { ast.BinaryOp.Gt => true, _ => false } { return a > b; }
  if match op { ast.BinaryOp.Ge => true, _ => false } { return a >= b; }
  return false;
}

fn const_where_lhs_text(b: ConstWhereBoundSig) -> String {
  if b.lhs_kind == ast.comptime_where_lhs_const_param() { return b.name; }
  if b.lhs_kind == ast.comptime_where_lhs_size_of() { return "@size_of(".concat(b.name).concat(")"); }
  if b.lhs_kind == ast.comptime_where_lhs_align_of() { return "@align_of(".concat(b.name).concat(")"); }
  if b.lhs_kind == ast.comptime_where_lhs_field_count() { return "@field_count(".concat(b.name).concat(")"); }
  if b.lhs_kind == ast.comptime_where_lhs_type() { return "@type(".concat(b.name).concat(")"); }
  return b.name;
}

pub fn check_const_where_bounds(ctx: Ctx, bounds: Vec[ConstWhereBoundSig], subs: Vec[TySub], csubs: Vec[ConstSub]) -> ConstWhereCheckResult {
  let mut i: i32 = 0;
  while i < bounds.len() {
    let b: ConstWhereBoundSig = bounds.get(i);
    let mut lhs_iv: i64 = 0;
    let mut lhs_text: String = const_where_lhs_text(b);
    if b.lhs_kind == ast.comptime_where_lhs_const_param() {
      let cs: ConstSub = const_sub_lookup(csubs, b.name);
      if cs.name == "" {
        return ConstWhereCheckResult { ok: false, err: "missing const generic arg for constraint: ".concat(b.name) };
      }
      lhs_iv = cs.iv;
      lhs_text = b.name;
    } else if
      b.lhs_kind == ast.comptime_where_lhs_size_of() ||
      b.lhs_kind == ast.comptime_where_lhs_align_of() ||
      b.lhs_kind == ast.comptime_where_lhs_field_count() ||
      b.lhs_kind == ast.comptime_where_lhs_type()
    {
      let lhs_ty0: i32 = const_where_ty_lookup(subs, b.name);
      if lhs_ty0 == -1 {
        return ConstWhereCheckResult { ok: false, err: "missing type generic arg for constraint: ".concat(b.name) };
      }
      let lhs_ty: i32 = strip_range(ctx, lhs_ty0);
      if b.lhs_kind == ast.comptime_where_lhs_size_of() {
        let sr: ReflectIntResult = intrinsic_size_of(ctx, lhs_ty);
        if !sr.ok { return ConstWhereCheckResult { ok: false, err: "comptime where size_of failed: ".concat(sr.err) }; }
        lhs_iv = sr.iv;
      } else if b.lhs_kind == ast.comptime_where_lhs_align_of() {
        let ar: ReflectIntResult = intrinsic_align_of(ctx, lhs_ty);
        if !ar.ok { return ConstWhereCheckResult { ok: false, err: "comptime where align_of failed: ".concat(ar.err) }; }
        lhs_iv = ar.iv;
      } else if b.lhs_kind == ast.comptime_where_lhs_type() {
        let tr: ReflectIntResult = intrinsic_type_id_of(ctx, lhs_ty);
        if !tr.ok { return ConstWhereCheckResult { ok: false, err: "comptime where type failed: ".concat(tr.err) }; }
        lhs_iv = tr.iv;
      } else {
        let fr: ReflectIntResult = intrinsic_field_count_of(ctx, lhs_ty);
        if !fr.ok { return ConstWhereCheckResult { ok: false, err: "comptime where field_count failed: ".concat(fr.err) }; }
        lhs_iv = fr.iv;
      }
    } else {
      return ConstWhereCheckResult { ok: false, err: "unsupported comptime where lhs" };
    }
    let mut rhs_iv: i64 = b.rhs_iv;
    if b.rhs_is_param {
      let rhs_cs: ConstSub = const_sub_lookup(csubs, b.rhs_param);
      if rhs_cs.name == "" {
        return ConstWhereCheckResult { ok: false, err: "missing const generic arg for constraint rhs: ".concat(b.rhs_param) };
      }
      rhs_iv = rhs_cs.iv;
    }
    if !const_where_eval_i64(b.op, lhs_iv, rhs_iv) {
      let msg: String =
        "comptime generic constraint failed: "
          .concat(lhs_text).concat(" ")
          .concat(const_where_op_text(b.op)).concat(" ")
          .concat(b.rhs_text).concat(" (got ").concat(lhs_iv.to_string()).concat(")");
      return ConstWhereCheckResult { ok: false, err: msg };
    }
    i = i + 1;
  }
  return ConstWhereCheckResult { ok: true, err: "" };
}

pub fn inst_suffix_ex(ctx: Ctx, type_params: Vec[String], const_params: Vec[ConstParamSig], subs: Vec[TySub], csubs: Vec[ConstSub]) -> String {
  let mut raw: String = "";
  let mut i: i32 = 0;
  while i < type_params.len() {
    let tp: String = type_params.get(i);
    let ty: i32 = subs_lookup(subs, tp);
    raw = raw.concat(tp).concat("=").concat(ty_inst_str(ctx, ty));
    if i + 1 < type_params.len() { raw = raw.concat(","); }
    i = i + 1;
  }
  let mut j: i32 = 0;
  while j < const_params.len() {
    if raw != "" { raw = raw.concat(","); }
    let cp: ConstParamSig = const_params.get(j);
    let cs: ConstSub = const_sub_lookup(csubs, cp.name);
    if cs.name == "" {
      raw = raw.concat(cp.name).concat("=<missing>");
    } else {
      raw = raw.concat(cp.name)
        .concat("=").concat(cs.text)
        .concat(":").concat(ty_inst_str(ctx, cp.ty));
    }
    j = j + 1;
  }
  return mangle_ident(raw);
}

pub fn inst_name(ctx: Ctx, base: String, type_params: Vec[String], subs: Vec[TySub]) -> String {
  return inst_name_ex(ctx, base, type_params, Vec(), subs, Vec());
}

pub fn inst_name_ex(ctx: Ctx, base: String, type_params: Vec[String], const_params: Vec[ConstParamSig], subs: Vec[TySub], csubs: Vec[ConstSub]) -> String {
  return base.concat("$").concat(inst_suffix_ex(ctx, type_params, const_params, subs, csubs));
}
