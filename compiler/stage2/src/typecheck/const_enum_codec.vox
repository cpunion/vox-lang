// Codec for const enum payload values.
//
// We keep ConstSig shape stable by storing enum payload data in `sv`:
//   unit: "Variant"
//   payload: "Variant#N#kind|ty|iv|bv|sv#..."
// where `sv` of each field uses backslash escaping for `\`, `#`, `|`.

pub struct ConstEnumPayloadField {
  pub kind: i32,
  pub ty: i32,
  pub iv: i64,
  pub bv: bool,
  pub sv: String,
}

pub struct ConstEnumPayloadDecode {
  pub ok: bool,
  pub variant: String,
  pub fields: Vec[ConstEnumPayloadField],
}

fn empty_enum_decode() -> ConstEnumPayloadDecode {
  return ConstEnumPayloadDecode { ok: false, variant: "", fields: Vec() };
}

fn escape_enum_part(s: String) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < s.len() {
    let b: i32 = s.byte_at(i);
    if b == 92 || b == 35 || b == 124 { out = out.concat("\\"); } // \ # |
    out = out.concat(s.slice(i, i + 1));
    i = i + 1;
  }
  return out;
}

fn split_escaped(s: String, sep: i32) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut cur: String = "";
  let mut i: i32 = 0;
  while i < s.len() {
    let b: i32 = s.byte_at(i);
    if b == 92 { // '\'
      i = i + 1;
      if i < s.len() { cur = cur.concat(s.slice(i, i + 1)); }
    } else if b == sep {
      out.push(cur);
      cur = "";
    } else {
      cur = cur.concat(s.slice(i, i + 1));
    }
    i = i + 1;
  }
  out.push(cur);
  return out;
}

pub fn const_enum_pack(variant: String, fields: Vec[ConstEnumPayloadField]) -> String {
  if fields.len() == 0 { return variant; }
  let mut out: String = variant.concat("#").concat(fields.len().to_string());
  let mut i: i32 = 0;
  while i < fields.len() {
    let f: ConstEnumPayloadField = fields.get(i);
    let btxt: String = if f.bv { "1" } else { "0" };
    let ent: String =
      f.kind.to_string()
        .concat("|").concat(f.ty.to_string())
        .concat("|").concat(f.iv.to_string())
        .concat("|").concat(btxt)
        .concat("|").concat(escape_enum_part(f.sv));
    out = out.concat("#").concat(ent);
    i = i + 1;
  }
  return out;
}

pub fn const_enum_unpack(s: String) -> ConstEnumPayloadDecode {
  let parts: Vec[String] = split_escaped(s, 35); // '#'
  if parts.len() == 0 { return empty_enum_decode(); }
  if parts.len() == 1 {
    return ConstEnumPayloadDecode { ok: true, variant: parts.get(0), fields: Vec() };
  }

  let npr: ParseI64DecResult = parse_i64_dec(parts.get(1));
  if !npr.ok || npr.val < 0 { return empty_enum_decode(); }
  let n: i32 = npr.val as i32;
  if parts.len() != n + 2 { return empty_enum_decode(); }

  let mut fs: Vec[ConstEnumPayloadField] = Vec();
  let mut i: i32 = 0;
  while i < n {
    let ep: Vec[String] = split_escaped(parts.get(i + 2), 124); // '|'
    if ep.len() != 5 { return empty_enum_decode(); }

    let kpr: ParseI64DecResult = parse_i64_dec(ep.get(0));
    let tpr: ParseI64DecResult = parse_i64_dec(ep.get(1));
    let ipr: ParseI64DecResult = parse_i64_dec(ep.get(2));
    if !kpr.ok || !tpr.ok || !ipr.ok { return empty_enum_decode(); }

    let btxt: String = ep.get(3);
    if btxt != "0" && btxt != "1" { return empty_enum_decode(); }
    let bv: bool = btxt == "1";

    fs.push(ConstEnumPayloadField {
      kind: kpr.val as i32,
      ty: tpr.val as i32,
      iv: ipr.val,
      bv: bv,
      sv: ep.get(4),
    });
    i = i + 1;
  }

  return ConstEnumPayloadDecode { ok: true, variant: parts.get(0), fields: fs };
}
