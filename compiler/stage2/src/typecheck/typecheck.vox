import "ast" as ast

pub struct TcDiag {
  pub kind: i32,
  pub code: String,
  pub message: String,
  pub rendered: String,
}

pub enum TcError {
  None,
  Diag(TcDiag),
}

pub fn diag_kind_none() -> i32 { return 0; }
pub fn diag_kind_type() -> i32 { return 1; }
pub fn diag_kind_import() -> i32 { return 2; }

pub fn diag_code_type() -> String { return "E_TYPE_0001"; }
pub fn diag_code_import() -> String { return "E_IMPORT_0001"; }
pub fn diag_code_import_unknown_module() -> String { return "E_IMPORT_0002"; }
pub fn diag_code_import_ambiguous_module() -> String { return "E_IMPORT_0003"; }
pub fn diag_code_import_duplicate_alias() -> String { return "E_IMPORT_0004"; }
pub fn diag_code_import_duplicate_name() -> String { return "E_IMPORT_0005"; }
pub fn diag_code_import_name_conflict() -> String { return "E_IMPORT_0006"; }
pub fn diag_code_import_unknown_name() -> String { return "E_IMPORT_0007"; }
pub fn diag_code_import_ambiguous_name() -> String { return "E_IMPORT_0008"; }
pub fn diag_code_import_private_name() -> String { return "E_IMPORT_0009"; }
pub fn diag_code_irgen() -> String { return "E_IRGEN_0001"; }

pub fn tc_error_to_string(e: TcError) -> String {
  return match e {
    TcError.None => "none",
    TcError.Diag(d) => d.rendered,
  };
}

pub fn tc_error_kind(e: TcError) -> i32 {
  return match e {
    TcError.None => diag_kind_none(),
    TcError.Diag(d) => d.kind,
  };
}

pub fn tc_error_code(e: TcError) -> String {
  return match e {
    TcError.None => "",
    TcError.Diag(d) => d.code,
  };
}

pub fn tc_error_message(e: TcError) -> String {
  return match e {
    TcError.None => "",
    TcError.Diag(d) => d.message,
  };
}

// Minimal diagnostics formatting (v0): when span is unknown, fall back to 1:1.
// See docs/18-diagnostics.md.
pub fn diag1(file: String, msg: String) -> String {
  return file.concat(":1:1: ").concat(msg);
}

pub fn diag_span(sp: ast.Span, msg: String) -> String {
  if sp.file == "" { return diag1("", msg); }
  return sp.file.concat(":").concat(sp.line.to_string()).concat(":").concat(sp.col.to_string()).concat(": ").concat(msg);
}

fn mk_diag(kind: i32, code: String, msg: String, rendered: String) -> TcError {
  return TcError.Diag(TcDiag {
    kind: kind,
    code: code,
    message: msg,
    rendered: rendered,
  });
}

fn type_error_at(sp: ast.Span, msg: String) -> TcError {
  let code: String = diag_code_type();
  return mk_diag(diag_kind_type(), code, msg, diag_span(sp, "type error: ".concat(msg).concat(" [").concat(code).concat("]")));
}

fn type_error(file: String, msg: String) -> TcError {
  let code: String = diag_code_type();
  return mk_diag(diag_kind_type(), code, msg, diag1(file, "type error: ".concat(msg).concat(" [").concat(code).concat("]")));
}

pub fn tc_type_error_at(sp: ast.Span, msg: String) -> TcError { return type_error_at(sp, msg); }
pub fn tc_type_error(file: String, msg: String) -> TcError { return type_error(file, msg); }

fn import_error(file: String, msg: String) -> TcError {
  let code: String = diag_code_import();
  return mk_diag(diag_kind_import(), code, msg, diag1(file, "import error: ".concat(msg).concat(" [").concat(code).concat("]")));
}

fn import_error_at(sp: ast.Span, msg: String) -> TcError {
  let code: String = diag_code_import();
  return mk_diag(diag_kind_import(), code, msg, diag_span(sp, "import error: ".concat(msg).concat(" [").concat(code).concat("]")));
}

fn import_error_code(file: String, msg: String, code: String) -> TcError {
  return mk_diag(diag_kind_import(), code, msg, diag1(file, "import error: ".concat(msg).concat(" [").concat(code).concat("]")));
}

fn import_error_at_code(sp: ast.Span, msg: String, code: String) -> TcError {
  return mk_diag(diag_kind_import(), code, msg, diag_span(sp, "import error: ".concat(msg).concat(" [").concat(code).concat("]")));
}

pub fn irgen_error(file: String, msg: String) -> String {
  let code: String = diag_code_irgen();
  return diag1(file, "irgen error: ".concat(msg).concat(" [").concat(code).concat("]"));
}

pub fn irgen_error_at(sp: ast.Span, msg: String) -> String {
  let code: String = diag_code_irgen();
  return diag_span(sp, "irgen error: ".concat(msg).concat(" [").concat(code).concat("]"));
}

pub struct TcResult {
  pub ok: bool,
  pub err: TcError,
}

pub struct WorldModule {
  pub path: String,
  pub prog: ast.Program,
}

pub struct World {
  pub mods: Vec[WorldModule],
}

pub fn world() -> World { return World { mods: Vec() }; }

pub fn world_add(w: World, path: String, prog: ast.Program) -> World {
  let mut q: World = w;
  q.mods.push(WorldModule { path: path, prog: prog });
  return q;
}

struct FindImplByDeclResult { found: bool, sig: ImplSig }

fn empty_impl_sig() -> ImplSig {
  return ImplSig {
    mod_path: "",
    decl_idx: -1,
    is_inherent: false,
    trait_mod_path: "",
    trait_name: "",
    for_ty: -1,
    head_type_params: Vec(),
    head_type_param_bounds: Vec(),
    assoc_types: Vec(),
    methods: Vec(),
  };
}

fn find_impl_by_decl(ctx: Ctx, mod_path: String, decl_idx: i32) -> FindImplByDeclResult {
  let mut i: i32 = 0;
  while i < ctx.impls.len() {
    let s: ImplSig = ctx.impls.get(i);
    if s.mod_path == mod_path && s.decl_idx == decl_idx {
      return FindImplByDeclResult { found: true, sig: s };
    }
    i = i + 1;
  }
  return FindImplByDeclResult { found: false, sig: empty_impl_sig() };
}

fn dummy_type_name() -> ast.TypeName {
  let mut parts: Vec[String] = Vec();
  parts.push("i32");
  return ast.TypeName { parts: parts, args: Vec() };
}

fn synth_params(names: Vec[String]) -> Vec[ast.Param] {
  let mut out: Vec[ast.Param] = Vec();
  let mut i: i32 = 0;
  while i < names.len() {
    out.push(ast.Param { name: names.get(i), ty: dummy_type_name() });
    i = i + 1;
  }
  return out;
}

pub fn typecheck_world(w: World) -> TcResult {
  let br: BuildCtxResult = build_ctx(w);
  if !br.ok { return TcResult { ok: false, err: br.err }; }
  let c: Ctx = br.ctx;

  // Typecheck function/impl/default bodies (including generic bodies).
  let mut mi2: i32 = 0;
  while mi2 < w.mods.len() {
    let m2: WorldModule = w.mods.get(mi2);
    let mut fi2: i32 = 0;
    while fi2 < m2.prog.funcs.len() {
      let fd: ast.FuncDecl = m2.prog.funcs.get(fi2);
      let ir: ImportsResult = build_imports(w, m2.path, m2.prog.imports, fd.file);
      if !ir.ok { return TcResult { ok: false, err: ir.err }; }
      let imps: Imports = ir.imps;
      let fr: TcResult = typecheck_fn(c, w, m2.path, imps, m2.prog.exprs, fd);
      if !fr.ok { return fr; }
      fi2 = fi2 + 1;
    }

    // Typecheck impl method bodies (already lowered into ctx.funcs during collect_impls).
    let mut ii2: i32 = 0;
    while ii2 < m2.prog.impls.len() {
      let id: ast.ImplDecl = m2.prog.impls.get(ii2);
      let fr0: FindImplByDeclResult = find_impl_by_decl(c, m2.path, ii2);
      if !fr0.found { return TcResult { ok: false, err: type_error_at(id.sp, "missing impl sig") }; }

      let ir0: ImportsResult = build_imports(w, m2.path, m2.prog.imports, id.file);
      if !ir0.ok { return TcResult { ok: false, err: ir0.err }; }
      let imps0: Imports = ir0.imps;

      let mut mdi: i32 = 0;
      while mdi < id.methods.len() {
        let md: ast.FuncDecl = id.methods.get(mdi);
        let mf: FindImplMethodResult = find_impl_method(fr0.sig, md.name);
        if !mf.found { return TcResult { ok: false, err: type_error_at(md.sp, "missing impl method sig") }; }
        let tr: TcResult = typecheck_fn_with_sig(c, w, m2.path, imps0, m2.prog.exprs, md, mf.m.sig);
        if !tr.ok { return tr; }
        mdi = mdi + 1;
      }

      // Typecheck synthesized default trait methods lowered into impl signatures.
      let mut mi3: i32 = 0;
      while mi3 < fr0.sig.methods.len() {
        let ms: ImplMethodSig = fr0.sig.methods.get(mi3);
        if ms.from_default {
          let fmd: FindModResult = find_mod(w, ms.default_mod_path);
          if !fmd.found { return TcResult { ok: false, err: type_error_at(id.sp, "missing default trait method module") }; }
          let mdm: WorldModule = w.mods.get(fmd.idx);
          let ird: ImportsResult = build_imports(w, mdm.path, mdm.prog.imports, ms.default_file);
          if !ird.ok { return TcResult { ok: false, err: ird.err }; }
          let impsd: Imports = ird.imps;
          let fd: ast.FuncDecl = ast.FuncDecl {
            file: ms.default_file,
            sp: ast.span0(),
            vis: ast.vis_private(),
            is_pub: false,
            name: ms.name,
            type_params: Vec(),
            type_param_packs: Vec(),
            const_params: Vec(),
            type_param_bounds: Vec(),
            const_where_bounds: Vec(),
            params: synth_params(ms.default_params),
            ret: dummy_type_name(),
            body: ms.default_body,
          };
          let tr2: TcResult = typecheck_fn_with_sig(c, w, mdm.path, impsd, mdm.prog.exprs, fd, ms.sig);
          if !tr2.ok { return tr2; }
        }
        mi3 = mi3 + 1;
      }

      ii2 = ii2 + 1;
    }

    mi2 = mi2 + 1;
  }

  return TcResult { ok: true, err: TcError.None };
}

pub struct BuildCtxResult {
  pub ok: bool,
  pub err: TcError,
  pub ctx: Ctx,
}

pub fn build_ctx(w: World) -> BuildCtxResult {
  // Validate that all imported modules exist.
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let imps: Vec[ast.ImportDecl] = m.prog.imports;
    let mut ii: i32 = 0;
    while ii < imps.len() {
      let imp: ast.ImportDecl = imps.get(ii);
      let rr: ResolveImportResult = resolve_import_path(w, imp.file, imp.path, imp.sp);
      if !rr.ok { return BuildCtxResult { ok: false, err: rr.err, ctx: new_ctx() }; }
      let fm: FindModResult = find_mod(w, rr.path);
      if !fm.found {
        return BuildCtxResult {
          ok: false,
          err: import_error_at_code(imp.sp, "unknown module import: ".concat(imp.path), diag_code_import_unknown_module()),
          ctx: new_ctx(),
        };
      }
      ii = ii + 1;
    }
    mi = mi + 1;
  }

  let mut c: Ctx = new_ctx();
  let r0: TcCtxResult = collect_type_aliases(c, w);
  if !r0.ok { return BuildCtxResult { ok: false, err: r0.err, ctx: r0.ctx }; }
  c = r0.ctx;
  let r1: TcCtxResult = collect_structs(c, w);
  if !r1.ok { return BuildCtxResult { ok: false, err: r1.err, ctx: r1.ctx }; }
  c = r1.ctx;
  let r2: TcCtxResult = collect_enums(c, w);
  if !r2.ok { return BuildCtxResult { ok: false, err: r2.err, ctx: r2.ctx }; }
  c = r2.ctx;
  let r25: TcCtxResult = collect_traits(c, w);
  if !r25.ok { return BuildCtxResult { ok: false, err: r25.err, ctx: r25.ctx }; }
  c = r25.ctx;
  let r3: TcCtxResult = collect_funcs(c, w);
  if !r3.ok { return BuildCtxResult { ok: false, err: r3.err, ctx: r3.ctx }; }
  c = r3.ctx;
  let r35: TcCtxResult = collect_impls(c, w);
  if !r35.ok { return BuildCtxResult { ok: false, err: r35.err, ctx: r35.ctx }; }
  c = r35.ctx;
  let r00: TcCtxResult = collect_consts(c, w);
  if !r00.ok { return BuildCtxResult { ok: false, err: r00.err, ctx: r00.ctx }; }
  c = r00.ctx;
  let r4: TcCtxResult = collect_body_type_names(c, w);
  if !r4.ok { return BuildCtxResult { ok: false, err: r4.err, ctx: r4.ctx }; }
  c = r4.ctx;
  return BuildCtxResult { ok: true, err: TcError.None, ctx: c };
}
