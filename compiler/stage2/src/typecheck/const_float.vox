import "ast" as ast

// Unsigned decimal helpers used by const float folding. We keep float values as
// canonical decimal text so stage0 does not need native float execution support.

struct UDecDivMod { q: String, r: String }
struct FloatParts { neg: bool, intp: String, frac: String }
struct FloatDivTextResult { ok: bool, err: String, text: String }
struct ConstFloatBinaryEvalResult { ok: bool, err: String, is_bool: bool, text: String, out: bool }

fn digit_char(d: i32) -> String {
  let ds: String = "0123456789";
  if d < 0 { return "0"; }
  if d > 9 { return "9"; }
  return ds.slice(d, d + 1);
}

fn zeros(n: i32) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < n {
    out = out.concat("0");
    i = i + 1;
  }
  return out;
}

fn udec_trim(s0: String) -> String {
  if s0.len() == 0 { return "0"; }
  let mut i: i32 = 0;
  let n: i32 = s0.len();
  while (i + 1) < n && s0.byte_at(i) == 48 {
    i = i + 1;
  }
  return s0.slice(i, n);
}

fn udec_cmp(a0: String, b0: String) -> i32 {
  let a: String = udec_trim(a0);
  let b: String = udec_trim(b0);
  if a.len() < b.len() { return -1; }
  if a.len() > b.len() { return 1; }
  let mut i: i32 = 0;
  while i < a.len() {
    let ca: i32 = a.byte_at(i);
    let cb: i32 = b.byte_at(i);
    if ca < cb { return -1; }
    if ca > cb { return 1; }
    i = i + 1;
  }
  return 0;
}

fn digits_rev_to_text(digs: Vec[i32]) -> String {
  if digs.len() == 0 { return "0"; }
  let mut out: String = "";
  let mut i: i32 = digs.len() - 1;
  while i >= 0 {
    out = out.concat(digit_char(digs.get(i)));
    i = i - 1;
  }
  return udec_trim(out);
}

fn udec_add(a0: String, b0: String) -> String {
  let a: String = udec_trim(a0);
  let b: String = udec_trim(b0);
  let mut i: i32 = a.len() - 1;
  let mut j: i32 = b.len() - 1;
  let mut carry: i32 = 0;
  let mut digs: Vec[i32] = Vec();
  while i >= 0 || j >= 0 || carry > 0 {
    let da: i32 = if i >= 0 { a.byte_at(i) - 48 } else { 0 };
    let db: i32 = if j >= 0 { b.byte_at(j) - 48 } else { 0 };
    let sum: i32 = da + db + carry;
    digs.push(sum % 10);
    carry = sum / 10;
    i = i - 1;
    j = j - 1;
  }
  return digits_rev_to_text(digs);
}

fn udec_sub(a0: String, b0: String) -> String {
  let a: String = udec_trim(a0);
  let b: String = udec_trim(b0);
  let cmp: i32 = udec_cmp(a, b);
  if cmp <= 0 { return "0"; }

  let mut i: i32 = a.len() - 1;
  let mut j: i32 = b.len() - 1;
  let mut borrow: i32 = 0;
  let mut digs: Vec[i32] = Vec();
  while i >= 0 {
    let mut da: i32 = (a.byte_at(i) - 48) - borrow;
    let db: i32 = if j >= 0 { b.byte_at(j) - 48 } else { 0 };
    if da < db {
      da = da + 10;
      borrow = 1;
    } else {
      borrow = 0;
    }
    digs.push(da - db);
    i = i - 1;
    j = j - 1;
  }
  return digits_rev_to_text(digs);
}

fn udec_mul_digit(a0: String, d: i32) -> String {
  let a: String = udec_trim(a0);
  if a == "0" || d == 0 { return "0"; }
  if d == 1 { return a; }

  let mut i: i32 = a.len() - 1;
  let mut carry: i32 = 0;
  let mut digs: Vec[i32] = Vec();
  while i >= 0 {
    let da: i32 = a.byte_at(i) - 48;
    let prod: i32 = da * d + carry;
    digs.push(prod % 10);
    carry = prod / 10;
    i = i - 1;
  }
  while carry > 0 {
    digs.push(carry % 10);
    carry = carry / 10;
  }
  return digits_rev_to_text(digs);
}

fn udec_mul_pow10(a0: String, n: i32) -> String {
  let a: String = udec_trim(a0);
  if a == "0" { return "0"; }
  if n <= 0 { return a; }
  return a.concat(zeros(n));
}

fn udec_mul(a0: String, b0: String) -> String {
  let a: String = udec_trim(a0);
  let b: String = udec_trim(b0);
  if a == "0" || b == "0" { return "0"; }

  let mut out: String = "0";
  let mut shift: i32 = 0;
  let mut j: i32 = b.len() - 1;
  while j >= 0 {
    let d: i32 = b.byte_at(j) - 48;
    let mut part: String = udec_mul_digit(a, d);
    if part != "0" {
      part = part.concat(zeros(shift));
      out = udec_add(out, part);
    }
    shift = shift + 1;
    j = j - 1;
  }
  return udec_trim(out);
}

fn udec_divmod(a0: String, b0: String) -> UDecDivMod {
  let a: String = udec_trim(a0);
  let b: String = udec_trim(b0);
  if b == "0" { return UDecDivMod { q: "0", r: "0" }; }
  if a == "0" { return UDecDivMod { q: "0", r: "0" }; }
  if udec_cmp(a, b) < 0 { return UDecDivMod { q: "0", r: a }; }

  let mut rem: String = "0";
  let mut q: String = "";
  let mut i: i32 = 0;
  while i < a.len() {
    let ch: String = a.slice(i, i + 1);
    if rem == "0" { rem = ch; } else { rem = rem.concat(ch); }
    rem = udec_trim(rem);

    let mut d: i32 = 9;
    let mut chosen: i32 = 0;
    while d >= 0 {
      let p: String = udec_mul_digit(b, d);
      if udec_cmp(p, rem) <= 0 {
        chosen = d;
        d = -1;
      } else {
        d = d - 1;
      }
    }
    q = q.concat(digit_char(chosen));
    rem = udec_sub(rem, udec_mul_digit(b, chosen));
    i = i + 1;
  }
  return UDecDivMod { q: udec_trim(q), r: udec_trim(rem) };
}

fn max_i32(a: i32, b: i32) -> i32 { return if a > b { a } else { b }; }

fn float_parts(s0: String) -> FloatParts {
  let mut s: String = float_norm_text(s0);
  let mut neg: bool = false;
  if s.len() > 0 && s.byte_at(0) == 45 {
    neg = true;
    s = s.slice(1, s.len());
  }

  let mut dot: i32 = -1;
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 46 { dot = i; }
    i = i + 1;
  }
  if dot == -1 { return FloatParts { neg: neg, intp: s, frac: "0" }; }

  let mut intp: String = s.slice(0, dot);
  let mut frac: String = s.slice(dot + 1, s.len());
  if intp.len() == 0 { intp = "0"; }
  if frac.len() == 0 { frac = "0"; }
  return FloatParts { neg: neg, intp: intp, frac: frac };
}

fn float_abs_scaled(p: FloatParts, scale: i32) -> String {
  let mut s: String = p.intp.concat(p.frac);
  let pad: i32 = scale - p.frac.len();
  if pad > 0 { s = s.concat(zeros(pad)); }
  return udec_trim(s);
}

fn float_from_abs_scaled(abs0: String, scale0: i32, neg: bool) -> String {
  let mut abs: String = udec_trim(abs0);
  if abs == "0" { return "0.0"; }

  let mut scale: i32 = scale0;
  if scale < 0 { scale = 0; }
  if scale == 0 {
    let mut out0: String = abs.concat(".0");
    if neg { out0 = "-".concat(out0); }
    return float_norm_text(out0);
  }

  if abs.len() <= scale {
    abs = zeros(scale + 1 - abs.len()).concat(abs);
  }
  let split: i32 = abs.len() - scale;
  let intp: String = abs.slice(0, split);
  let frac: String = abs.slice(split, abs.len());
  let mut out: String = intp.concat(".").concat(frac);
  if neg { out = "-".concat(out); }
  return float_norm_text(out);
}

fn float_cmp_abs(pa: FloatParts, pb: FloatParts) -> i32 {
  let scale: i32 = max_i32(pa.frac.len(), pb.frac.len());
  let aa: String = float_abs_scaled(pa, scale);
  let bb: String = float_abs_scaled(pb, scale);
  return udec_cmp(aa, bb);
}

fn float_cmp_norm(a0: String, b0: String) -> i32 {
  let pa: FloatParts = float_parts(a0);
  let pb: FloatParts = float_parts(b0);
  if pa.neg != pb.neg {
    return if pa.neg { -1 } else { 1 };
  }
  let c: i32 = float_cmp_abs(pa, pb);
  if pa.neg { return -c; }
  return c;
}

fn float_add_norm(a0: String, b0: String) -> String {
  let pa: FloatParts = float_parts(a0);
  let pb: FloatParts = float_parts(b0);
  let scale: i32 = max_i32(pa.frac.len(), pb.frac.len());
  let aa: String = float_abs_scaled(pa, scale);
  let bb: String = float_abs_scaled(pb, scale);

  if pa.neg == pb.neg {
    return float_from_abs_scaled(udec_add(aa, bb), scale, pa.neg);
  }

  let c: i32 = udec_cmp(aa, bb);
  if c == 0 { return "0.0"; }
  if c > 0 { return float_from_abs_scaled(udec_sub(aa, bb), scale, pa.neg); }
  return float_from_abs_scaled(udec_sub(bb, aa), scale, pb.neg);
}

fn float_sub_norm(a: String, b: String) -> String {
  return float_add_norm(a, float_neg_text(b));
}

fn float_mul_norm(a0: String, b0: String) -> String {
  let pa: FloatParts = float_parts(a0);
  let pb: FloatParts = float_parts(b0);
  let aa: String = udec_trim(pa.intp.concat(pa.frac));
  let bb: String = udec_trim(pb.intp.concat(pb.frac));
  let scale: i32 = pa.frac.len() + pb.frac.len();
  let neg: bool = pa.neg != pb.neg;
  return float_from_abs_scaled(udec_mul(aa, bb), scale, neg);
}

fn float_div_norm(a0: String, b0: String) -> FloatDivTextResult {
  let pa: FloatParts = float_parts(a0);
  let pb: FloatParts = float_parts(b0);
  let mut n: String = udec_trim(pa.intp.concat(pa.frac));
  let mut d: String = udec_trim(pb.intp.concat(pb.frac));
  if d == "0" { return FloatDivTextResult { ok: false, err: "const division by zero", text: "" }; }

  let sa: i32 = pa.frac.len();
  let sb: i32 = pb.frac.len();
  if sb > sa { n = udec_mul_pow10(n, sb - sa); }
  if sa > sb { d = udec_mul_pow10(d, sa - sb); }

  let dm0: UDecDivMod = udec_divmod(n, d);
  let q: String = dm0.q;
  let mut rem: String = dm0.r;
  let mut frac: String = "";
  let mut i: i32 = 0;
  while i < 18 && rem != "0" {
    rem = udec_mul_pow10(rem, 1);
    let dm: UDecDivMod = udec_divmod(rem, d);
    frac = frac.concat(dm.q);
    rem = dm.r;
    i = i + 1;
  }
  if frac.len() == 0 { frac = "0"; }

  let neg: bool = pa.neg != pb.neg;
  let out: String = float_from_abs_scaled(q.concat(frac), frac.len(), neg);
  return FloatDivTextResult { ok: true, err: "", text: out };
}

fn float_mod_norm(a0: String, b0: String) -> FloatDivTextResult {
  let pa: FloatParts = float_parts(a0);
  let pb: FloatParts = float_parts(b0);
  let aa: String = udec_trim(pa.intp.concat(pa.frac));
  let bb: String = udec_trim(pb.intp.concat(pb.frac));
  if bb == "0" { return FloatDivTextResult { ok: false, err: "const division by zero", text: "" }; }

  // q_abs = floor(|a|/|b|) with exact decimal alignment.
  let num: String = udec_mul_pow10(aa, pb.frac.len());
  let den: String = udec_mul_pow10(bb, pa.frac.len());
  let dm: UDecDivMod = udec_divmod(num, den);
  let q_abs: String = dm.q;
  if q_abs == "0" { return FloatDivTextResult { ok: true, err: "", text: float_norm_text(a0) }; }

  // q*b has the same sign as a (trunc toward zero).
  let scale: i32 = max_i32(pa.frac.len(), pb.frac.len());
  let b_scaled: String = udec_mul_pow10(bb, scale - pb.frac.len());
  let qb_abs: String = udec_mul(q_abs, b_scaled);
  let qb: String = float_from_abs_scaled(qb_abs, scale, pa.neg);

  return FloatDivTextResult { ok: true, err: "", text: float_sub_norm(float_norm_text(a0), qb) };
}

fn const_float_binary_eval(op: ast.BinaryOp, a0: String, b0: String) -> ConstFloatBinaryEvalResult {
  let a: String = float_norm_text(a0);
  let b: String = float_norm_text(b0);

  if match op { ast.BinaryOp.Add => true, _ => false } {
    return ConstFloatBinaryEvalResult { ok: true, err: "", is_bool: false, text: float_add_norm(a, b), out: false };
  }
  if match op { ast.BinaryOp.Sub => true, _ => false } {
    return ConstFloatBinaryEvalResult { ok: true, err: "", is_bool: false, text: float_sub_norm(a, b), out: false };
  }
  if match op { ast.BinaryOp.Mul => true, _ => false } {
    return ConstFloatBinaryEvalResult { ok: true, err: "", is_bool: false, text: float_mul_norm(a, b), out: false };
  }
  if match op { ast.BinaryOp.Div => true, _ => false } {
    let dr: FloatDivTextResult = float_div_norm(a, b);
    if !dr.ok { return ConstFloatBinaryEvalResult { ok: false, err: dr.err, is_bool: false, text: "", out: false }; }
    return ConstFloatBinaryEvalResult { ok: true, err: "", is_bool: false, text: dr.text, out: false };
  }
  if match op { ast.BinaryOp.Mod => true, _ => false } {
    let mr: FloatDivTextResult = float_mod_norm(a, b);
    if !mr.ok { return ConstFloatBinaryEvalResult { ok: false, err: mr.err, is_bool: false, text: "", out: false }; }
    return ConstFloatBinaryEvalResult { ok: true, err: "", is_bool: false, text: mr.text, out: false };
  }

  if match op { ast.BinaryOp.Lt => true, ast.BinaryOp.Le => true, ast.BinaryOp.Gt => true, ast.BinaryOp.Ge => true, _ => false } {
    let c: i32 = float_cmp_norm(a, b);
    let out: bool =
      match op {
        ast.BinaryOp.Lt => c < 0,
        ast.BinaryOp.Le => c <= 0,
        ast.BinaryOp.Gt => c > 0,
        _ => c >= 0,
      };
    return ConstFloatBinaryEvalResult { ok: true, err: "", is_bool: true, text: "", out: out };
  }

  return ConstFloatBinaryEvalResult { ok: false, err: "const float op unsupported", is_bool: false, text: "", out: false };
}
