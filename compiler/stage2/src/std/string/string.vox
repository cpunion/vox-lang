fn panic_range() -> () { panic("StrView range out of bounds"); }

fn panic_index() -> () { panic("StrView index out of bounds"); }

fn check_range(n: i32, lo: i32, hi: i32) -> () {
  if lo < 0 || hi < lo || hi > n { panic_range(); }
}

pub struct StrView {
  owner: String,
  lo: i32,
  hi: i32,
}

pub fn view_all(owner: String) -> StrView {
  let n: i32 = owner.len();
  return StrView { owner: owner, lo: 0, hi: n };
}

pub fn view_range(owner: String, lo: i32, hi: i32) -> StrView {
  let n: i32 = owner.len();
  check_range(n, lo, hi);
  return StrView { owner: owner, lo: lo, hi: hi };
}

pub fn len(v: StrView) -> i32 { return v.hi - v.lo; }

pub fn is_empty(v: StrView) -> bool { return len(v) == 0; }

pub fn byte_at(v: StrView, idx: i32) -> i32 {
  let n: i32 = len(v);
  if idx < 0 || idx >= n { panic_index(); }
  return v.owner.byte_at(v.lo + idx);
}

pub fn sub(v: StrView, lo: i32, hi: i32) -> StrView {
  let n: i32 = len(v);
  check_range(n, lo, hi);
  return StrView { owner: v.owner, lo: v.lo + lo, hi: v.lo + hi };
}

pub fn to_string(v: StrView) -> String { return v.owner.slice(v.lo, v.hi); }

pub fn starts_with(v: StrView, pre: String) -> bool {
  let pn: i32 = pre.len();
  if pn > len(v) { return false; }
  let mut i: i32 = 0;
  while i < pn {
    if byte_at(v, i) != pre.byte_at(i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn ends_with(v: StrView, suf: String) -> bool {
  let sn: i32 = suf.len();
  let n: i32 = len(v);
  if sn > n { return false; }
  let mut i: i32 = 0;
  while i < sn {
    if byte_at(v, n - sn + i) != suf.byte_at(i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn index_of(v: StrView, needle: String) -> i32 {
  let nn: i32 = needle.len();
  let vn: i32 = len(v);
  if nn == 0 { return 0; }
  if nn > vn { return -1; }
  let mut i: i32 = 0;
  while i <= vn - nn {
    let mut ok: bool = true;
    let mut j: i32 = 0;
    while j < nn {
      if byte_at(v, i + j) != needle.byte_at(j) {
        ok = false;
        j = nn;
      } else {
        j = j + 1;
      }
    }
    if ok { return i; }
    i = i + 1;
  }
  return -1;
}

pub fn last_index_of(v: StrView, needle: String) -> i32 {
  let nn: i32 = needle.len();
  let vn: i32 = len(v);
  if nn == 0 { return vn; }
  if nn > vn { return -1; }
  let mut i: i32 = vn - nn;
  while i >= 0 {
    let mut ok: bool = true;
    let mut j: i32 = 0;
    while j < nn {
      if byte_at(v, i + j) != needle.byte_at(j) {
        ok = false;
        j = nn;
      } else {
        j = j + 1;
      }
    }
    if ok { return i; }
    i = i - 1;
  }
  return -1;
}

pub fn contains(v: StrView, needle: String) -> bool { return index_of(v, needle) >= 0; }
