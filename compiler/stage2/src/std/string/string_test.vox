import "std/testing" as t
import "std/string" as s

fn test_strview_range_to_string_smoke() -> () {
  let v: s.StrView = s.view_range("vox-lang", 0, 3);
  t.assert_eq(s.to_string(v), "vox");
}

fn test_strview_sub_and_len_smoke() -> () {
  let base: s.StrView = s.view_all("vox-lang");
  let mid: s.StrView = s.sub(base, 4, 8);
  t.assert_eq(s.to_string(mid), "lang");

  let v: s.StrView = s.view_range("vox-lang", 1, 4);
  t.assert_eq(s.len(v), 3);
}

fn test_strview_predicates_smoke() -> () {
  let v0: s.StrView = s.view_range("vox-lang", 0, 3);
  t.assert(s.starts_with(v0, "vo"));

  let v1: s.StrView = s.view_range("vox-lang", 0, 3);
  t.assert(s.ends_with(v1, "ox"));

  let v2: s.StrView = s.view_range("vox-lang", 2, 2);
  t.assert(s.is_empty(v2));
}

fn test_strview_contains_and_index_ops_smoke() -> () {
  let v: s.StrView = s.view_all("vox-lang-vox");
  t.assert(s.contains(v, "lang"));
  t.assert_eq(s.index_of(v, "vox"), 0);
  t.assert_eq(s.last_index_of(v, "vox"), 9);
  t.assert_eq(s.index_of(v, "none"), -1);
  t.assert_eq(s.last_index_of(v, "none"), -1);
}

fn test_strview_index_ops_empty_needle_smoke() -> () {
  let v: s.StrView = s.view_range("vox", 1, 3);
  t.assert_eq(s.index_of(v, ""), 0);
  t.assert_eq(s.last_index_of(v, ""), s.len(v));
}

fn test_strview_view_match_ops_smoke() -> () {
  let v: s.StrView = s.view_all("vox-lang-vox");
  let pre: s.StrView = s.view_range("vox", 0, 2); // "vo"
  let suf: s.StrView = s.view_range("vox", 1, 3); // "ox"
  let mid: s.StrView = s.view_range("xlangx", 1, 5); // "lang"
  let miss: s.StrView = s.view_range("none", 0, 4);
  let empty: s.StrView = s.view_range("q", 1, 1);

  t.assert(s.starts_with_view(v, pre));
  t.assert(s.ends_with_view(v, suf));
  t.assert(s.contains_view(v, mid));
  t.assert_eq(s.index_of_view(v, mid), 4);
  t.assert_eq(s.last_index_of_view(v, pre), 9);
  t.assert(!s.contains_view(v, miss));
  t.assert_eq(s.index_of_view(v, miss), -1);
  t.assert_eq(s.last_index_of_view(v, miss), -1);
  t.assert(s.starts_with_view(v, empty));
  t.assert(s.ends_with_view(v, empty));
  t.assert_eq(s.index_of_view(v, empty), 0);
  t.assert_eq(s.last_index_of_view(v, empty), s.len(v));
}

fn test_strview_compare_ops_smoke() -> () {
  let a: s.StrView = s.view_range("vox-lang", 0, 3); // "vox"
  let b: s.StrView = s.view_range("vox", 0, 3);
  let c: s.StrView = s.view_range("voy", 0, 3);
  let short: s.StrView = s.view_range("vo", 0, 2);

  t.assert(s.equals(a, "vox"));
  t.assert(!s.equals(a, "vo"));
  t.assert_eq(s.compare(a, "vox"), 0);
  t.assert_eq(s.compare(a, "voy"), -1);
  t.assert_eq(s.compare(a, "vo"), 1);

  t.assert(s.equals_view(a, b));
  t.assert(!s.equals_view(a, c));
  t.assert_eq(s.compare_view(a, b), 0);
  t.assert_eq(s.compare_view(a, c), -1);
  t.assert_eq(s.compare_view(a, short), 1);
}

fn test_strview_take_drop_prefix_suffix_smoke() -> () {
  let base: s.StrView = s.view_all("vox-lang");
  let pre: s.StrView = s.take_prefix(base, 3);
  let suf: s.StrView = s.take_suffix(base, 4);
  let drop_pre: s.StrView = s.drop_prefix(base, 4);
  let drop_suf: s.StrView = s.drop_suffix(base, 5);

  t.assert_eq(s.to_string(pre), "vox");
  t.assert_eq(s.to_string(suf), "lang");
  t.assert_eq(s.to_string(drop_pre), "lang");
  t.assert_eq(s.to_string(drop_suf), "vox");

  let whole: s.StrView = s.take_prefix(base, s.len(base));
  let empty: s.StrView = s.drop_prefix(base, s.len(base));
  t.assert(s.equals_view(whole, base));
  t.assert(s.is_empty(empty));
}
