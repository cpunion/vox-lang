import "std/testing" as t
import "std/collections" as c

fn test_map_set_get_contains_len_smoke() -> () {
  let mut m: c.Map[String, i32] = c.map();
  t.assert(c.map_is_empty(m));

  m = c.map_set(m, "a", 1);
  m = c.map_set(m, "b", 2);
  t.assert_eq(c.map_len(m), 2);
  t.assert(c.map_contains_key(m, "a"));
  t.assert(c.map_contains_key(m, "b"));
  t.assert(!c.map_contains_key(m, "x"));
  t.assert_eq(c.map_get[String, i32](m, "a"), 1);
  t.assert_eq(c.map_get[String, i32](m, "b"), 2);
}

fn test_map_set_overwrite_smoke() -> () {
  let mut m: c.Map[i32, String] = c.map();
  m = c.map_set(m, 7, "old");
  m = c.map_set(m, 7, "new");
  t.assert_eq(c.map_len(m), 1);
  t.assert_eq(c.map_get[i32, String](m, 7), "new");
}

fn test_map_remove_smoke() -> () {
  let mut m: c.Map[i32, i32] = c.map();
  m = c.map_set(m, 1, 10);
  m = c.map_set(m, 2, 20);
  m = c.map_remove(m, 1);
  t.assert_eq(c.map_len(m), 1);
  t.assert(!c.map_contains_key(m, 1));
  t.assert(c.map_contains_key(m, 2));
  t.assert_eq(c.map_get[i32, i32](m, 2), 20);

  m = c.map_remove(m, 9);
  t.assert_eq(c.map_len(m), 1);
}

fn test_map_get_or_smoke() -> () {
  let mut m: c.Map[String, i32] = c.map();
  m = c.map_set(m, "x", 7);
  t.assert_eq(c.map_get_or[String, i32](m, "x", 0), 7);
  t.assert_eq(c.map_get_or[String, i32](m, "y", 9), 9);
}
