fn panic_key_not_found() -> () { panic("Map key not found"); }

pub struct Map[K, V] {
  keys: Vec[K],
  vals: Vec[V],
}

// OOP-style facade over Map via trait method sugar:
// `m.set(k, v)`, `m.get(k)`, `m.contains_key(k)`, `m.remove(k)`, ...
pub trait MapOps {
  type Key;
  type Value;

  fn len(x: Self) -> i32;
  fn is_empty(x: Self) -> bool;
  fn index_of_key(x: Self, key: Self.Key) -> i32;
  fn contains_key(x: Self, key: Self.Key) -> bool;
  fn get(x: Self, key: Self.Key) -> Self.Value;
  fn get_or(x: Self, key: Self.Key, fallback: Self.Value) -> Self.Value;
  fn keys(x: Self) -> Vec[Self.Key];
  fn values(x: Self) -> Vec[Self.Value];
  fn set(x: Self, key: Self.Key, val: Self.Value) -> Self;
  fn clear(x: Self) -> Self;
  fn remove(x: Self, key: Self.Key) -> Self;
}

impl[K: Eq, V] MapOps for Map[K, V] {
  type Key = K;
  type Value = V;

  fn len(x: Map[K, V]) -> i32 { return x.keys.len(); }
  fn is_empty(x: Map[K, V]) -> bool { return x.keys.len() == 0; }
  fn index_of_key(x: Map[K, V], key: Self.Key) -> i32 {
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      if x.keys.get(i) == key { return i; }
      i = i + 1;
    }
    return -1;
  }
  fn contains_key(x: Map[K, V], key: Self.Key) -> bool {
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      if x.keys.get(i) == key { return true; }
      i = i + 1;
    }
    return false;
  }
  fn get(x: Map[K, V], key: Self.Key) -> Self.Value {
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      if x.keys.get(i) == key { return x.vals.get(i); }
      i = i + 1;
    }
    panic_key_not_found();
    // Unreachable at runtime; keeps IR builder happy for generic return type.
    return x.vals.get(0);
  }
  fn get_or(x: Map[K, V], key: Self.Key, fallback: Self.Value) -> Self.Value {
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      if x.keys.get(i) == key { return x.vals.get(i); }
      i = i + 1;
    }
    return fallback;
  }
  fn keys(x: Map[K, V]) -> Vec[Self.Key] {
    let mut out: Vec[K] = Vec();
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      out.push(x.keys.get(i));
      i = i + 1;
    }
    return out;
  }
  fn values(x: Map[K, V]) -> Vec[Self.Value] {
    let mut out: Vec[V] = Vec();
    let mut i: i32 = 0;
    let n: i32 = x.vals.len();
    while i < n {
      out.push(x.vals.get(i));
      i = i + 1;
    }
    return out;
  }
  fn set(x: Map[K, V], key: Self.Key, val: Self.Value) -> Self {
    let mut out_keys: Vec[K] = Vec();
    let mut out_vals: Vec[V] = Vec();
    let mut found: bool = false;
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      let k = x.keys.get(i);
      if k == key {
        out_keys.push(key);
        out_vals.push(val);
        found = true;
      } else {
        out_keys.push(k);
        out_vals.push(x.vals.get(i));
      }
      i = i + 1;
    }
    if !found {
      out_keys.push(key);
      out_vals.push(val);
    }
    return Map { keys: out_keys, vals: out_vals };
  }
  fn clear(_x: Map[K, V]) -> Map[K, V] { return Map { keys: Vec(), vals: Vec() }; }
  fn remove(x: Map[K, V], key: Self.Key) -> Map[K, V] {
    let mut out_keys: Vec[K] = Vec();
    let mut out_vals: Vec[V] = Vec();
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      let k = x.keys.get(i);
      if k != key {
        out_keys.push(k);
        out_vals.push(x.vals.get(i));
      }
      i = i + 1;
    }
    return Map { keys: out_keys, vals: out_vals };
  }
}

pub fn map[K, V]() -> Map[K, V] {
  return Map { keys: Vec(), vals: Vec() };
}
