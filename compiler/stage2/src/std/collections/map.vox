fn panic_key_not_found() -> () { panic("Map key not found"); }

pub struct Map[K, V] {
  keys: Vec[K],
  vals: Vec[V],
}

impl[K: Eq, V] Map[K, V] {
  fn len(x: Map[K, V]) -> i32 { return x.keys.len(); }
  fn is_empty(x: Map[K, V]) -> bool { return x.keys.len() == 0; }

  fn index_of_key(x: Map[K, V], key: K) -> i32 {
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      if x.keys.get(i) == key { return i; }
      i = i + 1;
    }
    return -1;
  }

  fn contains_key(x: Map[K, V], key: K) -> bool { return x.index_of_key(key) != -1; }

  fn get(x: Map[K, V], key: K) -> V {
    let i: i32 = x.index_of_key(key);
    if i == -1 {
      panic_key_not_found();
      // Unreachable at runtime; keeps IR builder happy for generic return type.
      return x.vals.get(0);
    }
    return x.vals.get(i);
  }

  fn get_or(x: Map[K, V], key: K, fallback: V) -> V {
    let i: i32 = x.index_of_key(key);
    if i == -1 { return fallback; }
    return x.vals.get(i);
  }

  fn keys(x: Map[K, V]) -> Vec[K] {
    let mut out: Vec[K] = Vec();
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      out.push(x.keys.get(i));
      i = i + 1;
    }
    return out;
  }

  fn values(x: Map[K, V]) -> Vec[V] {
    let mut out: Vec[V] = Vec();
    let mut i: i32 = 0;
    let n: i32 = x.vals.len();
    while i < n {
      out.push(x.vals.get(i));
      i = i + 1;
    }
    return out;
  }

  // Normal path implementation (no bootstrap-safe rebuild workaround):
  // overwrite uses Vec.set; delete uses Vec.remove; clear uses Vec.clear.
  fn set(x: Map[K, V], key: K, val: V) -> Map[K, V] {
    let mut out: Map[K, V] = x;
    let i: i32 = out.index_of_key(key);
    if i != -1 {
      out.vals.set(i, val);
      return out;
    }
    out.keys.push(key);
    out.vals.push(val);
    return out;
  }

  fn clear(x: Map[K, V]) -> Map[K, V] {
    let mut out: Map[K, V] = x;
    out.keys.clear();
    out.vals.clear();
    return out;
  }

  fn release(x: Map[K, V]) -> Map[K, V] { return Release.release(x); }

  fn remove(x: Map[K, V], key: K) -> Map[K, V] {
    let mut out: Map[K, V] = x;
    let i: i32 = out.index_of_key(key);
    if i == -1 { return out; }
    out.keys.remove(i);
    out.vals.remove(i);
    return out;
  }
}

impl[K: Eq + Clone, V: Clone] Clone for Map[K, V] {
  fn clone(x: Map[K, V]) -> Map[K, V] {
    return Map { keys: Clone.clone(x.keys), vals: Clone.clone(x.vals) };
  }
}

pub fn map[K, V]() -> Map[K, V] {
  return Map { keys: Vec(), vals: Vec() };
}

impl[K: Eq, V] Release for Map[K, V] {
  fn release(x: Map[K, V]) -> Map[K, V] {
    return Map { keys: Vec(), vals: Vec() };
  }
}
