fn panic_key_not_found() -> () { panic("Map key not found"); }

pub struct Map[K, V] {
  keys: Vec[K],
  vals: Vec[V],
}

pub fn map[K, V]() -> Map[K, V] {
  return Map { keys: Vec(), vals: Vec() };
}

pub fn map_len[K, V](m: Map[K, V]) -> i32 { return m.keys.len(); }

pub fn map_is_empty[K, V](m: Map[K, V]) -> bool { return m.keys.len() == 0; }

pub fn map_index_of_key[K: Eq, V](m: Map[K, V], key: K) -> i32 {
  let mut i: i32 = 0;
  let n: i32 = m.keys.len();
  while i < n {
    if m.keys.get(i) == key { return i; }
    i = i + 1;
  }
  return -1;
}

pub fn map_contains_key[K: Eq, V](m: Map[K, V], key: K) -> bool {
  let mut i: i32 = 0;
  let n: i32 = m.keys.len();
  while i < n {
    if m.keys.get(i) == key { return true; }
    i = i + 1;
  }
  return false;
}

pub fn map_get[K: Eq, V](m: Map[K, V], key: K) -> V {
  let mut i: i32 = 0;
  let n: i32 = m.keys.len();
  while i < n {
    if m.keys.get(i) == key { return m.vals.get(i); }
    i = i + 1;
  }
  panic_key_not_found();
  // Unreachable at runtime; keeps IR builder happy for generic return type.
  return m.vals.get(0);
}

pub fn map_get_or[K: Eq, V](m: Map[K, V], key: K, fallback: V) -> V {
  let mut i: i32 = 0;
  let n: i32 = m.keys.len();
  while i < n {
    if m.keys.get(i) == key { return m.vals.get(i); }
    i = i + 1;
  }
  return fallback;
}

pub fn map_keys[K, V](m: Map[K, V]) -> Vec[K] {
  let mut out: Vec[K] = Vec();
  let mut i: i32 = 0;
  let n: i32 = m.keys.len();
  while i < n {
    out.push(m.keys.get(i));
    i = i + 1;
  }
  return out;
}

pub fn map_values[K, V](m: Map[K, V]) -> Vec[V] {
  let mut out: Vec[V] = Vec();
  let mut i: i32 = 0;
  let n: i32 = m.vals.len();
  while i < n {
    out.push(m.vals.get(i));
    i = i + 1;
  }
  return out;
}

pub fn map_clear[K, V](_m: Map[K, V]) -> Map[K, V] {
  return Map { keys: Vec(), vals: Vec() };
}

pub fn map_set[K: Eq, V](m0: Map[K, V], key: K, val: V) -> Map[K, V] {
  let mut m = m0;
  let mut i: i32 = 0;
  let n: i32 = m.keys.len();
  while i < n {
    if m.keys.get(i) == key {
      m.vals.set(i, val);
      return m;
    }
    i = i + 1;
  }
  m.keys.push(key);
  m.vals.push(val);
  return m;
}

pub fn map_remove[K: Eq, V](m0: Map[K, V], key: K) -> Map[K, V] {
  let mut m = m0;
  let mut i: i32 = 0;
  let n: i32 = m.keys.len();
  while i < n {
    if m.keys.get(i) == key {
      m.keys.remove(i);
      m.vals.remove(i);
      return m;
    }
    i = i + 1;
  }
  return m;
}
