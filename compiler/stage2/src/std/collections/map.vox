fn panic_key_not_found() -> () { panic("Map key not found"); }

pub struct Map[K, V] {
  keys: Vec[K],
  vals: Vec[V],
}

impl[K: Eq, V] Map[K, V] {
  fn len(x: Map[K, V]) -> i32 { return x.keys.len(); }
  fn is_empty(x: Map[K, V]) -> bool { return x.keys.len() == 0; }
  fn index_of_key(x: Map[K, V], key: K) -> i32 {
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      if x.keys.get(i) == key { return i; }
      i = i + 1;
    }
    return -1;
  }
  fn contains_key(x: Map[K, V], key: K) -> bool {
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      if x.keys.get(i) == key { return true; }
      i = i + 1;
    }
    return false;
  }
  fn get(x: Map[K, V], key: K) -> V {
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      if x.keys.get(i) == key { return x.vals.get(i); }
      i = i + 1;
    }
    panic_key_not_found();
    // Unreachable at runtime; keeps IR builder happy for generic return type.
    return x.vals.get(0);
  }
  fn get_or(x: Map[K, V], key: K, fallback: V) -> V {
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      if x.keys.get(i) == key { return x.vals.get(i); }
      i = i + 1;
    }
    return fallback;
  }
  fn keys(x: Map[K, V]) -> Vec[K] {
    let mut out: Vec[K] = Vec();
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      out.push(x.keys.get(i));
      i = i + 1;
    }
    return out;
  }
  fn values(x: Map[K, V]) -> Vec[V] {
    let mut out: Vec[V] = Vec();
    let mut i: i32 = 0;
    let n: i32 = x.vals.len();
    while i < n {
      out.push(x.vals.get(i));
      i = i + 1;
    }
    return out;
  }
  fn set(x: Map[K, V], key: K, val: V) -> Map[K, V] {
    let mut out_keys: Vec[K] = Vec();
    let mut out_vals: Vec[V] = Vec();
    let mut found: bool = false;
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      let k = x.keys.get(i);
      if k == key {
        out_keys.push(key);
        out_vals.push(val);
        found = true;
      } else {
        out_keys.push(k);
        out_vals.push(x.vals.get(i));
      }
      i = i + 1;
    }
    if !found {
      out_keys.push(key);
      out_vals.push(val);
    }
    return Map { keys: out_keys, vals: out_vals };
  }
  fn clear(_x: Map[K, V]) -> Map[K, V] { return Map { keys: Vec(), vals: Vec() }; }
  fn remove(x: Map[K, V], key: K) -> Map[K, V] {
    let mut out_keys: Vec[K] = Vec();
    let mut out_vals: Vec[V] = Vec();
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      let k = x.keys.get(i);
      if k != key {
        out_keys.push(k);
        out_vals.push(x.vals.get(i));
      }
      i = i + 1;
    }
    return Map { keys: out_keys, vals: out_vals };
  }
}

pub fn map[K, V]() -> Map[K, V] {
  return Map { keys: Vec(), vals: Vec() };
}
