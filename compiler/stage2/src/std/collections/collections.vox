fn panic_range() -> () { panic("Slice range out of bounds"); }

fn panic_index() -> () { panic("Slice index out of bounds"); }

fn check_range(n: i32, lo: i32, hi: i32) -> () {
  if lo < 0 || hi < lo || hi > n { panic_range(); }
}

pub struct Slice[T] {
  owner: Vec[T],
  lo: i32,
  hi: i32,
}

pub fn view_all[T](owner: Vec[T]) -> Slice[T] {
  let n: i32 = owner.len();
  return Slice { owner: owner, lo: 0, hi: n };
}

pub fn view_range[T](owner: Vec[T], lo: i32, hi: i32) -> Slice[T] {
  let n: i32 = owner.len();
  check_range(n, lo, hi);
  return Slice { owner: owner, lo: lo, hi: hi };
}

pub fn len[T](s: Slice[T]) -> i32 { return s.hi - s.lo; }

pub fn is_empty[T](s: Slice[T]) -> bool { return s.hi == s.lo; }

pub fn get[T](s: Slice[T], idx: i32) -> T {
  let n: i32 = s.hi - s.lo;
  if idx < 0 || idx >= n { panic_index(); }
  return s.owner.get(s.lo + idx);
}

pub fn sub[T](s: Slice[T], lo: i32, hi: i32) -> Slice[T] {
  let n: i32 = s.hi - s.lo;
  check_range(n, lo, hi);
  return Slice { owner: s.owner, lo: s.lo + lo, hi: s.lo + hi };
}

pub fn to_vec[T](s: Slice[T]) -> Vec[T] {
  let mut out: Vec[T] = Vec();
  let n: i32 = s.hi - s.lo;
  let mut i: i32 = 0;
  while i < n {
    out.push(s.owner.get(s.lo + i));
    i = i + 1;
  }
  return out;
}

pub fn index_of[T: Eq](s: Slice[T], needle: T) -> i32 {
  let mut i: i32 = 0;
  let n: i32 = s.hi - s.lo;
  while i < n {
    if s.owner.get(s.lo + i) == needle { return i; }
    i = i + 1;
  }
  return -1;
}

pub fn contains[T: Eq](s: Slice[T], needle: T) -> bool {
  let mut i: i32 = 0;
  let n: i32 = s.hi - s.lo;
  while i < n {
    if s.owner.get(s.lo + i) == needle { return true; }
    i = i + 1;
  }
  return false;
}

pub fn starts_with[T: Eq](s: Slice[T], pre: Slice[T]) -> bool {
  let pn: i32 = pre.hi - pre.lo;
  let sn: i32 = s.hi - s.lo;
  if pn > sn { return false; }
  let mut i: i32 = 0;
  while i < pn {
    if s.owner.get(s.lo + i) != pre.owner.get(pre.lo + i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn ends_with[T: Eq](s: Slice[T], suf: Slice[T]) -> bool {
  let sn: i32 = s.hi - s.lo;
  let fnn: i32 = suf.hi - suf.lo;
  if fnn > sn { return false; }
  let mut i: i32 = 0;
  while i < fnn {
    if s.owner.get(s.lo + (sn - fnn) + i) != suf.owner.get(suf.lo + i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn index_of_slice[T: Eq](s: Slice[T], needle: Slice[T]) -> i32 {
  let sn: i32 = s.hi - s.lo;
  let nn: i32 = needle.hi - needle.lo;
  if nn == 0 { return 0; }
  if nn > sn { return -1; }
  let mut i: i32 = 0;
  while i <= sn - nn {
    let mut ok: bool = true;
    let mut j: i32 = 0;
    while j < nn {
      if s.owner.get(s.lo + i + j) != needle.owner.get(needle.lo + j) {
        ok = false;
        j = nn;
      } else {
        j = j + 1;
      }
    }
    if ok { return i; }
    i = i + 1;
  }
  return -1;
}

pub fn contains_slice[T: Eq](s: Slice[T], needle: Slice[T]) -> bool {
  let sn: i32 = s.hi - s.lo;
  let nn: i32 = needle.hi - needle.lo;
  if nn == 0 { return true; }
  if nn > sn { return false; }
  let mut i: i32 = 0;
  while i <= sn - nn {
    let mut ok: bool = true;
    let mut j: i32 = 0;
    while j < nn {
      if s.owner.get(s.lo + i + j) != needle.owner.get(needle.lo + j) {
        ok = false;
        j = nn;
      } else {
        j = j + 1;
      }
    }
    if ok { return true; }
    i = i + 1;
  }
  return false;
}
