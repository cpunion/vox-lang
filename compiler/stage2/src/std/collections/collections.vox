fn panic_range() -> () { panic("Slice range out of bounds"); }

fn panic_index() -> () { panic("Slice index out of bounds"); }

fn check_range(n: i32, lo: i32, hi: i32) -> () {
  if lo < 0 || hi < lo || hi > n { panic_range(); }
}

pub struct Slice[T] {
  owner: Vec[T],
  lo: i32,
  hi: i32,
}

pub fn view_all[T](owner: Vec[T]) -> Slice[T] {
  let n: i32 = owner.len();
  return Slice { owner: owner, lo: 0, hi: n };
}

pub fn view_range[T](owner: Vec[T], lo: i32, hi: i32) -> Slice[T] {
  let n: i32 = owner.len();
  check_range(n, lo, hi);
  return Slice { owner: owner, lo: lo, hi: hi };
}

pub fn len[T](s: Slice[T]) -> i32 { return s.hi - s.lo; }

pub fn is_empty[T](s: Slice[T]) -> bool { return s.hi == s.lo; }

pub fn get[T](s: Slice[T], idx: i32) -> T {
  let n: i32 = s.hi - s.lo;
  if idx < 0 || idx >= n { panic_index(); }
  return s.owner.get(s.lo + idx);
}

pub fn sub[T](s: Slice[T], lo: i32, hi: i32) -> Slice[T] {
  let n: i32 = s.hi - s.lo;
  check_range(n, lo, hi);
  return Slice { owner: s.owner, lo: s.lo + lo, hi: s.lo + hi };
}

// View-first helpers: keep sub-sequence operations in Slice form and avoid
// forcing owned Vec materialization for prefix/suffix slicing.
pub fn take_prefix[T](s: Slice[T], n: i32) -> Slice[T] {
  let sn: i32 = s.hi - s.lo;
  check_range(sn, 0, n);
  return Slice { owner: s.owner, lo: s.lo, hi: s.lo + n };
}

pub fn take_suffix[T](s: Slice[T], n: i32) -> Slice[T] {
  let sn: i32 = s.hi - s.lo;
  check_range(sn, 0, n);
  return Slice { owner: s.owner, lo: s.hi - n, hi: s.hi };
}

pub fn drop_prefix[T](s: Slice[T], n: i32) -> Slice[T] {
  let sn: i32 = s.hi - s.lo;
  check_range(sn, 0, n);
  return Slice { owner: s.owner, lo: s.lo + n, hi: s.hi };
}

pub fn drop_suffix[T](s: Slice[T], n: i32) -> Slice[T] {
  let sn: i32 = s.hi - s.lo;
  check_range(sn, 0, n);
  return Slice { owner: s.owner, lo: s.lo, hi: s.hi - n };
}

pub fn to_vec[T](s: Slice[T]) -> Vec[T] {
  let mut out: Vec[T] = Vec();
  let n: i32 = s.hi - s.lo;
  let mut i: i32 = 0;
  while i < n {
    out.push(s.owner.get(s.lo + i));
    i = i + 1;
  }
  return out;
}

pub fn index_of[T: Eq](s: Slice[T], needle: T) -> i32 {
  let mut i: i32 = 0;
  let n: i32 = s.hi - s.lo;
  while i < n {
    if s.owner.get(s.lo + i) == needle { return i; }
    i = i + 1;
  }
  return -1;
}

pub fn last_index_of[T: Eq](s: Slice[T], needle: T) -> i32 {
  let mut i: i32 = (s.hi - s.lo) - 1;
  while i >= 0 {
    if s.owner.get(s.lo + i) == needle { return i; }
    i = i - 1;
  }
  return -1;
}

pub fn contains[T: Eq](s: Slice[T], needle: T) -> bool {
  let mut i: i32 = 0;
  let n: i32 = s.hi - s.lo;
  while i < n {
    if s.owner.get(s.lo + i) == needle { return true; }
    i = i + 1;
  }
  return false;
}

pub fn starts_with[T: Eq](s: Slice[T], pre: Slice[T]) -> bool {
  let pn: i32 = pre.hi - pre.lo;
  let sn: i32 = s.hi - s.lo;
  if pn > sn { return false; }
  let mut i: i32 = 0;
  while i < pn {
    if s.owner.get(s.lo + i) != pre.owner.get(pre.lo + i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn ends_with[T: Eq](s: Slice[T], suf: Slice[T]) -> bool {
  let sn: i32 = s.hi - s.lo;
  let fnn: i32 = suf.hi - suf.lo;
  if fnn > sn { return false; }
  let mut i: i32 = 0;
  while i < fnn {
    if s.owner.get(s.lo + (sn - fnn) + i) != suf.owner.get(suf.lo + i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn index_of_slice[T: Eq](s: Slice[T], needle: Slice[T]) -> i32 {
  let sn: i32 = s.hi - s.lo;
  let nn: i32 = needle.hi - needle.lo;
  if nn == 0 { return 0; }
  if nn > sn { return -1; }
  let mut i: i32 = 0;
  while i <= sn - nn {
    let mut ok: bool = true;
    let mut j: i32 = 0;
    while j < nn {
      if s.owner.get(s.lo + i + j) != needle.owner.get(needle.lo + j) {
        ok = false;
        j = nn;
      } else {
        j = j + 1;
      }
    }
    if ok { return i; }
    i = i + 1;
  }
  return -1;
}

pub fn last_index_of_slice[T: Eq](s: Slice[T], needle: Slice[T]) -> i32 {
  let sn: i32 = s.hi - s.lo;
  let nn: i32 = needle.hi - needle.lo;
  if nn == 0 { return sn; }
  if nn > sn { return -1; }
  let mut i: i32 = sn - nn;
  while i >= 0 {
    let mut ok: bool = true;
    let mut j: i32 = 0;
    while j < nn {
      if s.owner.get(s.lo + i + j) != needle.owner.get(needle.lo + j) {
        ok = false;
        j = nn;
      } else {
        j = j + 1;
      }
    }
    if ok { return i; }
    i = i - 1;
  }
  return -1;
}

pub fn contains_slice[T: Eq](s: Slice[T], needle: Slice[T]) -> bool {
  let sn: i32 = s.hi - s.lo;
  let nn: i32 = needle.hi - needle.lo;
  if nn == 0 { return true; }
  if nn > sn { return false; }
  let mut i: i32 = 0;
  while i <= sn - nn {
    let mut ok: bool = true;
    let mut j: i32 = 0;
    while j < nn {
      if s.owner.get(s.lo + i + j) != needle.owner.get(needle.lo + j) {
        ok = false;
        j = nn;
      } else {
        j = j + 1;
      }
    }
    if ok { return true; }
    i = i + 1;
  }
  return false;
}

pub fn equals[T: Eq](a: Slice[T], b: Slice[T]) -> bool {
  let an: i32 = a.hi - a.lo;
  if an != (b.hi - b.lo) { return false; }
  let mut i: i32 = 0;
  while i < an {
    if a.owner.get(a.lo + i) != b.owner.get(b.lo + i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn equals_vec[T: Eq](a: Slice[T], b: Vec[T]) -> bool {
  let an: i32 = a.hi - a.lo;
  if an != b.len() { return false; }
  let mut i: i32 = 0;
  while i < an {
    if a.owner.get(a.lo + i) != b.get(i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn compare[T: Ord](a: Slice[T], b: Slice[T]) -> i32 {
  let an: i32 = a.hi - a.lo;
  let bn: i32 = b.hi - b.lo;
  let mut n: i32 = an;
  if bn < n { n = bn; }
  let mut i: i32 = 0;
  while i < n {
    let av: T = a.owner.get(a.lo + i);
    let bv: T = b.owner.get(b.lo + i);
    if av < bv { return -1; }
    if av > bv { return 1; }
    i = i + 1;
  }
  if an < bn { return -1; }
  if an > bn { return 1; }
  return 0;
}

pub fn compare_vec[T: Ord](a: Slice[T], b: Vec[T]) -> i32 {
  let an: i32 = a.hi - a.lo;
  let bn: i32 = b.len();
  let mut n: i32 = an;
  if bn < n { n = bn; }
  let mut i: i32 = 0;
  while i < n {
    let av: T = a.owner.get(a.lo + i);
    let bv: T = b.get(i);
    if av < bv { return -1; }
    if av > bv { return 1; }
    i = i + 1;
  }
  if an < bn { return -1; }
  if an > bn { return 1; }
  return 0;
}
