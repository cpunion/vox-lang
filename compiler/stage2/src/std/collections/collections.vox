fn panic_range() -> () { panic("Slice range out of bounds"); }

fn panic_index() -> () { panic("Slice index out of bounds"); }

fn check_range(n: i32, lo: i32, hi: i32) -> () {
  if lo < 0 || hi < lo || hi > n { panic_range(); }
}

pub struct Slice[T] {
  owner: Vec[T],
  lo: i32,
  hi: i32,
}

pub fn view_all[T](owner: Vec[T]) -> Slice[T] {
  let n: i32 = owner.len();
  return Slice { owner: owner, lo: 0, hi: n };
}

pub fn view_range[T](owner: Vec[T], lo: i32, hi: i32) -> Slice[T] {
  let n: i32 = owner.len();
  check_range(n, lo, hi);
  return Slice { owner: owner, lo: lo, hi: hi };
}

pub fn len[T](s: Slice[T]) -> i32 { return s.hi - s.lo; }

pub fn is_empty[T](s: Slice[T]) -> bool { return s.hi == s.lo; }

pub fn get[T](s: Slice[T], idx: i32) -> T {
  let n: i32 = s.hi - s.lo;
  if idx < 0 || idx >= n { panic_index(); }
  return s.owner.get(s.lo + idx);
}

pub fn sub[T](s: Slice[T], lo: i32, hi: i32) -> Slice[T] {
  let n: i32 = s.hi - s.lo;
  check_range(n, lo, hi);
  return Slice { owner: s.owner, lo: s.lo + lo, hi: s.lo + hi };
}

pub fn to_vec[T](s: Slice[T]) -> Vec[T] {
  let mut out: Vec[T] = Vec();
  let n: i32 = s.hi - s.lo;
  let mut i: i32 = 0;
  while i < n {
    out.push(s.owner.get(s.lo + i));
    i = i + 1;
  }
  return out;
}

pub fn index_of[T: Eq](s: Slice[T], needle: T) -> i32 {
  let mut i: i32 = 0;
  let n: i32 = s.hi - s.lo;
  while i < n {
    if s.owner.get(s.lo + i) == needle { return i; }
    i = i + 1;
  }
  return -1;
}

pub fn contains[T: Eq](s: Slice[T], needle: T) -> bool {
  let mut i: i32 = 0;
  let n: i32 = s.hi - s.lo;
  while i < n {
    if s.owner.get(s.lo + i) == needle { return true; }
    i = i + 1;
  }
  return false;
}
