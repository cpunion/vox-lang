import "std/testing" as t
import "std/collections" as c

fn mk_nums() -> Vec[i32] {
  let mut v: Vec[i32] = Vec();
  v.push(10);
  v.push(20);
  v.push(30);
  v.push(40);
  return v;
}

fn test_slice_view_range_get_sub_smoke() -> () {
  let s: c.Slice[i32] = c.view_range(mk_nums(), 1, 4);
  t.assert_eq(c.len(s), 3);
  t.assert_eq(c.get(s, 0), 20);
  t.assert_eq(c.get(s, 2), 40);

  let mid: c.Slice[i32] = c.sub(s, 1, 3);
  t.assert_eq(c.len(mid), 2);
  t.assert_eq(c.get(mid, 0), 30);
  t.assert_eq(c.get(mid, 1), 40);
}

fn test_slice_to_vec_smoke() -> () {
  let s: c.Slice[i32] = c.view_range(mk_nums(), 0, 3);
  let v: Vec[i32] = c.to_vec(s);
  t.assert_eq(v.len(), 3);
  t.assert_eq(v.get(0), 10);
  t.assert_eq(v.get(1), 20);
  t.assert_eq(v.get(2), 30);
}

fn test_slice_contains_and_index_of_smoke() -> () {
  let s: c.Slice[i32] = c.view_all(mk_nums());
  t.assert(c.contains(s, 30));
  t.assert_eq(c.index_of(s, 30), 2);
  t.assert_eq(c.last_index_of(s, 30), 2);
  t.assert_eq(c.index_of(s, 99), -1);
  t.assert_eq(c.last_index_of(s, 99), -1);
}

fn test_slice_string_eq_smoke() -> () {
  let mut vs: Vec[String] = Vec();
  vs.push("vox");
  vs.push("lang");
  let s: c.Slice[String] = c.view_all(vs);
  t.assert(c.contains(s, "lang"));
  t.assert_eq(c.index_of(s, "vox"), 0);
}

fn test_slice_is_empty_smoke() -> () {
  let s: c.Slice[i32] = c.view_range(mk_nums(), 2, 2);
  t.assert(c.is_empty(s));
}

fn test_slice_subsequence_ops_smoke() -> () {
  let s: c.Slice[i32] = c.view_all(mk_nums());
  let pre: c.Slice[i32] = c.view_range(mk_nums(), 0, 2);
  let suf: c.Slice[i32] = c.view_range(mk_nums(), 2, 4);
  let mid: c.Slice[i32] = c.view_range(mk_nums(), 1, 3);
  let empty: c.Slice[i32] = c.view_range(mk_nums(), 1, 1);

  t.assert(c.starts_with(s, pre));
  t.assert(c.ends_with(s, suf));
  t.assert(c.contains_slice(s, mid));
  t.assert_eq(c.index_of_slice(s, mid), 1);
  t.assert_eq(c.last_index_of_slice(s, mid), 1);
  t.assert(c.starts_with(s, empty));
  t.assert(c.ends_with(s, empty));
  t.assert_eq(c.index_of_slice(s, empty), 0);
  t.assert_eq(c.last_index_of_slice(s, empty), c.len(s));

  let mut miss_vec: Vec[i32] = Vec();
  miss_vec.push(20);
  miss_vec.push(40);
  let miss: c.Slice[i32] = c.view_all(miss_vec);
  t.assert(!c.contains_slice(s, miss));
  t.assert_eq(c.index_of_slice(s, miss), -1);
  t.assert_eq(c.last_index_of_slice(s, miss), -1);

  let mut rep_vec: Vec[i32] = Vec();
  rep_vec.push(10);
  rep_vec.push(20);
  rep_vec.push(10);
  rep_vec.push(20);
  rep_vec.push(30);
  let rep: c.Slice[i32] = c.view_all(rep_vec);
  let needle_rep: c.Slice[i32] = c.view_range(mk_nums(), 0, 2); // [10,20]
  t.assert_eq(c.index_of_slice(rep, needle_rep), 0);
  t.assert_eq(c.last_index_of_slice(rep, needle_rep), 2);
}
