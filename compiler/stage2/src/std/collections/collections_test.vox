import "std/testing" as t
import "std/collections" as c

fn mk_nums() -> Vec[i32] {
  let mut v: Vec[i32] = Vec();
  v.push(10);
  v.push(20);
  v.push(30);
  v.push(40);
  return v;
}

fn test_slice_view_range_get_sub_smoke() -> () {
  let s: c.Slice[i32] = c.view_range(mk_nums(), 1, 4);
  t.assert_eq(c.len(s), 3);
  t.assert_eq(c.get(s, 0), 20);
  t.assert_eq(c.get(s, 2), 40);

  let mid: c.Slice[i32] = c.sub(s, 1, 3);
  t.assert_eq(c.len(mid), 2);
  t.assert_eq(c.get(mid, 0), 30);
  t.assert_eq(c.get(mid, 1), 40);
}

fn test_slice_to_vec_smoke() -> () {
  let s: c.Slice[i32] = c.view_range(mk_nums(), 0, 3);
  let v: Vec[i32] = c.to_vec(s);
  t.assert_eq(v.len(), 3);
  t.assert_eq(v.get(0), 10);
  t.assert_eq(v.get(1), 20);
  t.assert_eq(v.get(2), 30);
}

fn test_slice_contains_and_index_of_smoke() -> () {
  let s: c.Slice[i32] = c.view_all(mk_nums());
  t.assert(c.contains(s, 30));
  t.assert_eq(c.index_of(s, 30), 2);
  t.assert_eq(c.index_of(s, 99), -1);
}

fn test_slice_string_eq_smoke() -> () {
  let mut vs: Vec[String] = Vec();
  vs.push("vox");
  vs.push("lang");
  let s: c.Slice[String] = c.view_all(vs);
  t.assert(c.contains(s, "lang"));
  t.assert_eq(c.index_of(s, "vox"), 0);
}

fn test_slice_is_empty_smoke() -> () {
  let s: c.Slice[i32] = c.view_range(mk_nums(), 2, 2);
  t.assert(c.is_empty(s));
}
