import "std/testing" as t
import "std/collections" as c

fn mk_nums() -> Vec[i32] {
  let mut v: Vec[i32] = Vec();
  v.push(10);
  v.push(20);
  v.push(30);
  v.push(40);
  return v;
}

fn test_slice_view_range_get_sub_smoke() -> () {
  let s: c.Slice[i32] = c.view_range(mk_nums(), 1, 4);
  t.assert_eq(c.len(s), 3);
  t.assert_eq(c.get(s, 0), 20);
  t.assert_eq(c.get(s, 2), 40);

  let mid: c.Slice[i32] = c.sub(s, 1, 3);
  t.assert_eq(c.len(mid), 2);
  t.assert_eq(c.get(mid, 0), 30);
  t.assert_eq(c.get(mid, 1), 40);
}

fn test_slice_to_vec_smoke() -> () {
  let s: c.Slice[i32] = c.view_range(mk_nums(), 0, 3);
  let v: Vec[i32] = c.to_vec(s);
  t.assert_eq(v.len(), 3);
  t.assert_eq(v.get(0), 10);
  t.assert_eq(v.get(1), 20);
  t.assert_eq(v.get(2), 30);
}

fn test_slice_contains_and_index_of_smoke() -> () {
  let s: c.Slice[i32] = c.view_all(mk_nums());
  t.assert(c.contains(s, 30));
  t.assert_eq(c.index_of(s, 30), 2);
  t.assert_eq(c.last_index_of(s, 30), 2);
  t.assert_eq(c.index_of(s, 99), -1);
  t.assert_eq(c.last_index_of(s, 99), -1);
}

fn test_slice_string_eq_smoke() -> () {
  let mut vs: Vec[String] = Vec();
  vs.push("vox");
  vs.push("lang");
  let s: c.Slice[String] = c.view_all(vs);
  t.assert(c.contains(s, "lang"));
  t.assert_eq(c.index_of(s, "vox"), 0);
}

fn test_slice_is_empty_smoke() -> () {
  let s: c.Slice[i32] = c.view_range(mk_nums(), 2, 2);
  t.assert(c.is_empty(s));
}

fn test_slice_subsequence_ops_smoke() -> () {
  let s: c.Slice[i32] = c.view_all(mk_nums());
  let pre: c.Slice[i32] = c.view_range(mk_nums(), 0, 2);
  let suf: c.Slice[i32] = c.view_range(mk_nums(), 2, 4);
  let mid: c.Slice[i32] = c.view_range(mk_nums(), 1, 3);
  let empty: c.Slice[i32] = c.view_range(mk_nums(), 1, 1);

  t.assert(c.starts_with(s, pre));
  t.assert(c.ends_with(s, suf));
  t.assert(c.contains_slice(s, mid));
  t.assert_eq(c.index_of_slice(s, mid), 1);
  t.assert_eq(c.last_index_of_slice(s, mid), 1);
  t.assert(c.starts_with(s, empty));
  t.assert(c.ends_with(s, empty));
  t.assert_eq(c.index_of_slice(s, empty), 0);
  t.assert_eq(c.last_index_of_slice(s, empty), c.len(s));

  let mut miss_vec: Vec[i32] = Vec();
  miss_vec.push(20);
  miss_vec.push(40);
  let miss: c.Slice[i32] = c.view_all(miss_vec);
  t.assert(!c.contains_slice(s, miss));
  t.assert_eq(c.index_of_slice(s, miss), -1);
  t.assert_eq(c.last_index_of_slice(s, miss), -1);

  let mut rep_vec: Vec[i32] = Vec();
  rep_vec.push(10);
  rep_vec.push(20);
  rep_vec.push(10);
  rep_vec.push(20);
  rep_vec.push(30);
  let rep: c.Slice[i32] = c.view_all(rep_vec);
  let needle_rep: c.Slice[i32] = c.view_range(mk_nums(), 0, 2); // [10,20]
  t.assert_eq(c.index_of_slice(rep, needle_rep), 0);
  t.assert_eq(c.last_index_of_slice(rep, needle_rep), 2);
}

fn test_slice_compare_ops_smoke() -> () {
  let base: c.Slice[i32] = c.view_all(mk_nums()); // [10,20,30,40]
  let same: c.Slice[i32] = c.view_range(mk_nums(), 0, 4);
  let shorter: c.Slice[i32] = c.view_range(mk_nums(), 0, 3);

  let mut larger_vec: Vec[i32] = Vec();
  larger_vec.push(10);
  larger_vec.push(20);
  larger_vec.push(31);
  let larger: c.Slice[i32] = c.view_all(larger_vec);

  t.assert(c.equals(base, same));
  t.assert(!c.equals(base, shorter));
  t.assert(c.equals_vec(base, mk_nums()));
  t.assert(!c.equals_vec(base, c.to_vec(shorter)));

  t.assert_eq(c.compare(base, same), 0);
  t.assert_eq(c.compare(base, shorter), 1);
  t.assert_eq(c.compare(base, larger), -1);
  t.assert_eq(c.compare_vec(base, mk_nums()), 0);
  t.assert_eq(c.compare_vec(base, c.to_vec(shorter)), 1);
}

fn test_slice_take_drop_prefix_suffix_smoke() -> () {
  let base: c.Slice[i32] = c.view_all(mk_nums()); // [10,20,30,40]
  let pre: c.Slice[i32] = c.take_prefix(base, 2);
  let suf: c.Slice[i32] = c.take_suffix(base, 2);
  let drop_pre: c.Slice[i32] = c.drop_prefix(base, 2);
  let drop_suf: c.Slice[i32] = c.drop_suffix(base, 2);

  t.assert_eq(c.len(pre), 2);
  t.assert_eq(c.get(pre, 0), 10);
  t.assert_eq(c.get(pre, 1), 20);

  t.assert_eq(c.len(suf), 2);
  t.assert_eq(c.get(suf, 0), 30);
  t.assert_eq(c.get(suf, 1), 40);

  t.assert(c.equals(drop_pre, suf));
  t.assert(c.equals(drop_suf, pre));

  let whole: c.Slice[i32] = c.take_prefix(base, c.len(base));
  let empty: c.Slice[i32] = c.drop_prefix(base, c.len(base));
  t.assert(c.equals(whole, base));
  t.assert(c.is_empty(empty));
}

fn test_vec_clone_deep_smoke() -> () {
  let mut v: Vec[i32] = Vec();
  v.push(1);
  v.push(2);

  let mut cpy: Vec[i32] = Clone.clone(v);
  cpy.set(0, 9);

  t.assert_eq(v.get(0), 1);
  t.assert_eq(cpy.get(0), 9);
  t.assert_eq(v.get(1), 2);
  t.assert_eq(cpy.get(1), 2);
}

fn test_vec_release_alias_safe_smoke() -> () {
  let mut a: Vec[i32] = Vec();
  a.push(7);
  a.push(9);
  let b: Vec[i32] = a;

  a = c.release_vec(a);

  t.assert_eq(a.len(), 0);
  t.assert_eq(b.len(), 2);
  t.assert_eq(b.get(0), 7);
  t.assert_eq(b.get(1), 9);
}
