pub fn emit_runtime_lines() -> Vec[String] {
  let mut out: Vec[String] = Vec();

  // Minimal Vec runtime (stage0): by-value elements, no drop glue.
  out.push("typedef struct { uint8_t* data; int32_t len; int32_t cap; int32_t elem_size; } vox_vec;");
  out.push("static vox_vec vox_vec_new(int32_t elem_size) {");
  out.push("  vox_vec v; v.data = NULL; v.len = 0; v.cap = 0; v.elem_size = elem_size; return v;");
  out.push("}");
  out.push("static void vox_vec_grow(vox_vec* v, int32_t new_cap) {");
  out.push("  if (new_cap <= v->cap) return;");
  out.push("  if (new_cap < 4) new_cap = 4;");
  out.push("  size_t bytes = (size_t)new_cap * (size_t)v->elem_size;");
  out.push("  // Stage0/Stage1 v0: leak Vec buffers so plain struct copies of `vox_vec` are safe.");
  out.push("  uint8_t* p = (uint8_t*)malloc(bytes);");
  out.push("  if (!p) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  if (v->data && v->len != 0) {");
  out.push("    memcpy(p, v->data, (size_t)v->len * (size_t)v->elem_size);");
  out.push("  }");
  out.push("  v->data = p; v->cap = new_cap;");
  out.push("}");
  out.push("static void vox_vec_push(vox_vec* v, const void* elem) {");
  out.push("  if (v->len == v->cap) { int32_t nc = v->cap == 0 ? 4 : v->cap * 2; vox_vec_grow(v, nc); }");
  out.push("  memcpy(v->data + (size_t)v->len * (size_t)v->elem_size, elem, (size_t)v->elem_size);");
  out.push("  v->len++;");
  out.push("}");
  out.push("static void vox_vec_clear(vox_vec* v) {");
  out.push("  if (!v) return;");
  out.push("  v->len = 0;");
  out.push("}");
  out.push("static int32_t vox_vec_len(const vox_vec* v) { return v->len; }");
  out.push("static bool vox_vec_eq(const vox_vec* a, const vox_vec* b) {");
  out.push("  if (!a || !b) return false;");
  out.push("  if (a->len != b->len || a->elem_size != b->elem_size) return false;");
  out.push("  size_t bytes = (size_t)a->len * (size_t)a->elem_size;");
  out.push("  if (bytes == 0) return true;");
  out.push("  return memcmp(a->data, b->data, bytes) == 0;");
  out.push("}");
  out.push("static void vox_vec_get(const vox_vec* v, int32_t idx, void* out) {");
  out.push("  if (idx < 0 || idx >= v->len) { fprintf(stderr, \"vec index out of bounds: idx=%\" PRId32 \" len=%\" PRId32 \"\\n\", idx, v->len); exit(1); }");
  out.push("  memcpy(out, v->data + (size_t)idx * (size_t)v->elem_size, (size_t)v->elem_size);");
  out.push("}");
  out.push("");

  // Minimal string runtime helpers (stage0).
  out.push("static int32_t vox_str_len(const char* s) {");
  out.push("  if (!s) return 0;");
  out.push("  size_t n = strlen(s);");
  out.push("  if (n > INT32_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }");
  out.push("  return (int32_t)n;");
  out.push("}");
  out.push("static int32_t vox_str_byte_at(const char* s, int32_t idx) {");
  out.push("  int32_t n = vox_str_len(s);");
  out.push("  if (idx < 0 || idx >= n) { fprintf(stderr, \"string index out of bounds\\n\"); exit(1); }");
  out.push("  return (int32_t)(uint8_t)s[idx];");
  out.push("}");
  out.push("");
  out.push("static const char* vox_str_slice(const char* s, int32_t start, int32_t end) {");
  out.push("  int32_t n = vox_str_len(s);");
  out.push("  if (start < 0 || end < start || end > n) { fprintf(stderr, \"string slice out of bounds\\n\"); exit(1); }");
  out.push("  int32_t m = end - start;");
  out.push("  char* out = (char*)malloc((size_t)m + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, s + start, (size_t)m);");
  out.push("  out[m] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_str_concat(const char* a, const char* b) {");
  out.push("  if (!a) a = \"\";");
  out.push("  if (!b) b = \"\";");
  out.push("  size_t na = strlen(a);");
  out.push("  size_t nb = strlen(b);");
  out.push("  if (na + nb + 1 > SIZE_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc(na + nb + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, a, na);");
  out.push("  memcpy(out + na, b, nb);");
  out.push("  out[na + nb] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static bool vox_str_starts_with(const char* s, const char* pre) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!pre) pre = \"\";");
  out.push("  size_t ns = strlen(s);");
  out.push("  size_t np = strlen(pre);");
  out.push("  if (np > ns) return false;");
  out.push("  return memcmp(s, pre, np) == 0;");
  out.push("}");
  out.push("");

  out.push("static bool vox_str_ends_with(const char* s, const char* suf) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!suf) suf = \"\";");
  out.push("  size_t ns = strlen(s);");
  out.push("  size_t nf = strlen(suf);");
  out.push("  if (nf > ns) return false;");
  out.push("  return memcmp(s + (ns - nf), suf, nf) == 0;");
  out.push("}");
  out.push("");

  out.push("static bool vox_str_contains(const char* s, const char* needle) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!needle) needle = \"\";");
  out.push("  return strstr(s, needle) != NULL;");
  out.push("}");
  out.push("");

  out.push("static int32_t vox_str_index_of(const char* s, const char* needle) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!needle) needle = \"\";");
  out.push("  if (needle[0] == '\\0') return 0;");
  out.push("  const char* p = strstr(s, needle);");
  out.push("  if (!p) return -1;");
  out.push("  size_t idx = (size_t)(p - s);");
  out.push("  if (idx > (size_t)INT32_MAX) { fprintf(stderr, \"string index overflow\\n\"); exit(1); }");
  out.push("  return (int32_t)idx;");
  out.push("}");
  out.push("");

  out.push("static int32_t vox_str_last_index_of(const char* s, const char* needle) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!needle) needle = \"\";");
  out.push("  int32_t ns = vox_str_len(s);");
  out.push("  int32_t nn = vox_str_len(needle);");
  out.push("  if (nn == 0) return ns;");
  out.push("  if (ns < nn) return -1;");
  out.push("  int32_t last = -1;");
  out.push("  for (int32_t i = 0; i <= ns - nn; i++) {");
  out.push("    if (memcmp(s + i, needle, (size_t)nn) == 0) last = i;");
  out.push("  }");
  out.push("  return last;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_i32_to_string(int32_t v) {");
  out.push("  char buf[32];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%\" PRId32, v);");
  out.push("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_i64_to_string(int64_t v) {");
  out.push("  char buf[32];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%\" PRId64, v);");
  out.push("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_u64_to_string(uint64_t v) {");
  out.push("  char buf[32];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%\" PRIu64, v);");
  out.push("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_f32_to_string(float v) {");
  out.push("  char buf[64];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%.9g\", (double)v);");
  out.push("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_f64_to_string(double v) {");
  out.push("  char buf[64];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%.17g\", v);");
  out.push("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_bool_to_string(bool v) {");
  out.push("  return v ? \"true\" : \"false\";");
  out.push("}");
  out.push("");

  out.push("static const char* vox_str_escape_c(const char* s) {");
  out.push("  if (!s) s = \"\";");
  out.push("  size_t n = strlen(s);");
  out.push("  // First pass: compute output length.");
  out.push("  size_t out_n = 0;");
  out.push("  for (size_t i = 0; i < n; i++) {");
  out.push("    unsigned char ch = (unsigned char)s[i];");
  out.push("    switch (ch) {");
  out.push("    case '\\\\':");
  out.push("    case '\"':");
  out.push("    case '\\n':");
  out.push("    case '\\r':");
  out.push("    case '\\t':");
  out.push("      out_n += 2;");
  out.push("      break;");
  out.push("    default:");
  out.push("      if (ch >= 0x20 && ch <= 0x7e) out_n += 1; else out_n += 4; // \\\\xHH");
  out.push("      break;");
  out.push("    }");
  out.push("  }");
  out.push("  char* out = (char*)malloc(out_n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  size_t j = 0;");
  out.push("  for (size_t i = 0; i < n; i++) {");
  out.push("    unsigned char ch = (unsigned char)s[i];");
  out.push("    switch (ch) {");
  out.push("    case '\\\\': out[j++] = '\\\\'; out[j++] = '\\\\'; break;");
  out.push("    case '\"': out[j++] = '\\\\'; out[j++] = '\"'; break;");
  out.push("    case '\\n': out[j++] = '\\\\'; out[j++] = 'n'; break;");
  out.push("    case '\\r': out[j++] = '\\\\'; out[j++] = 'r'; break;");
  out.push("    case '\\t': out[j++] = '\\\\'; out[j++] = 't'; break;");
  out.push("    default:");
  out.push("      if (ch >= 0x20 && ch <= 0x7e) { out[j++] = (char)ch; }");
  out.push("      else {");
  out.push("        static const char* hex = \"0123456789abcdef\";");
  out.push("        out[j++] = '\\\\'; out[j++] = 'x';");
  out.push("        out[j++] = hex[(ch >> 4) & 0xf];");
  out.push("        out[j++] = hex[ch & 0xf];");
  out.push("      }");
  out.push("      break;");
  out.push("    }");
  out.push("  }");
  out.push("  out[j] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_vec_str_join(const vox_vec* v, const char* sep) {");
  out.push("  if (!sep) sep = \"\";");
  out.push("  if (!v || v->elem_size != (int32_t)sizeof(const char*)) { fprintf(stderr, \"vec_str_join expects Vec[String]\\n\"); exit(1); }");
  out.push("  int32_t n = v->len;");
  out.push("  const char* const* items = (const char* const*)v->data;");
  out.push("  size_t sep_n = strlen(sep);");
  out.push("  size_t total = 0;");
  out.push("  for (int32_t i = 0; i < n; i++) {");
  out.push("    const char* s = items[i];");
  out.push("    if (!s) s = \"\";");
  out.push("    total += strlen(s);");
  out.push("    if (i + 1 < n) total += sep_n;");
  out.push("  }");
  out.push("  if (total + 1 > SIZE_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc(total + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  size_t j = 0;");
  out.push("  for (int32_t i = 0; i < n; i++) {");
  out.push("    const char* s = items[i];");
  out.push("    if (!s) s = \"\";");
  out.push("    size_t m = strlen(s);");
  out.push("    memcpy(out + j, s, m);");
  out.push("    j += m;");
  out.push("    if (i + 1 < n && sep_n != 0) {");
  out.push("      memcpy(out + j, sep, sep_n);");
  out.push("      j += sep_n;");
  out.push("    }");
  out.push("  }");
  out.push("  out[j] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");

  // Runtime builtins
  out.push("static int vox__argc = 0;");
  out.push("static char** vox__argv = NULL;");
  out.push("");
  out.push("#if defined(_MSC_VER)");
  out.push("#  define VOX_NORETURN __declspec(noreturn)");
  out.push("#elif defined(__GNUC__) || defined(__clang__)");
  out.push("#  define VOX_NORETURN __attribute__((noreturn))");
  out.push("#else");
  out.push("#  define VOX_NORETURN");
  out.push("#endif");
  out.push("");
  out.push("static VOX_NORETURN void vox_builtin_panic(const char* msg) {");
  out.push("  if (!msg) msg = \"\";");
  out.push("  fprintf(stderr, \"%s\\n\", msg);");
  out.push("  exit(1);");
  out.push("}");
  out.push("");
  out.push("static void vox_builtin_print(const char* msg) {");
  out.push("  if (!msg) msg = \"\";");
  out.push("  fputs(msg, stdout);");
  out.push("  fflush(stdout);");
  out.push("}");
  out.push("");
  out.push("static vox_vec vox_builtin_args(void) {");
  out.push("  vox_vec v = vox_vec_new((int32_t)sizeof(const char*));");
  out.push("  for (int i = 1; i < vox__argc; i++) {");
  out.push("    const char* s = vox__argv[i];");
  out.push("    vox_vec_push(&v, &s);");
  out.push("  }");
  out.push("  return v;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_builtin_exe_path(void) {");
  out.push("  if (!vox__argv || vox__argc <= 0 || !vox__argv[0]) return \"\";");
  out.push("  return vox__argv[0];");
  out.push("}");
  out.push("");
  out.push("static int64_t vox_builtin_now_ns(void) {");
  out.push("  struct timespec ts;");
  out.push("#if defined(_WIN32)");
  out.push("  if (timespec_get(&ts, TIME_UTC) == 0) return 0;");
  out.push("#else");
  out.push("  if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0) {");
  out.push("    if (timespec_get(&ts, TIME_UTC) == 0) return 0;");
  out.push("  }");
  out.push("#endif");
  out.push("  return (int64_t)ts.tv_sec * (int64_t)1000000000 + (int64_t)ts.tv_nsec;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_builtin_read_file(const char* path) {");
  out.push("  if (!path) path = \"\";");
  out.push("  FILE* f = fopen(path, \"rb\");");
  out.push("  if (!f) { fprintf(stderr, \"read_file failed: %s\\n\", path); exit(1); }");
  out.push("  if (fseek(f, 0, SEEK_END) != 0) { fprintf(stderr, \"read_file fseek failed: %s\\n\", path); exit(1); }");
  out.push("  long n = ftell(f);");
  out.push("  if (n < 0) { fprintf(stderr, \"read_file ftell failed: %s\\n\", path); exit(1); }");
  out.push("  if (fseek(f, 0, SEEK_SET) != 0) { fprintf(stderr, \"read_file fseek failed: %s\\n\", path); exit(1); }");
  out.push("  char* out = (char*)malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  size_t got = fread(out, 1, (size_t)n, f);");
  out.push("  if (got != (size_t)n) { fprintf(stderr, \"read_file fread failed: %s\\n\", path); exit(1); }");
  out.push("  out[n] = '\\0';");
  out.push("  fclose(f);");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static void vox_builtin_write_file(const char* path, const char* text) {");
  out.push("  if (!path) path = \"\";");
  out.push("  if (!text) text = \"\";");
  out.push("  FILE* f = fopen(path, \"wb\");");
  out.push("  if (!f) { fprintf(stderr, \"write_file failed: %s\\n\", path); exit(1); }");
  out.push("  size_t n = strlen(text);");
  out.push("  if (n != 0) {");
  out.push("    size_t put = fwrite(text, 1, n, f);");
  out.push("    if (put != n) { fprintf(stderr, \"write_file fwrite failed: %s\\n\", path); exit(1); }");
  out.push("  }");
  out.push("  fclose(f);");
  out.push("}");
  out.push("");
  out.push("static bool vox_builtin_path_exists(const char* path) {");
  out.push("  if (!path || path[0] == '\\0') return false;");
  out.push("  struct stat st;");
  out.push("  return stat(path, &st) == 0;");
  out.push("}");
  out.push("");
  out.push("static void vox_builtin_mkdir_p(const char* path) {");
  out.push("  if (!path || path[0] == '\\0') return;");
  out.push("  size_t n = strlen(path);");
  out.push("  char* tmp = (char*)malloc(n + 1);");
  out.push("  if (!tmp) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(tmp, path, n + 1);");
  out.push("  for (size_t i = 1; i < n; i++) {");
  out.push("    char ch = tmp[i];");
  out.push("    if (ch != '/' && ch != '\\\\') continue;");
  out.push("    tmp[i] = '\\0';");
  out.push("    if (tmp[0] != '\\0' && !vox_builtin_path_exists(tmp)) {");
  out.push("#if defined(_WIN32)");
  out.push("      if (_mkdir(tmp) != 0) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }");
  out.push("#else");
  out.push("      if (mkdir(tmp, 0755) != 0) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }");
  out.push("#endif");
  out.push("    }");
  out.push("    tmp[i] = ch;");
  out.push("  }");
  out.push("  if (!vox_builtin_path_exists(tmp)) {");
  out.push("#if defined(_WIN32)");
  out.push("    if (_mkdir(tmp) != 0) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }");
  out.push("#else");
  out.push("    if (mkdir(tmp, 0755) != 0) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }");
  out.push("#endif");
  out.push("  }");
  out.push("  free(tmp);");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_builtin_exec(const char* cmd) {");
  out.push("  if (!cmd) cmd = \"\";");
  out.push("  int r = system(cmd);");
  out.push("  return (int32_t)r;");
  out.push("}");
  out.push("");
  out.push("static bool vox_str_has_suffix(const char* s, const char* suf) {");
  out.push("  if (!s || !suf) return false;");
  out.push("  size_t n = strlen(s);");
  out.push("  size_t m = strlen(suf);");
  out.push("  if (m > n) return false;");
  out.push("  return memcmp(s + (n - m), suf, m) == 0;");
  out.push("}");
  out.push("");
  out.push("static char* vox_path_join2(const char* a, const char* b) {");
  out.push("  if (!a) a = \"\";");
  out.push("  if (!b) b = \"\";");
  out.push("  size_t na = strlen(a);");
  out.push("  size_t nb = strlen(b);");
  out.push("  bool slash = (na != 0 && a[na - 1] != '/');");
  out.push("  size_t n = na + (slash ? 1 : 0) + nb;");
  out.push("  char* out = (char*)malloc(n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, a, na);");
  out.push("  size_t j = na;");
  out.push("  if (slash) out[j++] = '/';");
  out.push("  memcpy(out + j, b, nb);");
  out.push("  out[n] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static void vox_walk_dir(vox_vec* out, const char* root, const char* rel) {");
  out.push("  char* full = rel && rel[0] ? vox_path_join2(root, rel) : vox_path_join2(root, \"\");");
  out.push("  DIR* d = opendir(full);");
  out.push("  if (!d) { free(full); return; }");
  out.push("  struct dirent* ent;");
  out.push("  while ((ent = readdir(d)) != NULL) {");
  out.push("    const char* name = ent->d_name;");
  out.push("    if (!name || name[0] == '\\0') continue;");
  out.push("    if (strcmp(name, \".\") == 0 || strcmp(name, \"..\") == 0) continue;");
  out.push("    char* child_rel = rel && rel[0] ? vox_path_join2(rel, name) : vox_path_join2(\"\", name);");
  out.push("    char* child_full = vox_path_join2(root, child_rel);");
  out.push("    struct stat st;");
  out.push("    if (stat(child_full, &st) == 0 && S_ISDIR(st.st_mode)) {");
  out.push("      vox_walk_dir(out, root, child_rel);");
  out.push("      free(child_rel);");
  out.push("      free(child_full);");
  out.push("      continue;");
  out.push("    }");
  out.push("    if (vox_str_has_suffix(child_rel, \".vox\")) {");
  out.push("      const char* s = child_rel;");
  out.push("      vox_vec_push(out, &s);");
  out.push("    } else {");
  out.push("      free(child_rel);");
  out.push("    }");
  out.push("    free(child_full);");
  out.push("  }");
  out.push("  closedir(d);");
  out.push("  free(full);");
  out.push("}");
  out.push("");
  out.push("static vox_vec vox_builtin_walk_vox_files(const char* root) {");
  out.push("  if (!root || root[0] == '\\0') root = \".\";");
  out.push("  vox_vec out = vox_vec_new((int32_t)sizeof(const char*));");
  out.push("  vox_walk_dir(&out, root, \"src\");");
  out.push("  vox_walk_dir(&out, root, \"tests\");");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("typedef struct { atomic_flag lock; int32_t value; } vox_mutex_i32;");
  out.push("typedef struct { _Atomic int32_t value; } vox_atomic_i32;");
  out.push("");
  out.push("static int64_t vox_builtin_mutex_i32_new(int32_t init) {");
  out.push("  vox_mutex_i32* m = (vox_mutex_i32*)malloc(sizeof(vox_mutex_i32));");
  out.push("  if (!m) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  atomic_flag_clear(&m->lock);");
  out.push("  m->value = init;");
  out.push("  return (int64_t)(intptr_t)m;");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_builtin_mutex_i32_load(int64_t h) {");
  out.push("  vox_mutex_i32* m = (vox_mutex_i32*)(intptr_t)h;");
  out.push("  if (!m) { vox_builtin_panic(\"invalid mutex handle\"); }");
  out.push("  while (atomic_flag_test_and_set(&m->lock)) {}");
  out.push("  int32_t v = m->value;");
  out.push("  atomic_flag_clear(&m->lock);");
  out.push("  return v;");
  out.push("}");
  out.push("");
  out.push("static void vox_builtin_mutex_i32_store(int64_t h, int32_t v) {");
  out.push("  vox_mutex_i32* m = (vox_mutex_i32*)(intptr_t)h;");
  out.push("  if (!m) { vox_builtin_panic(\"invalid mutex handle\"); }");
  out.push("  while (atomic_flag_test_and_set(&m->lock)) {}");
  out.push("  m->value = v;");
  out.push("  atomic_flag_clear(&m->lock);");
  out.push("}");
  out.push("");
  out.push("static int64_t vox_builtin_atomic_i32_new(int32_t init) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)malloc(sizeof(vox_atomic_i32));");
  out.push("  if (!a) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  atomic_store_explicit(&a->value, init, memory_order_seq_cst);");
  out.push("  return (int64_t)(intptr_t)a;");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_builtin_atomic_i32_load(int64_t h) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }");
  out.push("  return atomic_load_explicit(&a->value, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("static void vox_builtin_atomic_i32_store(int64_t h, int32_t v) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }");
  out.push("  atomic_store_explicit(&a->value, v, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_builtin_atomic_i32_fetch_add(int64_t h, int32_t delta) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }");
  out.push("  return atomic_fetch_add_explicit(&a->value, delta, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_builtin_atomic_i32_swap(int64_t h, int32_t v) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }");
  out.push("  return atomic_exchange_explicit(&a->value, v, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("typedef struct { atomic_flag lock; int64_t value; } vox_mutex_i64;");
  out.push("typedef struct { _Atomic int64_t value; } vox_atomic_i64;");
  out.push("");
  out.push("static int64_t vox_builtin_mutex_i64_new(int64_t init) {");
  out.push("  vox_mutex_i64* m = (vox_mutex_i64*)malloc(sizeof(vox_mutex_i64));");
  out.push("  if (!m) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  atomic_flag_clear(&m->lock);");
  out.push("  m->value = init;");
  out.push("  return (int64_t)(intptr_t)m;");
  out.push("}");
  out.push("");
  out.push("static int64_t vox_builtin_mutex_i64_load(int64_t h) {");
  out.push("  vox_mutex_i64* m = (vox_mutex_i64*)(intptr_t)h;");
  out.push("  if (!m) { vox_builtin_panic(\"invalid mutex handle\"); }");
  out.push("  while (atomic_flag_test_and_set(&m->lock)) {}");
  out.push("  int64_t v = m->value;");
  out.push("  atomic_flag_clear(&m->lock);");
  out.push("  return v;");
  out.push("}");
  out.push("");
  out.push("static void vox_builtin_mutex_i64_store(int64_t h, int64_t v) {");
  out.push("  vox_mutex_i64* m = (vox_mutex_i64*)(intptr_t)h;");
  out.push("  if (!m) { vox_builtin_panic(\"invalid mutex handle\"); }");
  out.push("  while (atomic_flag_test_and_set(&m->lock)) {}");
  out.push("  m->value = v;");
  out.push("  atomic_flag_clear(&m->lock);");
  out.push("}");
  out.push("");
  out.push("static int64_t vox_builtin_atomic_i64_new(int64_t init) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)malloc(sizeof(vox_atomic_i64));");
  out.push("  if (!a) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  atomic_store_explicit(&a->value, init, memory_order_seq_cst);");
  out.push("  return (int64_t)(intptr_t)a;");
  out.push("}");
  out.push("");
  out.push("static int64_t vox_builtin_atomic_i64_load(int64_t h) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }");
  out.push("  return atomic_load_explicit(&a->value, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("static void vox_builtin_atomic_i64_store(int64_t h, int64_t v) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }");
  out.push("  atomic_store_explicit(&a->value, v, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("static int64_t vox_builtin_atomic_i64_fetch_add(int64_t h, int64_t delta) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }");
  out.push("  return atomic_fetch_add_explicit(&a->value, delta, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("static int64_t vox_builtin_atomic_i64_swap(int64_t h, int64_t v) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!a) { vox_builtin_panic(\"invalid atomic handle\"); }");
  out.push("  return atomic_exchange_explicit(&a->value, v, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("#if defined(_WIN32)");
  out.push("static void vox_tcp_win_ensure_init(void) {");
  out.push("  static int inited = 0;");
  out.push("  if (inited) return;");
  out.push("  WSADATA wsa;");
  out.push("  int rc = WSAStartup(MAKEWORD(2, 2), &wsa);");
  out.push("  if (rc != 0) { vox_builtin_panic(\"tcp wsa startup failed\"); }");
  out.push("  inited = 1;");
  out.push("}");
  out.push("");
  out.push("static int64_t vox_builtin_tcp_connect(const char* host, int32_t port) {");
  out.push("  vox_tcp_win_ensure_init();");
  out.push("  if (!host) host = \"\";");
  out.push("  if (port <= 0 || port > 65535) { vox_builtin_panic(\"invalid tcp port\"); }");
  out.push("  char port_buf[16];");
  out.push("  snprintf(port_buf, sizeof(port_buf), \"%\" PRId32, port);");
  out.push("  struct addrinfo hints;");
  out.push("  memset(&hints, 0, sizeof(hints));");
  out.push("  hints.ai_family = AF_UNSPEC;");
  out.push("  hints.ai_socktype = SOCK_STREAM;");
  out.push("  hints.ai_protocol = IPPROTO_TCP;");
  out.push("  struct addrinfo* res = NULL;");
  out.push("  int rc = getaddrinfo(host, port_buf, &hints, &res);");
  out.push("  if (rc != 0 || !res) { vox_builtin_panic(\"tcp connect resolve failed\"); }");
  out.push("  SOCKET fd = INVALID_SOCKET;");
  out.push("  for (struct addrinfo* p = res; p != NULL; p = p->ai_next) {");
  out.push("    fd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);");
  out.push("    if (fd == INVALID_SOCKET) continue;");
  out.push("    if (connect(fd, p->ai_addr, (int)p->ai_addrlen) == 0) { break; }");
  out.push("    closesocket(fd);");
  out.push("    fd = INVALID_SOCKET;");
  out.push("  }");
  out.push("  freeaddrinfo(res);");
  out.push("  if (fd == INVALID_SOCKET) { vox_builtin_panic(\"tcp connect failed\"); }");
  out.push("  return (int64_t)(uintptr_t)fd;");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_builtin_tcp_send(int64_t h, const char* text) {");
  out.push("  if (h < 0) { vox_builtin_panic(\"invalid tcp handle\"); }");
  out.push("  SOCKET fd = (SOCKET)(uintptr_t)h;");
  out.push("  if (fd == INVALID_SOCKET) { vox_builtin_panic(\"invalid tcp handle\"); }");
  out.push("  if (!text) text = \"\";");
  out.push("  size_t n = strlen(text);");
  out.push("  if (n > (size_t)INT_MAX) { vox_builtin_panic(\"tcp send too large\"); }");
  out.push("  int sent = send(fd, text, (int)n, 0);");
  out.push("  if (sent < 0) { vox_builtin_panic(\"tcp send failed\"); }");
  out.push("  return (int32_t)sent;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_builtin_tcp_recv(int64_t h, int32_t max_n) {");
  out.push("  if (h < 0) { vox_builtin_panic(\"invalid tcp handle\"); }");
  out.push("  SOCKET fd = (SOCKET)(uintptr_t)h;");
  out.push("  if (fd == INVALID_SOCKET) { vox_builtin_panic(\"invalid tcp handle\"); }");
  out.push("  if (max_n <= 0) return \"\";");
  out.push("  char* buf = (char*)malloc((size_t)max_n + 1);");
  out.push("  if (!buf) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  int n = recv(fd, buf, max_n, 0);");
  out.push("  if (n < 0) { free(buf); vox_builtin_panic(\"tcp recv failed\"); }");
  out.push("  if (n == 0) { free(buf); return \"\"; }");
  out.push("  buf[n] = '\\0';");
  out.push("  return buf;");
  out.push("}");
  out.push("");
  out.push("static void vox_builtin_tcp_close(int64_t h) {");
  out.push("  if (h < 0) return;");
  out.push("  SOCKET fd = (SOCKET)(uintptr_t)h;");
  out.push("  if (fd == INVALID_SOCKET) return;");
  out.push("  closesocket(fd);");
  out.push("}");
  out.push("#else");
  out.push("static int64_t vox_builtin_tcp_connect(const char* host, int32_t port) {");
  out.push("  if (!host) host = \"\";");
  out.push("  if (port <= 0 || port > 65535) { vox_builtin_panic(\"invalid tcp port\"); }");
  out.push("  char port_buf[16];");
  out.push("  snprintf(port_buf, sizeof(port_buf), \"%\" PRId32, port);");
  out.push("  struct addrinfo hints;");
  out.push("  memset(&hints, 0, sizeof(hints));");
  out.push("  hints.ai_family = AF_UNSPEC;");
  out.push("  hints.ai_socktype = SOCK_STREAM;");
  out.push("  struct addrinfo* res = NULL;");
  out.push("  int rc = getaddrinfo(host, port_buf, &hints, &res);");
  out.push("  if (rc != 0 || !res) { vox_builtin_panic(\"tcp connect resolve failed\"); }");
  out.push("  int fd = -1;");
  out.push("  for (struct addrinfo* p = res; p != NULL; p = p->ai_next) {");
  out.push("    fd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);");
  out.push("    if (fd < 0) continue;");
  out.push("    if (connect(fd, p->ai_addr, p->ai_addrlen) == 0) { break; }");
  out.push("    close(fd);");
  out.push("    fd = -1;");
  out.push("  }");
  out.push("  freeaddrinfo(res);");
  out.push("  if (fd < 0) { vox_builtin_panic(\"tcp connect failed\"); }");
  out.push("  return (int64_t)fd;");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_builtin_tcp_send(int64_t h, const char* text) {");
  out.push("  int fd = (int)h;");
  out.push("  if (fd < 0) { vox_builtin_panic(\"invalid tcp handle\"); }");
  out.push("  if (!text) text = \"\";");
  out.push("  size_t n = strlen(text);");
  out.push("  ssize_t sent = send(fd, text, n, 0);");
  out.push("  if (sent < 0) { vox_builtin_panic(\"tcp send failed\"); }");
  out.push("  if ((uint64_t)sent > (uint64_t)INT32_MAX) { vox_builtin_panic(\"tcp send too large\"); }");
  out.push("  return (int32_t)sent;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_builtin_tcp_recv(int64_t h, int32_t max_n) {");
  out.push("  int fd = (int)h;");
  out.push("  if (fd < 0) { vox_builtin_panic(\"invalid tcp handle\"); }");
  out.push("  if (max_n <= 0) return \"\";");
  out.push("  char* buf = (char*)malloc((size_t)max_n + 1);");
  out.push("  if (!buf) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  ssize_t n = recv(fd, buf, (size_t)max_n, 0);");
  out.push("  if (n < 0) { free(buf); vox_builtin_panic(\"tcp recv failed\"); }");
  out.push("  if (n == 0) { free(buf); return \"\"; }");
  out.push("  buf[n] = '\\0';");
  out.push("  return buf;");
  out.push("}");
  out.push("");
  out.push("static void vox_builtin_tcp_close(int64_t h) {");
  out.push("  int fd = (int)h;");
  out.push("  if (fd < 0) return;");
  out.push("  close(fd);");
  out.push("}");
  out.push("#endif");
  out.push("");

  return out;
}
