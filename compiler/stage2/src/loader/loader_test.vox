import "std/testing" as t

fn test_loader_merges_multi_files_root_module() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "src/a.vox", text: "fn a() -> i32 { return 1; }" });
  fs.push(SourceFile { path: "src/b.vox", text: "fn b() -> i32 { return 2; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(r.ok);
  t.assert_eq(r.world.mods.len(), 1);
  let m = r.world.mods.get(0);
  t.assert_eq(m.path, "main");
  t.assert_eq(m.prog.funcs.len(), 2);
}

fn test_loader_submodule_path() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "src/a/x.vox", text: "fn x() -> i32 { return 0; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(r.ok);
  t.assert_eq(r.world.mods.len(), 1);
  let m = r.world.mods.get(0);
  t.assert_eq(m.path, "a");
}

fn test_loader_tests_module_path() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "tests/basic.vox", text: "fn test_ok() -> () { return; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(r.ok);
  t.assert_eq(r.world.mods.len(), 1);
  let m = r.world.mods.get(0);
  t.assert_eq(m.path, "tests");
}

fn test_loader_dependency_prefix_module_path() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "dep/src/dep.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(SourceFile { path: "dep/src/a/x.vox", text: "pub fn x() -> i32 { return 0; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(r.ok);
  t.assert_eq(r.world.mods.len(), 2);
  // Order not specified; just check both exist.
  let a = r.world.mods.get(0).path;
  let b = r.world.mods.get(1).path;
  t.assert((a == "pkg/dep" && b == "pkg/dep/a") || (a == "pkg/dep/a" && b == "pkg/dep"));
}

fn test_loader_parse_error_meta_propagation() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return 0; }\nelse" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(!r.ok);
  t.assert(r.err_kind == load_diag_kind_parse());
  t.assert(r.err_code == "E_PARSE_0001");
  t.assert(r.err_message.len() > 0);
}

fn test_loader_unsupported_path_error_meta() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "README.vox", text: "fn main() -> i32 { return 0; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(!r.ok);
  t.assert(r.err_kind == load_diag_kind_loader());
  t.assert(r.err_code == "E_LOAD_0001");
}
