import "ast" as ast
import "typecheck" as tc

pub struct ExpandConfig {
  pub max_rounds: i32,
}

pub struct ExpandResult {
  pub ok: bool,
  pub err: tc.TcError,
  pub world: tc.World,
  pub rounds: i32,
}

struct ExpandRoundResult {
  ok: bool,
  err: tc.TcError,
  changed: bool,
  world: tc.World,
}

struct MacroSite {
  found: bool,
  mod_idx: i32,
  expr_id: i32,
  callee: i32,
  targs: Vec[ast.TypeName],
  args: Vec[i32],
  sp: ast.Span,
  name: String,
}

fn no_site() -> MacroSite {
  return MacroSite {
    found: false,
    mod_idx: -1,
    expr_id: -1,
    callee: -1,
    targs: Vec(),
    args: Vec(),
    sp: ast.span0(),
    name: "",
  };
}

fn find_macro_callee_name(exprs: ast.ExprPool, callee: i32) -> String {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, callee);
  return match n {
    ast.ExprNode.Ident(s) => s,
    ast.ExprNode.Member(_recv, name) => name,
    _ => "<expr>",
  };
}

fn site_from_macro_call(exprs: ast.ExprPool, mod_idx: i32, expr_id: i32, callee: i32, targs: Vec[ast.TypeName], args: Vec[i32]) -> MacroSite {
  let name: String = find_macro_callee_name(exprs, callee);
  return MacroSite {
    found: true,
    mod_idx: mod_idx,
    expr_id: expr_id,
    callee: callee,
    targs: targs,
    args: args,
    sp: ast.expr_pool_span(exprs, expr_id),
    name: name,
  };
}

fn find_macro_site_in_expr_block(exprs: ast.ExprPool, mod_idx: i32, b: ast.ExprBlock) -> MacroSite {
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let s: MacroSite = find_macro_site_in_stmt(exprs, mod_idx, b.stmts.get(i));
    if s.found { return s; }
    i = i + 1;
  }
  if b.has_tail { return find_macro_site_in_expr(exprs, mod_idx, b.tail); }
  return no_site();
}

fn find_macro_site_in_block(exprs: ast.ExprPool, mod_idx: i32, b: ast.Block) -> MacroSite {
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let s: MacroSite = find_macro_site_in_stmt(exprs, mod_idx, b.stmts.get(i));
    if s.found { return s; }
    i = i + 1;
  }
  return no_site();
}

fn find_macro_site_in_if_stmt(exprs: ast.ExprPool, mod_idx: i32, cond: i32, then_b: ast.Block, has_else: bool, else_b: ast.Block) -> MacroSite {
  let s0: MacroSite = find_macro_site_in_expr(exprs, mod_idx, cond);
  if s0.found { return s0; }
  let s1: MacroSite = find_macro_site_in_block(exprs, mod_idx, then_b);
  if s1.found { return s1; }
  if has_else { return find_macro_site_in_block(exprs, mod_idx, else_b); }
  return no_site();
}

fn find_macro_site_in_while_stmt(exprs: ast.ExprPool, mod_idx: i32, cond: i32, body: ast.Block) -> MacroSite {
  let s0: MacroSite = find_macro_site_in_expr(exprs, mod_idx, cond);
  if s0.found { return s0; }
  return find_macro_site_in_block(exprs, mod_idx, body);
}

fn find_macro_site_in_if_expr(exprs: ast.ExprPool, mod_idx: i32, c0: i32, t0: i32, e0: i32) -> MacroSite {
  let s0: MacroSite = find_macro_site_in_expr(exprs, mod_idx, c0);
  if s0.found { return s0; }
  let s1: MacroSite = find_macro_site_in_expr(exprs, mod_idx, t0);
  if s1.found { return s1; }
  return find_macro_site_in_expr(exprs, mod_idx, e0);
}

fn find_macro_site_in_binary_expr(exprs: ast.ExprPool, mod_idx: i32, l: i32, r: i32) -> MacroSite {
  let s0: MacroSite = find_macro_site_in_expr(exprs, mod_idx, l);
  if s0.found { return s0; }
  return find_macro_site_in_expr(exprs, mod_idx, r);
}

fn find_macro_site_in_call_expr(exprs: ast.ExprPool, mod_idx: i32, callee: i32, args: Vec[i32]) -> MacroSite {
  let s0: MacroSite = find_macro_site_in_expr(exprs, mod_idx, callee);
  if s0.found { return s0; }
  let mut i: i32 = 0;
  while i < args.len() {
    let si: MacroSite = find_macro_site_in_expr(exprs, mod_idx, args.get(i));
    if si.found { return si; }
    i = i + 1;
  }
  return no_site();
}

fn find_macro_site_in_struct_lit_expr(exprs: ast.ExprPool, mod_idx: i32, tyex: i32, fields: Vec[ast.StructLitField]) -> MacroSite {
  let s0: MacroSite = find_macro_site_in_expr(exprs, mod_idx, tyex);
  if s0.found { return s0; }
  let mut i: i32 = 0;
  while i < fields.len() {
    let si: MacroSite = find_macro_site_in_expr(exprs, mod_idx, fields.get(i).expr);
    if si.found { return si; }
    i = i + 1;
  }
  return no_site();
}

fn find_macro_site_in_match_expr(exprs: ast.ExprPool, mod_idx: i32, scrut: i32, arms: Vec[ast.MatchArm]) -> MacroSite {
  let s0: MacroSite = find_macro_site_in_expr(exprs, mod_idx, scrut);
  if s0.found { return s0; }
  let mut i: i32 = 0;
  while i < arms.len() {
    let si: MacroSite = find_macro_site_in_expr(exprs, mod_idx, arms.get(i).expr);
    if si.found { return si; }
    i = i + 1;
  }
  return no_site();
}

fn find_macro_site_in_stmt(exprs: ast.ExprPool, mod_idx: i32, st: ast.Stmt) -> MacroSite {
  return match st {
    ast.Stmt.Let(_sp, _mut, _name, _has_ann, _ann, init) => find_macro_site_in_expr(exprs, mod_idx, init),
    ast.Stmt.Assign(_sp, _name, ex) => find_macro_site_in_expr(exprs, mod_idx, ex),
    ast.Stmt.AssignField(_sp, _recv, _field, ex) => find_macro_site_in_expr(exprs, mod_idx, ex),
    ast.Stmt.ExprStmt(_sp, ex) => find_macro_site_in_expr(exprs, mod_idx, ex),
    ast.Stmt.IfStmt(_sp, cond, then_b, has_else, else_b) => find_macro_site_in_if_stmt(exprs, mod_idx, cond, then_b, has_else, else_b),
    ast.Stmt.WhileStmt(_sp, cond, body) => find_macro_site_in_while_stmt(exprs, mod_idx, cond, body),
    ast.Stmt.Break(_sp) => no_site(),
    ast.Stmt.Continue(_sp) => no_site(),
    ast.Stmt.ReturnStmt(_sp, has_ex, ex) => if has_ex { find_macro_site_in_expr(exprs, mod_idx, ex) } else { no_site() },
  };
}

fn find_macro_site_in_expr(exprs: ast.ExprPool, mod_idx: i32, id: i32) -> MacroSite {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);
  return match n {
    ast.ExprNode.Int(_v) => no_site(),
    ast.ExprNode.Float(_v) => no_site(),
    ast.ExprNode.Bool(_v) => no_site(),
    ast.ExprNode.Ident(_s) => no_site(),
    ast.ExprNode.Str(_s) => no_site(),
    ast.ExprNode.DotIdent(_s) => no_site(),
    ast.ExprNode.Block(b) => find_macro_site_in_expr_block(exprs, mod_idx, b),
    ast.ExprNode.If(c0, t0, e0) => find_macro_site_in_if_expr(exprs, mod_idx, c0, t0, e0),
    ast.ExprNode.Unary(_op, a) => find_macro_site_in_expr(exprs, mod_idx, a),
    ast.ExprNode.As(a, _tn) => find_macro_site_in_expr(exprs, mod_idx, a),
    ast.ExprNode.Binary(_op, l, r) => find_macro_site_in_binary_expr(exprs, mod_idx, l, r),
    ast.ExprNode.Member(recv, _name) => find_macro_site_in_expr(exprs, mod_idx, recv),
    ast.ExprNode.Call(callee, _targs, args) => find_macro_site_in_call_expr(exprs, mod_idx, callee, args),
    ast.ExprNode.MacroCall(callee, targs, args) => site_from_macro_call(exprs, mod_idx, id, callee, targs, args),
    ast.ExprNode.TryBlock(bid) => find_macro_site_in_expr(exprs, mod_idx, bid),
    ast.ExprNode.Try(a) => find_macro_site_in_expr(exprs, mod_idx, a),
    ast.ExprNode.StructLit(tyex, fields) => find_macro_site_in_struct_lit_expr(exprs, mod_idx, tyex, fields),
    ast.ExprNode.Match(scrut, arms) => find_macro_site_in_match_expr(exprs, mod_idx, scrut, arms),
  };
}

fn find_first_macro_site_in_prog(prog: ast.Program, mod_idx: i32) -> MacroSite {
  let mut ci: i32 = 0;
  while ci < prog.consts.len() {
    let s: MacroSite = find_macro_site_in_expr(prog.exprs, mod_idx, prog.consts.get(ci).init);
    if s.found { return s; }
    ci = ci + 1;
  }

  let mut fi: i32 = 0;
  while fi < prog.funcs.len() {
    let s: MacroSite = find_macro_site_in_block(prog.exprs, mod_idx, prog.funcs.get(fi).body);
    if s.found { return s; }
    fi = fi + 1;
  }

  let mut ti: i32 = 0;
  while ti < prog.traits.len() {
    let mut mi: i32 = 0;
    while mi < prog.traits.get(ti).methods.len() {
      let md: ast.TraitMethodDecl = prog.traits.get(ti).methods.get(mi);
      if md.has_body {
        let s: MacroSite = find_macro_site_in_block(prog.exprs, mod_idx, md.body);
        if s.found { return s; }
      }
      mi = mi + 1;
    }
    ti = ti + 1;
  }

  let mut ii: i32 = 0;
  while ii < prog.impls.len() {
    let mut mi: i32 = 0;
    while mi < prog.impls.get(ii).methods.len() {
      let s: MacroSite = find_macro_site_in_block(prog.exprs, mod_idx, prog.impls.get(ii).methods.get(mi).body);
      if s.found { return s; }
      mi = mi + 1;
    }
    ii = ii + 1;
  }

  return no_site();
}

fn find_first_macro_site_in_world(w: tc.World) -> MacroSite {
  let mut i: i32 = 0;
  while i < w.mods.len() {
    let m: tc.WorldModule = w.mods.get(i);
    let s: MacroSite = find_first_macro_site_in_prog(m.prog, i);
    if s.found { return s; }
    i = i + 1;
  }
  return no_site();
}

fn expr_pool_replace(exprs: ast.ExprPool, id: i32, n: ast.ExprNode, sp: ast.Span) -> ast.ExprPool {
  let mut nodes: Vec[ast.ExprNode] = Vec();
  let mut spans: Vec[ast.Span] = Vec();
  let mut i: i32 = 0;
  while i < exprs.nodes.len() {
    if i == id {
      nodes.push(n);
      spans.push(sp);
    } else {
      nodes.push(ast.expr_pool_get(exprs, i));
      spans.push(ast.expr_pool_span(exprs, i));
    }
    i = i + 1;
  }
  return ast.ExprPool { nodes: nodes, spans: spans };
}

fn program_with_exprs(prog: ast.Program, exprs: ast.ExprPool) -> ast.Program {
  return ast.Program {
    imports: prog.imports,
    types: prog.types,
    consts: prog.consts,
    structs: prog.structs,
    enums: prog.enums,
    traits: prog.traits,
    impls: prog.impls,
    funcs: prog.funcs,
    exprs: exprs,
  };
}

fn world_replace_mod_prog(w: tc.World, mod_idx: i32, prog: ast.Program) -> tc.World {
  let mut mods: Vec[tc.WorldModule] = Vec();
  let mut i: i32 = 0;
  while i < w.mods.len() {
    let m: tc.WorldModule = w.mods.get(i);
    if i == mod_idx {
      mods.push(tc.WorldModule { path: m.path, prog: prog });
    } else {
      mods.push(m);
    }
    i = i + 1;
  }
  return tc.World { mods: mods };
}

fn round_ok(w: tc.World, changed: bool) -> ExpandRoundResult {
  return ExpandRoundResult { ok: true, err: tc.TcError.None, changed: changed, world: w };
}

fn round_err(w: tc.World, e: tc.TcError) -> ExpandRoundResult {
  return ExpandRoundResult { ok: false, err: e, changed: false, world: w };
}

fn round_replace_expr(w: tc.World, site: MacroSite, n: ast.ExprNode) -> ExpandRoundResult {
  let m: tc.WorldModule = w.mods.get(site.mod_idx);
  let exprs2: ast.ExprPool = expr_pool_replace(m.prog.exprs, site.expr_id, n, site.sp);
  let prog2: ast.Program = program_with_exprs(m.prog, exprs2);
  let w2: tc.World = world_replace_mod_prog(w, site.mod_idx, prog2);
  return round_ok(w2, true);
}

fn expand_compile_bang(w: tc.World, site: MacroSite) -> ExpandRoundResult {
  if site.targs.len() != 0 || site.args.len() != 1 {
    return round_err(w, tc.tc_type_error_at(site.sp, "compile! expects exactly one value arg and no type args"));
  }
  let m: tc.WorldModule = w.mods.get(site.mod_idx);
  let arg_id: i32 = site.args.get(0);
  let arg_node: ast.ExprNode = ast.expr_pool_get(m.prog.exprs, arg_id);
  return round_replace_expr(w, site, arg_node);
}

fn expand_panic_bang(w: tc.World, site: MacroSite) -> ExpandRoundResult {
  if site.targs.len() != 0 || site.args.len() != 1 {
    return round_err(w, tc.tc_type_error_at(site.sp, "panic! expects exactly one value arg and no type args"));
  }
  return round_replace_expr(w, site, ast.ExprNode.Call(site.callee, Vec(), site.args));
}

fn expand_compile_error_bang(w: tc.World, site: MacroSite) -> ExpandRoundResult {
  if site.targs.len() != 0 || site.args.len() != 1 {
    return round_err(w, tc.tc_type_error_at(site.sp, "compile_error! expects exactly one value arg and no type args"));
  }
  let m: tc.WorldModule = w.mods.get(site.mod_idx);
  let ar: ast.AddExprResult = ast.expr_pool_add(m.prog.exprs, ast.ExprNode.Ident("@compile_error"), site.sp);
  let call: ast.ExprNode = ast.ExprNode.Call(ar.id, Vec(), site.args);
  let exprs2: ast.ExprPool = expr_pool_replace(ar.pool, site.expr_id, call, site.sp);
  let prog2: ast.Program = program_with_exprs(m.prog, exprs2);
  let w2: tc.World = world_replace_mod_prog(w, site.mod_idx, prog2);
  return round_ok(w2, true);
}

fn assert_with_callee_node(exprs: ast.ExprPool, callee: i32) -> ast.ExprNode {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, callee);
  return match n {
    ast.ExprNode.Ident(_s) => ast.ExprNode.Ident("assert_with"),
    ast.ExprNode.Member(recv, _name) => ast.ExprNode.Member(recv, "assert_with"),
    _ => ast.ExprNode.Ident("assert_with"),
  };
}

fn expand_assert_bang(w: tc.World, site: MacroSite) -> ExpandRoundResult {
  if site.targs.len() != 0 {
    return round_err(w, tc.tc_type_error_at(site.sp, "assert! expects no type args"));
  }
  if site.args.len() == 1 {
    return round_replace_expr(w, site, ast.ExprNode.Call(site.callee, Vec(), site.args));
  }
  if site.args.len() == 2 {
    let m: tc.WorldModule = w.mods.get(site.mod_idx);
    let ar: ast.AddExprResult = ast.expr_pool_add(m.prog.exprs, assert_with_callee_node(m.prog.exprs, site.callee), site.sp);
    let call: ast.ExprNode = ast.ExprNode.Call(ar.id, Vec(), site.args);
    let exprs2: ast.ExprPool = expr_pool_replace(ar.pool, site.expr_id, call, site.sp);
    let prog2: ast.Program = program_with_exprs(m.prog, exprs2);
    let w2: tc.World = world_replace_mod_prog(w, site.mod_idx, prog2);
    return round_ok(w2, true);
  }
  return round_err(w, tc.tc_type_error_at(site.sp, "assert! expects one or two value args"));
}

fn is_binary_assert_macro_name(name: String) -> bool {
  return name == "assert_eq" ||
    name == "assert_ne" ||
    name == "assert_lt" ||
    name == "assert_le" ||
    name == "assert_gt" ||
    name == "assert_ge";
}

fn expand_binary_assert_bang(w: tc.World, site: MacroSite) -> ExpandRoundResult {
  if site.targs.len() != 0 || site.args.len() != 2 {
    return round_err(w, tc.tc_type_error_at(site.sp, site.name.concat("! expects exactly two value args and no type args")));
  }
  return round_replace_expr(w, site, ast.ExprNode.Call(site.callee, Vec(), site.args));
}

fn expand_user_macro_call_as_fn_call(w: tc.World, site: MacroSite) -> ExpandRoundResult {
  // Stage2 transitional behavior:
  // 1) try local macro-style inline (single `return <expr>;` template)
  // 2) fallback: lower `name!(...)` to plain `name(...)`
  let inl: ExpandRoundResult = try_expand_local_user_macro_inline(w, site);
  if !inl.ok { return inl; }
  if inl.changed { return inl; }
  return round_replace_expr(w, site, ast.ExprNode.Call(site.callee, site.targs, site.args));
}

fn expand_world_round(w: tc.World) -> ExpandRoundResult {
  let site: MacroSite = find_first_macro_site_in_world(w);
  if !site.found { return round_ok(w, false); }

  if site.name == "compile" {
    return expand_compile_bang(w, site);
  }
  if site.name == "panic" {
    return expand_panic_bang(w, site);
  }
  if site.name == "compile_error" {
    return expand_compile_error_bang(w, site);
  }
  if site.name == "assert" {
    return expand_assert_bang(w, site);
  }
  if is_binary_assert_macro_name(site.name) {
    return expand_binary_assert_bang(w, site);
  }

  return expand_user_macro_call_as_fn_call(w, site);
}

pub fn default_config() -> ExpandConfig { return ExpandConfig { max_rounds: 512 }; }

pub fn expand_world(w: tc.World, cfg0: ExpandConfig) -> ExpandResult {
  // Stage2 skeleton:
  // - reserves a dedicated expansion phase between parse/load and typecheck
  // - iterates in rounds until fixed-point / limit
  // - currently supports a minimal built-in macro set
  //   (`compile!`, `panic!`, `compile_error!`, `assert!`, `assert_eq!/assert_ne!/assert_lt!/assert_le!/assert_gt!/assert_ge!`)
  // - non-builtin macro calls try local inline template expansion first;
  //   unsupported shapes fallback to call sugar: `name!(...)` => `name(...)`
  let cfg: ExpandConfig =
    if cfg0.max_rounds <= 0 {
      default_config()
    } else {
      cfg0
    };

  let mut cur: tc.World = w;
  let mut round: i32 = 0;
  while round < cfg.max_rounds {
    let rr: ExpandRoundResult = expand_world_round(cur);
    if !rr.ok {
      return ExpandResult { ok: false, err: rr.err, world: rr.world, rounds: round };
    }
    cur = rr.world;
    if !rr.changed {
      return ExpandResult { ok: true, err: tc.TcError.None, world: cur, rounds: round };
    }
    round = round + 1;
  }

  return ExpandResult {
    ok: false,
    err: tc.tc_type_error("",
      "macro expansion exceeded max rounds: ".concat(cfg.max_rounds.to_string())),
    world: cur,
    rounds: cfg.max_rounds,
  };
}
