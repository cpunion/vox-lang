import "ast" as ast
import "typecheck" as tc

struct CloneExprResult {
  ok: bool,
  pool: ast.ExprPool,
  id: i32,
}

fn clone_expr_ok(pool: ast.ExprPool, id: i32) -> CloneExprResult {
  return CloneExprResult { ok: true, pool: pool, id: id };
}

fn clone_expr_err(pool: ast.ExprPool) -> CloneExprResult {
  return CloneExprResult { ok: false, pool: pool, id: -1 };
}

fn find_local_func_idx(prog: ast.Program, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < prog.funcs.len() {
    if prog.funcs.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_world_mod_idx(w: tc.World, path: String) -> i32 {
  let mut i: i32 = 0;
  while i < w.mods.len() {
    if w.mods.get(i).path == path { return i; }
    i = i + 1;
  }
  return -1;
}

fn macro_template_return_expr_id(fd: ast.FuncDecl) -> i32 {
  if fd.body.stmts.len() != 1 { return -1; }
  let st: ast.Stmt = fd.body.stmts.get(0);
  return
    match st {
      ast.Stmt.ReturnStmt(_sp, has_ex, ex) => if has_ex { ex } else { -1 },
      _ => -1,
    };
}

fn template_expr_list_supported(pool: ast.ExprPool, ids: Vec[i32]) -> bool {
  let mut i: i32 = 0;
  while i < ids.len() {
    if !template_expr_supported(pool, ids.get(i)) { return false; }
    i = i + 1;
  }
  return true;
}

fn template_struct_fields_supported(pool: ast.ExprPool, fields: Vec[ast.StructLitField]) -> bool {
  let mut i: i32 = 0;
  while i < fields.len() {
    if !template_expr_supported(pool, fields.get(i).expr) { return false; }
    i = i + 1;
  }
  return true;
}

fn template_expr_supported(pool: ast.ExprPool, id: i32) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(pool, id);
  return match n {
    ast.ExprNode.Int(_v) => true,
    ast.ExprNode.Float(_v) => true,
    ast.ExprNode.Bool(_v) => true,
    ast.ExprNode.Ident(_s) => true,
    ast.ExprNode.Str(_s) => true,
    ast.ExprNode.DotIdent(_s) => true,
    ast.ExprNode.If(c0, t0, e0) => template_expr_supported(pool, c0) && template_expr_supported(pool, t0) && template_expr_supported(pool, e0),
    ast.ExprNode.Unary(_op, a) => template_expr_supported(pool, a),
    ast.ExprNode.As(a, _tn) => template_expr_supported(pool, a),
    ast.ExprNode.Binary(_op, l, r) => template_expr_supported(pool, l) && template_expr_supported(pool, r),
    ast.ExprNode.Member(recv, _name) => template_expr_supported(pool, recv),
    ast.ExprNode.Call(callee, _ta, args) => template_expr_supported(pool, callee) && template_expr_list_supported(pool, args),
    ast.ExprNode.MacroCall(callee, _ta, args) => template_expr_supported(pool, callee) && template_expr_list_supported(pool, args),
    ast.ExprNode.Try(a) => template_expr_supported(pool, a),
    ast.ExprNode.StructLit(tyex, fields) => template_expr_supported(pool, tyex) && template_struct_fields_supported(pool, fields),
    // Keep v1 hygienic/simple: no local-binding forms in inline template.
    ast.ExprNode.Block(_b) => false,
    ast.ExprNode.TryBlock(_b) => false,
    ast.ExprNode.Match(_scrut, _arms) => false,
  };
}

fn param_exists(params: Vec[ast.Param], name: String) -> bool {
  return find_param_arg_idx(params, name) >= 0;
}

fn cross_mod_expr_list_safe(pool: ast.ExprPool, ids: Vec[i32], params: Vec[ast.Param]) -> bool {
  let mut i: i32 = 0;
  while i < ids.len() {
    if !cross_mod_expr_safe(pool, ids.get(i), params) { return false; }
    i = i + 1;
  }
  return true;
}

fn cross_mod_struct_fields_safe(pool: ast.ExprPool, fields: Vec[ast.StructLitField], params: Vec[ast.Param]) -> bool {
  let mut i: i32 = 0;
  while i < fields.len() {
    if !cross_mod_expr_safe(pool, fields.get(i).expr, params) { return false; }
    i = i + 1;
  }
  return true;
}

fn cross_mod_expr_safe(pool: ast.ExprPool, id: i32, params: Vec[ast.Param]) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(pool, id);
  return match n {
    ast.ExprNode.Int(_v) => true,
    ast.ExprNode.Float(_v) => true,
    ast.ExprNode.Bool(_v) => true,
    ast.ExprNode.Str(_s) => true,
    ast.ExprNode.Ident(s) => param_exists(params, s),
    ast.ExprNode.DotIdent(_s) => false,
    ast.ExprNode.If(c0, t0, e0) =>
      cross_mod_expr_safe(pool, c0, params) &&
      cross_mod_expr_safe(pool, t0, params) &&
      cross_mod_expr_safe(pool, e0, params),
    ast.ExprNode.Unary(_op, a) => cross_mod_expr_safe(pool, a, params),
    ast.ExprNode.As(_a, _tn) => false,
    ast.ExprNode.Binary(_op, l, r) => cross_mod_expr_safe(pool, l, params) && cross_mod_expr_safe(pool, r, params),
    ast.ExprNode.Member(recv, _name) => cross_mod_expr_safe(pool, recv, params),
    ast.ExprNode.Call(callee, _ta, args) =>
      cross_mod_expr_safe(pool, callee, params) &&
      cross_mod_expr_list_safe(pool, args, params),
    ast.ExprNode.MacroCall(callee, _ta, args) =>
      cross_mod_expr_safe(pool, callee, params) &&
      cross_mod_expr_list_safe(pool, args, params),
    ast.ExprNode.Try(a) => cross_mod_expr_safe(pool, a, params),
    ast.ExprNode.StructLit(tyex, fields) =>
      cross_mod_expr_safe(pool, tyex, params) &&
      cross_mod_struct_fields_safe(pool, fields, params),
    ast.ExprNode.Block(_b) => false,
    ast.ExprNode.TryBlock(_b) => false,
    ast.ExprNode.Match(_scrut, _arms) => false,
  };
}

fn find_param_arg_idx(params: Vec[ast.Param], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < params.len() {
    if params.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn clone_expr_list_with_args(src: ast.ExprPool, dst0: ast.ExprPool, ids: Vec[i32], params: Vec[ast.Param], args: Vec[i32]) -> CloneExprListResult {
  let mut dst: ast.ExprPool = dst0;
  let mut out: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < ids.len() {
    let cr: CloneExprResult = clone_expr_with_args(src, dst, ids.get(i), params, args);
    if !cr.ok { return CloneExprListResult { ok: false, pool: dst, ids: Vec() }; }
    dst = cr.pool;
    out.push(cr.id);
    i = i + 1;
  }
  return CloneExprListResult { ok: true, pool: dst, ids: out };
}

struct CloneExprListResult {
  ok: bool,
  pool: ast.ExprPool,
  ids: Vec[i32],
}

struct CloneStructFieldsResult {
  ok: bool,
  pool: ast.ExprPool,
  fields: Vec[ast.StructLitField],
}

fn clone_struct_fields_with_args(src: ast.ExprPool, dst0: ast.ExprPool, fields: Vec[ast.StructLitField], params: Vec[ast.Param], args: Vec[i32]) -> CloneStructFieldsResult {
  let mut dst: ast.ExprPool = dst0;
  let mut out: Vec[ast.StructLitField] = Vec();
  let mut i: i32 = 0;
  while i < fields.len() {
    let f: ast.StructLitField = fields.get(i);
    let cr: CloneExprResult = clone_expr_with_args(src, dst, f.expr, params, args);
    if !cr.ok { return CloneStructFieldsResult { ok: false, pool: dst, fields: Vec() }; }
    dst = cr.pool;
    out.push(ast.StructLitField { name: f.name, expr: cr.id });
    i = i + 1;
  }
  return CloneStructFieldsResult { ok: true, pool: dst, fields: out };
}

fn clone_expr_with_args(src: ast.ExprPool, dst0: ast.ExprPool, id: i32, params: Vec[ast.Param], args: Vec[i32]) -> CloneExprResult {
  let n: ast.ExprNode = ast.expr_pool_get(src, id);
  let sp: ast.Span = ast.expr_pool_span(src, id);

  if match n { ast.ExprNode.Int(_v) => true, _ => false } {
    let ar: ast.AddExprResult = ast.expr_pool_add(dst0, n, sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Float(_v) => true, _ => false } {
    let ar: ast.AddExprResult = ast.expr_pool_add(dst0, n, sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Bool(_v) => true, _ => false } {
    let ar: ast.AddExprResult = ast.expr_pool_add(dst0, n, sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Str(_v) => true, _ => false } {
    let ar: ast.AddExprResult = ast.expr_pool_add(dst0, n, sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.DotIdent(_v) => true, _ => false } {
    let ar: ast.AddExprResult = ast.expr_pool_add(dst0, n, sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Ident(_v) => true, _ => false } {
    let name: String = match n { ast.ExprNode.Ident(s) => s, _ => "" };
    let pi: i32 = find_param_arg_idx(params, name);
    if pi >= 0 && pi < args.len() {
      return clone_expr_ok(dst0, args.get(pi));
    }
    let ar: ast.AddExprResult = ast.expr_pool_add(dst0, n, sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let op: ast.UnaryOp = match n { ast.ExprNode.Unary(x, _a) => x, _ => ast.UnaryOp.Pos };
    let a0: i32 = match n { ast.ExprNode.Unary(_x, a) => a, _ => -1 };
    let cr: CloneExprResult = clone_expr_with_args(src, dst0, a0, params, args);
    if !cr.ok { return clone_expr_err(cr.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cr.pool, ast.ExprNode.Unary(op, cr.id), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a0: i32 = match n { ast.ExprNode.As(a, _tn) => a, _ => -1 };
    let tn: ast.TypeName = match n { ast.ExprNode.As(_a, t) => t, _ => ast.TypeName { parts: Vec(), args: Vec() } };
    let cr: CloneExprResult = clone_expr_with_args(src, dst0, a0, params, args);
    if !cr.ok { return clone_expr_err(cr.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cr.pool, ast.ExprNode.As(cr.id, tn), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let op: ast.BinaryOp = match n { ast.ExprNode.Binary(o, _l, _r) => o, _ => ast.BinaryOp.Add };
    let l0: i32 = match n { ast.ExprNode.Binary(_o, l, _r) => l, _ => -1 };
    let r0: i32 = match n { ast.ExprNode.Binary(_o, _l, r) => r, _ => -1 };
    let cl: CloneExprResult = clone_expr_with_args(src, dst0, l0, params, args);
    if !cl.ok { return clone_expr_err(cl.pool); }
    let cr: CloneExprResult = clone_expr_with_args(src, cl.pool, r0, params, args);
    if !cr.ok { return clone_expr_err(cr.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cr.pool, ast.ExprNode.Binary(op, cl.id, cr.id), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } {
    let c0: i32 = match n { ast.ExprNode.If(c, _t, _e) => c, _ => -1 };
    let t0: i32 = match n { ast.ExprNode.If(_c, t, _e) => t, _ => -1 };
    let e0: i32 = match n { ast.ExprNode.If(_c, _t, e) => e, _ => -1 };
    let cc: CloneExprResult = clone_expr_with_args(src, dst0, c0, params, args);
    if !cc.ok { return clone_expr_err(cc.pool); }
    let ct: CloneExprResult = clone_expr_with_args(src, cc.pool, t0, params, args);
    if !ct.ok { return clone_expr_err(ct.pool); }
    let ce: CloneExprResult = clone_expr_with_args(src, ct.pool, e0, params, args);
    if !ce.ok { return clone_expr_err(ce.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(ce.pool, ast.ExprNode.If(cc.id, ct.id, ce.id), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Member(_recv, _name) => true, _ => false } {
    let recv0: i32 = match n { ast.ExprNode.Member(recv, _name) => recv, _ => -1 };
    let name: String = match n { ast.ExprNode.Member(_recv, s) => s, _ => "" };
    let cr: CloneExprResult = clone_expr_with_args(src, dst0, recv0, params, args);
    if !cr.ok { return clone_expr_err(cr.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cr.pool, ast.ExprNode.Member(cr.id, name), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Call(_callee, _ta, _args) => true, _ => false } {
    let callee0: i32 = match n { ast.ExprNode.Call(callee, _ta, _args) => callee, _ => -1 };
    let ta: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_callee, targs, _args) => targs, _ => Vec() };
    let args0: Vec[i32] = match n { ast.ExprNode.Call(_callee, _ta, xs) => xs, _ => Vec() };
    let cc: CloneExprResult = clone_expr_with_args(src, dst0, callee0, params, args);
    if !cc.ok { return clone_expr_err(cc.pool); }
    let ca: CloneExprListResult = clone_expr_list_with_args(src, cc.pool, args0, params, args);
    if !ca.ok { return clone_expr_err(ca.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(ca.pool, ast.ExprNode.Call(cc.id, ta, ca.ids), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.MacroCall(_callee, _ta, _args) => true, _ => false } {
    let callee0: i32 = match n { ast.ExprNode.MacroCall(callee, _ta, _args) => callee, _ => -1 };
    let ta: Vec[ast.TypeName] = match n { ast.ExprNode.MacroCall(_callee, targs, _args) => targs, _ => Vec() };
    let args0: Vec[i32] = match n { ast.ExprNode.MacroCall(_callee, _ta, xs) => xs, _ => Vec() };
    let cc: CloneExprResult = clone_expr_with_args(src, dst0, callee0, params, args);
    if !cc.ok { return clone_expr_err(cc.pool); }
    let ca: CloneExprListResult = clone_expr_list_with_args(src, cc.pool, args0, params, args);
    if !ca.ok { return clone_expr_err(ca.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(ca.pool, ast.ExprNode.MacroCall(cc.id, ta, ca.ids), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Try(_a) => true, _ => false } {
    let a0: i32 = match n { ast.ExprNode.Try(a) => a, _ => -1 };
    let cr: CloneExprResult = clone_expr_with_args(src, dst0, a0, params, args);
    if !cr.ok { return clone_expr_err(cr.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cr.pool, ast.ExprNode.Try(cr.id), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.StructLit(_tyex, _fields) => true, _ => false } {
    let tyex0: i32 = match n { ast.ExprNode.StructLit(tyex, _fields) => tyex, _ => -1 };
    let fs0: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_tyex, fs) => fs, _ => Vec() };
    let ct: CloneExprResult = clone_expr_with_args(src, dst0, tyex0, params, args);
    if !ct.ok { return clone_expr_err(ct.pool); }
    let cf: CloneStructFieldsResult = clone_struct_fields_with_args(src, ct.pool, fs0, params, args);
    if !cf.ok { return clone_expr_err(cf.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cf.pool, ast.ExprNode.StructLit(ct.id, cf.fields), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }

  return clone_expr_err(dst0);
}

fn try_expand_local_user_macro_inline(w: tc.World, site: MacroSite) -> ExpandRoundResult {
  if site.targs.len() != 0 { return round_ok(w, false); }

  let call_mod: tc.WorldModule = w.mods.get(site.mod_idx);
  let callee_node: ast.ExprNode = ast.expr_pool_get(call_mod.prog.exprs, site.callee);

  let mut callee_mod_idx: i32 = site.mod_idx;
  let mut callee_name: String = "";

  if match callee_node { ast.ExprNode.Ident(_s) => true, _ => false } {
    callee_name = match callee_node { ast.ExprNode.Ident(s) => s, _ => "" };
  } else if match callee_node { ast.ExprNode.Member(_recv, _name) => true, _ => false } {
    let recv_id: i32 = match callee_node { ast.ExprNode.Member(recv, _name) => recv, _ => -1 };
    let name1: String = match callee_node { ast.ExprNode.Member(_recv, name) => name, _ => "" };
    let recv_node: ast.ExprNode = ast.expr_pool_get(call_mod.prog.exprs, recv_id);
    if !match recv_node { ast.ExprNode.Ident(_a) => true, _ => false } {
      return round_ok(w, false);
    }
    let alias: String = match recv_node { ast.ExprNode.Ident(a) => a, _ => "" };
    let ar: tc.ImportAliasesResult = tc.build_import_aliases(w, call_mod.prog.imports, site.sp.file);
    if !ar.ok { return round_err(w, ar.err); }
    let target_path: String = tc.find_alias(ar.aliases, alias);
    if target_path == "" { return round_ok(w, false); }
    let mi: i32 = find_world_mod_idx(w, target_path);
    if mi < 0 { return round_ok(w, false); }
    callee_mod_idx = mi;
    callee_name = name1;
  } else {
    return round_ok(w, false);
  }

  if callee_name == "" { return round_ok(w, false); }

  let callee_mod: tc.WorldModule = w.mods.get(callee_mod_idx);
  let fi: i32 = find_local_func_idx(callee_mod.prog, callee_name);
  if fi < 0 { return round_ok(w, false); }
  let fd: ast.FuncDecl = callee_mod.prog.funcs.get(fi);
  if callee_mod_idx != site.mod_idx && !fd.is_pub { return round_ok(w, false); }
  if fd.type_params.len() != 0 || fd.const_params.len() != 0 { return round_ok(w, false); }
  if fd.params.len() != site.args.len() { return round_ok(w, false); }

  let template_id: i32 = macro_template_return_expr_id(fd);
  if template_id < 0 { return round_ok(w, false); }
  if !template_expr_supported(callee_mod.prog.exprs, template_id) { return round_ok(w, false); }
  if callee_mod_idx != site.mod_idx && !cross_mod_expr_safe(callee_mod.prog.exprs, template_id, fd.params) {
    return round_ok(w, false);
  }

  let cr: CloneExprResult = clone_expr_with_args(callee_mod.prog.exprs, call_mod.prog.exprs, template_id, fd.params, site.args);
  if !cr.ok { return round_ok(w, false); }

  let repl: ast.ExprNode = ast.expr_pool_get(cr.pool, cr.id);
  let exprs2: ast.ExprPool = expr_pool_replace(cr.pool, site.expr_id, repl, site.sp);
  let prog2: ast.Program = program_with_exprs(call_mod.prog, exprs2);
  let w2: tc.World = world_replace_mod_prog(w, site.mod_idx, prog2);
  return round_ok(w2, true);
}
