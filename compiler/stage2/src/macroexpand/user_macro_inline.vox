import "ast" as ast
import "typecheck" as tc

struct CloneExprResult {
  ok: bool,
  pool: ast.ExprPool,
  id: i32,
}

struct MacroTemplateExprResult {
  ok: bool,
  pool: ast.ExprPool,
  id: i32,
}

fn clone_expr_ok(pool: ast.ExprPool, id: i32) -> CloneExprResult {
  return CloneExprResult { ok: true, pool: pool, id: id };
}

fn clone_expr_err(pool: ast.ExprPool) -> CloneExprResult {
  return CloneExprResult { ok: false, pool: pool, id: -1 };
}

fn macro_template_expr_ok(pool: ast.ExprPool, id: i32) -> MacroTemplateExprResult {
  return MacroTemplateExprResult { ok: true, pool: pool, id: id };
}

fn macro_template_expr_err(pool: ast.ExprPool) -> MacroTemplateExprResult {
  return MacroTemplateExprResult { ok: false, pool: pool, id: -1 };
}

fn find_local_func_idx(prog: ast.Program, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < prog.funcs.len() {
    if prog.funcs.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_world_mod_idx(w: tc.World, path: String) -> i32 {
  let mut i: i32 = 0;
  while i < w.mods.len() {
    if w.mods.get(i).path == path { return i; }
    i = i + 1;
  }
  return -1;
}

fn block_contains_return(b: ast.Block) -> bool {
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    if stmt_contains_return(b.stmts.get(i)) { return true; }
    i = i + 1;
  }
  return false;
}

fn stmt_contains_return(st: ast.Stmt) -> bool {
  return
    match st {
      ast.Stmt.IfStmt(_sp, _cond, then_b, has_else, else_b) =>
        block_contains_return(then_b) || (has_else && block_contains_return(else_b)),
      ast.Stmt.WhileStmt(_sp, _cond, body) =>
        block_contains_return(body),
      ast.Stmt.ReturnStmt(_sp, _has_ex, _ex) => true,
      _ => false,
    };
}

fn macro_template_expr(pool0: ast.ExprPool, fd: ast.FuncDecl) -> MacroTemplateExprResult {
  if fd.body.stmts.len() == 0 { return macro_template_expr_err(pool0); }
  let last_idx: i32 = fd.body.stmts.len() - 1;
  let last_st: ast.Stmt = fd.body.stmts.get(last_idx);
  let has_tail: bool = match last_st { ast.Stmt.ReturnStmt(_sp, has_ex, _ex) => has_ex, _ => false };
  if !has_tail { return macro_template_expr_err(pool0); }
  let tail: i32 = match last_st { ast.Stmt.ReturnStmt(_sp, _has_ex, ex) => ex, _ => -1 };
  if last_idx == 0 { return macro_template_expr_ok(pool0, tail); }

  let mut prefix: Vec[ast.Stmt] = Vec();
  let mut i: i32 = 0;
  while i < last_idx {
    let st: ast.Stmt = fd.body.stmts.get(i);
    if stmt_contains_return(st) { return macro_template_expr_err(pool0); }
    prefix.push(st);
    i = i + 1;
  }

  let sp: ast.Span = match last_st { ast.Stmt.ReturnStmt(s, _has_ex, _ex) => s, _ => fd.sp };
  let ar: ast.AddExprResult = ast.expr_pool_add(
    pool0,
    ast.ExprNode.Block(ast.ExprBlock { stmts: prefix, has_tail: true, tail: tail }),
    sp);
  return macro_template_expr_ok(ar.pool, ar.id);
}

fn template_expr_list_supported(pool: ast.ExprPool, ids: Vec[i32]) -> bool {
  let mut i: i32 = 0;
  while i < ids.len() {
    if !template_expr_supported(pool, ids.get(i)) { return false; }
    i = i + 1;
  }
  return true;
}

fn template_stmt_supported(pool: ast.ExprPool, st: ast.Stmt) -> bool {
  return
    match st {
      ast.Stmt.Let(_sp, _mut, _name, _has_ann, _ann, init) =>
        template_expr_supported(pool, init),
      ast.Stmt.Assign(_sp, _name, ex) =>
        template_expr_supported(pool, ex),
      ast.Stmt.AssignField(_sp, _recv, _field, ex) =>
        template_expr_supported(pool, ex),
      ast.Stmt.ExprStmt(_sp, ex) =>
        template_expr_supported(pool, ex),
      ast.Stmt.IfStmt(_sp, cond, then_b, has_else, else_b) =>
        template_expr_supported(pool, cond) &&
        template_block_supported(pool, then_b) &&
        (!has_else || template_block_supported(pool, else_b)),
      ast.Stmt.WhileStmt(_sp, cond, body) =>
        template_expr_supported(pool, cond) &&
        template_block_supported(pool, body),
      ast.Stmt.Break(_sp) => true,
      ast.Stmt.Continue(_sp) => true,
      ast.Stmt.ReturnStmt(_sp, has_ex, ex) =>
        !has_ex || template_expr_supported(pool, ex),
    };
}

fn template_block_supported(pool: ast.ExprPool, b: ast.Block) -> bool {
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    if !template_stmt_supported(pool, b.stmts.get(i)) { return false; }
    i = i + 1;
  }
  return true;
}

fn template_expr_block_supported(pool: ast.ExprPool, b: ast.ExprBlock) -> bool {
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    if !template_stmt_supported(pool, b.stmts.get(i)) { return false; }
    i = i + 1;
  }
  if b.has_tail {
    return template_expr_supported(pool, b.tail);
  }
  return true;
}

fn template_match_arms_supported(pool: ast.ExprPool, arms: Vec[ast.MatchArm]) -> bool {
  let mut i: i32 = 0;
  while i < arms.len() {
    if !template_expr_supported(pool, arms.get(i).expr) { return false; }
    i = i + 1;
  }
  return true;
}

fn template_struct_fields_supported(pool: ast.ExprPool, fields: Vec[ast.StructLitField]) -> bool {
  let mut i: i32 = 0;
  while i < fields.len() {
    if !template_expr_supported(pool, fields.get(i).expr) { return false; }
    i = i + 1;
  }
  return true;
}

fn expr_node_kind_name(n: ast.ExprNode) -> String {
  return match n {
    ast.ExprNode.Int(_v) => "Int",
    ast.ExprNode.Float(_v) => "Float",
    ast.ExprNode.Bool(_v) => "Bool",
    ast.ExprNode.Ident(_s) => "Ident",
    ast.ExprNode.Str(_s) => "Str",
    ast.ExprNode.DotIdent(_s) => "DotIdent",
    ast.ExprNode.If(_c, _t, _e) => "If",
    ast.ExprNode.Unary(_op, _a) => "Unary",
    ast.ExprNode.As(_a, _tn) => "As",
    ast.ExprNode.Binary(_op, _l, _r) => "Binary",
    ast.ExprNode.Member(_recv, _name) => "Member",
    ast.ExprNode.Call(_callee, _ta, _args) => "Call",
    ast.ExprNode.MacroCall(_callee, _ta, _args) => "MacroCall",
    ast.ExprNode.Try(_a) => "Try",
    ast.ExprNode.StructLit(_tyex, _fields) => "StructLit",
    ast.ExprNode.Block(_b) => "Block",
    ast.ExprNode.TryBlock(_b) => "TryBlock",
    ast.ExprNode.Match(_scrut, _arms) => "Match",
  };
}

fn template_root_kind(pool: ast.ExprPool, id: i32) -> String {
  return expr_node_kind_name(ast.expr_pool_get(pool, id));
}

fn template_expr_supported(pool: ast.ExprPool, id: i32) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(pool, id);
  return match n {
    ast.ExprNode.Int(_v) => true,
    ast.ExprNode.Float(_v) => true,
    ast.ExprNode.Bool(_v) => true,
    ast.ExprNode.Ident(_s) => true,
    ast.ExprNode.Str(_s) => true,
    ast.ExprNode.DotIdent(_s) => true,
    ast.ExprNode.If(c0, t0, e0) => template_expr_supported(pool, c0) && template_expr_supported(pool, t0) && template_expr_supported(pool, e0),
    ast.ExprNode.Unary(_op, a) => template_expr_supported(pool, a),
    ast.ExprNode.As(a, _tn) => template_expr_supported(pool, a),
    ast.ExprNode.Binary(_op, l, r) => template_expr_supported(pool, l) && template_expr_supported(pool, r),
    ast.ExprNode.Member(recv, _name) => template_expr_supported(pool, recv),
    ast.ExprNode.Call(callee, _ta, args) => template_expr_supported(pool, callee) && template_expr_list_supported(pool, args),
    ast.ExprNode.MacroCall(callee, _ta, args) => template_expr_supported(pool, callee) && template_expr_list_supported(pool, args),
    ast.ExprNode.Try(a) => template_expr_supported(pool, a),
    ast.ExprNode.StructLit(tyex, fields) => template_expr_supported(pool, tyex) && template_struct_fields_supported(pool, fields),
    ast.ExprNode.Block(b) => template_expr_block_supported(pool, b),
    ast.ExprNode.TryBlock(b) => template_expr_supported(pool, b),
    ast.ExprNode.Match(scrut, arms) =>
      template_expr_supported(pool, scrut) &&
      template_match_arms_supported(pool, arms),
  };
}

fn param_exists(params: Vec[ast.Param], name: String) -> bool {
  return find_param_arg_idx(params, name) >= 0;
}

fn name_in_scope(scope: Vec[String], name: String) -> bool {
  let mut i: i32 = 0;
  while i < scope.len() {
    if scope.get(i) == name { return true; }
    i = i + 1;
  }
  return false;
}

fn scope_with_name(scope0: Vec[String], name: String) -> Vec[String] {
  if name_in_scope(scope0, name) { return scope0; }
  let mut scope: Vec[String] = scope0;
  scope.push(name);
  return scope;
}

fn scope_from_params(params: Vec[ast.Param]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < params.len() {
    out = scope_with_name(out, params.get(i).name);
    i = i + 1;
  }
  return out;
}

fn cross_mod_expr_list_safe(pool: ast.ExprPool, ids: Vec[i32], scope: Vec[String]) -> bool {
  let mut i: i32 = 0;
  while i < ids.len() {
    if !cross_mod_expr_safe_with_scope(pool, ids.get(i), scope) { return false; }
    i = i + 1;
  }
  return true;
}

fn cross_mod_block_safe(pool: ast.ExprPool, b: ast.Block, scope0: Vec[String]) -> bool {
  let mut scope: Vec[String] = scope0;
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let st: ast.Stmt = b.stmts.get(i);
    if match st { ast.Stmt.Let(_sp, _mut, _name, _has_ann, _ann, _init) => true, _ => false } {
      let name: String = match st { ast.Stmt.Let(_sp, _mut, n, _ha, _ann, _init) => n, _ => "" };
      let init: i32 = match st { ast.Stmt.Let(_sp, _mut, _n, _ha, _ann, ex) => ex, _ => -1 };
      if !cross_mod_expr_safe_with_scope(pool, init, scope) { return false; }
      scope = scope_with_name(scope, name);
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.Assign(_sp, _name, _ex) => true, _ => false } {
      let name: String = match st { ast.Stmt.Assign(_sp, n, _ex) => n, _ => "" };
      let ex: i32 = match st { ast.Stmt.Assign(_sp, _n, ex0) => ex0, _ => -1 };
      if !name_in_scope(scope, name) { return false; }
      if !cross_mod_expr_safe_with_scope(pool, ex, scope) { return false; }
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.AssignField(_sp, _recv, _field, _ex) => true, _ => false } {
      let recv: String = match st { ast.Stmt.AssignField(_sp, r, _f, _ex) => r, _ => "" };
      let ex: i32 = match st { ast.Stmt.AssignField(_sp, _r, _f, ex0) => ex0, _ => -1 };
      if !name_in_scope(scope, recv) { return false; }
      if !cross_mod_expr_safe_with_scope(pool, ex, scope) { return false; }
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.ExprStmt(_sp, _ex) => true, _ => false } {
      let ex: i32 = match st { ast.Stmt.ExprStmt(_sp, ex0) => ex0, _ => -1 };
      if !cross_mod_expr_safe_with_scope(pool, ex, scope) { return false; }
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.IfStmt(_sp, _cond, _then_b, _has_else, _else_b) => true, _ => false } {
      let cond: i32 = match st { ast.Stmt.IfStmt(_sp, c, _t, _he, _e) => c, _ => -1 };
      let then_b: ast.Block = match st { ast.Stmt.IfStmt(_sp, _c, t, _he, _e) => t, _ => ast.Block { stmts: Vec() } };
      let has_else: bool = match st { ast.Stmt.IfStmt(_sp, _c, _t, he, _e) => he, _ => false };
      let else_b: ast.Block = match st { ast.Stmt.IfStmt(_sp, _c, _t, _he, e) => e, _ => ast.Block { stmts: Vec() } };
      if !cross_mod_expr_safe_with_scope(pool, cond, scope) { return false; }
      if !cross_mod_block_safe(pool, then_b, scope) { return false; }
      if has_else && !cross_mod_block_safe(pool, else_b, scope) { return false; }
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.WhileStmt(_sp, _cond, _body) => true, _ => false } {
      let cond: i32 = match st { ast.Stmt.WhileStmt(_sp, c, _b) => c, _ => -1 };
      let body: ast.Block = match st { ast.Stmt.WhileStmt(_sp, _c, b0) => b0, _ => ast.Block { stmts: Vec() } };
      if !cross_mod_expr_safe_with_scope(pool, cond, scope) { return false; }
      if !cross_mod_block_safe(pool, body, scope) { return false; }
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.ReturnStmt(_sp, _has_ex, _ex) => true, _ => false } {
      let has_ex: bool = match st { ast.Stmt.ReturnStmt(_sp, he, _ex) => he, _ => false };
      if has_ex {
        let ex: i32 = match st { ast.Stmt.ReturnStmt(_sp, _he, ex0) => ex0, _ => -1 };
        if !cross_mod_expr_safe_with_scope(pool, ex, scope) { return false; }
      }
      i = i + 1;
      continue;
    }
    // break/continue
    i = i + 1;
  }
  return true;
}

fn cross_mod_expr_block_safe(pool: ast.ExprPool, b: ast.ExprBlock, scope0: Vec[String]) -> bool {
  let mut scope: Vec[String] = scope0;
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let st: ast.Stmt = b.stmts.get(i);
    if match st { ast.Stmt.Let(_sp, _mut, _name, _has_ann, _ann, _init) => true, _ => false } {
      let name: String = match st { ast.Stmt.Let(_sp, _mut, n, _ha, _ann, _init) => n, _ => "" };
      let init: i32 = match st { ast.Stmt.Let(_sp, _mut, _n, _ha, _ann, ex) => ex, _ => -1 };
      if !cross_mod_expr_safe_with_scope(pool, init, scope) { return false; }
      scope = scope_with_name(scope, name);
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.Assign(_sp, _name, _ex) => true, _ => false } {
      let name: String = match st { ast.Stmt.Assign(_sp, n, _ex) => n, _ => "" };
      let ex: i32 = match st { ast.Stmt.Assign(_sp, _n, ex0) => ex0, _ => -1 };
      if !name_in_scope(scope, name) { return false; }
      if !cross_mod_expr_safe_with_scope(pool, ex, scope) { return false; }
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.AssignField(_sp, _recv, _field, _ex) => true, _ => false } {
      let recv: String = match st { ast.Stmt.AssignField(_sp, r, _f, _ex) => r, _ => "" };
      let ex: i32 = match st { ast.Stmt.AssignField(_sp, _r, _f, ex0) => ex0, _ => -1 };
      if !name_in_scope(scope, recv) { return false; }
      if !cross_mod_expr_safe_with_scope(pool, ex, scope) { return false; }
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.ExprStmt(_sp, _ex) => true, _ => false } {
      let ex: i32 = match st { ast.Stmt.ExprStmt(_sp, ex0) => ex0, _ => -1 };
      if !cross_mod_expr_safe_with_scope(pool, ex, scope) { return false; }
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.IfStmt(_sp, _cond, _then_b, _has_else, _else_b) => true, _ => false } {
      let cond: i32 = match st { ast.Stmt.IfStmt(_sp, c, _t, _he, _e) => c, _ => -1 };
      let then_b: ast.Block = match st { ast.Stmt.IfStmt(_sp, _c, t, _he, _e) => t, _ => ast.Block { stmts: Vec() } };
      let has_else: bool = match st { ast.Stmt.IfStmt(_sp, _c, _t, he, _e) => he, _ => false };
      let else_b: ast.Block = match st { ast.Stmt.IfStmt(_sp, _c, _t, _he, e) => e, _ => ast.Block { stmts: Vec() } };
      if !cross_mod_expr_safe_with_scope(pool, cond, scope) { return false; }
      if !cross_mod_block_safe(pool, then_b, scope) { return false; }
      if has_else && !cross_mod_block_safe(pool, else_b, scope) { return false; }
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.WhileStmt(_sp, _cond, _body) => true, _ => false } {
      let cond: i32 = match st { ast.Stmt.WhileStmt(_sp, c, _b) => c, _ => -1 };
      let body: ast.Block = match st { ast.Stmt.WhileStmt(_sp, _c, b0) => b0, _ => ast.Block { stmts: Vec() } };
      if !cross_mod_expr_safe_with_scope(pool, cond, scope) { return false; }
      if !cross_mod_block_safe(pool, body, scope) { return false; }
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.ReturnStmt(_sp, _has_ex, _ex) => true, _ => false } {
      let has_ex: bool = match st { ast.Stmt.ReturnStmt(_sp, he, _ex) => he, _ => false };
      if has_ex {
        let ex: i32 = match st { ast.Stmt.ReturnStmt(_sp, _he, ex0) => ex0, _ => -1 };
        if !cross_mod_expr_safe_with_scope(pool, ex, scope) { return false; }
      }
      i = i + 1;
      continue;
    }
    // break/continue
    i = i + 1;
  }
  if b.has_tail {
    return cross_mod_expr_safe_with_scope(pool, b.tail, scope);
  }
  return true;
}

fn cross_mod_match_arms_safe(pool: ast.ExprPool, arms: Vec[ast.MatchArm], scope: Vec[String]) -> bool {
  let mut i: i32 = 0;
  while i < arms.len() {
    if !cross_mod_expr_safe_with_scope(pool, arms.get(i).expr, scope) { return false; }
    i = i + 1;
  }
  return true;
}

fn cross_mod_struct_fields_safe(pool: ast.ExprPool, fields: Vec[ast.StructLitField], scope: Vec[String]) -> bool {
  let mut i: i32 = 0;
  while i < fields.len() {
    if !cross_mod_expr_safe_with_scope(pool, fields.get(i).expr, scope) { return false; }
    i = i + 1;
  }
  return true;
}

fn cross_mod_expr_safe_with_scope(pool: ast.ExprPool, id: i32, scope: Vec[String]) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(pool, id);
  return match n {
    ast.ExprNode.Int(_v) => true,
    ast.ExprNode.Float(_v) => true,
    ast.ExprNode.Bool(_v) => true,
    ast.ExprNode.Str(_s) => true,
    ast.ExprNode.Ident(s) => name_in_scope(scope, s),
    ast.ExprNode.DotIdent(_s) => false,
    ast.ExprNode.If(c0, t0, e0) =>
      cross_mod_expr_safe_with_scope(pool, c0, scope) &&
      cross_mod_expr_safe_with_scope(pool, t0, scope) &&
      cross_mod_expr_safe_with_scope(pool, e0, scope),
    ast.ExprNode.Unary(_op, a) => cross_mod_expr_safe_with_scope(pool, a, scope),
    ast.ExprNode.As(_a, _tn) => false,
    ast.ExprNode.Binary(_op, l, r) => cross_mod_expr_safe_with_scope(pool, l, scope) && cross_mod_expr_safe_with_scope(pool, r, scope),
    ast.ExprNode.Member(recv, _name) => cross_mod_expr_safe_with_scope(pool, recv, scope),
    ast.ExprNode.Call(callee, _ta, args) =>
      cross_mod_expr_safe_with_scope(pool, callee, scope) &&
      cross_mod_expr_list_safe(pool, args, scope),
    ast.ExprNode.MacroCall(callee, _ta, args) =>
      cross_mod_expr_safe_with_scope(pool, callee, scope) &&
      cross_mod_expr_list_safe(pool, args, scope),
    ast.ExprNode.Try(a) => cross_mod_expr_safe_with_scope(pool, a, scope),
    ast.ExprNode.StructLit(tyex, fields) =>
      cross_mod_expr_safe_with_scope(pool, tyex, scope) &&
      cross_mod_struct_fields_safe(pool, fields, scope),
    ast.ExprNode.Block(b) =>
      cross_mod_expr_block_safe(pool, b, scope),
    ast.ExprNode.TryBlock(b) =>
      cross_mod_expr_safe_with_scope(pool, b, scope),
    ast.ExprNode.Match(scrut, arms) =>
      cross_mod_expr_safe_with_scope(pool, scrut, scope) &&
      cross_mod_match_arms_safe(pool, arms, scope),
  };
}

fn cross_mod_expr_safe(pool: ast.ExprPool, id: i32, params: Vec[ast.Param]) -> bool {
  return cross_mod_expr_safe_with_scope(pool, id, scope_from_params(params));
}

fn find_param_arg_idx(params: Vec[ast.Param], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < params.len() {
    if params.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

struct TypeArgSub {
  name: String,
  ty: ast.TypeName,
}

struct ConstArgSub {
  name: String,
  text: String,
}

fn find_type_sub_idx(subs: Vec[TypeArgSub], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < subs.len() {
    if subs.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_const_sub_idx(subs: Vec[ConstArgSub], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < subs.len() {
    if subs.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn const_arg_tn(text: String) -> ast.TypeName {
  let mut parts: Vec[String] = Vec();
  parts.push("@const");
  parts.push(text);
  return ast.TypeName { parts: parts, args: Vec() };
}

fn is_const_arg_tn(tn: ast.TypeName) -> bool {
  return tn.parts.len() == 2 && tn.parts.get(0) == "@const" && tn.args.len() == 0;
}

fn const_arg_text(tn: ast.TypeName) -> String {
  if !is_const_arg_tn(tn) { return ""; }
  return tn.parts.get(1);
}

fn substitute_type_name(tn0: ast.TypeName, ty_subs: Vec[TypeArgSub], const_subs: Vec[ConstArgSub]) -> ast.TypeName {
  if tn0.args.len() == 0 && tn0.parts.len() == 1 {
    let name: String = tn0.parts.get(0);
    let ti: i32 = find_type_sub_idx(ty_subs, name);
    if ti >= 0 { return ty_subs.get(ti).ty; }
    let ci: i32 = find_const_sub_idx(const_subs, name);
    if ci >= 0 { return const_arg_tn(const_subs.get(ci).text); }
  }
  let mut args: Vec[ast.TypeName] = Vec();
  let mut i: i32 = 0;
  while i < tn0.args.len() {
    args.push(substitute_type_name(tn0.args.get(i), ty_subs, const_subs));
    i = i + 1;
  }
  return ast.TypeName { parts: tn0.parts, args: args };
}

fn substitute_type_name_list(ts: Vec[ast.TypeName], ty_subs: Vec[TypeArgSub], const_subs: Vec[ConstArgSub]) -> Vec[ast.TypeName] {
  let mut out: Vec[ast.TypeName] = Vec();
  let mut i: i32 = 0;
  while i < ts.len() {
    out.push(substitute_type_name(ts.get(i), ty_subs, const_subs));
    i = i + 1;
  }
  return out;
}

fn clone_expr_list_with_args(
  src: ast.ExprPool,
  dst0: ast.ExprPool,
  ids: Vec[i32],
  params: Vec[ast.Param],
  args: Vec[i32],
  ty_subs: Vec[TypeArgSub],
  const_subs: Vec[ConstArgSub]
) -> CloneExprListResult {
  let mut dst: ast.ExprPool = dst0;
  let mut out: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < ids.len() {
    let cr: CloneExprResult = clone_expr_with_args(src, dst, ids.get(i), params, args, ty_subs, const_subs);
    if !cr.ok { return CloneExprListResult { ok: false, pool: dst, ids: Vec() }; }
    dst = cr.pool;
    out.push(cr.id);
    i = i + 1;
  }
  return CloneExprListResult { ok: true, pool: dst, ids: out };
}

struct CloneExprListResult {
  ok: bool,
  pool: ast.ExprPool,
  ids: Vec[i32],
}

struct CloneMatchArmsResult {
  ok: bool,
  pool: ast.ExprPool,
  arms: Vec[ast.MatchArm],
}

fn clone_match_arms_with_args(
  src: ast.ExprPool,
  dst0: ast.ExprPool,
  arms0: Vec[ast.MatchArm],
  params: Vec[ast.Param],
  args: Vec[i32],
  ty_subs: Vec[TypeArgSub],
  const_subs: Vec[ConstArgSub]
) -> CloneMatchArmsResult {
  let mut dst: ast.ExprPool = dst0;
  let mut out: Vec[ast.MatchArm] = Vec();
  let mut i: i32 = 0;
  while i < arms0.len() {
    let a: ast.MatchArm = arms0.get(i);
    let cr: CloneExprResult = clone_expr_with_args(src, dst, a.expr, params, args, ty_subs, const_subs);
    if !cr.ok { return CloneMatchArmsResult { ok: false, pool: cr.pool, arms: Vec() }; }
    dst = cr.pool;
    out.push(ast.MatchArm { pat: a.pat, expr: cr.id });
    i = i + 1;
  }
  return CloneMatchArmsResult { ok: true, pool: dst, arms: out };
}

fn clone_stmt_list_with_args(
  src: ast.ExprPool,
  dst0: ast.ExprPool,
  sts: Vec[ast.Stmt],
  params: Vec[ast.Param],
  args: Vec[i32],
  ty_subs: Vec[TypeArgSub],
  const_subs: Vec[ConstArgSub]
) -> CloneStmtListResult {
  let mut dst: ast.ExprPool = dst0;
  let mut out: Vec[ast.Stmt] = Vec();
  let mut i: i32 = 0;
  while i < sts.len() {
    let cr: CloneStmtResult = clone_stmt_with_args(
      src,
      dst,
      sts.get(i),
      params,
      args,
      ty_subs,
      const_subs);
    if !cr.ok { return CloneStmtListResult { ok: false, pool: dst, sts: Vec() }; }
    dst = cr.pool;
    out.push(cr.st);
    i = i + 1;
  }
  return CloneStmtListResult { ok: true, pool: dst, sts: out };
}

struct CloneStmtResult {
  ok: bool,
  pool: ast.ExprPool,
  st: ast.Stmt,
}

struct CloneStmtListResult {
  ok: bool,
  pool: ast.ExprPool,
  sts: Vec[ast.Stmt],
}

fn clone_block_with_args(
  src: ast.ExprPool,
  dst0: ast.ExprPool,
  b: ast.Block,
  params: Vec[ast.Param],
  args: Vec[i32],
  ty_subs: Vec[TypeArgSub],
  const_subs: Vec[ConstArgSub]
) -> CloneBlockResult {
  let cs: CloneStmtListResult = clone_stmt_list_with_args(src, dst0, b.stmts, params, args, ty_subs, const_subs);
  if !cs.ok { return CloneBlockResult { ok: false, pool: cs.pool, b: ast.Block { stmts: Vec() } }; }
  return CloneBlockResult { ok: true, pool: cs.pool, b: ast.Block { stmts: cs.sts } };
}

struct CloneBlockResult {
  ok: bool,
  pool: ast.ExprPool,
  b: ast.Block,
}

fn clone_expr_block_with_args(
  src: ast.ExprPool,
  dst0: ast.ExprPool,
  b: ast.ExprBlock,
  params: Vec[ast.Param],
  args: Vec[i32],
  ty_subs: Vec[TypeArgSub],
  const_subs: Vec[ConstArgSub]
) -> CloneExprBlockResult {
  let cs: CloneStmtListResult = clone_stmt_list_with_args(src, dst0, b.stmts, params, args, ty_subs, const_subs);
  if !cs.ok {
    return CloneExprBlockResult {
      ok: false,
      pool: cs.pool,
      b: ast.ExprBlock { stmts: Vec(), has_tail: false, tail: -1 },
    };
  }
  let mut dst: ast.ExprPool = cs.pool;
  let mut tail: i32 = -1;
  if b.has_tail {
    let ct: CloneExprResult = clone_expr_with_args(src, dst, b.tail, params, args, ty_subs, const_subs);
    if !ct.ok {
      return CloneExprBlockResult {
        ok: false,
        pool: ct.pool,
        b: ast.ExprBlock { stmts: Vec(), has_tail: false, tail: -1 },
      };
    }
    dst = ct.pool;
    tail = ct.id;
  }
  return CloneExprBlockResult {
    ok: true,
    pool: dst,
    b: ast.ExprBlock { stmts: cs.sts, has_tail: b.has_tail, tail: tail },
  };
}

struct CloneExprBlockResult {
  ok: bool,
  pool: ast.ExprPool,
  b: ast.ExprBlock,
}

fn clone_stmt_with_args(
  src: ast.ExprPool,
  dst0: ast.ExprPool,
  st: ast.Stmt,
  params: Vec[ast.Param],
  args: Vec[i32],
  ty_subs: Vec[TypeArgSub],
  const_subs: Vec[ConstArgSub]
) -> CloneStmtResult {
  return
    match st {
      ast.Stmt.Let(sp, mut0, name, has_ann, ann, init) => {
        let cr: CloneExprResult = clone_expr_with_args(src, dst0, init, params, args, ty_subs, const_subs);
        if !cr.ok { CloneStmtResult { ok: false, pool: cr.pool, st: ast.Stmt.Break(sp) } } else {
          CloneStmtResult {
            ok: true,
            pool: cr.pool,
            st: ast.Stmt.Let(sp, mut0, name, has_ann, substitute_type_name(ann, ty_subs, const_subs), cr.id),
          }
        }
      },
      ast.Stmt.Assign(sp, name, ex) => {
        let cr: CloneExprResult = clone_expr_with_args(src, dst0, ex, params, args, ty_subs, const_subs);
        if !cr.ok { CloneStmtResult { ok: false, pool: cr.pool, st: ast.Stmt.Break(sp) } } else {
          CloneStmtResult { ok: true, pool: cr.pool, st: ast.Stmt.Assign(sp, name, cr.id) }
        }
      },
      ast.Stmt.AssignField(sp, recv, field, ex) => {
        let cr: CloneExprResult = clone_expr_with_args(src, dst0, ex, params, args, ty_subs, const_subs);
        if !cr.ok { CloneStmtResult { ok: false, pool: cr.pool, st: ast.Stmt.Break(sp) } } else {
          CloneStmtResult { ok: true, pool: cr.pool, st: ast.Stmt.AssignField(sp, recv, field, cr.id) }
        }
      },
      ast.Stmt.ExprStmt(sp, ex) => {
        let cr: CloneExprResult = clone_expr_with_args(src, dst0, ex, params, args, ty_subs, const_subs);
        if !cr.ok { CloneStmtResult { ok: false, pool: cr.pool, st: ast.Stmt.Break(sp) } } else {
          CloneStmtResult { ok: true, pool: cr.pool, st: ast.Stmt.ExprStmt(sp, cr.id) }
        }
      },
      ast.Stmt.IfStmt(sp, cond, then_b, has_else, else_b) => {
        let cc: CloneExprResult = clone_expr_with_args(src, dst0, cond, params, args, ty_subs, const_subs);
        if !cc.ok { CloneStmtResult { ok: false, pool: cc.pool, st: ast.Stmt.Break(sp) } } else {
          let cthen: CloneBlockResult = clone_block_with_args(src, cc.pool, then_b, params, args, ty_subs, const_subs);
          if !cthen.ok { CloneStmtResult { ok: false, pool: cthen.pool, st: ast.Stmt.Break(sp) } } else {
            let mut pool2: ast.ExprPool = cthen.pool;
            let mut else2: ast.Block = ast.Block { stmts: Vec() };
            if has_else {
              let celse: CloneBlockResult = clone_block_with_args(src, pool2, else_b, params, args, ty_subs, const_subs);
              if !celse.ok { return CloneStmtResult { ok: false, pool: celse.pool, st: ast.Stmt.Break(sp) }; }
              pool2 = celse.pool;
              else2 = celse.b;
            }
            CloneStmtResult {
              ok: true,
              pool: pool2,
              st: ast.Stmt.IfStmt(sp, cc.id, cthen.b, has_else, else2),
            }
          }
        }
      },
      ast.Stmt.WhileStmt(sp, cond, body) => {
        let cc: CloneExprResult = clone_expr_with_args(src, dst0, cond, params, args, ty_subs, const_subs);
        if !cc.ok { CloneStmtResult { ok: false, pool: cc.pool, st: ast.Stmt.Break(sp) } } else {
          let cb: CloneBlockResult = clone_block_with_args(src, cc.pool, body, params, args, ty_subs, const_subs);
          if !cb.ok { CloneStmtResult { ok: false, pool: cb.pool, st: ast.Stmt.Break(sp) } } else {
            CloneStmtResult { ok: true, pool: cb.pool, st: ast.Stmt.WhileStmt(sp, cc.id, cb.b) }
          }
        }
      },
      ast.Stmt.Break(sp) => CloneStmtResult { ok: true, pool: dst0, st: ast.Stmt.Break(sp) },
      ast.Stmt.Continue(sp) => CloneStmtResult { ok: true, pool: dst0, st: ast.Stmt.Continue(sp) },
      ast.Stmt.ReturnStmt(sp, has_ex, ex) => {
        if !has_ex {
          CloneStmtResult { ok: true, pool: dst0, st: ast.Stmt.ReturnStmt(sp, false, ex) }
        } else {
          let cr: CloneExprResult = clone_expr_with_args(src, dst0, ex, params, args, ty_subs, const_subs);
          if !cr.ok { CloneStmtResult { ok: false, pool: cr.pool, st: ast.Stmt.Break(sp) } } else {
            CloneStmtResult { ok: true, pool: cr.pool, st: ast.Stmt.ReturnStmt(sp, true, cr.id) }
          }
        }
      },
    };
}

struct CloneStructFieldsResult {
  ok: bool,
  pool: ast.ExprPool,
  fields: Vec[ast.StructLitField],
}

fn clone_struct_fields_with_args(
  src: ast.ExprPool,
  dst0: ast.ExprPool,
  fields: Vec[ast.StructLitField],
  params: Vec[ast.Param],
  args: Vec[i32],
  ty_subs: Vec[TypeArgSub],
  const_subs: Vec[ConstArgSub]
) -> CloneStructFieldsResult {
  let mut dst: ast.ExprPool = dst0;
  let mut out: Vec[ast.StructLitField] = Vec();
  let mut i: i32 = 0;
  while i < fields.len() {
    let f: ast.StructLitField = fields.get(i);
    let cr: CloneExprResult = clone_expr_with_args(src, dst, f.expr, params, args, ty_subs, const_subs);
    if !cr.ok { return CloneStructFieldsResult { ok: false, pool: dst, fields: Vec() }; }
    dst = cr.pool;
    out.push(ast.StructLitField { name: f.name, expr: cr.id });
    i = i + 1;
  }
  return CloneStructFieldsResult { ok: true, pool: dst, fields: out };
}

fn clone_expr_with_args(
  src: ast.ExprPool,
  dst0: ast.ExprPool,
  id: i32,
  params: Vec[ast.Param],
  args: Vec[i32],
  ty_subs: Vec[TypeArgSub],
  const_subs: Vec[ConstArgSub]
) -> CloneExprResult {
  let n: ast.ExprNode = ast.expr_pool_get(src, id);
  let sp: ast.Span = ast.expr_pool_span(src, id);

  if match n { ast.ExprNode.Int(_v) => true, _ => false } {
    let ar: ast.AddExprResult = ast.expr_pool_add(dst0, n, sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Float(_v) => true, _ => false } {
    let ar: ast.AddExprResult = ast.expr_pool_add(dst0, n, sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Bool(_v) => true, _ => false } {
    let ar: ast.AddExprResult = ast.expr_pool_add(dst0, n, sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Str(_v) => true, _ => false } {
    let ar: ast.AddExprResult = ast.expr_pool_add(dst0, n, sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.DotIdent(_v) => true, _ => false } {
    let ar: ast.AddExprResult = ast.expr_pool_add(dst0, n, sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Ident(_v) => true, _ => false } {
    let name: String = match n { ast.ExprNode.Ident(s) => s, _ => "" };
    let pi: i32 = find_param_arg_idx(params, name);
    if pi >= 0 && pi < args.len() {
      return clone_expr_ok(dst0, args.get(pi));
    }
    let ar: ast.AddExprResult = ast.expr_pool_add(dst0, n, sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let op: ast.UnaryOp = match n { ast.ExprNode.Unary(x, _a) => x, _ => ast.UnaryOp.Pos };
    let a0: i32 = match n { ast.ExprNode.Unary(_x, a) => a, _ => -1 };
    let cr: CloneExprResult = clone_expr_with_args(src, dst0, a0, params, args, ty_subs, const_subs);
    if !cr.ok { return clone_expr_err(cr.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cr.pool, ast.ExprNode.Unary(op, cr.id), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a0: i32 = match n { ast.ExprNode.As(a, _tn) => a, _ => -1 };
    let tn: ast.TypeName = match n { ast.ExprNode.As(_a, t) => t, _ => ast.TypeName { parts: Vec(), args: Vec() } };
    let cr: CloneExprResult = clone_expr_with_args(src, dst0, a0, params, args, ty_subs, const_subs);
    if !cr.ok { return clone_expr_err(cr.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cr.pool, ast.ExprNode.As(cr.id, substitute_type_name(tn, ty_subs, const_subs)), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let op: ast.BinaryOp = match n { ast.ExprNode.Binary(o, _l, _r) => o, _ => ast.BinaryOp.Add };
    let l0: i32 = match n { ast.ExprNode.Binary(_o, l, _r) => l, _ => -1 };
    let r0: i32 = match n { ast.ExprNode.Binary(_o, _l, r) => r, _ => -1 };
    let cl: CloneExprResult = clone_expr_with_args(src, dst0, l0, params, args, ty_subs, const_subs);
    if !cl.ok { return clone_expr_err(cl.pool); }
    let cr: CloneExprResult = clone_expr_with_args(src, cl.pool, r0, params, args, ty_subs, const_subs);
    if !cr.ok { return clone_expr_err(cr.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cr.pool, ast.ExprNode.Binary(op, cl.id, cr.id), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } {
    let c0: i32 = match n { ast.ExprNode.If(c, _t, _e) => c, _ => -1 };
    let t0: i32 = match n { ast.ExprNode.If(_c, t, _e) => t, _ => -1 };
    let e0: i32 = match n { ast.ExprNode.If(_c, _t, e) => e, _ => -1 };
    let cc: CloneExprResult = clone_expr_with_args(src, dst0, c0, params, args, ty_subs, const_subs);
    if !cc.ok { return clone_expr_err(cc.pool); }
    let ct: CloneExprResult = clone_expr_with_args(src, cc.pool, t0, params, args, ty_subs, const_subs);
    if !ct.ok { return clone_expr_err(ct.pool); }
    let ce: CloneExprResult = clone_expr_with_args(src, ct.pool, e0, params, args, ty_subs, const_subs);
    if !ce.ok { return clone_expr_err(ce.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(ce.pool, ast.ExprNode.If(cc.id, ct.id, ce.id), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Member(_recv, _name) => true, _ => false } {
    let recv0: i32 = match n { ast.ExprNode.Member(recv, _name) => recv, _ => -1 };
    let name: String = match n { ast.ExprNode.Member(_recv, s) => s, _ => "" };
    let cr: CloneExprResult = clone_expr_with_args(src, dst0, recv0, params, args, ty_subs, const_subs);
    if !cr.ok { return clone_expr_err(cr.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cr.pool, ast.ExprNode.Member(cr.id, name), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Call(_callee, _ta, _args) => true, _ => false } {
    let callee0: i32 = match n { ast.ExprNode.Call(callee, _ta, _args) => callee, _ => -1 };
    let ta: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_callee, targs, _args) => targs, _ => Vec() };
    let args0: Vec[i32] = match n { ast.ExprNode.Call(_callee, _ta, xs) => xs, _ => Vec() };
    let cc: CloneExprResult = clone_expr_with_args(src, dst0, callee0, params, args, ty_subs, const_subs);
    if !cc.ok { return clone_expr_err(cc.pool); }
    let ca: CloneExprListResult = clone_expr_list_with_args(src, cc.pool, args0, params, args, ty_subs, const_subs);
    if !ca.ok { return clone_expr_err(ca.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(ca.pool, ast.ExprNode.Call(cc.id, substitute_type_name_list(ta, ty_subs, const_subs), ca.ids), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.MacroCall(_callee, _ta, _args) => true, _ => false } {
    let callee0: i32 = match n { ast.ExprNode.MacroCall(callee, _ta, _args) => callee, _ => -1 };
    let ta: Vec[ast.TypeName] = match n { ast.ExprNode.MacroCall(_callee, targs, _args) => targs, _ => Vec() };
    let args0: Vec[i32] = match n { ast.ExprNode.MacroCall(_callee, _ta, xs) => xs, _ => Vec() };
    let cc: CloneExprResult = clone_expr_with_args(src, dst0, callee0, params, args, ty_subs, const_subs);
    if !cc.ok { return clone_expr_err(cc.pool); }
    let ca: CloneExprListResult = clone_expr_list_with_args(src, cc.pool, args0, params, args, ty_subs, const_subs);
    if !ca.ok { return clone_expr_err(ca.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(ca.pool, ast.ExprNode.MacroCall(cc.id, substitute_type_name_list(ta, ty_subs, const_subs), ca.ids), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Try(_a) => true, _ => false } {
    let a0: i32 = match n { ast.ExprNode.Try(a) => a, _ => -1 };
    let cr: CloneExprResult = clone_expr_with_args(src, dst0, a0, params, args, ty_subs, const_subs);
    if !cr.ok { return clone_expr_err(cr.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cr.pool, ast.ExprNode.Try(cr.id), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.StructLit(_tyex, _fields) => true, _ => false } {
    let tyex0: i32 = match n { ast.ExprNode.StructLit(tyex, _fields) => tyex, _ => -1 };
    let fs0: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_tyex, fs) => fs, _ => Vec() };
    let ct: CloneExprResult = clone_expr_with_args(src, dst0, tyex0, params, args, ty_subs, const_subs);
    if !ct.ok { return clone_expr_err(ct.pool); }
    let cf: CloneStructFieldsResult = clone_struct_fields_with_args(src, ct.pool, fs0, params, args, ty_subs, const_subs);
    if !cf.ok { return clone_expr_err(cf.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cf.pool, ast.ExprNode.StructLit(ct.id, cf.fields), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.TryBlock(_b) => true, _ => false } {
    let b0: i32 = match n { ast.ExprNode.TryBlock(b) => b, _ => -1 };
    let cb: CloneExprResult = clone_expr_with_args(src, dst0, b0, params, args, ty_subs, const_subs);
    if !cb.ok { return clone_expr_err(cb.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cb.pool, ast.ExprNode.TryBlock(cb.id), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Match(_scrut, _arms) => true, _ => false } {
    let scrut0: i32 = match n { ast.ExprNode.Match(scrut, _arms) => scrut, _ => -1 };
    let arms0: Vec[ast.MatchArm] = match n { ast.ExprNode.Match(_scrut, arms) => arms, _ => Vec() };
    let cs: CloneExprResult = clone_expr_with_args(src, dst0, scrut0, params, args, ty_subs, const_subs);
    if !cs.ok { return clone_expr_err(cs.pool); }
    let ca: CloneMatchArmsResult = clone_match_arms_with_args(src, cs.pool, arms0, params, args, ty_subs, const_subs);
    if !ca.ok { return clone_expr_err(ca.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(ca.pool, ast.ExprNode.Match(cs.id, ca.arms), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }
  if match n { ast.ExprNode.Block(_b) => true, _ => false } {
    let b0: ast.ExprBlock = match n { ast.ExprNode.Block(b) => b, _ => ast.ExprBlock { stmts: Vec(), has_tail: false, tail: -1 } };
    let cb: CloneExprBlockResult = clone_expr_block_with_args(src, dst0, b0, params, args, ty_subs, const_subs);
    if !cb.ok { return clone_expr_err(cb.pool); }
    let ar: ast.AddExprResult = ast.expr_pool_add(cb.pool, ast.ExprNode.Block(cb.b), sp);
    return clone_expr_ok(ar.pool, ar.id);
  }

  return clone_expr_err(dst0);
}

fn inline_skip(w0: tc.World, site0: MacroSite, reason: String) -> ExpandRoundResult {
  let note: String = "macro ".concat(site0.name).concat("!: inline skipped: ").concat(reason);
  return round_ok_with_notes(w0, false, notes1(note));
}

fn try_expand_local_user_macro_inline(w: tc.World, site: MacroSite) -> ExpandRoundResult {

  let call_mod: tc.WorldModule = w.mods.get(site.mod_idx);
  let callee_node: ast.ExprNode = ast.expr_pool_get(call_mod.prog.exprs, site.callee);

  let mut callee_mod_idx: i32 = site.mod_idx;
  let mut callee_name: String = "";

  if match callee_node { ast.ExprNode.Ident(_s) => true, _ => false } {
    callee_name = match callee_node { ast.ExprNode.Ident(s) => s, _ => "" };
  } else if match callee_node { ast.ExprNode.Member(_recv, _name) => true, _ => false } {
    let recv_id: i32 = match callee_node { ast.ExprNode.Member(recv, _name) => recv, _ => -1 };
    let name1: String = match callee_node { ast.ExprNode.Member(_recv, name) => name, _ => "" };
    let recv_node: ast.ExprNode = ast.expr_pool_get(call_mod.prog.exprs, recv_id);
    if !match recv_node { ast.ExprNode.Ident(_a) => true, _ => false } {
      return inline_skip(w, site, "member macro callee receiver must be import alias identifier");
    }
    let alias: String = match recv_node { ast.ExprNode.Ident(a) => a, _ => "" };
    let ar: tc.ImportAliasesResult = tc.build_import_aliases(w, call_mod.prog.imports, site.sp.file);
    if !ar.ok { return round_err(w, ar.err); }
    let target_path: String = tc.find_alias(ar.aliases, alias);
    if target_path == "" { return inline_skip(w, site, "member receiver alias not found in imports"); }
    let mi: i32 = find_world_mod_idx(w, target_path);
    if mi < 0 { return inline_skip(w, site, "target module not loaded into world"); }
    callee_mod_idx = mi;
    callee_name = name1;
  } else {
    return inline_skip(w, site, "callee must be identifier or module member path");
  }

  if callee_name == "" { return inline_skip(w, site, "empty callee name"); }

  let callee_mod: tc.WorldModule = w.mods.get(callee_mod_idx);
  let fi: i32 = find_local_func_idx(callee_mod.prog, callee_name);
  if fi < 0 { return inline_skip(w, site, "callee function not found in target module"); }
  let fd: ast.FuncDecl = callee_mod.prog.funcs.get(fi);
  if callee_mod_idx != site.mod_idx && !fd.is_pub { return inline_skip(w, site, "callee function is not public across modules"); }
  if fd.params.len() != site.args.len() { return inline_skip(w, site, "arity mismatch between callee params and macro args"); }

  let tyc: i32 = fd.type_params.len();
  let cc: i32 = fd.const_params.len();
  let expect_targs: i32 = tyc + cc;
  if site.targs.len() != expect_targs {
    return inline_skip(w, site, "generic arg count mismatch for inline template");
  }

  let mut ty_subs: Vec[TypeArgSub] = Vec();
  let mut i: i32 = 0;
  while i < tyc {
    let ta: ast.TypeName = site.targs.get(i);
    if is_const_arg_tn(ta) { return inline_skip(w, site, "type arg position received const arg"); }
    ty_subs.push(TypeArgSub { name: fd.type_params.get(i), ty: ta });
    i = i + 1;
  }

  let mut const_subs: Vec[ConstArgSub] = Vec();
  let mut j: i32 = 0;
  while j < cc {
    let ta: ast.TypeName = site.targs.get(tyc + j);
    let text: String = const_arg_text(ta);
    if text == "" { return inline_skip(w, site, "const arg position received non-const type arg"); }
    const_subs.push(ConstArgSub { name: fd.const_params.get(j).name, text: text });
    j = j + 1;
  }

  let mt: MacroTemplateExprResult = macro_template_expr(callee_mod.prog.exprs, fd);
  if !mt.ok { return inline_skip(w, site, "callee body is not inline-template shape"); }
  let template_pool: ast.ExprPool = mt.pool;
  let template_id: i32 = mt.id;
  let root_kind: String = template_root_kind(template_pool, template_id);
  if !template_expr_supported(template_pool, template_id) {
    return inline_skip(w, site, "template contains unsupported expression forms (root: ".concat(root_kind).concat(")"));
  }
  if callee_mod_idx != site.mod_idx && !cross_mod_expr_safe(template_pool, template_id, fd.params) {
    return inline_skip(w, site, "cross-module template is not scope-safe (root: ".concat(root_kind).concat(")"));
  }

  let cr: CloneExprResult = clone_expr_with_args(
    template_pool,
    call_mod.prog.exprs,
    template_id,
    fd.params,
    site.args,
    ty_subs,
    const_subs);
  if !cr.ok { return inline_skip(w, site, "template cloning/substitution failed"); }

  let repl: ast.ExprNode = ast.expr_pool_get(cr.pool, cr.id);
  let exprs2: ast.ExprPool = expr_pool_replace(cr.pool, site.expr_id, repl, site.sp);
  let prog2: ast.Program = program_with_exprs(call_mod.prog, exprs2);
  let w2: tc.World = world_replace_mod_prog(w, site.mod_idx, prog2);
  return round_ok(w2, true);
}
