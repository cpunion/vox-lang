import "std/testing" as t
import "parse" as p
import "typecheck" as tc
import "macroexpand" as mx

fn me_contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn me_world_from(path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text_with_path("src/main.vox", src);
  t.assert(r.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, path, r.prog);
  return w;
}

fn test_macroexpand_no_macro_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return 1 + 2; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.err == tc.TcError.None);
}

fn test_macroexpand_reports_first_macro_site() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return add1!(41); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "macro expansion is not supported in stage2 yet"));
  t.assert(me_contains(msg, "add1!"));
}

fn test_macroexpand_compile_bang_splices_expr_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return compile!(1 + 2); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.rounds == 1);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_nested_splices_expr_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return compile!(compile!(1 + 2)); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.rounds == 2);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_const_init_smoke() -> () {
  let w: tc.World = me_world_from("main", "const X: i32 = compile!(1 + 2)\nfn main() -> i32 { return X; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.rounds == 1);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return compile!(1, 2); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "compile! expects exactly one value arg"));
}

fn test_macroexpand_panic_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { if false { panic!(\"boom\"); } return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_panic_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { panic!(\"a\", \"b\"); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "panic! expects exactly one value arg"));
}

fn test_macroexpand_assert_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn assert(cond: bool) -> () { if !cond { panic(\"bad\"); } }\nfn main() -> i32 { assert!(true); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_assert_bang_with_msg_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn assert_with(cond: bool, msg: String) -> () { if !cond { panic(msg); } }\nfn main() -> i32 { assert!(true, \"ok\"); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_assert_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { assert!(); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "assert! expects one or two value args"));
}
