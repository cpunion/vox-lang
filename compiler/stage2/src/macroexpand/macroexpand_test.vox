import "std/testing" as t
import "parse" as p
import "typecheck" as tc
import "macroexpand" as mx

fn me_contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn me_world_from(path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text_with_path("src/main.vox", src);
  t.assert(r.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, path, r.prog);
  return w;
}

fn test_macroexpand_no_macro_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return 1 + 2; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.err == tc.TcError.None);
}

fn test_macroexpand_user_macro_sugar_lowers_to_call() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return add1!(41); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.rounds == 1);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(!tr.ok);
  let msg: String = tc.tc_error_to_string(tr.err);
  t.assert(me_contains(msg, "unknown fn"));
  t.assert(me_contains(msg, "add1"));
}

fn test_macroexpand_compile_bang_splices_expr_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return compile!(1 + 2); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.rounds == 1);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_sugar_preserves_type_args() -> () {
  let w: tc.World = me_world_from("main",
    "fn id[T](x: T) -> T { return x; }\n"
      .concat("fn main() -> i32 { return id[i32]!(7); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_sugar_in_const_init_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn add1(x: i32) -> i32 { return x + 1; }\n"
      .concat("const X: i32 = add1!(41)\n")
      .concat("fn main() -> i32 { return X; }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_nested_splices_expr_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return compile!(compile!(1 + 2)); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.rounds == 2);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_const_init_smoke() -> () {
  let w: tc.World = me_world_from("main", "const X: i32 = compile!(1 + 2)\nfn main() -> i32 { return X; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.rounds == 1);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_in_trait_default_method_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "trait A { fn a(x: Self) -> i32 { return compile!(1 + 2); } }\nimpl A for i32 {}\nfn main() -> i32 { return A.a(1); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_in_impl_method_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "trait A { fn a(x: Self) -> i32; }\nimpl A for i32 { fn a(x: i32) -> i32 { return compile!(x + 1); } }\nfn main() -> i32 { return A.a(1); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return compile!(1, 2); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "compile! expects exactly one value arg"));
}

fn test_macroexpand_panic_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { if false { panic!(\"boom\"); } return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_panic_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { panic!(\"a\", \"b\"); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "panic! expects exactly one value arg"));
}

fn test_macroexpand_compile_error_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { compile_error!(\"boom\"); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(!tr.ok);
  let msg: String = tc.tc_error_to_string(tr.err);
  t.assert(me_contains(msg, "boom"));
}

fn test_macroexpand_compile_error_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { compile_error!(\"a\", \"b\"); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "compile_error! expects exactly one value arg"));
}

fn test_macroexpand_assert_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn assert(cond: bool) -> () { if !cond { panic(\"bad\"); } }\nfn main() -> i32 { assert!(true); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_assert_bang_with_msg_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn assert_with(cond: bool, msg: String) -> () { if !cond { panic(msg); } }\nfn main() -> i32 { assert!(true, \"ok\"); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_assert_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { assert!(); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "assert! expects one or two value args"));
}

fn test_macroexpand_assert_cmp_bang_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn assert_eq(a: i32, b: i32) -> () {}\n"
      .concat("fn assert_ne(a: i32, b: i32) -> () {}\n")
      .concat("fn assert_lt(a: i32, b: i32) -> () {}\n")
      .concat("fn assert_le(a: i32, b: i32) -> () {}\n")
      .concat("fn assert_gt(a: i32, b: i32) -> () {}\n")
      .concat("fn assert_ge(a: i32, b: i32) -> () {}\n")
      .concat("fn main() -> i32 {\n")
      .concat("  assert_eq!(1, 1);\n")
      .concat("  assert_ne!(1, 2);\n")
      .concat("  assert_lt!(1, 2);\n")
      .concat("  assert_le!(1, 1);\n")
      .concat("  assert_gt!(2, 1);\n")
      .concat("  assert_ge!(2, 2);\n")
      .concat("  return 0;\n")
      .concat("}"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_assert_cmp_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { assert_eq!(1); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "assert_eq! expects exactly two value args and no type args"));
}

fn test_macroexpand_exceeds_max_rounds_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return compile!(compile!(1 + 2)); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.ExpandConfig { max_rounds: 1 });
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "macro expansion exceeded max rounds"));
}
