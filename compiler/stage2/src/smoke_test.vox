import "std/testing" as t
import "std/sync" as s

struct CompoundS { x: i32 }
const CONST_I8_A: i8 = 120;
const CONST_I8_B: i8 = CONST_I8_A + CONST_I8_A;
const CONST_U64_MAX: u64 = 18446744073709551615;
const CONST_U64_WRAP: u64 = CONST_U64_MAX + 1;

fn test_std_testing_smoke() -> () {
  t.assert(true);
  t.assert_eq(1 + 1, 2);
  t.assert_ne(1 + 1, 3);
  t.assert_eq(true, true);
  t.assert_ne(true, false);
  t.assert_eq("a", "a");
  t.assert_ne("a", "b");
  t.assert_lt(1, 2);
  t.assert_le(2, 2);
  t.assert_gt(3, 2);
  t.assert_ge(3, 3);
  t.assert_lt("a", "b");
  t.assert_ge("b", "a");
}

fn test_prelude_fallback_smoke() -> () {
  // Unqualified names fall back to std/prelude.
  assert(true);
}

fn test_bitwise_and_shift_smoke() -> () {
  let a: i32 = 6 & 3;
  let b: i32 = 1 << 4;
  let c: i32 = b >> 2;
  t.assert_eq((a | c) ^ 1, 7);
}

fn test_compound_assign_smoke() -> () {
  let mut x: i32 = 32;
  x += 10;
  x -= 2;
  x *= 3;
  x /= 5;
  x %= 7;
  x <<= 4;
  x >>= 3;
  x &= 3;
  x |= 8;
  x ^= 15;

  let mut s: CompoundS = CompoundS { x: 32 };
  s.x += 10;
  s.x -= 2;
  s.x *= 3;
  s.x /= 5;
  s.x %= 7;
  s.x <<= 4;
  s.x >>= 3;
  s.x &= 3;
  s.x |= 8;
  s.x ^= 15;
  t.assert_eq(x + s.x, 10);
}

fn test_const_i8_wrapping_add_smoke() -> () {
  let ok: bool = (CONST_I8_B as i32) == ((-16) as i32);
  t.assert(ok);
}

fn test_const_u64_wrapping_add_smoke() -> () {
  t.assert(CONST_U64_WRAP == 0);
}

fn test_expr_cast_u64_max_literal_smoke() -> () {
  let x: u64 = CONST_U64_MAX;
  t.assert(x > 1);
}

fn test_std_sync_runtime_shared_handle_smoke() -> () {
  let mut m: s.Mutex[i32] = s.mutex[i32](7);
  let m2: s.Mutex[i32] = m;
  m = s.mutex_store[i32](m, 3);
  t.assert_eq(s.mutex_load[i32](m2), 3);

  let mut a: s.Atomic[i32] = s.atomic[i32](10);
  let a2: s.Atomic[i32] = a;
  a = s.atomic_fetch_add[i32](a, 2);
  t.assert_eq(s.atomic_load[i32](a2), 12);
  a = s.atomic_swap[i32](a, 5);
  t.assert_eq(s.atomic_load[i32](a2), 5);
}

fn test_std_sync_runtime_generic_handle_smoke() -> () {
  let mut m: s.Mutex[i64] = s.mutex[i64](7 as i64);
  let m2: s.Mutex[i64] = m;
  m = s.mutex_store[i64](m, 11 as i64);
  t.assert_eq(s.mutex_load[i64](m2), 11 as i64);

  let mut a: s.Atomic[i64] = s.atomic[i64](1 as i64);
  let a2: s.Atomic[i64] = a;
  a = s.atomic_fetch_add[i64](a, 4 as i64);
  t.assert_eq(s.atomic_load[i64](a2), 5 as i64);
  a = s.atomic_swap[i64](a, 9 as i64);
  t.assert_eq(s.atomic_load[i64](a2), 9 as i64);
}

fn test_std_sync_runtime_generic_api_smoke() -> () {
  let mut m: s.Mutex[i32] = s.mutex[i32](8);
  let m2: s.Mutex[i32] = m;
  m = s.mutex_store[i32](m, 13);
  t.assert_eq(s.mutex_load[i32](m2), 13);
  t.assert_eq(s.mutex_into_inner[i32](m), 13);

  let mut a: s.Atomic[i64] = s.atomic[i64](2 as i64);
  let a2: s.Atomic[i64] = a;
  a = s.atomic_fetch_add[i64](a, 5 as i64);
  t.assert_eq(s.atomic_load[i64](a2), 7 as i64);
  t.assert_eq(s.atomic_fetch_add_prev[i64](a, 1 as i64), 7 as i64);
  a = s.atomic_swap[i64](a, 9 as i64);
  t.assert_eq(s.atomic_swap_prev[i64](a2, 11 as i64), 9 as i64);
  t.assert_eq(s.atomic_load[i64](a), 11 as i64);
}
