import "std/testing" as t
import "std/sync" as s

struct CompoundS { x: i32 }
const CONST_I8_A: i8 = 120;
const CONST_I8_B: i8 = CONST_I8_A + CONST_I8_A;
const CONST_U64_MAX: u64 = 18446744073709551615;
const CONST_U64_WRAP: u64 = CONST_U64_MAX + 1;

fn test_std_testing_smoke() -> () {
  t.assert(true);
  t.assert_eq(1 + 1, 2);
  t.assert_ne(1 + 1, 3);
  t.assert_eq(true, true);
  t.assert_ne(true, false);
  t.assert_eq("a", "a");
  t.assert_ne("a", "b");
  t.assert_lt(1, 2);
  t.assert_le(2, 2);
  t.assert_gt(3, 2);
  t.assert_ge(3, 3);
  t.assert_lt("a", "b");
  t.assert_ge("b", "a");
}

fn test_prelude_fallback_smoke() -> () {
  // Unqualified names fall back to std/prelude.
  assert(true);
}

fn test_bitwise_and_shift_smoke() -> () {
  let a: i32 = 6 & 3;
  let b: i32 = 1 << 4;
  let c: i32 = b >> 2;
  t.assert_eq((a | c) ^ 1, 7);
}

fn test_compound_assign_smoke() -> () {
  let mut x: i32 = 32;
  x += 10;
  x -= 2;
  x *= 3;
  x /= 5;
  x %= 7;
  x <<= 4;
  x >>= 3;
  x &= 3;
  x |= 8;
  x ^= 15;

  let mut s: CompoundS = CompoundS { x: 32 };
  s.x += 10;
  s.x -= 2;
  s.x *= 3;
  s.x /= 5;
  s.x %= 7;
  s.x <<= 4;
  s.x >>= 3;
  s.x &= 3;
  s.x |= 8;
  s.x ^= 15;
  t.assert_eq(x + s.x, 10);
}

fn test_const_i8_wrapping_add_smoke() -> () {
  let ok: bool = (CONST_I8_B as i32) == ((-16) as i32);
  t.assert(ok);
}

fn test_const_u64_wrapping_add_smoke() -> () {
  t.assert(CONST_U64_WRAP == 0);
}

fn test_expr_cast_u64_max_literal_smoke() -> () {
  let x: u64 = CONST_U64_MAX;
  t.assert(x > 1);
}

fn test_std_sync_runtime_shared_handle_smoke() -> () {
  let mut m: s.MutexI32 = s.mutex_i32(7);
  let m2: s.MutexI32 = m;
  m = s.mutex_i32_store(m, 3);
  t.assert_eq(s.mutex_i32_load(m2), 3);

  let mut a: s.AtomicI32 = s.atomic_i32(10);
  let a2: s.AtomicI32 = a;
  a = s.atomic_i32_fetch_add(a, 2);
  t.assert_eq(s.atomic_i32_load(a2), 12);
  a = s.atomic_i32_swap(a, 5);
  t.assert_eq(s.atomic_i32_load(a2), 5);
}

fn test_std_sync_runtime_generic_handle_smoke() -> () {
  let mut m: s.MutexI64 = s.mutex_i64(7 as i64);
  let m2: s.MutexI64 = m;
  m = s.mutex_i64_store(m, 11 as i64);
  t.assert_eq(s.mutex_i64_load(m2), 11 as i64);

  let mut a: s.AtomicI64 = s.atomic_i64(1 as i64);
  let a2: s.AtomicI64 = a;
  a = s.atomic_i64_fetch_add(a, 4 as i64);
  t.assert_eq(s.atomic_i64_load(a2), 5 as i64);
  a = s.atomic_i64_swap(a, 9 as i64);
  t.assert_eq(s.atomic_i64_load(a2), 9 as i64);
}
