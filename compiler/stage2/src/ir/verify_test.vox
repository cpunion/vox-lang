import "std/testing" as t
import "ir" as ir

struct TestPool {
  pool: ir.TyPool,
  ty_unit: i32,
  ty_bool: i32,
  ty_i32: i32,
  ty_f64: i32,
}

fn mk_pool() -> TestPool {
  let mut pool: ir.TyPool = ir.ty_pool();

  let a0: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_unit());
  pool = a0.pool;
  let ty_unit: i32 = a0.idx;

  let a1: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_bool());
  pool = a1.pool;
  let ty_bool: i32 = a1.idx;

  let a2: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_i32());
  pool = a2.pool;
  let ty_i32: i32 = a2.idx;

  let a3: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_f64());
  pool = a3.pool;
  let ty_f64: i32 = a3.idx;

  return TestPool {
    pool: pool,
    ty_unit: ty_unit,
    ty_bool: ty_bool,
    ty_i32: ty_i32,
    ty_f64: ty_f64,
  };
}

fn has_substr(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn test_ir_verify_valid_cast_and_cfg_smoke() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.IntCast(0, tp.ty_i32, tp.ty_i32, ir.v_int(1)));
  instrs.push(ir.Instr.IntCastChecked(1, tp.ty_i32, tp.ty_f64, ir.v_float("1.5")));
  instrs.push(ir.Instr.FloatCast(2, tp.ty_f64, tp.ty_i32, ir.v_int(3)));
  instrs.push(ir.Instr.RangeCheck(tp.ty_i32, ir.v_int(2), 0, 3));

  let b0: ir.Block = ir.Block {
    name: "entry",
    instrs: instrs,
    has_term: true,
    term: ir.Term.CondBr(ir.v_bool(true), "ok", "ko"),
  };
  let b1: ir.Block = ir.Block {
    name: "ok",
    instrs: Vec(),
    has_term: true,
    term: ir.Term.Ret(false, ir.v_int(0)),
  };
  let b2: ir.Block = ir.Block {
    name: "ko",
    instrs: Vec(),
    has_term: true,
    term: ir.Term.Panic(ir.v_str("bad")),
  };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b0);
  blocks.push(b1);
  blocks.push(b2);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert_with(vr.ok, vr.err);
}

fn test_ir_verify_rejects_int_cast_from_float() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.IntCast(0, tp.ty_i32, tp.ty_f64, ir.v_float("1.0")));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "int_cast"));
}

fn test_ir_verify_rejects_int_cast_checked_non_int_dst() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.IntCastChecked(0, tp.ty_f64, tp.ty_i32, ir.v_int(1)));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "dst must be int"));
}

fn test_ir_verify_rejects_range_check_non_int_ty() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.RangeCheck(tp.ty_f64, ir.v_float("1.0"), 0, 3));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "range_check must use int type"));
}

fn test_ir_verify_rejects_vec_clear_negative_slot() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.VecClear(-1));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "vec_clear slot"));
}

fn test_ir_verify_rejects_vec_extend_negative_other_slot() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.VecExtend(0, -1));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "vec_extend other_slot"));
}

fn test_ir_verify_rejects_vec_pop_negative_slot() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.VecPop(0, tp.ty_i32, -1));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "vec_pop slot"));
}

fn test_ir_verify_rejects_unknown_branch_target() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(ir.Block {
    name: "entry",
    instrs: Vec(),
    has_term: true,
    term: ir.Term.Br("missing"),
  });
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "unknown branch target"));
}

fn test_ir_verify_rejects_enum_init_unknown_variant() -> () {
  let tp: TestPool = mk_pool();
  let mut pool: ir.TyPool = tp.pool;
  let er: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_enum("", "E"));
  pool = er.pool;
  let ty_e: i32 = er.idx;

  let mut p: ir.Program = ir.program(pool);
  let mut payload_tys0: Vec[i32] = Vec();
  payload_tys0.push(tp.ty_i32);
  let mut variants: Vec[ir.EnumVariant] = Vec();
  variants.push(ir.EnumVariant { name: "A", fields: payload_tys0 });
  p.enums.push(ir.EnumDecl { name: "E", variants: variants });

  let payload: Vec[ir.Value] = Vec();
  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.EnumInit(0, ty_e, "B", payload));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "enum_init unknown variant"));
}

fn test_ir_verify_rejects_enum_init_payload_arity_mismatch() -> () {
  let tp: TestPool = mk_pool();
  let mut pool: ir.TyPool = tp.pool;
  let er: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_enum("", "E"));
  pool = er.pool;
  let ty_e: i32 = er.idx;

  let mut p: ir.Program = ir.program(pool);
  let mut payload_tys1: Vec[i32] = Vec();
  payload_tys1.push(tp.ty_i32);
  let mut variants: Vec[ir.EnumVariant] = Vec();
  variants.push(ir.EnumVariant { name: "A", fields: payload_tys1 });
  p.enums.push(ir.EnumDecl { name: "E", variants: variants });

  let payload: Vec[ir.Value] = Vec();
  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.EnumInit(0, ty_e, "A", payload));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "enum_init payload arity mismatch"));
}

fn test_ir_verify_rejects_struct_init_unknown_field() -> () {
  let tp: TestPool = mk_pool();
  let mut pool: ir.TyPool = tp.pool;
  let sr: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_struct("", "S"));
  pool = sr.pool;
  let ty_s: i32 = sr.idx;

  let mut p: ir.Program = ir.program(pool);
  let mut fields_decl: Vec[ir.StructField] = Vec();
  fields_decl.push(ir.StructField { name: "x", ty: tp.ty_i32 });
  p.structs.push(ir.StructDecl { name: "S", fields: fields_decl });

  let mut fields_init: Vec[ir.StructInitField] = Vec();
  fields_init.push(ir.StructInitField { name: "y", val: ir.v_int(1) });
  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.StructInit(0, ty_s, fields_init));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "struct_init unknown field"));
}

fn test_ir_verify_rejects_cmp_ordered_on_struct() -> () {
  let tp: TestPool = mk_pool();
  let mut pool: ir.TyPool = tp.pool;
  let sr: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_struct("", "S"));
  pool = sr.pool;
  let ty_s: i32 = sr.idx;

  let mut p: ir.Program = ir.program(pool);
  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.Cmp(0, ir.CmpKind.Lt, ty_s, ir.v_temp(1), ir.v_temp(2)));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "expects ordered type"));
}

fn test_ir_verify_rejects_cmp_eq_on_vec() -> () {
  let tp: TestPool = mk_pool();
  let mut pool: ir.TyPool = tp.pool;
  let vr0: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_vec(tp.ty_i32));
  pool = vr0.pool;
  let ty_v: i32 = vr0.idx;

  let mut p: ir.Program = ir.program(pool);
  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.Cmp(0, ir.CmpKind.Eq, ty_v, ir.v_temp(1), ir.v_temp(2)));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "expects eq-comparable type"));
}

fn test_ir_verify_rejects_binop_add_on_struct() -> () {
  let tp: TestPool = mk_pool();
  let mut pool: ir.TyPool = tp.pool;
  let sr: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_struct("", "S"));
  pool = sr.pool;
  let ty_s: i32 = sr.idx;

  let mut p: ir.Program = ir.program(pool);
  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.BinOp(0, ir.BinOpKind.Add, ty_s, ir.v_temp(1), ir.v_temp(2)));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "expects int/float"));
}

fn test_ir_verify_rejects_binop_shift_on_float() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.BinOp(0, ir.BinOpKind.Shl, tp.ty_f64, ir.v_float("1.0"), ir.v_int(1)));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "expects int"));
}
