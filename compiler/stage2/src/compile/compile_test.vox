import "std/testing" as t
import "compile" as c
import "loader" as ld
import "codegen" as cg

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn starts_with(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

fn test_compile_main_text_to_c_smoke() -> () {
  let r: c.CompileResult = c.compile_main_text_to_c(
    "fn main() -> i32 { print(\"x\"); return 0; }",
    cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() }
  );
  t.assert(r.ok);
}

fn test_compile_files_to_c_smoke_multi_module() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/a.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a\" as a\nfn main() -> i32 { return a.one(); }" });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  // Expect both main and imported module symbol to appear.
  t.assert(contains(r.c, "vox_fn_mmain"));
  t.assert(contains(r.c, "vox_fn_ma_3a_3aone"));
}

fn test_compile_i64_literal_over_i32_range_smoke() -> () {
  // Stage1 v0: integer literals are stored as text and typed later, so values beyond
  // i32 range must still work when an i64 type is expected.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const X: i64 = 3000000000\nfn main() -> i32 { if X > 2000000000 { return 1; } return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "3000000000"));
}

fn test_compile_float_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let x: f64 = 1.5; let y: f32 = x as f32; let z: f64 = y as f64; if z > 0.0 { return 1; } return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "(float)"));
  t.assert(contains(r.c, "(double)"));
}

fn test_compile_string_to_string_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let s: String = \"vox\"; let t2: String = s.to_string(); return t2.len(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_str_alias_maps_to_string_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let s: str = "vox";
        let t: String = s.concat("-lang");
        let u: str = t.to_string();
        return u.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ref_str_alias_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn len1(s: &str) -> i32 { return s.len(); }
      fn main() -> i32 { return len1("vox"); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ref_static_str_alias_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn id(s: &'static str) -> &'static str { return s; }
      fn main() -> i32 { let s: &'static str = id("vox"); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ref_i32_alias_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn add1(x: &i32) -> i32 { return x + 1; }
      fn id(x: &'static i32) -> &'static i32 { return x; }
      fn main() -> i32 { return add1(id(41)); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ref_mut_i32_alias_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn add1(x: &mut i32) -> i32 { return x + 1; }
      fn id(x: &'static mut i32) -> &'static mut i32 { return x; }
      fn main() -> i32 { return add1(id(41)); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ref_named_lifetime_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn bad(s: &'a str) -> i32 { return s.len(); }\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "only 'static is allowed"));
}

fn test_compile_ref_mut_named_lifetime_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn bad(s: &'a mut i32) -> i32 { return s; }\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "only 'static is allowed"));
}

fn test_compile_ref_named_lifetime_in_let_annotation_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let x: &'a i32 = 1; return x; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "only 'static is allowed"));
}

fn test_compile_string_predicate_methods_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let s: String = "vox-lang";
        if s.starts_with("vox") && s.ends_with("lang") && s.contains("-") { return 1; }
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_str_starts_with("));
  t.assert(contains(r.c, "vox_str_ends_with("));
  t.assert(contains(r.c, "vox_str_contains("));
}

fn test_compile_string_index_methods_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let s: String = "vox-lang-vox";
        let i0: i32 = s.index_of("vox");
        let i1: i32 = s.last_index_of("vox");
        let i2: i32 = s.index_of("zzz");
        return i0 + i1 + i2;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_str_index_of("));
  t.assert(contains(r.c, "vox_str_last_index_of("));
}

fn test_compile_string_is_empty_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let s0: String = "";
        let s1: String = "vox";
        return if s0.is_empty() && !s1.is_empty() { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_str_len("));
}

fn test_compile_vec_is_empty_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        if v.is_empty() { v.push(9); }
        return if !v.is_empty() && v.len() == 1 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_len("));
}

fn test_compile_vec_clear_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        v.push(1);
        v.push(2);
        v.clear();
        return if v.len() == 0 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_clear("));
}

fn test_compile_vec_extend_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut a: Vec[i32] = Vec();
        a.push(1);
        let mut b: Vec[i32] = Vec();
        b.push(2);
        b.push(3);
        a.extend(b);
        return if a.len() == 3 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_extend("));
}

fn test_compile_vec_insert_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        v.push(1);
        v.insert(0, 9);
        return v.get(0) + v.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_insert("));
}

fn test_compile_vec_pop_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        v.push(1);
        v.push(2);
        return v.pop() + v.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_pop("));
}

fn test_compile_vec_remove_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        v.push(1);
        v.push(2);
        return v.remove(0) + v.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_remove("));
}

fn test_compile_nested_field_assign_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "struct I { x: i32 }\nstruct O { i: I }\nfn main() -> i32 { let mut o: O = O { i: I { x: 1 } }; o.i.x = 2; o.i.x += 3; return o.i.x; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_vec_nested_field_push_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        o.inner.items.push(40);
        o.inner.items.push(2);
        return o.inner.items.get(0) + o.inner.items.get(1) + o.inner.items.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_vec_nested_field_clear_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        o.inner.items.push(40);
        o.inner.items.clear();
        return if o.inner.items.len() == 0 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_clear("));
}

fn test_compile_vec_nested_field_extend_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        let mut extra: Vec[i32] = Vec();
        extra.push(40);
        extra.push(2);
        o.inner.items.extend(extra);
        return if o.inner.items.len() == 2 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_extend("));
}

fn test_compile_vec_nested_field_insert_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        o.inner.items.push(40);
        o.inner.items.insert(0, 2);
        return o.inner.items.get(0);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_insert("));
}

fn test_compile_vec_nested_field_set_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        o.inner.items.push(40);
        o.inner.items.set(0, 2);
        return o.inner.items.get(0);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_set("));
}

fn test_compile_vec_nested_field_pop_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        o.inner.items.push(40);
        o.inner.items.push(2);
        return o.inner.items.pop();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_pop("));
}

fn test_compile_vec_nested_field_remove_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        o.inner.items.push(40);
        o.inner.items.push(2);
        return o.inner.items.remove(0);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_remove("));
}

fn test_compile_vec_push_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        v.push(1);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.push receiver is immutable"));
}

fn test_compile_vec_insert_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        v.insert(0, 1);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.insert receiver is immutable"));
}

fn test_compile_vec_set_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        v.set(0, 1);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.set receiver is immutable"));
}

fn test_compile_vec_extend_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        let w2: Vec[i32] = Vec();
        v.extend(w2);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.extend receiver is immutable"));
}

fn test_compile_vec_clear_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        v.clear();
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.clear receiver is immutable"));
}

fn test_compile_vec_pop_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        return v.pop();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.pop receiver is immutable"));
}

fn test_compile_vec_remove_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        return v.remove(0);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.remove receiver is immutable"));
}

fn test_compile_nested_field_compound_assign_all_ops_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct I { x: i32 }
      struct O { i: I }
      fn main() -> i32 {
        let mut o: O = O { i: I { x: 255 } };
        o.i.x += 1;
        o.i.x -= 2;
        o.i.x *= 3;
        o.i.x /= 4;
        o.i.x %= 5;
        o.i.x &= 6;
        o.i.x |= 7;
        o.i.x ^= 8;
        o.i.x <<= 1;
        o.i.x >>= 2;
        return o.i.x;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_int_float_cast_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let x: i32 = 7; let y: f64 = x as f64; let z: i32 = y as i32; return z; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "isfinite"));
}

fn test_compile_unary_not_int_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let x: i32 = !1; return x; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_int_cast_safe_widen_skips_runtime_check() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main(x: i32) -> i64 { let y: i64 = x as i64; return y; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(!contains(r.c, "i32 to i64 overflow"));
}

fn test_compile_int_cast_narrow_keeps_runtime_check() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main(x: i64) -> i32 { let y: i32 = x as i32; return y; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "i64 to i32 overflow"));
}

fn test_compile_float_scientific_and_suffix_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let a: f64 = 1e3; let b: f32 = 2.5e-2f32; let c: f64 = b as f64; if a > c { return 1; } return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "1e3"));
}

fn test_compile_float_mod_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> f64 { return 5.5 % 2.0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "fmod("));
}

fn test_compile_string_ordered_compare_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { if \"ab\" < \"ac\" { return 1; } return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "strcmp("));
}

fn test_compile_const_float_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const A: f64 = 1.5\nconst B: f32 = A as f32\nconst C: f64 = B as f64\nfn main() -> f64 { return C; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "double"));
}

fn test_compile_const_float_arith_cmp_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const A: f64 = 1.0 + 2.0\nconst B: bool = A > 2.5\nconst C: bool = A == 3.0\nconst D: bool = A != 4.0\nfn main() -> i32 { return if B && C && D { 1 } else { 0 }; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_float_mod_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const A: f64 = 5.5 % 2.0\nfn main() -> f64 { return A; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_reflect_intrinsics_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      type R = @range(0..=7) i32
      struct S { a: i32, b: i64 }
      enum E { A(i32), B }
      const SZ: usize = @size_of(S)
      const AL: usize = @align_of(S)
      const FC_S: usize = @field_count(S)
      const FC_E: usize = @field_count(E)
      const FN0: String = @field_name(S, 0)
      const VN1: String = @field_name(E, 1)
      const FT1: String = @field_type(S, 1)
      const ET0: String = @field_type(E, 0)
      const ET1: String = @field_type(E, 1)
      const FTY1: TypeId = @field_type_id(S, 1)
      const ETY0: TypeId = @field_type_id(E, 0)
      const ETY1: TypeId = @field_type_id(E, 1)
      const TY_S: TypeId = @type(S)
      const TY_I32: TypeId = @type(i32)
      const TY_I64: TypeId = @type(i64)
      const TN: String = @type_name(S)
      const EQTY: bool = @same_type(i32, i32)
      const NETY: bool = @same_type(i32, i64)
      const A0: bool = @assignable_to(R, i32)
      const A1: bool = @assignable_to(i32, R)
      const A2: bool = @assignable_to(i32, i32)
      const C0: bool = @castable_to(i32, f64)
      const C1: bool = @castable_to(String, i32)
      const E2E0: bool = @eq_comparable_with(S, S)
      const E2E1: bool = @eq_comparable_with(Vec[i32], Vec[i32])
      const O2O0: bool = @ordered_with(String, String)
      const O2O1: bool = @ordered_with(S, S)
      const I0: bool = @is_integer(i32)
      const I1: bool = @is_integer(S)
      const SI: bool = @is_signed_int(i64)
      const SU: bool = @is_unsigned_int(u64)
      const F0: bool = @is_float(f64)
      const B0: bool = @is_bool(bool)
      const S0: bool = @is_string(String)
      const ST: bool = @is_struct(S)
      const EN: bool = @is_enum(E)
      const V0: bool = @is_vec(Vec[i32])
      const R0: bool = @is_range(R)
      const EQC0: bool = @is_eq_comparable(S)
      const EQC1: bool = @is_eq_comparable(Vec[i32])
      const ORD0: bool = @is_ordered(String)
      const ORD1: bool = @is_ordered(S)
      const U0: bool = @is_unit(())
      const U1: bool = @is_unit(i32)
      const N0: bool = @is_numeric(i32)
      const N1: bool = @is_numeric(String)
      fn main() -> i32 {
        return if SZ >= AL && FC_S == 2 && FC_E == 2 && FN0 == "a" && VN1 == "B" &&
            FT1 == "i64" && ET0 == "i32" && ET1 == "()" && FTY1 == TY_I64 && ETY0 == TY_I32 &&
            ETY1 == @type(()) && TY_S == @type(S) && TY_I32 != TY_I64 && EQTY && !NETY &&
            A0 && !A1 && A2 && C0 && !C1 && E2E0 && !E2E1 && O2O0 && !O2O1 && TN.len() > 0 &&
            I0 && !I1 && SI && SU && F0 && B0 && S0 && ST && EN && V0 && R0 &&
            EQC0 && !EQC1 && ORD0 && !ORD1 && U0 && !U1 && N0 && !N1 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_type_alias_field_type_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct S { a: i32, b: String }
      enum E { A(i64), B }
      type B = @field_type(S, 1)
      type TA = @field_type(E, 0)
      type TB = @field_type(E, 1)
      fn touch(x: TB) -> i32 { return 0; }
      fn main() -> i32 {
        let x: B = "ok";
        let a: TA = 7;
        return x.len() + (a as i32);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_type_alias_field_type_generic_nominal_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Pair[T] { a: T, b: T }
      enum Wrap[T] { One(T), None }
      type PA = @field_type(Pair[i32], 0)
      type WA = @field_type(Wrap[i64], 0)
      type WN = @field_type(Wrap[i64], 1)
      fn touch(x: WN) -> i32 { return 0; }
      fn main() -> i32 {
        let a: PA = 3;
        let b: WA = 4;
        return a + (b as i32);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_type_alias_field_type_multi_payload_enum_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum E { A(i32, i64), B }
      type T = @field_type(E, 0)
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_reflect_intrinsic_field_type_id_multi_payload_enum_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum E { A(i32, i64), B(i32, i64), C(i32, i32), D }
      const T0: TypeId = @field_type_id(E, 0)
      const T1: TypeId = @field_type_id(E, 1)
      const T2: TypeId = @field_type_id(E, 2)
      const TD: TypeId = @field_type_id(E, 3)
      const OK0: bool = T0 == T1
      const OK1: bool = T0 != T2
      const OK2: bool = TD == @type(())
      fn main() -> i32 { return if OK0 && OK1 && OK2 { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_reflect_layout_intrinsics_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      const Z0: bool = @is_zero_sized(())
      const Z1: bool = @is_zero_sized(i32)
      const L0: bool = @same_layout(i32, u32)
      const L1: bool = @same_layout(i32, i64)
      const B0: bool = @bitcastable(i32, u32)
      const B1: bool = @bitcastable(i32, i64)
      fn main() -> i32 { return if Z0 && !Z1 && L0 && !L1 && B0 && !B1 { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_error_rejected_with_message() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { @compile_error(\"boom\"); return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "compile_error: boom"));
}

fn test_compile_const_compile_error_rejected_with_message() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const X: i32 = @compile_error(\"const-boom\")\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "compile_error: const-boom"));
}

fn test_compile_const_unary_not_int_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = !0\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_fn_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn add2(x: i32) -> i32 { return x + 2; }\nconst N: i32 = add2(5)\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_fn_call_named_import_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "dep/src/dep.vox", text: "pub fn plus(a: i32, b: i32) -> i32 { return a + b; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { plus } from \"dep\"\nconst N: i32 = plus(3, 4)\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_fn_call_generic_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn id[T](x: T) -> T { return x; }\nconst N: i32 = id(7)\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_fn_call_const_generic_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nconst M: i32 = addn[3](4)\nfn main() -> i32 { return M; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_fn_call_generic_trait_bound_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      fn id[T: Eq](x: T) -> T { return x; }
      const N: i32 = id(7)
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_fn_call_generic_trait_bound_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      fn id[T: Eq](x: T) -> T { return x; }
      const S: String = id("x")
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert(!r.ok);
}

fn test_compile_const_fn_call_generic_type_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn id[T](x: T) -> T { return x; }\nconst N: i32 = id[String](7)\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert(!r.ok);
}

fn test_compile_const_block_expr_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = { let a: i32 = 2; let b: i32 = a + 3; b * 2 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_block_shadowing_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = { let x: i32 = 1; let x: i32 = 2; x }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_block_if_stmt_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = { let x: i32 = 1; if true { let y: i32 = 2; } else { let z: i32 = 3; }; x + 4 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_block_while_break_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = { while true { break; } 7 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_block_return_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = { return 9; 1 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_logic_short_circuit_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      const A: bool = false && (1 / 0 == 0)
      const B: bool = true || (1 / 0 == 0)
      fn main() -> i32 { return if A || B { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_struct_member_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct P { x: i32, y: i32 }
      const P0: P = P { x: 3, y: 4 }
      const N: i32 = P0.x + P0.y
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_typed_path_generic_struct_lit_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Pair[T] { a: T, b: T }
      const P0: Pair[i32] = Pair[i32] { a: 3, b: 4 }
      const N: i32 = P0.a + P0.b
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_generic_struct_lit_uses_expected_type_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Pair[T] { a: T, b: T }
      const P0: Pair[i32] = Pair { a: 3, b: 4 }
      const N: i32 = P0.a + P0.b
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_block_assign_field_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct P { x: i32 }
      const N: i32 = { let mut p: P = P { x: 1 }; p.x = 7; p.x }
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_block_assign_nested_field_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct I { x: i32 }
      struct O { i: I }
      const N: i32 = { let mut o: O = O { i: I { x: 1 } }; o.i.x = 9; o.i.x }
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_block_compound_assign_nested_field_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct I { x: i32 }
      struct O { i: I }
      const N: i32 = { let mut o: O = O { i: I { x: 1 } }; o.i.x += 2; o.i.x }
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_block_compound_assign_nested_field_all_ops_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct I { x: i32 }
      struct O { i: I }
      const N: i32 = {
        let mut o: O = O { i: I { x: 255 } };
        o.i.x += 1;
        o.i.x -= 2;
        o.i.x *= 3;
        o.i.x /= 4;
        o.i.x %= 5;
        o.i.x &= 6;
        o.i.x |= 7;
        o.i.x ^= 8;
        o.i.x <<= 1;
        o.i.x >>= 2;
        o.i.x
      }
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_block_assign_nested_string_field_with_codec_chars_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct I { s: String }
      struct O { i: I }
      const N: i32 = { let mut o: O = O { i: I { s: "a#|b" } }; o.i.s = "q#|w"; o.i.s.len() }
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_block_branch_assign_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      const N: i32 = { let mut x: i32 = 1; if true { x = 3; } else { x = 4; }; x }
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_match_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = match 2 { 1 => 10, 2 => 20, _ => 0 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_match_bind_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = match 2 { x => x + 1 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_match_bool_patterns_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main(b: bool) -> i32 { return match b { true => 1, false => 0 }; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_match_bool_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = match true { true => 1, false => 0 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_enum_unit_match_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "enum E { A, B }\nconst X: E = .A\nconst N: i32 = match X { .A => 1, .B => 0 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_enum_payload_match_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "enum E { A(i32), B }\nconst X: E = .A(7)\nconst N: i32 = match X { .A(v) => v + 1, .B => 0 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_enum_payload_match_multiple_binds_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "enum E { A(i32, i32), B }\nconst X: E = .A(7, 2)\nconst N: i32 = match X { .A(a, b) => a - b, .B => 0 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_enum_ctor_qualified_path_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum E { A(i32), B }
      const X: E = E.A(7)
      const Y: E = E.B
      const N: i32 = match X { .A(v) => v, .B => 0 }
      fn main() -> i32 { return if Y == E.B { N } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_enum_ctor_alias_path_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "dep/src/dep.vox", text: "pub enum E { A(i32), B }" });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "dep" as dep
      const X: dep.E = dep.E.A(7)
      const Y: dep.E = dep.E.B
      const N: i32 = match X { .A(v) => v, .B => 0 }
      fn main() -> i32 { return if Y == dep.E.B { N } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_typed_path_generic_enum_ctor_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Option[T] { Some(T), None }
      const A: Option[i32] = Option[i32].Some(7)
      const B: Option[i32] = Option[i32].None
      fn main() -> i32 { let _a: Option[i32] = A; let _b: Option[i32] = B; return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_generic_enum_ctor_uses_expected_type_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Option[T] { Some(T), None }
      const A: Option[i32] = Option.Some(7)
      const B: Option[i32] = Option.None
      fn main() -> i32 { let _a: Option[i32] = A; let _b: Option[i32] = B; return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_enum_ctor_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "enum Option[T] { Some(T), None }\nenum Maybe[T] { Some(T), None }\nconst A: Option[i32] = Maybe.Some(7)\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert(!r.ok);
}

fn test_compile_union_type_alias_match_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "type Value = I32: i32 | Str: String\nfn main() -> i32 { let x: Value = Value.I32(7); return match x { .I32(v) => v, .Str(_s) => 0 }; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_union_match_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "type Value = I32: i32 | Str: String\nconst X: Value = Value.I32(7)\nconst N: i32 = match X { .I32(v) => v, .Str(_s) => 0 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_int_float_cast_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const A: f64 = 7 as f64\nconst B: i32 = 3.9 as i32\nfn main() -> i32 { return A as i32 + B; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "7.0"));
}

fn test_compile_enum_payload_equality_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "enum E { A(i32), None }\nfn main() -> i32 { let a: E = E.A(1); let b: E = E.A(1); return if a == b { 1 } else { 0 }; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_enum_eq_"));
}

fn test_compile_struct_equality_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "struct S { a: i32, b: String }\nfn main() -> i32 { let x: S = S { a: 1, b: \"x\" }; let y: S = S { a: 1, b: \"x\" }; return if x == y { 1 } else { 0 }; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_struct_eq_"));
}

fn test_compile_const_struct_equality_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct S { a: i32, b: String }
      const X: S = S { a: 1, b: "x" }
      const Y: S = S { a: 1, b: "x" }
      const B: bool = X == Y
      fn main() -> i32 { return if B { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_enum_payload_equality_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum E { A(i32, String), None }
      const X: E = E.A(7, "x")
      const Y: E = E.A(7, "x")
      const B: bool = X == Y
      fn main() -> i32 { return if B { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_generic_eq_operator_with_struct_instantiation_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      struct S { a: i32 }
      impl Eq for S { fn eq(a: S, b: S) -> bool { return a.a == b.a; } }
      fn same[T: Eq](a: T, b: T) -> bool { return a == b; }
      fn main() -> i32 { let x: S = S { a: 1 }; let y: S = S { a: 1 }; return if same(x, y) { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_struct_eq_"));
}

fn test_compile_generic_cmp_operator_with_ord_bound_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Ord { fn lt(a: Self, b: Self) -> bool; }
      impl Ord for i32 { fn lt(a: i32, b: i32) -> bool { return a < b; } }
      fn less[T: Ord](a: T, b: T) -> bool { return a < b; }
      fn main() -> i32 { return if less(1, 2) { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_generic_cmp_operator_without_ord_bound_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn less[T](a: T, b: T) -> bool { return a < b; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_generic_nominal_instantiation_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Pair[T] { a: T, b: T }
      enum Option[T] { Some(T), None }
      fn main() -> i32 {
        let p: Pair[i32] = Pair { a: 1, b: 2 };
        let o: Option[i32] = Option.Some(p.a + p.b);
        return match o { Option.Some(v) => v, Option.None => 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_struct_type_name("Pair$gT_3di32")));
  t.assert(contains(r.c, cg.c_enum_type_name("Option$gT_3di32")));
}

fn test_compile_generic_fn_return_nominal_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Boxed[T] { v: T }
      fn mk[T](x: T) -> Boxed[T] { return Boxed { v: x }; }
      fn main() -> i32 {
        let b: Boxed[i32] = mk[i32](7);
        return b.v;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_struct_type_name("Boxed$gT_3di32")));
}

fn test_compile_generic_nominal_struct_path_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Pair[T] { a: T, b: T }\nstruct Box[T] { a: T, b: T }\nfn main() -> i32 {\n  let _p: Pair[i32] = Box { a: 1, b: 2 };\n  return 0;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert(!r.ok);
}

fn test_compile_generic_nominal_instantiation_with_typed_path_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Pair[T] { a: T, b: T }
      enum Option[T] { Some(T), None }
      fn main() -> i32 {
        let p = Pair[i32] { a: 1, b: 2 };
        let o = Option[i32].Some(p.a + p.b);
        let n = Option[i32].None;
        let y: i32 = match n { Option.Some(v) => v, Option.None => 0 };
        return match o { Option.Some(v) => v + y, Option.None => 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_struct_type_name("Pair$gT_3di32")));
  t.assert(contains(r.c, cg.c_enum_type_name("Option$gT_3di32")));
}

fn test_compile_ifexpr_branch_return_diverges_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main(flag: bool) -> i32 {\n  let x: i32 = if flag {\n    return 7;\n  } else {\n    3\n  };\n  return x;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ifexpr_both_branches_diverge_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main(flag: bool) -> i32 {\n  let _x: i32 = if flag {\n    return 7;\n  } else {\n    return 9;\n  };\n  return 0;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ifexpr_branch_break_in_loop_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 {\n  let mut i: i32 = 0;\n  while i < 10 {\n    let _x: i32 = if i > 5 {\n      break;\n    } else {\n      i\n    };\n    i = i + 1;\n  }\n  return i;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ifexpr_range_result_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    // Repro: if-expression result type is a refined integer.
    text: "type Tiny = @range(1..=3) i32\nfn main(flag: bool) -> i32 {\n  let x: Tiny = if flag {\n    2 as Tiny\n  } else {\n    3 as Tiny\n  };\n  return x as i32;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ifexpr_else_if_chain_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn sign(x: i32) -> i32 {\n  let y: i32 = if x < 0 {\n    -1\n  } else if x == 0 {\n    0\n  } else {\n    1\n  };\n  return y;\n}\nfn main() -> i32 { return sign(7); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_testing_assert_eq_wrapper_preserves_eq_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_eq[T: Eq](a: T, b: T) -> () { if a != b { panic("assertion failed"); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: "import \"std/prelude\" as prelude\npub fn assert_eq[T: prelude.Eq](a: T, b: T) -> () { prelude.assert_eq(a, b); }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_eq(1, 1); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_std_testing_assert_ne_wrapper_preserves_eq_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_eq[T: Eq](a: T, b: T) -> () { if a != b { panic("assertion failed"); } }
      pub fn assert_ne[T: Eq](a: T, b: T) -> () { if a == b { panic("assertion failed"); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: "import \"std/prelude\" as prelude\npub fn assert_ne[T: prelude.Eq](a: T, b: T) -> () { prelude.assert_ne(a, b); }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_ne(1, 2); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_std_testing_assert_lt_wrapper_preserves_ord_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Ord { fn lt(a: Self, b: Self) -> bool; }
      impl Ord for i32 { fn lt(a: i32, b: i32) -> bool { return a < b; } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_lt[T: Ord](a: T, b: T) -> () { if a < b { return; } panic("assertion failed"); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: """
      import "std/prelude" as prelude
      pub fn assert_lt[T: prelude.Ord](a: T, b: T) -> () { prelude.assert_lt(a, b); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_lt(1, 2); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_std_io_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      pub fn out(msg: String) -> () { print(msg); }
      pub fn out_ln(msg: String) -> () { print(msg); print("\\n"); }
      pub fn fail(msg: String) -> () { panic(msg); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/io\" as io\nfn main() -> i32 { io.out(\"x\"); io.out_ln(\"y\"); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_time_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/time/time.vox",
    text: """
      pub fn now_ns() -> i64 { return __now_ns(); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/time" as tm
      fn main() -> i32 {
        let t0: i64 = tm.now_ns();
        if t0 >= 0 { return 0; }
        return 1;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_sync_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/sync/sync.vox",
    text: """
      pub trait SyncScalar {
        fn mutex_new(v: Self) -> i64;
        fn mutex_load(sample: Self, handle: i64) -> Self;
        fn mutex_store(v: Self, handle: i64) -> ();
        fn atomic_new(v: Self) -> i64;
        fn atomic_load(sample: Self, handle: i64) -> Self;
        fn atomic_store(v: Self, handle: i64) -> ();
        fn atomic_fetch_add(delta: Self, handle: i64) -> Self;
      }
      impl SyncScalar for i32 {
        fn mutex_new(v: i32) -> i64 { return __mutex_i32_new(v); }
        fn mutex_load(sample: i32, handle: i64) -> i32 { return __mutex_i32_load(handle); }
        fn mutex_store(v: i32, handle: i64) -> () { __mutex_i32_store(handle, v); }
        fn atomic_new(v: i32) -> i64 { return __atomic_i32_new(v); }
        fn atomic_load(sample: i32, handle: i64) -> i32 { return __atomic_i32_load(handle); }
        fn atomic_store(v: i32, handle: i64) -> () { __atomic_i32_store(handle, v); }
        fn atomic_fetch_add(delta: i32, handle: i64) -> i32 { return __atomic_i32_fetch_add(handle, delta); }
      }
      pub struct Mutex[T: SyncScalar] { handle: i64, sample: T }
      pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] { return Mutex { handle: SyncScalar.mutex_new(v), sample: v }; }
      pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
        SyncScalar.mutex_store(v, m.handle);
        return Mutex { handle: m.handle, sample: v };
      }
      pub fn mutex_into_inner[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub struct Atomic[T: SyncScalar] { handle: i64, sample: T }
      pub fn atomic[T: SyncScalar](v: T) -> Atomic[T] { return Atomic { handle: SyncScalar.atomic_new(v), sample: v }; }
      pub fn atomic_load[T: SyncScalar](a: Atomic[T]) -> T { return SyncScalar.atomic_load(a.sample, a.handle); }
      pub fn atomic_store[T: SyncScalar](a: Atomic[T], v: T) -> Atomic[T] {
        SyncScalar.atomic_store(v, a.handle);
        return Atomic { handle: a.handle, sample: v };
      }
      pub fn atomic_fetch_add[T: SyncScalar](a: Atomic[T], delta: T) -> Atomic[T] {
        let next: T = SyncScalar.atomic_fetch_add(delta, a.handle);
        return Atomic { handle: a.handle, sample: next };
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/sync" as s
      fn main() -> i32 {
        let m: s.Mutex[i32] = s.mutex[i32](7);
        let x: i32 = s.mutex_into_inner[i32](m);
        let mut a: s.Atomic[i32] = s.atomic[i32](1);
        a = s.atomic_fetch_add[i32](a, 2);
        a = s.atomic_store[i32](a, 4);
        return x + s.atomic_load[i32](a);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_sync_i64_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/sync/sync.vox",
    text: """
      pub trait SyncScalar {
        fn mutex_new(v: Self) -> i64;
        fn mutex_load(sample: Self, handle: i64) -> Self;
        fn mutex_store(v: Self, handle: i64) -> ();
        fn atomic_new(v: Self) -> i64;
        fn atomic_load(sample: Self, handle: i64) -> Self;
        fn atomic_fetch_add(delta: Self, handle: i64) -> Self;
      }
      impl SyncScalar for i64 {
        fn mutex_new(v: i64) -> i64 { return __mutex_i64_new(v); }
        fn mutex_load(sample: i64, handle: i64) -> i64 { return __mutex_i64_load(handle); }
        fn mutex_store(v: i64, handle: i64) -> () { __mutex_i64_store(handle, v); }
        fn atomic_new(v: i64) -> i64 { return __atomic_i64_new(v); }
        fn atomic_load(sample: i64, handle: i64) -> i64 { return __atomic_i64_load(handle); }
        fn atomic_fetch_add(delta: i64, handle: i64) -> i64 { return __atomic_i64_fetch_add(handle, delta); }
      }
      pub struct Mutex[T: SyncScalar] { handle: i64, sample: T }
      pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] { return Mutex { handle: SyncScalar.mutex_new(v), sample: v }; }
      pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
        SyncScalar.mutex_store(v, m.handle);
        return Mutex { handle: m.handle, sample: v };
      }
      pub struct Atomic[T: SyncScalar] { handle: i64, sample: T }
      pub fn atomic[T: SyncScalar](v: T) -> Atomic[T] { return Atomic { handle: SyncScalar.atomic_new(v), sample: v }; }
      pub fn atomic_load[T: SyncScalar](a: Atomic[T]) -> T { return SyncScalar.atomic_load(a.sample, a.handle); }
      pub fn atomic_fetch_add[T: SyncScalar](a: Atomic[T], d: T) -> Atomic[T] {
        let next: T = SyncScalar.atomic_fetch_add(d, a.handle);
        return Atomic { handle: a.handle, sample: next };
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/sync" as s
      fn main() -> i32 {
        let mut m: s.Mutex[i64] = s.mutex[i64](7 as i64);
        let m2: s.Mutex[i64] = m;
        m = s.mutex_store[i64](m, 9 as i64);
        let mut a: s.Atomic[i64] = s.atomic[i64](3 as i64);
        a = s.atomic_fetch_add[i64](a, 4 as i64);
        return (s.mutex_load[i64](m2) + s.atomic_load[i64](a)) as i32;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_io_net_intrinsics_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      pub struct NetAddr { host: String, port: i32 }
      pub struct NetConn { handle: i64 }
      pub fn net_addr(host: String, port: i32) -> NetAddr { return NetAddr { host: host, port: port }; }
      pub fn net_connect(a: NetAddr) -> NetConn { return NetConn { handle: __tcp_connect(a.host, a.port) }; }
      pub fn net_send(c: NetConn, text: String) -> i32 { return __tcp_send(c.handle, text); }
      pub fn net_recv(c: NetConn, max_n: i32) -> String { return __tcp_recv(c.handle, max_n); }
      pub fn net_close(c: NetConn) -> () { __tcp_close(c.handle); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/io" as io
      fn main() -> i32 {
        let a: io.NetAddr = io.net_addr("127.0.0.1", 7);
        let c: io.NetConn = io.net_connect(a);
        let _n: i32 = io.net_send(c, "x");
        let _s: String = io.net_recv(c, 8);
        io.net_close(c);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_trait_static_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl Show for I { fn show(x: I) -> String { return "ok"; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = Show.show(x); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Show$show$0")));
}

fn test_compile_generic_impl_trait_static_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      impl[T] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(7); let s: String = Show.show(v); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Show$show$0$gT_3di32")));
}

fn test_compile_generic_impl_trait_method_sugar_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      impl[T] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(7); let s: String = v.show(); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Show$show$0$gT_3di32")));
}

fn test_compile_impl_specialization_prefers_more_specific_impl_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T] Tag for Vec[T] { fn tag(x: Vec[T]) -> i32 { return 1; } }
      impl Tag for Vec[i32] { fn tag(x: Vec[i32]) -> i32 { return 2; } }
      fn main() -> i32 { let mut vi: Vec[i32] = Vec(); let mut vs: Vec[String] = Vec(); vi.push(7); vs.push("x"); return Tag.tag(vi) + Tag.tag(vs); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Tag$tag$1")));
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Tag$tag$0$gT_3dString")));
}

fn test_compile_impl_specialization_requires_strict_order_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T] Tag for Vec[T] { fn tag(x: Vec[T]) -> i32 { return 1; } }
      impl[U] Tag for Vec[U] { fn tag(x: Vec[U]) -> i32 { return 2; } }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); return Tag.tag(v); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "overlapping impl without strict specialization"));
}

fn test_compile_impl_specialization_prefers_stronger_bounds_and_filters_non_matching_bounds_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T] Tag for T { fn tag(x: T) -> i32 { return 1; } }
      impl[T: Eq] Tag for T { fn tag(x: T) -> i32 { return 2; } }
      fn main() -> i32 { return Tag.tag(7) + Tag.tag("x"); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_impl_specialization_incomparable_bounds_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { fn a(x: Self) -> i32; }
      trait B { fn b(x: Self) -> i32; }
      impl A for i32 { fn a(x: i32) -> i32 { return x; } }
      impl B for i32 { fn b(x: i32) -> i32 { return x; } }
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T: A] Tag for T { fn tag(x: T) -> i32 { return 1; } }
      impl[T: B] Tag for T { fn tag(x: T) -> i32 { return 2; } }
      fn main() -> i32 { return Tag.tag(1); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "overlapping impl without strict specialization"));
}

fn test_compile_generic_impl_bound_rejected_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Mark { fn mark(x: Self) -> bool; }
      trait Show { fn show(x: Self) -> String; }
      impl[T: Mark] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(7); let s: String = Show.show(v); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  let bound_msg: bool = contains(r.err, "does not satisfy trait bound");
  let no_impl_msg: bool = contains(r.err, "no impl for trait call");
  t.assert(bound_msg || no_impl_msg);
  if bound_msg {
    t.assert(contains(r.err, "Mark"));
  } else {
    t.assert(contains(r.err, "Show"));
  }
}

fn test_compile_trait_method_sugar_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl Show for I { fn show(x: I) -> String { return "ok"; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = x.show(); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_trait_default_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String { return "ok"; } }
      struct I { v: i32 }
      impl Show for I {}
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = x.show(); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_trait_default_method_external_trait_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/dep/dep.vox",
    text: """
      fn dep_tag() -> String { return "dep"; }
      pub trait Show { fn show(x: Self) -> String { return dep_tag(); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "dep" as d
      struct I { v: i32 }
      impl d.Show for I {}
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = x.show(); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$dep$Show$show")));
}

fn test_compile_trait_generic_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T; }
      struct I { v: i32 }
      impl Wrap for I { fn wrap[T: Eq](x: I, v: T) -> T { return v; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = Wrap.wrap[i32](x, 7); let b: i32 = I { v: 2 }.wrap[i32](9); return a + b; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_trait_const_generic_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = AddN.addn[3](x, 4); let b: i32 = I { v: 2 }.addn[5](6); return a + b; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$AddN$addn$0$gN_3d3_3ai32")));
  t.assert(contains(r.c, cg.c_fn_name("impl$main$AddN$addn$0$gN_3d5_3ai32")));
}

fn test_compile_trait_const_generic_method_default_const_arg_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32 = 3](x: Self, v: i32) -> i32; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = AddN.addn(x, 4); let b: i32 = I { v: 2 }.addn(6); return a + b; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$AddN$addn$0$gN_3d3_3ai32")));
}

fn test_compile_trait_const_generic_method_comptime_where_rhs_unknown_reports_method_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "\ntrait AddN {\n  fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N < M;\n}\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:3:3:"));
  t.assert(contains(r.err, "unknown const param in comptime where rhs"));
}

fn test_compile_trait_const_generic_method_comptime_where_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N > 0 { return v + N; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return AddN.addn[3](x, 4); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_trait_const_generic_method_comptime_where_impl_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N >= 0 { return v + N; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}

fn test_compile_trait_const_generic_method_comptime_where_rhs_param_impl_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddNM { fn addnm[const N: i32, const M: i32](x: Self, v: i32) -> i32 where comptime N < M; }
      struct I { v: i32 }
      impl AddNM for I { fn addnm[const N: i32, const M: i32](x: I, v: i32) -> i32 where comptime N <= M { return v + N; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}

fn test_compile_trait_const_generic_method_comptime_where_type_layout_impl_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Fit { fn fit[T](x: Self, v: T) -> i32 where comptime @size_of(T) <= 8; }
      struct I { v: i32 }
      impl Fit for I { fn fit[T](x: I, v: T) -> i32 where comptime @size_of(T) <= 16 { return 1; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}

fn test_compile_trait_const_generic_method_default_violates_comptime_where_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32 = 0](x: Self, v: i32) -> i32 where comptime N > 0; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N > 0 { return v + N; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "default violates comptime where"));
}

fn test_compile_trait_const_generic_method_comptime_where_rhs_reflect_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait FitRU {
        fn fit[T, U](x: Self, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U);
      }
      struct I { v: i32 }
      impl FitRU for I {
        fn fit[T, U](x: I, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U) { return 1; }
      }
      fn main() -> i32 { let x: I = I { v: 1 }; let y: i64 = 0; return FitRU.fit(x, 3, y); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_trait_const_generic_method_comptime_where_rhs_reflect_impl_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait FitRU {
        fn fit[T, U](x: Self, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U);
      }
      struct I { v: i32 }
      impl FitRU for I {
        fn fit[T, U](x: I, a: T, b: U) -> i32 where comptime @size_of(T) < @align_of(U) { return 1; }
      }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "@size_of(T) <= @align_of(U)"), r.err);
}

fn test_compile_trait_const_generic_method_impl_name_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const M: i32](x: I, v: i32) -> i32 { return v + M; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl method const param name mismatch"));
}

fn test_compile_trait_const_generic_method_default_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32 = 3](x: Self, v: i32) -> i32; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32 = 4](x: I, v: i32) -> i32 { return v + N; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "default mismatch"));
}

fn test_compile_trait_generic_method_impl_type_param_rename_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T; }
      struct I { v: i32 }
      impl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return Wrap.wrap[i32](x, 7); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_trait_generic_method_impl_type_param_rename_assoc_projection_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Pass { type Item; fn pass[T: Pass](x: Self, v: T.Item) -> T.Item; }
      struct I { v: i32 }
      impl Pass for I { type Item = i32; fn pass[U: Pass](x: I, v: U.Item) -> U.Item { return v; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return Pass.pass[I](x, 7); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_trait_generic_method_impl_type_param_rename_assoc_projection_nested_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Pass { type Item; fn dup[T: Pass](x: Self, v: T.Item) -> Vec[T.Item]; }
      struct I { v: i32 }
      impl Pass for I { type Item = i32; fn dup[U: Pass](x: I, v: U.Item) -> Vec[U.Item] { return Vec(); } }
      fn main() -> i32 { let x: I = I { v: 1 }; let ys: Vec[i32] = Pass.dup[I](x, 7); return ys.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_impl_method_bound_mismatch_reports_missing_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
      pub trait Show { fn show(x: Self) -> String; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Wrap { fn wrap[T: Eq + Show](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl method missing type bound"));
  t.assert(contains(r.err, "Show"));
}

fn test_compile_trait_generic_default_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T { return v; } }
      struct I { v: i32 }
      impl Wrap for I {}
      fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = Wrap.wrap[i32](x, 7); let b: i32 = I { v: 2 }.wrap[i32](9); return a + b; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_supertrait_forward_decl_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait B: A { fn b(x: Self) -> i32; }
      trait A { fn a(x: Self) -> i32; }
      struct I { v: i32 }
      impl A for I { fn a(x: I) -> i32 { return 1; } }
      impl B for I { fn b(x: I) -> i32 { return 2; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return B.b(x) + A.a(x); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_supertrait_impl_requires_parent_impl() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait A { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl B for I { fn b(x: I) -> i32 { return 2; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "requires supertrait A"));
}

fn test_compile_supertrait_cycle_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait A: B { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "supertrait cycle"));
}

fn test_compile_supertrait_cycle_reports_decl_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "\ntrait A: B { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "supertrait cycle"));
}

fn test_compile_supertrait_impl_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { fn a(x: Self) -> i32; }
      trait B: A { fn b(x: Self) -> i32; }
      struct I { v: i32 }
      impl A for I { fn a(x: I) -> i32 { return 1; } }
      impl B for I { fn b(x: I) -> i32 { return 2; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return B.b(x) + A.a(x); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_trait_assoc_type_impl_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Iter { type Item; fn next(x: Self) -> i32; }
      struct I { v: i32 }
      impl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return Iter.next(x); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_trait_assoc_type_projection_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Iter { type Item; fn next(x: Self) -> Self.Item; }
      struct I { v: i32 }
      impl Iter for I { type Item = i32; fn next(x: I) -> Self.Item { return x.v; } }
      fn id[T: Iter](x: T) -> T.Item { return x.next(); }
      fn main() -> i32 { let x: I = I { v: 1 }; let y: i32 = id[I](x); return y; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_trait_assoc_type_projection_infer_local_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Iter { type Item; fn next(x: Self) -> Self.Item; }
      struct I { v: i32 }
      impl Iter for I { type Item = i32; fn next(x: I) -> Self.Item { return x.v; } }
      fn id[T: Iter](x: T) -> T.Item { return x.next(); }
      fn main() -> i32 { let x: I = I { v: 1 }; let y = id[I](x); return y; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_trait_assoc_type_unknown_in_method_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; fn next(x: Self) -> Self.Missing; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "unknown associated type in trait method"));
  t.assert(contains(r.err, "Missing"));
}

fn test_compile_trait_assoc_type_projection_unknown_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait A { fn a(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl A for I { fn a(x: I) -> i32 { return x.v; } }\nfn bad[T: A](x: T) -> T.Item { return 0; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "unknown associated type projection"));
  t.assert(contains(r.err, "T.Item"));
}

fn test_compile_trait_assoc_type_projection_ambiguous_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { type Item; fn a(x: Self) -> i32; }
      trait B { type Item; fn b(x: Self) -> i32; }
      struct I { v: i32 }
      impl A for I { type Item = i32; fn a(x: I) -> i32 { return x.v; } }
      impl B for I { type Item = i32; fn b(x: I) -> i32 { return x.v; } }
      fn bad[T: A + B](x: T) -> T.Item { return x.a(); }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "ambiguous associated type projection"));
  t.assert(contains(r.err, "T.Item"));
}

fn test_compile_trait_assoc_type_impl_missing_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl missing associated type"));
  t.assert(contains(r.err, "Item"));
}

fn test_compile_trait_assoc_type_impl_extra_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl associated type not in trait"));
  t.assert(contains(r.err, "Item"));
}

fn test_compile_trait_assoc_type_duplicate_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "duplicate trait associated type"));
  t.assert(contains(r.err, "Item"));
}

fn test_compile_trait_assoc_type_duplicate_reports_assoc_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter {\n  type Item;\n  type Item;\n  fn next(x: Self) -> i32;\n}\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:3:3:"));
  t.assert(contains(r.err, "duplicate trait associated type"));
}

fn test_compile_impl_assoc_type_duplicate_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; type Item = i64; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "duplicate impl associated type"));
  t.assert(contains(r.err, "Item"));
}

fn test_compile_impl_assoc_type_duplicate_reports_assoc_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I {\n  type Item = i32;\n  type Item = i64;\n  fn next(x: I) -> i32 { return x.v; }\n}\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:5:3:"));
  t.assert(contains(r.err, "duplicate impl associated type"));
}

fn test_compile_trait_method_name_conflicts_assoc_type_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; fn Item(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn Item(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "trait method conflicts with associated type"));
  t.assert(contains(r.err, "Item"));
}

fn test_compile_trait_method_sugar_ambiguous_rejected_with_candidates() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { fn show(x: Self) -> String; }
      trait B { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl A for I { fn show(x: I) -> String { return "a"; } }
      impl B for I { fn show(x: I) -> String { return "b"; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let _s: String = x.show(); return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "ambiguous trait method call"));
  t.assert(contains(r.err, "A.show"));
  t.assert(contains(r.err, "B.show"));
}

fn test_compile_trait_call_unknown_method_rejected_with_candidates() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; fn debug(x: Self) -> String; }
      struct I { v: i32 }
      impl Show for I { fn show(x: I) -> String { return "ok"; } fn debug(x: I) -> String { return "dbg"; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let _s: String = Show.missing(x); return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "unknown trait method"));
  t.assert(contains(r.err, "available methods"));
  t.assert(contains(r.err, "show"));
  t.assert(contains(r.err, "debug"));
}

fn test_compile_orphan_impl_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/dep/dep.vox",
    text: "pub trait Show { fn show(x: Self) -> String; }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"dep\" as d\nimpl d.Show for i32 { fn show(x: i32) -> String { return \"x\"; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "orphan impl is not allowed"));
}

fn test_compile_impl_missing_required_method_reports_candidates() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Show { fn show(x: Self) -> String; fn debug(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I { fn show(x: I) -> String { return \"ok\"; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl missing trait method"));
  t.assert(contains(r.err, "required methods"));
  t.assert(contains(r.err, "show"));
  t.assert(contains(r.err, "debug"));
}

fn test_compile_impl_extra_method_reports_candidates() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Show { fn show(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I { fn show(x: I) -> String { return \"ok\"; } fn debug(x: I) -> String { return \"dbg\"; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl method not in trait"));
  t.assert(contains(r.err, "available methods"));
  t.assert(contains(r.err, "show"));
}

fn test_compile_generic_trait_bound_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      fn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }
      fn main() -> i32 { return if same("a", "b") { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_generic_where_trait_bound_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      fn same[T](a: T, b: T) -> bool where T: Eq { return Eq.eq(a, b); }
      fn main() -> i32 { return if same("a", "b") { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_const_generic_fn_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn[3](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  // C backend mangles IR symbols: '$' -> '_24', '_' -> '_5f'.
  t.assert(contains(r.c, "addn_24gN_5f3d3_5f3ai32"));
}

fn test_compile_const_fn_call_with_pure_member_methods_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn calc() -> i32 {
        let s: String = "abcd";
        let t2: String = s.slice(1, 3).concat("x");
        let n: String = 42.to_string();
        let b: String = true.to_string();
        return t2.len() + t2.byte_at(0) + n.len() + b.len();
      }
      const N: i32 = calc()
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "107"));
}

fn test_compile_const_fn_call_with_escape_and_float_to_string_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn calc() -> i32 {
        let e: String = "\n".escape_c();
        let f: String = 1.5.to_string();
        let g: String = 2.0.to_string();
        return e.len() + f.len() + g.len();
      }
      const N: i32 = calc()
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "6"));
}

fn test_compile_const_fn_call_with_string_predicate_methods_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn calc() -> i32 {
        let s: String = "ab_cd";
        let b0: bool = s.starts_with("ab");
        let b1: bool = s.ends_with("cd");
        let b2: bool = s.contains("_");
        return if b0 && b1 && b2 { 1 } else { 0 };
      }
      const N: i32 = calc()
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "1"));
}

fn test_compile_const_fn_call_with_string_is_empty_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn calc() -> i32 {
        let s0: String = "";
        let s1: String = "x";
        return if s0.is_empty() && !s1.is_empty() { 1 } else { 0 };
      }
      const N: i32 = calc()
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "1"));
}

fn test_compile_const_fn_call_with_string_index_methods_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn calc() -> i32 {
        let s: String = "ab_cd_ab";
        let i0: i32 = s.index_of("ab");
        let i1: i32 = s.last_index_of("ab");
        let i2: i32 = s.index_of("zz");
        return i0 + i1 + i2;
      }
      const N: i32 = calc()
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "5"));
}

fn test_compile_const_fn_call_member_method_oob_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn bad() -> i32 {
        let s: String = "ab";
        return s.byte_at(2);
      }
      const N: i32 = bad()
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "string index out of bounds"));
}

fn test_compile_const_generic_fn_forwards_const_param_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn wrap[const N: i32](x: i32) -> i32 { return addn[N](x); }\nfn main() -> i32 { return wrap[3](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "wrap_24gN_5f3d3_5f3ai32"));
  t.assert(contains(r.c, "addn_24gN_5f3d3_5f3ai32"));
}

fn test_compile_const_generic_fn_forwards_const_param_with_comptime_where_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0 { return x + N; }\nfn wrap[const N: i32](x: i32) -> i32 { return addn[N](x); }\nfn main() -> i32 { return wrap[3](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_forwards_const_param_with_comptime_where_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0 { return x + N; }\nfn wrap[const N: i32](x: i32) -> i32 { return addn[N](x); }\nfn main() -> i32 { return wrap[0](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "constraint failed"));
}

fn test_compile_const_generic_fn_comptime_where_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0, comptime N <= 8 { return x + N; }\nfn main() -> i32 { return addn[3](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0, comptime N <= 8 { return x + N; }\nfn main() -> i32 { return addn[0](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "constraint failed"));
}

fn test_compile_const_generic_fn_comptime_where_rhs_param_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addnm[const N: i32, const M: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return addnm[3, 5](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_rhs_param_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addnm[const N: i32, const M: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return addnm[5, 3](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "constraint failed"));
}

fn test_compile_const_generic_fn_comptime_where_rhs_unknown_reports_decl_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "\n\nfn addnm[const N: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:3:1:"));
  t.assert(contains(r.err, "unknown const param in comptime where rhs"));
}

fn test_compile_const_generic_fn_comptime_where_type_layout_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn fit[T](x: T) -> i32 where comptime @size_of(T) <= 8, comptime @align_of(T) <= 8 { return 7; }\nfn main() -> i32 { return fit(3); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_type_layout_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Big { a: i64, b: i64 }\nfn fit[T](x: T) -> i32 where comptime @size_of(T) <= 8 { return 7; }\nfn main() -> i32 { return fit(Big { a: 1, b: 2 }); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "@size_of(T) <= 8"));
}

fn test_compile_const_generic_fn_comptime_where_type_layout_rhs_param_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn fit[T, const LIM: i32](x: T) -> i32 where comptime @size_of(T) <= LIM { return 7; }\nfn main() -> i32 { return fit[8](3); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_field_count_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Pair { a: i32, b: i32 }\nfn fit[T](x: T) -> i32 where comptime @field_count(T) <= 2 { return 7; }\nfn main() -> i32 { let p: Pair = Pair { a: 1, b: 2 }; return fit(p); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_field_count_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Triple { a: i32, b: i32, c: i32 }\nfn fit[T](x: T) -> i32 where comptime @field_count(T) <= 2 { return 7; }\nfn main() -> i32 { let t0: Triple = Triple { a: 1, b: 2, c: 3 }; return fit(t0); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "@field_count(T) <= 2"));
}

fn test_compile_const_generic_fn_comptime_where_type_id_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn fit[T](x: T) -> i32 where comptime @type(T) > 0 { return 7; }\nfn main() -> i32 { return fit(3); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_type_id_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn fit[T](x: T) -> i32 where comptime @type(T) < 0 { return 7; }\nfn main() -> i32 { return fit(3); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "@type(T) < 0"));
}

fn test_compile_const_generic_fn_comptime_where_rhs_reflect_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn fit[T, U](x: T, y: U) -> i32 where comptime @size_of(T) <= @align_of(U) { return 7; }\nfn main() -> i32 { let y: i64 = 0; return fit(3, y); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_rhs_reflect_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn fit[T, U](x: T, y: U) -> i32 where comptime @size_of(T) <= @align_of(U) { return 7; }\nfn main() -> i32 { let y: u8 = 0; let x: i64 = 1; return fit(x, y); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "@size_of(T) <= @align_of(U)"));
}

fn test_compile_generic_struct_comptime_where_type_layout_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Small[T] where comptime @size_of(T) <= 8, comptime @align_of(T) <= 8 { v: T }\nfn main() -> i32 { let s: Small[i32] = Small[i32] { v: 7 }; return s.v; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_generic_struct_comptime_where_type_layout_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Big { a: i64, b: i64 }\nstruct Small[T] where comptime @size_of(T) <= 8 { v: T }\nfn main() -> i32 { let b: Big = Big { a: 1, b: 2 }; let s: Small[Big] = Small[Big] { v: b }; return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "type resolve failed in let annotation"), r.err);
}

fn test_compile_generic_enum_comptime_where_type_layout_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "enum Tiny[T] where comptime @size_of(T) <= 8 { V(T) }\nfn main() -> i32 { let x: Tiny[i32] = Tiny[i32].V(7); return match x { Tiny.V(v) => v }; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_generic_enum_comptime_where_type_layout_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Big { a: i64, b: i64 }\nenum Tiny[T] where comptime @size_of(T) <= 8 { V(T) }\nfn main() -> i32 { let b: Big = Big { a: 1, b: 2 }; let x: Tiny[Big] = Tiny[Big].V(b); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "type resolve failed in let annotation"), r.err);
}

fn test_compile_const_generic_fn_default_violates_comptime_where_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32 = 0](x: i32) -> i32 where comptime N > 0 { return x + N; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "default violates comptime where"));
}

fn test_compile_const_generic_fn_default_const_arg_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn(4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "addn_24gN_5f3d3_5f3ai32"));
}

fn test_compile_const_generic_fn_default_const_arg_override_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { let a: i32 = addn(4); let b: i32 = addn[9](4); return a + b; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "addn_24gN_5f3d3_5f3ai32"));
  t.assert(contains(r.c, "addn_24gN_5f3d9_5f3ai32"));
}

fn test_compile_const_generic_fn_missing_const_arg_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn(4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_generic_fn_body_checked_without_instantiation() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn bad[T](x: T) -> T { let y: i32 = x; return x; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_generic_impl_method_body_checked_without_instantiation() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Boxed { fn id[T](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Boxed for I { fn id[T](x: I, v: T) -> T { let y: i32 = v; return v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_generic_default_method_body_checked_without_instantiation() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Boxed { fn id[T](x: Self, v: T) -> T { let y: i32 = v; return v; } }\nstruct I { v: i32 }\nimpl Boxed for I {}\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_generic_bound_trait_static_call_in_body_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_generic_bound_trait_method_sugar_in_body_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
      fn f[T: Show](x: T) -> String { return x.show(); }
      fn main() -> i32 { let s: String = f(7); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_generic_bound_trait_method_sugar_generic_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      trait Wrap { fn wrap[U: Eq](x: Self, v: U) -> U; }
      struct I { v: i32 }
      impl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }
      fn f[T: Wrap](x: T) -> i32 { return x.wrap[i32](7); }
      fn main() -> i32 { let x: I = I { v: 1 }; return f(x); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_generic_bound_trait_method_sugar_supertrait_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      trait Wrap: Show { fn id(x: Self) -> Self; }
      struct I { v: i32 }
      impl Show for I { fn show(x: I) -> String { return "ok"; } }
      impl Wrap for I { fn id(x: I) -> I { return x; } }
      fn f[T: Wrap](x: T) -> String { return x.show(); }
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = f(x); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_generic_bound_trait_method_sugar_missing_bound_method_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn f[T: Eq](x: T) -> String { return x.show(); }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "trait method not in bounds"));
  t.assert(contains(r.err, "Eq"));
}

fn test_compile_generic_bound_trait_method_sugar_ambiguous_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { fn show(x: Self) -> String; }
      trait B { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl A for I { fn show(x: I) -> String { return "a"; } }
      impl B for I { fn show(x: I) -> String { return "b"; } }
      fn f[T: A + B](x: T) -> String { return x.show(); }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "ambiguous trait method call"));
  t.assert(contains(r.err, "A.show"));
  t.assert(contains(r.err, "B.show"));
}

fn test_compile_prelude_trait_fallback_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
      pub trait Show { fn show(x: Self) -> String; }
      impl Eq for String { fn eq(a: String, b: String) -> bool { return a == b; } }
      impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 {\n  let s: String = Show.show(7);\n  if Eq.eq(s, \"7\") { return 1; }\n  return 0;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_prelude_trait_default_method_fallback_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "fn tag() -> String { return \"pre\"; }\npub trait Show { fn show(x: Self) -> String { return tag(); } }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct I { v: i32 }\nimpl Show for I {}\nfn main() -> i32 { let s: String = I { v: 1 }.show(); return s.len(); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("std.prelude::tag")));
}

fn test_compile_u64_max_literal_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const X: u64 = 18446744073709551615\nfn main() -> i32 { if X > 1 { return 1; } return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_merges_multi_files_in_root_module() -> () {
  // Both files are under src/, so they belong to the same root module ("main").
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/helper.vox", text: "fn helper() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return helper(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_merges_multi_files_in_same_submodule() -> () {
  // Both files are under src/a/, so they belong to the same module "a" and can share private symbols.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/x.vox", text: "fn hidden() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/a/y.vox", text: "pub fn one() -> i32 { return hidden(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a\" as a\nfn main() -> i32 { return a.one(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_external_tests_cannot_call_private() -> () {
  // tests/** runs in a separate "tests" module; it must not access private symbols from src/**.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/a.vox", text: "pub fn one() -> i32 { return hidden(); }\nfn hidden() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return 0; }" });
  fs.push(ld.SourceFile { path: "tests/basic.vox", text: "import \"a\" as a\nfn test_private_is_not_accessible() -> () { a.hidden(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_pub_crate_visible_inside_src_but_hidden_from_tests() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/a.vox", text: "pub(crate) fn hidden() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/b/b.vox", text: "import \"a\" as a\npub fn call_hidden() -> i32 { return a.hidden(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"b\" as b\nfn main() -> i32 { return b.call_hidden(); }" });
  fs.push(ld.SourceFile { path: "tests/basic.vox", text: "import \"a\" as a\nfn test_pub_crate_not_visible_from_tests() -> () { a.hidden(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_pub_super_visible_in_parent_scope_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/b/c/c.vox", text: "pub(super) fn only_parent_scope() -> i32 { return 7; }" });
  fs.push(ld.SourceFile { path: "src/a/b/use.vox", text: "import \"a/b/c\" as c\npub fn ok() -> i32 { return c.only_parent_scope(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a/b\" as ab\nfn main() -> i32 { return ab.ok(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_pub_super_hidden_outside_parent_scope() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/b/c/c.vox", text: "pub(super) fn only_parent_scope() -> i32 { return 7; }" });
  fs.push(ld.SourceFile { path: "src/a/d/use.vox", text: "import \"a/b/c\" as c\npub fn bad() -> i32 { return c.only_parent_scope(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a/d\" as ad\nfn main() -> i32 { return ad.bad(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_rejects_user_call_to_reserved_intrinsic() -> () {
  // `__*` intrinsics are reserved for std/** modules only.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { __read_file(\"x\"); return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_rejects_user_defines_reserved_name() -> () {
  // Users must not define `__*` names.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn __x() -> i32 { return 0; }\nfn main() -> i32 { return __x(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_codegen_no_symbol_collision_between_pkg_and_plain_names() -> () {
  // Ensure C backend name mangling stays collision-free:
  // local: dep__one (unqualified)
  // dep package: pkg.dep::one
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"dep\" as dep\nfn dep__one() -> i32 { return 1; }\nfn main() -> i32 { return dep__one() + dep.one(); }" });
  fs.push(ld.SourceFile { path: "dep/src/dep.vox", text: "pub fn one() -> i32 { return 2; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("dep__one")));
  t.assert(contains(r.c, cg.c_fn_name("pkg.dep::one")));
}

fn test_compile_imports_are_file_local() -> () {
  // Imports must be file-local (Go-like). Importing in a.vox should not enable
  // using that namespace in main.vox.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a.vox", text: "import \"dep\" as dep\nfn ok() -> i32 { return dep.one(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return dep.one(); }" });
  fs.push(ld.SourceFile { path: "dep/src/dep.vox", text: "pub fn one() -> i32 { return 1; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_rejects_duplicate_import_alias_in_file() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/a.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/b/b.vox", text: "pub fn one() -> i32 { return 2; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a\" as x\nimport \"b\" as x\nfn main() -> i32 { return x.one(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "duplicate import alias"));
  t.assert(contains(r.err, "[E_IMPORT_0004]"));
}

fn test_compile_duplicate_named_import_reports_line() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn one() -> i32 { return 1; }\npub fn two() -> i32 { return 2; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { one as x, two as x } from \"dep\"\nfn main() -> i32 { return x(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:1:"));
  t.assert(contains(r.err, "duplicate imported name"));
  t.assert(contains(r.err, "[E_IMPORT_0005]"));
}

fn test_compile_type_error_has_file_line_col_prefix() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  // Put the error at a stable location: line 2, col 1.
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 {\nnope();\nreturn 0;\n}" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "[E_TYPE_0001]"));
  t.assert(r.err_kind == c.compile_diag_kind_type());
  t.assert(r.err_code == "E_TYPE_0001");
  t.assert(contains(r.err_message, "unknown fn"));
}

fn test_compile_macroexpand_error_has_kind_and_code() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return compile!(1, 2); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(r.err_kind == c.compile_diag_kind_macroexpand());
  t.assert(r.err_code == "E_MACROEXPAND_0001");
  t.assert(contains(r.err_message, "compile! expects exactly one value arg"));
  t.assert(contains(r.err, "[E_MACROEXPAND_0001]"));
}

fn test_compile_const_error_uses_expr_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "\n\nconst N: i32 = 1 / 0\nfn main() -> i32 { return N; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:3:"));
  t.assert(contains(r.err, "const division by zero"));
  t.assert(contains(r.err, "[E_TYPE_0001]"));
}

fn test_compile_type_error_column_uses_rune_index() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 {\n\"\"; nope();\nreturn 0;\n}" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:6:"));
  t.assert(contains(r.err, "[E_TYPE_0001]"));
}

fn test_compile_duplicate_trait_reports_decl_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "trait A {}\ntrait A {}\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "duplicate trait"));
}

fn test_compile_irgen_missing_return_reports_fn_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "\nfn helper() -> i32 {\nlet x: i32 = 1;\n}\nfn main() -> i32 { return helper(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "irgen error: missing return"));
  t.assert(contains(r.err, "[E_IRGEN_0001]"));
}

fn test_compile_type_error_message_includes_reason() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 {\nnope();\nreturn 0;\n}" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "unknown fn"));
  t.assert(contains(r.err, "nope"));
}

fn test_compile_parse_error_includes_code() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return 0; }\nelse" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "[E_PARSE_0001]"));
  t.assert(r.err_kind == c.compile_diag_kind_parse());
  t.assert(r.err_code == "E_PARSE_0001");
  t.assert(contains(r.err_message, "unexpected token"));
}

fn test_compile_lex_error_includes_code_and_rune_col() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return 0; }\n\"\"#" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:4:"));
  t.assert(contains(r.err, "[E_LEX_0001]"));
  t.assert(r.err_kind == c.compile_diag_kind_lex());
  t.assert(r.err_code == "E_LEX_0001");
  t.assert(contains(r.err_message, "lex error"));
}

fn test_compile_loader_error_meta() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "README.vox", text: "fn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(r.err_kind == c.compile_diag_kind_loader());
  t.assert(r.err_code == "E_LOAD_0001");
}

fn test_compile_ambiguous_import_requires_scheme() -> () {
  // If a local module `dep` and a dependency package `dep` both exist,
  // plain `import "dep"` is ambiguous and must be disambiguated with `pkg:` or `mod:`.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "dep/src/dep.vox", text: "pub fn one() -> i32 { return 2; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"dep\" as dep\nfn main() -> i32 { return dep.one(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:1:1:"));
  t.assert(contains(r.err, "ambiguous import"));
  t.assert(contains(r.err, "[E_IMPORT_0003]"));
  t.assert(r.err_kind == c.compile_diag_kind_import());
  t.assert(r.err_code == "E_IMPORT_0003");
}

fn test_compile_pkg_scheme_disambiguates_import() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "dep/src/dep.vox", text: "pub fn one() -> i32 { return 2; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"pkg:dep\" as dep\nfn main() -> i32 { return dep.one(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("pkg.dep::one")));
}
