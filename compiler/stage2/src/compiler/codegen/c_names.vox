import "compiler/ir" as ir

fn is_alpha_num(ch: i32) -> bool {
  return (ch >= 97 && ch <= 122) || (ch >= 65 && ch <= 90) || (ch >= 48 && ch <= 57);
}

fn is_ident_char(ch: i32) -> bool {
  return is_alpha_num(ch) || ch == 95; // '_'
}

fn hex2(ch: i32) -> String {
  let hex: String = "0123456789abcdef";
  // `byte_at` returns 0..255 (stage0), so plain division/mod is enough.
  let b: i32 = ch;
  let hi: i32 = b / 16;
  let lo: i32 = b % 16;
  return hex.slice(hi, hi + 1).concat(hex.slice(lo, lo + 1));
}

pub fn c_ident(s: String) -> String {
  // Best-effort sanitization: keep [A-Za-z0-9_], map others to '_'.
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < s.len() {
    let mut ch: i32 = s.byte_at(i);
    let ok: bool = is_ident_char(ch);
    if !ok { ch = 95; }
    if i == 0 && (ch >= 48 && ch <= 57) { out = out.concat("_"); }
    if ok { out = out.concat(s.slice(i, i + 1)); }
    else { out = out.concat("_"); }
    i = i + 1;
  }
  if out == "" { return "_"; }
  return out;
}

pub fn c_mangle(s: String) -> String {
  // Collision-free mangling for qualified names.
  // Keep [A-Za-z0-9] as-is, hex-escape everything else (including '_').
  let mut out: String = "m";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    if is_alpha_num(ch) {
      out = out.concat(s.slice(i, i + 1));
    } else {
      out = out.concat("_").concat(hex2(ch));
    }
    i = i + 1;
  }
  return out;
}

pub fn c_fn_name(name: String) -> String { return "vox_fn_".concat(c_mangle(name)); }
pub fn c_label_name(name: String) -> String { return "vox_blk_".concat(c_ident(name)); }
pub fn c_struct_type_name(name: String) -> String { return "vox_struct_".concat(c_mangle(name)); }
pub fn c_enum_type_name(name: String) -> String { return "vox_enum_".concat(c_mangle(name)); }

pub fn c_param_name(i: i32) -> String { return "p".concat(i.to_string()); }
pub fn c_temp_name(id: i32) -> String { return "t".concat(id.to_string()); }
pub fn c_slot_name(id: i32) -> String { return "v".concat(id.to_string()); }

pub fn ty_qname(t: ir.Ty) -> String {
  if t.mod_path == "" || t.mod_path == "main" { return t.name; }
  let mut s: String = t.mod_path;
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 47 { // '/'
      s = s.slice(0, i).concat(".").concat(s.slice(i + 1, s.len()));
    }
    i = i + 1;
  }
  return s.concat("::").concat(t.name);
}
