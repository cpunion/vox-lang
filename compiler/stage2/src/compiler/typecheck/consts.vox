import "compiler/ast" as ast
import "compiler/ir" as ir

struct ConstItem { mod_path: String, decl: ast.ConstDecl }

fn const_qname(mod_path: String, name: String) -> String { return mod_path.concat("::").concat(name); }

fn const_find_item(items: Vec[ConstItem], mod_path: String, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < items.len() {
    let it: ConstItem = items.get(i);
    if it.mod_path == mod_path && it.decl.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn const_set_sig_at(xs0: Vec[ConstSig], idx: i32, val: ConstSig) -> Vec[ConstSig] {
  let mut xs: Vec[ConstSig] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    xs.push(if i == idx { val } else { xs0.get(i) });
    i = i + 1;
  }
  return xs;
}

fn const_contains_str(xs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn join_mod_path(base: String, segs: Vec[String]) -> String {
  let mut out: String = base;
  let mut i: i32 = 0;
  while i < segs.len() {
    out = out.concat("/").concat(segs.get(i));
    i = i + 1;
  }
  return out;
}

struct EvalConstExprResult { ok: bool, err: TcError, kind: i32, ty: i32, iv: i64, bv: bool, sv: String, sigs: Vec[ConstSig], states: Vec[i32] }
struct ResolveConstResult { ok: bool, err: TcError, sigs: Vec[ConstSig], states: Vec[i32], ctx: Ctx }

fn is_int_scalar_kind(k: ir.TyKind) -> bool {
  return match k {
    ir.TyKind.I8 => true,
    ir.TyKind.U8 => true,
    ir.TyKind.I16 => true,
    ir.TyKind.U16 => true,
    ir.TyKind.I32 => true,
    ir.TyKind.U32 => true,
    ir.TyKind.I64 => true,
    ir.TyKind.U64 => true,
    ir.TyKind.ISize => true,
    ir.TyKind.USize => true,
    _ => false,
  };
}

fn is_signed_int_kind(k: ir.TyKind) -> bool {
  return match k { ir.TyKind.I8 => true, ir.TyKind.I16 => true, ir.TyKind.I32 => true, ir.TyKind.I64 => true, ir.TyKind.ISize => true, _ => false };
}

fn is_unsigned_int_kind(k: ir.TyKind) -> bool {
  return match k { ir.TyKind.U8 => true, ir.TyKind.U16 => true, ir.TyKind.U32 => true, ir.TyKind.U64 => true, ir.TyKind.USize => true, _ => false };
}

fn int_bits_of_kind(k: ir.TyKind) -> i64 {
  return match k {
    ir.TyKind.I8 => 8,
    ir.TyKind.U8 => 8,
    ir.TyKind.I16 => 16,
    ir.TyKind.U16 => 16,
    ir.TyKind.I32 => 32,
    ir.TyKind.U32 => 32,
    ir.TyKind.I64 => 64,
    ir.TyKind.U64 => 64,
    ir.TyKind.ISize => 64,
    ir.TyKind.USize => 64,
    _ => 0,
  };
}

fn int_kind(ctx: Ctx, ty: i32) -> ir.TyKind {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  return t.kind;
}

fn is_float_scalar_ty(ctx: Ctx, ty: i32) -> bool {
  let b: i32 = strip_range(ctx, ty);
  return b == ctx.ty_f32 || b == ctx.ty_f64;
}

fn is_digit_byte(b: i32) -> bool { return b >= 48 && b <= 57; }

struct ParseSignedI32Result { ok: bool, val: i32 }

fn zeros_text(n: i32) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < n {
    out = out.concat("0");
    i = i + 1;
  }
  return out;
}

pub fn float_suffix_kind_text(s: String) -> i32 {
  // 0 = none, 32 = f32, 64 = f64
  if s.len() < 3 { return 0; }
  if s.byte_at(s.len() - 3) != 102 { return 0; } // 'f'
  let b1: i32 = s.byte_at(s.len() - 2);
  let b2: i32 = s.byte_at(s.len() - 1);
  if b1 == 51 && b2 == 50 { return 32; } // f32
  if b1 == 54 && b2 == 52 { return 64; } // f64
  return 0;
}

pub fn float_strip_suffix_text(s: String) -> String {
  let k: i32 = float_suffix_kind_text(s);
  if k == 0 { return s; }
  return s.slice(0, s.len() - 3);
}

fn parse_signed_i32_dec(s: String) -> ParseSignedI32Result {
  if s.len() == 0 { return ParseSignedI32Result { ok: false, val: 0 }; }
  let mut i: i32 = 0;
  let mut neg: bool = false;
  if s.byte_at(0) == 45 { neg = true; i = 1; } else if s.byte_at(0) == 43 { i = 1; }
  if i >= s.len() { return ParseSignedI32Result { ok: false, val: 0 }; }
  let ds: String = s.slice(i, s.len());
  let pr: ParseI32DecResult = parse_i32_dec(ds);
  if !pr.ok { return ParseSignedI32Result { ok: false, val: 0 }; }
  if neg { return ParseSignedI32Result { ok: true, val: -pr.val }; }
  return ParseSignedI32Result { ok: true, val: pr.val };
}

fn float_norm_text(s0: String) -> String {
  // Canonical form used for const float equality:
  // - optional leading '-'
  // - at least one digit before dot
  // - at least one digit after dot
  // - trim leading zeros in integer part and trailing zeros in fraction.
  // Also accepts exponent (`1e3`, `1.2e-3`) and suffix (`f32`/`f64`).
  let mut s: String = float_strip_suffix_text(s0);
  let mut neg: bool = false;
  if s.len() > 0 && s.byte_at(0) == 45 { // '-'
    neg = true;
    s = s.slice(1, s.len());
  }

  // Split exponent part if present.
  let mut exp_shift: i32 = 0;
  let mut epos: i32 = -1;
  let mut ei: i32 = 0;
  while ei < s.len() {
    let b: i32 = s.byte_at(ei);
    if b == 101 || b == 69 { // 'e' / 'E'
      epos = ei;
      ei = s.len();
    } else {
      ei = ei + 1;
    }
  }
  if epos != -1 {
    let expt: String = s.slice(epos + 1, s.len());
    let pr: ParseSignedI32Result = parse_signed_i32_dec(expt);
    if pr.ok {
      exp_shift = pr.val;
      s = s.slice(0, epos);
    }
  }

  let mut dot: i32 = -1;
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 46 { dot = i; }
    i = i + 1;
  }
  let mut intp: String = "";
  let mut frac: String = "";
  if dot == -1 { intp = s; } else { intp = s.slice(0, dot); frac = s.slice(dot + 1, s.len()); }
  if intp.len() == 0 { intp = "0"; }

  // Re-scale by exponent by moving decimal point.
  let mut digits: String = intp.concat(frac);
  if digits.len() == 0 { digits = "0"; }
  let shift: i32 = exp_shift - frac.len();
  if shift >= 0 {
    intp = digits.concat(zeros_text(shift));
    frac = "0";
  } else {
    let split: i32 = digits.len() + shift; // shift is negative
    if split <= 0 {
      intp = "0";
      frac = zeros_text(-split).concat(digits);
    } else {
      intp = digits.slice(0, split);
      frac = digits.slice(split, digits.len());
    }
  }
  if frac.len() == 0 { frac = "0"; }

  // trim int leading zeros
  let mut ii: i32 = 0;
  while ii < intp.len() && intp.byte_at(ii) == 48 { ii = ii + 1; }
  if ii >= intp.len() { intp = "0"; } else { intp = intp.slice(ii, intp.len()); }

  // trim frac trailing zeros
  let mut fj: i32 = frac.len() - 1;
  while fj >= 0 && frac.byte_at(fj) == 48 { fj = fj - 1; }
  if fj < 0 { frac = "0"; } else { frac = frac.slice(0, fj + 1); }

  let mut out: String = intp.concat(".").concat(frac);
  if out == "0.0" { return "0.0"; }
  if neg { out = "-".concat(out); }
  return out;
}

fn float_neg_text(s: String) -> String {
  let n: String = float_norm_text(s);
  if n == "0.0" { return n; }
  if n.len() > 0 && n.byte_at(0) == 45 { return n.slice(1, n.len()); }
  return "-".concat(n);
}

fn string_cmp_text(a: String, b: String) -> i32 {
  if a == b { return 0; }
  let mut i: i32 = 0;
  let n: i32 = if a.len() < b.len() { a.len() } else { b.len() };
  while i < n {
    let ba: i32 = a.byte_at(i);
    let bb: i32 = b.byte_at(i);
    if ba < bb { return -1; }
    if ba > bb { return 1; }
    i = i + 1;
  }
  return if a.len() < b.len() { -1 } else { 1 };
}

fn signed_min_of_kind(k: ir.TyKind) -> i64 {
  if k == ir.TyKind.I8 { return -128; }
  if k == ir.TyKind.I16 { return -32768; }
  if k == ir.TyKind.I32 { return -2147483647 - 1; }
  return -9223372036854775807 - 1;
}

fn signed_max_of_kind(k: ir.TyKind) -> i64 {
  if k == ir.TyKind.I8 { return 127; }
  if k == ir.TyKind.I16 { return 32767; }
  if k == ir.TyKind.I32 { return 2147483647; }
  return 9223372036854775807;
}

fn unsigned_max_bits_of_kind(k: ir.TyKind) -> i64 {
  if k == ir.TyKind.U8 { return 255; }
  if k == ir.TyKind.U16 { return 65535; }
  if k == ir.TyKind.U32 { return 4294967295; }
  // u64/usize max as full 64-bit ones.
  return -1;
}

fn u64_lt_bits(a: i64, b: i64) -> bool {
  let an: bool = a < 0;
  let bn: bool = b < 0;
  if an != bn {
    return !an && bn;
  }
  return a < b;
}

fn u64_le_bits(a: i64, b: i64) -> bool {
  return !u64_lt_bits(b, a);
}

fn u64_div_bits(a0: i64, b0: i64) -> i64 {
  // Bit-by-bit long division on u64 values represented as i64 bit patterns.
  let mut a: i64 = a0;
  let b: i64 = b0;
  let mut q: i64 = 0;
  let mut rem: i64 = 0;
  let mut i: i32 = 0;
  while i < 64 {
    let top1: bool = a < 0;
    rem = rem << 1;
    if top1 { rem = rem | 1; }
    a = a << 1;
    q = q << 1;
    if !u64_lt_bits(rem, b) {
      rem = rem - b;
      q = q | 1;
    }
    i = i + 1;
  }
  return q;
}

fn u64_mod_bits(a0: i64, b0: i64) -> i64 {
  let mut a: i64 = a0;
  let b: i64 = b0;
  let mut rem: i64 = 0;
  let mut i: i32 = 0;
  while i < 64 {
    let top1: bool = a < 0;
    rem = rem << 1;
    if top1 { rem = rem | 1; }
    a = a << 1;
    if !u64_lt_bits(rem, b) {
      rem = rem - b;
    }
    i = i + 1;
  }
  return rem;
}

fn wrap_signed_i8(v: i64) -> i64 {
  let m: i64 = 256;
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  if x >= 128 { x = x - m; }
  return x;
}

fn wrap_unsigned_u8(v: i64) -> i64 {
  let m: i64 = 256;
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  return x;
}

fn wrap_signed_i16(v: i64) -> i64 {
  let m: i64 = 65536;
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  if x >= 32768 { x = x - m; }
  return x;
}

fn wrap_unsigned_u16(v: i64) -> i64 {
  let m: i64 = 65536;
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  return x;
}

fn wrap_signed_i32(v: i64) -> i64 {
  let m: i64 = 4294967296; // 2^32
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  if x >= 2147483648 { x = x - m; } // 2^31
  return x;
}

fn wrap_unsigned_u32(v: i64) -> i64 {
  let m: i64 = 4294967296; // 2^32
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  return x;
}

struct WrapResult { ok: bool, err: TcError, v: i64 }

fn wrap_value_for_type(ctx: Ctx, file: String, ty: i32, v: i64) -> WrapResult {
  let k: ir.TyKind = int_kind(ctx, ty);
  if !is_int_scalar_kind(k) { return WrapResult { ok: false, err: type_error(file, "expected int type"), v: 0 }; }
  if k == ir.TyKind.I8 { return WrapResult { ok: true, err: TcError.None, v: wrap_signed_i8(v) }; }
  if k == ir.TyKind.U8 { return WrapResult { ok: true, err: TcError.None, v: wrap_unsigned_u8(v) }; }
  if k == ir.TyKind.I16 { return WrapResult { ok: true, err: TcError.None, v: wrap_signed_i16(v) }; }
  if k == ir.TyKind.U16 { return WrapResult { ok: true, err: TcError.None, v: wrap_unsigned_u16(v) }; }
  if k == ir.TyKind.I32 { return WrapResult { ok: true, err: TcError.None, v: wrap_signed_i32(v) }; }
  if k == ir.TyKind.U32 { return WrapResult { ok: true, err: TcError.None, v: wrap_unsigned_u32(v) }; }
  if k == ir.TyKind.I64 || k == ir.TyKind.ISize { return WrapResult { ok: true, err: TcError.None, v: v }; }
  if k == ir.TyKind.U64 || k == ir.TyKind.USize { return WrapResult { ok: true, err: TcError.None, v: v }; }
  return WrapResult { ok: false, err: type_error(file, "expected int type"), v: 0 };
}

struct CastConstResult { ok: bool, err: TcError, v: i64 }

fn cast_const_int_checked(ctx: Ctx, file: String, from_ty: i32, to_ty: i32, v: i64) -> CastConstResult {
  let fk: ir.TyKind = int_kind(ctx, from_ty);
  let tk: ir.TyKind = int_kind(ctx, to_ty);
  if !is_int_scalar_kind(fk) || !is_int_scalar_kind(tk) {
    return CastConstResult { ok: false, err: type_error(file, "const expression: int cast overflow"), v: 0 };
  }

  let msg: String = if (fk == ir.TyKind.I64 || fk == ir.TyKind.ISize) && tk == ir.TyKind.I32 { "const expression: i64 to i32 overflow" } else { "const expression: int cast overflow" };

  let wr_from: WrapResult = wrap_value_for_type(ctx, file, from_ty, v);
  if !wr_from.ok { return CastConstResult { ok: false, err: wr_from.err, v: 0 }; }
  let x: i64 = wr_from.v;

  if is_signed_int_kind(fk) {
    if is_signed_int_kind(tk) {
      let lo: i64 = signed_min_of_kind(tk);
      let hi: i64 = signed_max_of_kind(tk);
      if x < lo || x > hi { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
      let wr_to: WrapResult = wrap_value_for_type(ctx, file, to_ty, x);
      if !wr_to.ok { return CastConstResult { ok: false, err: wr_to.err, v: 0 }; }
      return CastConstResult { ok: true, err: TcError.None, v: wr_to.v };
    }
    if x < 0 { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
    let umax0: i64 = unsigned_max_bits_of_kind(tk);
    if u64_lt_bits(umax0, x) { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
    let wr_to0: WrapResult = wrap_value_for_type(ctx, file, to_ty, x);
    if !wr_to0.ok { return CastConstResult { ok: false, err: wr_to0.err, v: 0 }; }
    return CastConstResult { ok: true, err: TcError.None, v: wr_to0.v };
  }

  // from unsigned
  if is_signed_int_kind(tk) {
    let smax: i64 = signed_max_of_kind(tk);
    if u64_lt_bits(smax, x) { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
    let wr_to1: WrapResult = wrap_value_for_type(ctx, file, to_ty, x);
    if !wr_to1.ok { return CastConstResult { ok: false, err: wr_to1.err, v: 0 }; }
    return CastConstResult { ok: true, err: TcError.None, v: wr_to1.v };
  }
  let umax: i64 = unsigned_max_bits_of_kind(tk);
  if u64_lt_bits(umax, x) { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
  let wr_to2: WrapResult = wrap_value_for_type(ctx, file, to_ty, x);
  if !wr_to2.ok { return CastConstResult { ok: false, err: wr_to2.err, v: 0 }; }
  return CastConstResult { ok: true, err: TcError.None, v: wr_to2.v };
}

struct ConstLocal { name: String, mutable: bool, kind: i32, ty: i32, iv: i64, bv: bool, sv: String }

fn const_find_local(locals: Vec[ConstLocal], name: String) -> i32 {
  // Block const evaluation allows shadowing; resolve from innermost binding.
  let mut i: i32 = locals.len() - 1;
  while i >= 0 {
    if locals.get(i).name == name { return i; }
    i = i - 1;
  }
  return -1;
}

fn is_const_generic_arg_tn_or_const_local(tn: ast.TypeName, locals: Vec[ConstLocal]) -> bool {
  if is_const_generic_arg_tn(tn) { return true; }
  if tn.parts.len() != 1 || tn.args.len() != 0 { return false; }
  return const_find_local(locals, tn.parts.get(0)) != -1;
}

fn parse_const_generic_arg_in_const_locals(
  ctx: Ctx,
  tn: ast.TypeName,
  want_ty: i32,
  locals: Vec[ConstLocal]
) -> ParseConstGenericArgResult {
  let pr: ParseConstGenericArgResult = parse_const_generic_arg(ctx, tn, want_ty);
  if pr.ok { return pr; }

  if tn.parts.len() != 1 || tn.args.len() != 0 {
    return ParseConstGenericArgResult { ok: false, iv: 0, text: "" };
  }
  let name: String = tn.parts.get(0);
  let li: i32 = const_find_local(locals, name);
  if li == -1 {
    return ParseConstGenericArgResult { ok: false, iv: 0, text: name };
  }
  let lv: ConstLocal = locals.get(li);
  if lv.kind != const_kind_int() {
    return ParseConstGenericArgResult { ok: false, iv: 0, text: name };
  }
  let bty: i32 = strip_range(ctx, want_ty);
  if !is_int_like_ty(ctx, bty) {
    return ParseConstGenericArgResult { ok: false, iv: 0, text: name };
  }
  if !assignable_to(ctx, want_ty, lv.ty) {
    return ParseConstGenericArgResult { ok: false, iv: 0, text: name };
  }
  return ParseConstGenericArgResult { ok: true, iv: lv.iv, text: lv.iv.to_string() };
}

fn const_has_type_param_pack(sig: FuncSig) -> bool {
  return sig.type_param_packs.len() == 1;
}

fn const_type_param_fixed_prefix_len(sig: FuncSig) -> i32 {
  if const_has_type_param_pack(sig) { return sig.type_params.len() - 1; }
  return sig.type_params.len();
}

fn const_explicit_type_arg_arity_ok(sig: FuncSig, explicit_targ_n: i32) -> bool {
  if !const_has_type_param_pack(sig) { return explicit_targ_n <= sig.type_params.len(); }
  return explicit_targ_n >= 0;
}

fn const_explicit_type_arg_bind_name(sig: FuncSig, idx: i32) -> String {
  if !const_has_type_param_pack(sig) { return sig.type_params.get(idx); }
  let fixed_n: i32 = const_type_param_fixed_prefix_len(sig);
  if idx < fixed_n { return sig.type_params.get(idx); }
  return sig.type_param_packs.get(0);
}

fn const_type_name_is_pack_member(name: String, pack: String) -> bool {
  if name == pack { return true; }
  return starts_with(name, pack.concat("."));
}

fn const_ty_contains_pack_param(ctx: Ctx, ty: i32, pack: String) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty);
  if t.kind == ir.TyKind.Param { return const_type_name_is_pack_member(t.name, pack); }
  if t.kind == ir.TyKind.Vec || t.kind == ir.TyKind.Range { return const_ty_contains_pack_param(ctx, t.elem, pack); }
  return false;
}

fn const_sig_allows_heterogeneous_pack_args(ctx: Ctx, sig: FuncSig, pack: String) -> bool {
  let mut i: i32 = 0;
  while i < sig.params.len() {
    if const_ty_contains_pack_param(ctx, sig.params.get(i), pack) { return false; }
    i = i + 1;
  }
  if const_ty_contains_pack_param(ctx, sig.ret, pack) { return false; }
  if sig.has_variadic && const_ty_contains_pack_param(ctx, sig.variadic_elem, pack) { return false; }

  let mut bi: i32 = 0;
  while bi < sig.type_param_bounds.len() {
    let b: TypeParamBoundSig = sig.type_param_bounds.get(bi);
    if const_type_name_is_pack_member(b.type_param, pack) { return false; }
    bi = bi + 1;
  }

  let mut ci: i32 = 0;
  while ci < sig.const_where_bounds.len() {
    let b2: ConstWhereBoundSig = sig.const_where_bounds.get(ci);
    if const_type_name_is_pack_member(b2.name, pack) { return false; }
    ci = ci + 1;
  }

  return true;
}

fn const_local_from_value(name: String, mutable: bool, v: EvalConstExprResult) -> ConstLocal {
  return ConstLocal { name: name, mutable: mutable, kind: v.kind, ty: v.ty, iv: v.iv, bv: v.bv, sv: v.sv };
}

fn const_local_with_value(l0: ConstLocal, v: EvalConstExprResult) -> ConstLocal {
  return ConstLocal { name: l0.name, mutable: l0.mutable, kind: v.kind, ty: v.ty, iv: v.iv, bv: v.bv, sv: v.sv };
}

fn const_set_local_at(xs0: Vec[ConstLocal], idx: i32, val: ConstLocal) -> Vec[ConstLocal] {
  let mut xs: Vec[ConstLocal] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    xs.push(if i == idx { val } else { xs0.get(i) });
    i = i + 1;
  }
  return xs;
}

fn const_locals_prefix(xs0: Vec[ConstLocal], n0: i32) -> Vec[ConstLocal] {
  let mut out: Vec[ConstLocal] = Vec();
  let mut n: i32 = n0;
  if n < 0 { n = 0; }
  if n > xs0.len() { n = xs0.len(); }
  let mut i: i32 = 0;
  while i < n {
    out.push(xs0.get(i));
    i = i + 1;
  }
  return out;
}

fn const_set_payload_field_at(xs0: Vec[ConstEnumPayloadField], idx: i32, val: ConstEnumPayloadField) -> Vec[ConstEnumPayloadField] {
  let mut xs: Vec[ConstEnumPayloadField] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    xs.push(if i == idx { val } else { xs0.get(i) });
    i = i + 1;
  }
  return xs;
}

struct ConstExecStmtsResult {
  ok: bool,
  err: TcError,
  sigs: Vec[ConstSig],
  states: Vec[i32],
  locals: Vec[ConstLocal],
  flow: i32,      // 0 none, 1 break, 2 continue, 3 return
  ret_kind: i32,  // valid when flow == 3
  ret_ty: i32,
  ret_iv: i64,
  ret_bv: bool,
  ret_sv: String,
}

fn const_flow_none() -> i32 { return 0; }
fn const_flow_break() -> i32 { return 1; }
fn const_flow_continue() -> i32 { return 2; }
fn const_flow_return() -> i32 { return 3; }

fn const_exec_ok(sigs: Vec[ConstSig], states: Vec[i32], locals: Vec[ConstLocal]) -> ConstExecStmtsResult {
  return ConstExecStmtsResult {
    ok: true, err: TcError.None, sigs: sigs, states: states, locals: locals,
    flow: const_flow_none(), ret_kind: 0, ret_ty: -1, ret_iv: 0, ret_bv: false, ret_sv: "",
  };
}

fn const_exec_ctrl(
  sigs: Vec[ConstSig], states: Vec[i32], locals: Vec[ConstLocal], flow: i32,
  ret_kind: i32, ret_ty: i32, ret_iv: i64, ret_bv: bool, ret_sv: String
) -> ConstExecStmtsResult {
  return ConstExecStmtsResult {
    ok: true, err: TcError.None, sigs: sigs, states: states, locals: locals,
    flow: flow, ret_kind: ret_kind, ret_ty: ret_ty, ret_iv: ret_iv, ret_bv: ret_bv, ret_sv: ret_sv,
  };
}

fn const_exec_err(
  err: TcError, sigs: Vec[ConstSig], states: Vec[i32], locals: Vec[ConstLocal]
) -> ConstExecStmtsResult {
  return ConstExecStmtsResult {
    ok: false, err: err, sigs: sigs, states: states, locals: locals,
    flow: const_flow_none(), ret_kind: 0, ret_ty: -1, ret_iv: 0, ret_bv: false, ret_sv: "",
  };
}

fn const_exec_stmt_expr(
  ctx: Ctx, w: World, items: Vec[ConstItem],
  sigs0: Vec[ConstSig], states0: Vec[i32],
  cur_mod: String, imps: Imports, exprs: ast.ExprPool,
  file: String, exid: i32, locals0: Vec[ConstLocal]
) -> ConstExecStmtsResult {
  let er: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, exid, -1, locals0);
  if !er.ok { return const_exec_err(er.err, er.sigs, er.states, locals0); }
  return const_exec_ok(er.sigs, er.states, locals0);
}

fn const_exec_stmt_if(
  ctx: Ctx, w: World, items: Vec[ConstItem],
  sigs0: Vec[ConstSig], states0: Vec[i32],
  cur_mod: String, imps: Imports, exprs: ast.ExprPool,
  file: String, sp: ast.Span, cnd: i32, thn: ast.Block, has_else: bool, els: ast.Block,
  locals0: Vec[ConstLocal], loop_depth: i32
) -> ConstExecStmtsResult {
  let cr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, cnd, ctx.ty_bool, locals0);
  if !cr.ok { return const_exec_err(cr.err, cr.sigs, cr.states, locals0); }
  if cr.kind != const_kind_bool() {
    return const_exec_err(type_error_at(sp, "const if cond must be bool"), cr.sigs, cr.states, locals0);
  }

  let mut sigs1: Vec[ConstSig] = cr.sigs;
  let mut states1: Vec[i32] = cr.states;
  let mut locals1: Vec[ConstLocal] = locals0;
  if cr.bv {
    let base_len: i32 = locals1.len();
    let br1: ConstExecStmtsResult = const_exec_stmts(ctx, w, items, sigs1, states1, cur_mod, imps, exprs, file, thn.stmts, locals1, loop_depth);
    if !br1.ok { return br1; }
    sigs1 = br1.sigs;
    states1 = br1.states;
    locals1 = const_locals_prefix(br1.locals, base_len);
    if br1.flow != const_flow_none() {
      return const_exec_ctrl(sigs1, states1, locals1, br1.flow, br1.ret_kind, br1.ret_ty, br1.ret_iv, br1.ret_bv, br1.ret_sv);
    }
  } else if has_else {
    let base_len: i32 = locals1.len();
    let br2: ConstExecStmtsResult = const_exec_stmts(ctx, w, items, sigs1, states1, cur_mod, imps, exprs, file, els.stmts, locals1, loop_depth);
    if !br2.ok { return br2; }
    sigs1 = br2.sigs;
    states1 = br2.states;
    locals1 = const_locals_prefix(br2.locals, base_len);
    if br2.flow != const_flow_none() {
      return const_exec_ctrl(sigs1, states1, locals1, br2.flow, br2.ret_kind, br2.ret_ty, br2.ret_iv, br2.ret_bv, br2.ret_sv);
    }
  }
  return const_exec_ok(sigs1, states1, locals1);
}

fn const_exec_stmt_while(
  ctx: Ctx, w: World, items: Vec[ConstItem],
  sigs0: Vec[ConstSig], states0: Vec[i32],
  cur_mod: String, imps: Imports, exprs: ast.ExprPool,
  file: String, sp: ast.Span, cnd: i32, body: ast.Block,
  locals0: Vec[ConstLocal], loop_depth: i32
) -> ConstExecStmtsResult {
  let mut sigs1: Vec[ConstSig] = sigs0;
  let mut states1: Vec[i32] = states0;
  let mut locals1: Vec[ConstLocal] = locals0;
  let mut iter: i32 = 0;
  while true {
    if iter > 100000 {
      return const_exec_err(type_error_at(sp, "const while exceeded iteration limit"), sigs1, states1, locals1);
    }
    let crw: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs1, states1, cur_mod, imps, exprs, file, cnd, ctx.ty_bool, locals1);
    if !crw.ok { return const_exec_err(crw.err, crw.sigs, crw.states, locals1); }
    if crw.kind != const_kind_bool() {
      return const_exec_err(type_error_at(sp, "const while cond must be bool"), crw.sigs, crw.states, locals1);
    }
    sigs1 = crw.sigs;
    states1 = crw.states;
    if !crw.bv { break; }

    let base_len: i32 = locals1.len();
    let wr: ConstExecStmtsResult = const_exec_stmts(ctx, w, items, sigs1, states1, cur_mod, imps, exprs, file, body.stmts, locals1, loop_depth + 1);
    if !wr.ok { return wr; }
    sigs1 = wr.sigs;
    states1 = wr.states;
    locals1 = const_locals_prefix(wr.locals, base_len);
    if wr.flow == const_flow_return() {
      return const_exec_ctrl(sigs1, states1, locals1, wr.flow, wr.ret_kind, wr.ret_ty, wr.ret_iv, wr.ret_bv, wr.ret_sv);
    }
    if wr.flow == const_flow_break() { break; }
    iter = iter + 1;
  }
  return const_exec_ok(sigs1, states1, locals1);
}

fn const_exec_stmt_return(
  ctx: Ctx, w: World, items: Vec[ConstItem],
  sigs0: Vec[ConstSig], states0: Vec[i32],
  cur_mod: String, imps: Imports, exprs: ast.ExprPool,
  file: String, has_ex: bool, eid: i32, locals0: Vec[ConstLocal]
) -> ConstExecStmtsResult {
  if has_ex {
    let rr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, eid, -1, locals0);
    if !rr.ok { return const_exec_err(rr.err, rr.sigs, rr.states, locals0); }
    return const_exec_ctrl(rr.sigs, rr.states, locals0, const_flow_return(), rr.kind, rr.ty, rr.iv, rr.bv, rr.sv);
  }
  return const_exec_ctrl(sigs0, states0, locals0, const_flow_return(), 0, ctx.ty_unit, 0, false, "");
}

fn const_exec_stmt_let(
  ctx: Ctx, w: World, items: Vec[ConstItem],
  sigs0: Vec[ConstSig], states0: Vec[i32],
  cur_mod: String, imps: Imports, exprs: ast.ExprPool,
  file: String, sp: ast.Span, is_mut: bool, name: String, has_ann: bool, ann: ast.TypeName, init: i32,
  locals0: Vec[ConstLocal]
) -> ConstExecStmtsResult {
  let mut want: i32 = -1;
  if has_ann {
    let tr: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, Vec(), ann);
    if !tr.ok {
      return const_exec_err(type_error_at(sp, "const let type annotation resolve failed"), sigs0, states0, locals0);
    }
    want = tr.idx;
  }
  let vr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, init, want, locals0);
  if !vr.ok { return const_exec_err(vr.err, vr.sigs, vr.states, locals0); }
  if has_ann && !assignable_to(ctx, want, vr.ty) {
    return const_exec_err(type_error_at(sp, "const let type mismatch"), vr.sigs, vr.states, locals0);
  }
  let mut locals1: Vec[ConstLocal] = locals0;
  locals1.push(const_local_from_value(name, is_mut, vr));
  return const_exec_ok(vr.sigs, vr.states, locals1);
}

fn const_exec_stmt_assign(
  ctx: Ctx, w: World, items: Vec[ConstItem],
  sigs0: Vec[ConstSig], states0: Vec[i32],
  cur_mod: String, imps: Imports, exprs: ast.ExprPool,
  file: String, sp: ast.Span, name: String, rhs: i32, locals0: Vec[ConstLocal]
) -> ConstExecStmtsResult {
  let li: i32 = const_find_local(locals0, name);
  if li == -1 {
    return const_exec_err(type_error_at(sp, "const assign unknown local"), sigs0, states0, locals0);
  }
  let target: ConstLocal = locals0.get(li);
  if !target.mutable {
    return const_exec_err(type_error_at(sp, "const assign target is immutable"), sigs0, states0, locals0);
  }
  let rr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, rhs, target.ty, locals0);
  if !rr.ok { return const_exec_err(rr.err, rr.sigs, rr.states, locals0); }
  if !assignable_to(ctx, target.ty, rr.ty) {
    return const_exec_err(type_error_at(sp, "const assign type mismatch"), rr.sigs, rr.states, locals0);
  }
  return const_exec_ok(rr.sigs, rr.states, const_set_local_at(locals0, li, const_local_with_value(target, rr)));
}

fn const_split_field_path(path: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut start: i32 = 0;
  let mut i: i32 = 0;
  while i < path.len() {
    if path.byte_at(i) == 46 {
      out.push(path.slice(start, i));
      start = i + 1;
    }
    i = i + 1;
  }
  out.push(path.slice(start, path.len()));
  return out;
}

struct ConstFieldPathTyResult {
  ok: bool,
  err: TcError,
  ty: i32,
}

fn const_field_path_ty_ok(ty: i32) -> ConstFieldPathTyResult {
  return ConstFieldPathTyResult { ok: true, err: TcError.None, ty: ty };
}

fn const_field_path_ty_err(err: TcError) -> ConstFieldPathTyResult {
  return ConstFieldPathTyResult { ok: false, err: err, ty: -1 };
}

fn const_resolve_field_path_ty(
  ctx: Ctx, cur_mod: String, sp: ast.Span,
  base_ty: i32, parts: Vec[String]
) -> ConstFieldPathTyResult {
  if parts.len() == 0 {
    return const_field_path_ty_err(type_error_at(sp, "unknown field"));
  }
  let mut cur_ty: i32 = base_ty;
  let mut pi: i32 = 0;
  while pi < parts.len() {
    let rt: ir.Ty = ir.ty_pool_get(ctx.pool, cur_ty);
    if rt.kind != ir.TyKind.Struct {
      return const_field_path_ty_err(type_error_at(sp, "const field assign recv must be struct"));
    }
    let fs: FindStructResult = find_struct(ctx, rt.mod_path, rt.name);
    if !fs.found {
      return const_field_path_ty_err(type_error_at(sp, "unknown struct type"));
    }
    if !vis_allows(fs.sig.vis, fs.sig.mod_path, cur_mod) {
      return const_field_path_ty_err(type_error_at(sp, "type is private"));
    }

    let mut found: bool = false;
    let mut next_ty: i32 = ctx.ty_bad;
    let mut fvis: i32 = ast.vis_private();
    let mut fi: i32 = 0;
    while fi < fs.sig.fields.len() {
      let sf: StructFieldSig = fs.sig.fields.get(fi);
      if sf.name == parts.get(pi) {
        found = true;
        next_ty = sf.ty;
        fvis = sf.vis;
        fi = fs.sig.fields.len();
      } else {
        fi = fi + 1;
      }
    }
    if !found {
      return const_field_path_ty_err(type_error_at(sp, "unknown field"));
    }
    if !vis_allows(fvis, fs.sig.mod_path, cur_mod) {
      return const_field_path_ty_err(type_error_at(sp, "field is private"));
    }
    cur_ty = next_ty;
    pi = pi + 1;
  }
  return const_field_path_ty_ok(cur_ty);
}

struct ConstStructFieldUpdateResult {
  ok: bool,
  err: TcError,
  sv: String,
}

fn const_struct_field_update_ok(sv: String) -> ConstStructFieldUpdateResult {
  return ConstStructFieldUpdateResult { ok: true, err: TcError.None, sv: sv };
}

fn const_struct_field_update_err(err: TcError) -> ConstStructFieldUpdateResult {
  return ConstStructFieldUpdateResult { ok: false, err: err, sv: "" };
}

fn const_apply_struct_field_update(
  ctx: Ctx, cur_mod: String, sp: ast.Span,
  struct_ty: i32, struct_sv: String,
  parts: Vec[String], part_i: i32,
  val: ConstEnumPayloadField
) -> ConstStructFieldUpdateResult {
  if part_i < 0 || part_i >= parts.len() {
    return const_struct_field_update_err(type_error_at(sp, "unknown field"));
  }

  let tsty: ir.Ty = ir.ty_pool_get(ctx.pool, struct_ty);
  if tsty.kind != ir.TyKind.Struct {
    return const_struct_field_update_err(type_error_at(sp, "const field assign recv must be struct"));
  }
  let fs: FindStructResult = find_struct(ctx, ty_mod(tsty), ty_name(tsty));
  if !fs.found {
    return const_struct_field_update_err(type_error_at(sp, "unknown struct type"));
  }
  if !vis_allows(fs.sig.vis, fs.sig.mod_path, cur_mod) {
    return const_struct_field_update_err(type_error_at(sp, "type is private"));
  }
  let dec: ConstStructDecode = const_struct_unpack(struct_sv);
  if !dec.ok {
    return const_struct_field_update_err(type_error_at(sp, "bad const struct encoding"));
  }
  if dec.fields.len() != fs.sig.fields.len() {
    return const_struct_field_update_err(type_error_at(sp, "bad const struct encoding"));
  }

  let mut found: bool = false;
  let mut fidx: i32 = -1;
  let mut fty: i32 = ctx.ty_bad;
  let mut fi: i32 = 0;
  while fi < fs.sig.fields.len() {
    let sf: StructFieldSig = fs.sig.fields.get(fi);
    if sf.name == parts.get(part_i) {
      found = true;
      fidx = fi;
      fty = sf.ty;
      if !vis_allows(sf.vis, fs.sig.mod_path, cur_mod) {
        return const_struct_field_update_err(type_error_at(sp, "field is private"));
      }
      fi = fs.sig.fields.len();
    } else {
      fi = fi + 1;
    }
  }
  if !found {
    return const_struct_field_update_err(type_error_at(sp, "unknown field"));
  }

  if part_i + 1 == parts.len() {
    let packed: String = const_struct_pack(const_set_payload_field_at(dec.fields, fidx, val));
    return const_struct_field_update_ok(packed);
  }

  if !is_struct_ty(ctx, fty) {
    return const_struct_field_update_err(type_error_at(sp, "const field assign recv must be struct"));
  }
  let curf: ConstEnumPayloadField = dec.fields.get(fidx);
  if curf.kind != const_kind_struct() {
    return const_struct_field_update_err(type_error_at(sp, "bad const struct encoding"));
  }
  let ur: ConstStructFieldUpdateResult = const_apply_struct_field_update(ctx, cur_mod, sp, fty, curf.sv, parts, part_i + 1, val);
  if !ur.ok { return ur; }
  let nextf: ConstEnumPayloadField = ConstEnumPayloadField {
    kind: const_kind_struct(),
    ty: fty,
    iv: 0,
    bv: false,
    sv: ur.sv,
  };
  let packed2: String = const_struct_pack(const_set_payload_field_at(dec.fields, fidx, nextf));
  return const_struct_field_update_ok(packed2);
}

fn const_exec_stmt_assign_field(
  ctx: Ctx, w: World, items: Vec[ConstItem],
  sigs0: Vec[ConstSig], states0: Vec[i32],
  cur_mod: String, imps: Imports, exprs: ast.ExprPool,
  file: String, sp: ast.Span, recv: String, field: String, rhs: i32, locals0: Vec[ConstLocal]
) -> ConstExecStmtsResult {
  let li: i32 = const_find_local(locals0, recv);
  if li == -1 {
    return const_exec_err(type_error_at(sp, "const assign unknown local"), sigs0, states0, locals0);
  }
  let target: ConstLocal = locals0.get(li);
  if !target.mutable {
    return const_exec_err(type_error_at(sp, "const assign target is immutable"), sigs0, states0, locals0);
  }
  if target.kind != const_kind_struct() || !is_struct_ty(ctx, target.ty) {
    return const_exec_err(type_error_at(sp, "const field assign recv must be struct"), sigs0, states0, locals0);
  }
  let parts: Vec[String] = const_split_field_path(field);
  let frt: ConstFieldPathTyResult = const_resolve_field_path_ty(ctx, cur_mod, sp, target.ty, parts);
  if !frt.ok {
    return const_exec_err(frt.err, sigs0, states0, locals0);
  }

  let rr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, rhs, frt.ty, locals0);
  if !rr.ok { return const_exec_err(rr.err, rr.sigs, rr.states, locals0); }
  if !assignable_to(ctx, frt.ty, rr.ty) {
    return const_exec_err(type_error_at(sp, "const assign type mismatch"), rr.sigs, rr.states, locals0);
  }
  let fr: ConstToPayloadFieldResult = const_payload_field_from_eval(rr);
  if !fr.ok {
    return const_exec_err(type_error_at(sp, fr.err), rr.sigs, rr.states, locals0);
  }
  let ur: ConstStructFieldUpdateResult = const_apply_struct_field_update(ctx, cur_mod, sp, target.ty, target.sv, parts, 0, fr.f);
  if !ur.ok {
    return const_exec_err(ur.err, rr.sigs, rr.states, locals0);
  }
  let updated: ConstLocal = ConstLocal {
    name: target.name,
    mutable: target.mutable,
    kind: const_kind_struct(),
    ty: target.ty,
    iv: 0,
    bv: false,
    sv: ur.sv,
  };
  return const_exec_ok(rr.sigs, rr.states, const_set_local_at(locals0, li, updated));
}

fn const_exec_stmt(
  ctx: Ctx, w: World, items: Vec[ConstItem],
  sigs0: Vec[ConstSig], states0: Vec[i32],
  cur_mod: String, imps: Imports, exprs: ast.ExprPool,
  file: String, st: ast.Stmt, locals0: Vec[ConstLocal], loop_depth: i32
) -> ConstExecStmtsResult {
  return match st {
    ast.Stmt.Let(sp, is_mut, name, has_ann, ann, init) =>
      const_exec_stmt_let(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, sp, is_mut, name, has_ann, ann, init, locals0),
    ast.Stmt.Assign(sp, name, rhs) =>
      const_exec_stmt_assign(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, sp, name, rhs, locals0),
    ast.Stmt.AssignField(sp, recv, field, rhs) =>
      const_exec_stmt_assign_field(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, sp, recv, field, rhs, locals0),
    ast.Stmt.ExprStmt(_sp, exid) =>
      const_exec_stmt_expr(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, exid, locals0),
    ast.Stmt.IfStmt(sp, cnd, thn, has_else, els) =>
      const_exec_stmt_if(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, sp, cnd, thn, has_else, els, locals0, loop_depth),
    ast.Stmt.WhileStmt(sp, cnd, body) =>
      const_exec_stmt_while(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, sp, cnd, body, locals0, loop_depth),
    ast.Stmt.Break(sp) => if loop_depth <= 0 {
      const_exec_err(type_error_at(sp, "const break outside while"), sigs0, states0, locals0)
    } else {
      const_exec_ctrl(sigs0, states0, locals0, const_flow_break(), 0, -1, 0, false, "")
    },
    ast.Stmt.Continue(sp) => if loop_depth <= 0 {
      const_exec_err(type_error_at(sp, "const continue outside while"), sigs0, states0, locals0)
    } else {
      const_exec_ctrl(sigs0, states0, locals0, const_flow_continue(), 0, -1, 0, false, "")
    },
    ast.Stmt.ReturnStmt(_sp, has_ex, eid) =>
      const_exec_stmt_return(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, has_ex, eid, locals0),
  };
}

fn const_exec_stmts(
  ctx: Ctx, w: World, items: Vec[ConstItem],
  sigs0: Vec[ConstSig], states0: Vec[i32],
  cur_mod: String, imps: Imports, exprs: ast.ExprPool,
  file: String, stmts: Vec[ast.Stmt], locals0: Vec[ConstLocal], loop_depth: i32
) -> ConstExecStmtsResult {
  let mut sigs1: Vec[ConstSig] = sigs0;
  let mut states1: Vec[i32] = states0;
  let mut locals1: Vec[ConstLocal] = locals0;

  let mut si: i32 = 0;
  while si < stmts.len() {
    let st: ast.Stmt = stmts.get(si);
    let sr: ConstExecStmtsResult = const_exec_stmt(
      ctx, w, items,
      sigs1, states1,
      cur_mod, imps, exprs,
      file, st, locals1, loop_depth
    );
    if !sr.ok { return sr; }
    sigs1 = sr.sigs;
    states1 = sr.states;
    locals1 = sr.locals;
    if sr.flow != const_flow_none() { return sr; }
    si = si + 1;
  }

  return const_exec_ok(sigs1, states1, locals1);
}

struct ConstPatEvalResult {
  ok: bool,
  matched: bool,
  binds: Vec[ConstLocal],
  err: String,
}

fn const_pat_err(msg: String) -> ConstPatEvalResult {
  return ConstPatEvalResult {
    ok: false, matched: false, binds: Vec(),
    err: msg,
  };
}

fn const_pat_nomatch() -> ConstPatEvalResult {
  return ConstPatEvalResult {
    ok: true, matched: false, binds: Vec(),
    err: "",
  };
}

fn const_pat_match_no_bind() -> ConstPatEvalResult {
  return ConstPatEvalResult {
    ok: true, matched: true, binds: Vec(),
    err: "",
  };
}

fn const_pat_match_bind(name: String, v: EvalConstExprResult) -> ConstPatEvalResult {
  let mut bs: Vec[ConstLocal] = Vec();
  bs.push(const_local_from_value(name, false, v));
  return ConstPatEvalResult {
    ok: true, matched: true, binds: bs,
    err: "",
  };
}

fn const_pat_match_with_binds(bs: Vec[ConstLocal]) -> ConstPatEvalResult {
  return ConstPatEvalResult { ok: true, matched: true, binds: bs, err: "" };
}

fn const_bind_name_exists(bs: Vec[ConstLocal], name: String) -> bool {
  let mut i: i32 = 0;
  while i < bs.len() {
    if bs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn const_find_enum_variant_idx(ctx: Ctx, ty: i32, vname: String) -> i32 {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind != ir.TyKind.Enum { return -1; }
  let fe: FindEnumResult = find_enum(ctx, ty_mod(t), ty_name(t));
  if !fe.found { return -1; }
  let mut i: i32 = 0;
  while i < fe.sig.vars.len() {
    if fe.sig.vars.get(i).name == vname { return i; }
    i = i + 1;
  }
  return -1;
}

struct ConstFindVariantResult { ok: bool, idx: i32, fields: Vec[i32] }

fn const_find_enum_variant(ctx: Ctx, enum_ty: i32, vname: String) -> ConstFindVariantResult {
  let base: i32 = strip_range(ctx, enum_ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind != ir.TyKind.Enum { return ConstFindVariantResult { ok: false, idx: -1, fields: Vec() }; }
  let fe: FindEnumResult = find_enum(ctx, ty_mod(t), ty_name(t));
  if !fe.found { return ConstFindVariantResult { ok: false, idx: -1, fields: Vec() }; }
  let mut i: i32 = 0;
  while i < fe.sig.vars.len() {
    let v: EnumVariantSig = fe.sig.vars.get(i);
    if v.name == vname { return ConstFindVariantResult { ok: true, idx: i, fields: v.fields }; }
    i = i + 1;
  }
  return ConstFindVariantResult { ok: false, idx: -1, fields: Vec() };
}

struct ConstResolveEnumCtorResult { ok: bool, err: String, enum_ty: i32, variant: String, vidx: i32, fields: Vec[i32] }

struct ConstFindFuncDeclResult { found: bool, decl: ast.FuncDecl }

fn empty_func_decl() -> ast.FuncDecl {
  return ast.FuncDecl {
    file: "",
    sp: ast.span0(),
    vis: ast.vis_pub(),
    is_pub: false,
    name: "",
    type_params: Vec(),
    type_param_packs: Vec(),
    const_params: Vec(),
    type_param_bounds: Vec(),
    const_where_bounds: Vec(),
    params: Vec(),
    ret: ast.TypeName { parts: Vec(), args: Vec() },
    body: ast.Block { stmts: Vec() },
  };
}

fn const_find_func_decl(w: World, mod_path: String, name: String) -> ConstFindFuncDeclResult {
  let fm: FindModResult = find_mod(w, mod_path);
  if !fm.found { return ConstFindFuncDeclResult { found: false, decl: empty_func_decl() }; }
  let m: WorldModule = w.mods.get(fm.idx);
  let mut i: i32 = 0;
  while i < m.prog.funcs.len() {
    let fd: ast.FuncDecl = m.prog.funcs.get(i);
    if fd.name == name { return ConstFindFuncDeclResult { found: true, decl: fd }; }
    i = i + 1;
  }
  return ConstFindFuncDeclResult { found: false, decl: empty_func_decl() };
}

fn const_struct_path_matches_expected(ctx: Ctx, cur_mod: String, imps: Imports, parts: Vec[String], expected: i32) -> bool {
  if expected == -1 { return false; }
  let eb: i32 = strip_range(ctx, expected);
  if !is_struct_ty(ctx, eb) { return false; }
  if parts.len() != 1 && parts.len() != 2 { return false; }

  let mut struct_mod: String = "";
  let mut struct_name: String = "";
  if parts.len() == 1 {
    struct_mod = cur_mod;
    struct_name = parts.get(0);
    let nt: NamedTypeImport = find_named_type(imps.named_types, struct_name);
    if nt.local != "" {
      if nt.kind != named_type_kind_struct() { return false; }
      struct_mod = nt.mod_path;
      struct_name = nt.name;
    }
  } else {
    struct_mod = find_alias(imps.aliases, parts.get(0));
    if struct_mod == "" { return false; }
    struct_name = parts.get(1);
  }

  let et: ir.Ty = ir.ty_pool_get(ctx.pool, eb);
  if struct_mod != ty_mod(et) { return false; }
  let fs: FindStructResult = find_struct(ctx, ty_mod(et), ty_name(et));
  if !fs.found { return false; }
  return struct_name == fs.sig.base_name || struct_name == fs.sig.name;
}

fn const_resolve_enum_ctor(ctx: Ctx, w: World, cur_mod: String, imps: Imports, parts: Vec[String], enum_targs: Vec[ast.TypeName], expected: i32) -> ConstResolveEnumCtorResult {
  if enum_targs.len() != 0 {
    if parts.len() < 2 || parts.len() > 3 {
      return ConstResolveEnumCtorResult { ok: false, err: "bad enum ctor path in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
    }
    let mut enum_parts: Vec[String] = Vec();
    let mut i: i32 = 0;
    while i < parts.len() - 1 {
      enum_parts.push(parts.get(i));
      i = i + 1;
    }
    let vname_t: String = parts.get(parts.len() - 1);
    let tn: ast.TypeName = ast.TypeName { parts: enum_parts, args: enum_targs };
    let tr: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, Vec(), tn);
    if !tr.ok {
      return ConstResolveEnumCtorResult { ok: false, err: "bad typed enum ctor path in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
    }
    let c2: Ctx = tr.ctx;
    if tr.idx < 0 || tr.idx >= c2.pool.tys.len() {
      return ConstResolveEnumCtorResult { ok: false, err: "bad typed enum ctor path in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
    }
    let eb_t: i32 = strip_range(c2, tr.idx);
    let et_t: ir.Ty = ir.ty_pool_get(c2.pool, eb_t);
    if et_t.kind != ir.TyKind.Enum {
      return ConstResolveEnumCtorResult { ok: false, err: "const typed path requires enum type", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
    }
    if expected != -1 && strip_range(c2, expected) != eb_t {
      return ConstResolveEnumCtorResult { ok: false, err: "const enum ctor type mismatch", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
    }
    let fv_t: ConstFindVariantResult = const_find_enum_variant(c2, eb_t, vname_t);
    if !fv_t.ok {
      return ConstResolveEnumCtorResult { ok: false, err: "unknown enum variant in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
    }
    return ConstResolveEnumCtorResult { ok: true, err: "", enum_ty: eb_t, variant: vname_t, vidx: fv_t.idx, fields: fv_t.fields };
  }

  if expected == -1 {
    return ConstResolveEnumCtorResult { ok: false, err: "const enum shorthand requires expected enum type", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }
  let eb: i32 = strip_range(ctx, expected);
  let et: ir.Ty = ir.ty_pool_get(ctx.pool, eb);
  if et.kind != ir.TyKind.Enum {
    return ConstResolveEnumCtorResult { ok: false, err: "const enum shorthand requires expected enum type", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }
  let want_mod: String = ty_mod(et);
  let want_name: String = ty_name(et);

  if parts.len() == 0 || parts.len() > 3 {
    return ConstResolveEnumCtorResult { ok: false, err: "bad enum ctor path in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }

  let mut enum_mod: String = want_mod;
  let mut enum_name: String = want_name;
  let mut vname: String = "";

  if parts.len() == 1 {
    vname = parts.get(0);
  } else if parts.len() == 2 {
    enum_mod = cur_mod;
    enum_name = parts.get(0);
    let nt: NamedTypeImport = find_named_type(imps.named_types, enum_name);
    if nt.local != "" {
      if nt.kind != named_type_kind_enum() {
        return ConstResolveEnumCtorResult { ok: false, err: "unknown enum in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
      }
      enum_mod = nt.mod_path;
      enum_name = nt.name;
    }
    vname = parts.get(1);
  } else {
    enum_mod = find_alias(imps.aliases, parts.get(0));
    if enum_mod == "" {
      return ConstResolveEnumCtorResult { ok: false, err: "unknown module qualifier", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
    }
    enum_name = parts.get(1);
    vname = parts.get(2);
  }

  let fe_want: FindEnumResult = find_enum(ctx, want_mod, want_name);
  if !fe_want.found {
    return ConstResolveEnumCtorResult { ok: false, err: "unknown enum in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }
  let base_name: String = fe_want.sig.base_name;
  if enum_mod != want_mod || (enum_name != want_name && enum_name != base_name) {
    return ConstResolveEnumCtorResult { ok: false, err: "const enum ctor type mismatch", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }

  let fe2: FindEnumResult = find_enum(ctx, enum_mod, enum_name);
  if !fe2.found && enum_name != base_name {
    return ConstResolveEnumCtorResult { ok: false, err: "unknown enum in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }

  let fv: ConstFindVariantResult = const_find_enum_variant(ctx, eb, vname);
  if !fv.ok {
    return ConstResolveEnumCtorResult { ok: false, err: "unknown enum variant in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }
  return ConstResolveEnumCtorResult { ok: true, err: "", enum_ty: eb, variant: vname, vidx: fv.idx, fields: fv.fields };
}

fn const_match_int_pat(ctx: Ctx, scrut_ty: i32, scrut_iv: i64, text: String) -> ConstPatEvalResult {
  let base: i32 = strip_range(ctx, scrut_ty);
  if !is_int_like_ty(ctx, base) {
    return const_pat_err("const int pattern requires int scrutinee");
  }
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.U64 || t.kind == ir.TyKind.USize {
    let pru: ParseU64DecResult = parse_u64_dec(text);
    if !pru.ok { return const_pat_err("const int pattern out of range"); }
    if pru.val == scrut_iv { return const_pat_match_no_bind(); }
    return const_pat_nomatch();
  }

  let pr: ParseI64DecResult = parse_i64_dec(text);
  if !pr.ok { return const_pat_err("const int pattern out of range"); }
  let v: i64 = pr.val;
  let ok_lit: bool = match t.kind {
    ir.TyKind.I8 => v >= -128 && v <= 127,
    ir.TyKind.U8 => v >= 0 && v <= 255,
    ir.TyKind.I16 => v >= -32768 && v <= 32767,
    ir.TyKind.U16 => v >= 0 && v <= 65535,
    ir.TyKind.I32 => v >= -2147483648 && v <= 2147483647,
    ir.TyKind.U32 => v >= 0 && v <= 4294967295,
    ir.TyKind.I64 => true,
    ir.TyKind.ISize => true,
    _ => false,
  };
  if !ok_lit { return const_pat_err("const int pattern out of range"); }
  if v == scrut_iv { return const_pat_match_no_bind(); }
  return const_pat_nomatch();
}

fn const_payload_field_eval(scrut: EvalConstExprResult, f: ConstEnumPayloadField) -> EvalConstExprResult {
  return EvalConstExprResult {
    ok: true,
    err: TcError.None,
    kind: f.kind,
    ty: f.ty,
    iv: f.iv,
    bv: f.bv,
    sv: f.sv,
    sigs: scrut.sigs,
    states: scrut.states,
  };
}

fn const_pat_matches(ctx: Ctx, scrut: EvalConstExprResult, pat: ast.Pat) -> ConstPatEvalResult {
  return match pat {
    ast.Pat.Wild(_sp) => const_pat_match_no_bind(),
    ast.Pat.Bind(_sp, n) => const_pat_match_bind(n, scrut),
    ast.Pat.Bool(_sp, b) => {
      if scrut.kind != const_kind_bool() {
        const_pat_err("const bool pattern requires bool scrutinee")
      } else {
        if scrut.bv == b { const_pat_match_no_bind() } else { const_pat_nomatch() }
      }
    },
    ast.Pat.Int(_sp, text) => {
      if scrut.kind != const_kind_int() {
        const_pat_err("const int pattern requires int scrutinee")
      } else {
        const_match_int_pat(ctx, scrut.ty, scrut.iv, text)
      }
    },
    ast.Pat.Str(_sp, text) => {
      if scrut.kind != const_kind_str() {
        const_pat_err("const string pattern requires String scrutinee")
      } else {
        if scrut.sv == text { const_pat_match_no_bind() } else { const_pat_nomatch() }
      }
    },
    ast.Pat.EnumVariant(_sp, _enum_parts, vname, args) => {
      if scrut.kind != const_kind_enum() {
        const_pat_err("const enum pattern requires enum scrutinee")
      } else {
        let vidx: i32 = const_find_enum_variant_idx(ctx, scrut.ty, vname);
        if vidx == -1 {
          const_pat_err("unknown enum variant in const pattern")
        } else if scrut.iv != (vidx as i64) {
          const_pat_nomatch()
        } else {
          let dec: ConstEnumPayloadDecode = const_enum_unpack(scrut.sv);
          if !dec.ok {
            const_pat_err("bad const enum payload encoding")
          } else if dec.variant != vname {
            const_pat_err("const enum payload variant mismatch")
          } else if args.len() != dec.fields.len() {
            const_pat_err("const enum pattern arity mismatch")
          } else {
            let mut bs: Vec[ConstLocal] = Vec();
            let mut i: i32 = 0;
            while i < args.len() {
              let pr: ConstPatEvalResult = const_pat_matches(ctx, const_payload_field_eval(scrut, dec.fields.get(i)), args.get(i));
              if !pr.ok { return pr; }
              if !pr.matched { return const_pat_nomatch(); }
              let mut bi: i32 = 0;
              while bi < pr.binds.len() {
                let b: ConstLocal = pr.binds.get(bi);
                if const_bind_name_exists(bs, b.name) {
                  return const_pat_err("duplicate bind in const pattern: ".concat(b.name));
                }
                bs.push(b);
                bi = bi + 1;
              }
              i = i + 1;
            }
            const_pat_match_with_binds(bs)
          }
        }
      }
    },
  };
}

struct ConstToPayloadFieldResult { ok: bool, err: String, f: ConstEnumPayloadField }

fn const_payload_field_from_eval(v: EvalConstExprResult) -> ConstToPayloadFieldResult {
  let is_ok_kind: bool =
    v.kind == const_kind_int() ||
    v.kind == const_kind_bool() ||
    v.kind == const_kind_str() ||
    v.kind == const_kind_float() ||
    v.kind == const_kind_enum() ||
    v.kind == const_kind_struct();
  if !is_ok_kind {
    return ConstToPayloadFieldResult { ok: false, err: "const payload must be const value", f: ConstEnumPayloadField { kind: 0, ty: -1, iv: 0, bv: false, sv: "" } };
  }
  if v.kind == const_kind_enum() {
    let dec: ConstEnumPayloadDecode = const_enum_unpack(v.sv);
    if !dec.ok {
      return ConstToPayloadFieldResult { ok: false, err: "bad const enum payload encoding", f: ConstEnumPayloadField { kind: 0, ty: -1, iv: 0, bv: false, sv: "" } };
    }
  }
  if v.kind == const_kind_struct() {
    let dec2: ConstStructDecode = const_struct_unpack(v.sv);
    if !dec2.ok {
      return ConstToPayloadFieldResult { ok: false, err: "bad const struct encoding", f: ConstEnumPayloadField { kind: 0, ty: -1, iv: 0, bv: false, sv: "" } };
    }
  }
  return ConstToPayloadFieldResult {
    ok: true, err: "",
    f: ConstEnumPayloadField { kind: v.kind, ty: v.ty, iv: v.iv, bv: v.bv, sv: v.sv },
  };
}

fn eval_const_reflect_intrinsic(
  ctx: Ctx,
  w: World,
  cur_mod: String,
  imps: Imports,
  exprs: ast.ExprPool,
  call_id: i32,
  file: String,
  name: String,
  type_args: Vec[ast.TypeName],
  args: Vec[i32],
  expected: i32,
  sigs0: Vec[ConstSig],
  states0: Vec[i32]
) -> EvalConstExprResult {
  if args.len() != 0 {
    return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic call arity mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@field_name" || name == "@field_type" || name == "@field_type_id" {
    if type_args.len() != 2 {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic requires type and const index"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let tr0: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, Vec(), type_args.get(0));
    if !tr0.ok {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type arg resolve failed"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let pr: ParseConstGenericArgResult = parse_const_generic_arg(tr0.ctx, type_args.get(1), tr0.ctx.ty_usize);
    if !pr.ok {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic index out of range"), kind: 0, ty: tr0.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    if name == "@field_type_id" {
      let trt: ReflectIntResult = intrinsic_field_type_id_of(tr0.ctx, tr0.idx, pr.iv);
      if !trt.ok {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, trt.err), kind: 0, ty: tr0.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if expected != -1 && !assignable_to(tr0.ctx, expected, tr0.ctx.ty_usize) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr0.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: tr0.ctx.ty_usize, iv: trt.iv, bv: false, sv: "", sigs: sigs0, states: states0 };
    }

    let nr0: ReflectTextResult =
      if name == "@field_name" {
        intrinsic_field_name_of(tr0.ctx, tr0.idx, pr.iv)
      } else {
        intrinsic_field_type_of(tr0.ctx, tr0.idx, pr.iv)
      };
    if !nr0.ok {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, nr0.err), kind: 0, ty: tr0.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    if expected != -1 && !assignable_to(tr0.ctx, expected, tr0.ctx.ty_string) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr0.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_str(), ty: tr0.ctx.ty_string, iv: 0, bv: false, sv: nr0.text, sigs: sigs0, states: states0 };
  }
  if name == "@same_type" || name == "@assignable_to" || name == "@castable_to" || name == "@eq_comparable_with" || name == "@ordered_with" || name == "@same_layout" || name == "@bitcastable" {
    if type_args.len() != 2 {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic requires two type args"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let tra: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, Vec(), type_args.get(0));
    if !tra.ok {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type arg resolve failed"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let trb: ResolveTyResult = resolve_type(tra.ctx, w, cur_mod, imps, Vec(), type_args.get(1));
    if !trb.ok {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type arg resolve failed"), kind: 0, ty: tra.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let brt: ReflectBoolResult =
      if name == "@same_type" {
        intrinsic_same_type_of(trb.ctx, tra.idx, trb.idx)
      } else if name == "@assignable_to" {
        intrinsic_assignable_to_of(trb.ctx, tra.idx, trb.idx)
      } else if name == "@castable_to" {
        intrinsic_castable_to_of(trb.ctx, tra.idx, trb.idx)
      } else if name == "@eq_comparable_with" {
        intrinsic_eq_comparable_with_of(trb.ctx, tra.idx, trb.idx)
      } else if name == "@same_layout" {
        intrinsic_same_layout_of(trb.ctx, tra.idx, trb.idx)
      } else if name == "@bitcastable" {
        intrinsic_bitcastable_of(trb.ctx, tra.idx, trb.idx)
      } else {
        intrinsic_ordered_with_of(trb.ctx, tra.idx, trb.idx)
      };
    if !brt.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, brt.err), kind: 0, ty: trb.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(trb.ctx, expected, trb.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: trb.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: trb.ctx.ty_bool, iv: 0, bv: brt.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if type_args.len() != 1 {
    return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic requires one type arg"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
  }

  let tr: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, Vec(), type_args.get(0));
  if !tr.ok {
    return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type arg resolve failed"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
  }

  if name == "@size_of" {
    let sr: ReflectIntResult = intrinsic_size_of(tr.ctx, tr.idx);
    if !sr.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, sr.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_usize) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: tr.ctx.ty_usize, iv: sr.iv, bv: false, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@align_of" {
    let ar: ReflectIntResult = intrinsic_align_of(tr.ctx, tr.idx);
    if !ar.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, ar.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_usize) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: tr.ctx.ty_usize, iv: ar.iv, bv: false, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@field_count" {
    let fr: ReflectIntResult = intrinsic_field_count_of(tr.ctx, tr.idx);
    if !fr.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, fr.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_usize) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: tr.ctx.ty_usize, iv: fr.iv, bv: false, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@type" {
    let trr: ReflectIntResult = intrinsic_type_id_of(tr.ctx, tr.idx);
    if !trr.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, trr.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_usize) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: tr.ctx.ty_usize, iv: trr.iv, bv: false, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@type_name" {
    let nr: ReflectTextResult = intrinsic_type_name_of(tr.ctx, tr.idx);
    if !nr.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, nr.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_string) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_str(), ty: tr.ctx.ty_string, iv: 0, bv: false, sv: nr.text, sigs: sigs0, states: states0 };
  }
  if name == "@is_integer" {
    let br0: ReflectBoolResult = intrinsic_is_integer_of(tr.ctx, tr.idx);
    if !br0.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, br0.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: br0.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_signed_int" {
    let brs: ReflectBoolResult = intrinsic_is_signed_int_of(tr.ctx, tr.idx);
    if !brs.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, brs.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: brs.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_unsigned_int" {
    let bru: ReflectBoolResult = intrinsic_is_unsigned_int_of(tr.ctx, tr.idx);
    if !bru.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, bru.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: bru.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_float" {
    let br1: ReflectBoolResult = intrinsic_is_float_of(tr.ctx, tr.idx);
    if !br1.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, br1.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: br1.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_bool" {
    let brb: ReflectBoolResult = intrinsic_is_bool_of(tr.ctx, tr.idx);
    if !brb.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, brb.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: brb.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_string" {
    let brs0: ReflectBoolResult = intrinsic_is_string_of(tr.ctx, tr.idx);
    if !brs0.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, brs0.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: brs0.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_struct" {
    let br2: ReflectBoolResult = intrinsic_is_struct_of(tr.ctx, tr.idx);
    if !br2.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, br2.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: br2.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_enum" {
    let br3: ReflectBoolResult = intrinsic_is_enum_of(tr.ctx, tr.idx);
    if !br3.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, br3.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: br3.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_vec" {
    let br4: ReflectBoolResult = intrinsic_is_vec_of(tr.ctx, tr.idx);
    if !br4.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, br4.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: br4.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_range" {
    let br5: ReflectBoolResult = intrinsic_is_range_of(tr.ctx, tr.idx);
    if !br5.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, br5.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: br5.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_eq_comparable" {
    let breq: ReflectBoolResult = intrinsic_is_eq_comparable_of(tr.ctx, tr.idx);
    if !breq.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, breq.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: breq.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_ordered" {
    let brord: ReflectBoolResult = intrinsic_is_ordered_of(tr.ctx, tr.idx);
    if !brord.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, brord.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: brord.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_unit" {
    let brunit: ReflectBoolResult = intrinsic_is_unit_of(tr.ctx, tr.idx);
    if !brunit.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, brunit.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: brunit.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_numeric" {
    let brnum: ReflectBoolResult = intrinsic_is_numeric_of(tr.ctx, tr.idx);
    if !brnum.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, brnum.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: brnum.bv, sv: "", sigs: sigs0, states: states0 };
  }
  if name == "@is_zero_sized" {
    let brz: ReflectBoolResult = intrinsic_is_zero_sized_of(tr.ctx, tr.idx);
    if !brz.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, brz.err), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    if expected != -1 && !assignable_to(tr.ctx, expected, tr.ctx.ty_bool) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "const intrinsic type mismatch"), kind: 0, ty: tr.ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: tr.ctx.ty_bool, iv: 0, bv: brz.bv, sv: "", sigs: sigs0, states: states0 };
  }

  return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, call_id, "unknown const intrinsic"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
}

// Prefer expression span for const-eval diagnostics; fall back to file:1:1.
fn const_expr_error(file: String, exprs: ast.ExprPool, id: i32, msg: String) -> TcError {
  let sp: ast.Span = ast.expr_pool_span(exprs, id);
  if sp.file != "" { return type_error_at(sp, msg); }
  return type_error(file, msg);
}

// Evaluate in a specific module's expr pool (const init expr ids are module-local).
fn eval_const_expr_in_mod_locals(
  ctx: Ctx,
  w: World,
  items: Vec[ConstItem],
  sigs0: Vec[ConstSig],
  states0: Vec[i32],
  cur_mod: String,
  imps: Imports,
  exprs: ast.ExprPool,
  file: String,
  id: i32,
  expected: i32,
  locals: Vec[ConstLocal]
) -> EvalConstExprResult {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);

  // literals
  if match n { ast.ExprNode.Int(_v) => true, _ => false } {
    let s: String = match n { ast.ExprNode.Int(x) => x, _ => "" };

    // When expected is present, constrain to that scalar type (range types require explicit `as`).
    if expected != -1 {
      let eb: i32 = strip_range(ctx, expected);
      if eb != expected { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const int requires expected scalar int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if !is_int_like_ty(ctx, eb) { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const int requires expected int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }

      let bt: ir.Ty = ir.ty_pool_get(ctx.pool, eb);
      if bt.kind == ir.TyKind.U64 || bt.kind == ir.TyKind.USize {
        let pru: ParseU64DecResult = parse_u64_dec(s);
        if !pru.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "integer literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: eb, iv: pru.val, bv: false, sv: "", sigs: sigs0, states: states0 };
      }

      let pr2: ParseI64DecResult = parse_i64_dec(s);
      if !pr2.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "integer literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      let v: i64 = pr2.val;
      if bt.kind == ir.TyKind.I8 && (v < -128 || v > 127) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "i8 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if bt.kind == ir.TyKind.U8 && (v < 0 || v > 255) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "u8 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if bt.kind == ir.TyKind.I16 && (v < -32768 || v > 32767) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "i16 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if bt.kind == ir.TyKind.U16 && (v < 0 || v > 65535) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "u16 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if bt.kind == ir.TyKind.I32 && (v < -2147483648 || v > 2147483647) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "i32 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if bt.kind == ir.TyKind.U32 && (v < 0 || v > 4294967295) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "u32 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if bt.kind == ir.TyKind.ISize { return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: eb, iv: v, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: eb, iv: v, bv: false, sv: "", sigs: sigs0, states: states0 };
    }

    // No expected type: default to i32 if it fits, else i64.
    let pr2: ParseI64DecResult = parse_i64_dec(s);
    if !pr2.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "integer literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let v2: i64 = pr2.val;
    if v2 >= -2147483648 && v2 <= 2147483647 {
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: ctx.ty_i32, iv: v2, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: ctx.ty_i64, iv: v2, bv: false, sv: "", sigs: sigs0, states: states0 };
  }
  if match n { ast.ExprNode.Float(_v) => true, _ => false } {
    let s: String = match n { ast.ExprNode.Float(x) => x, _ => "" };
    let suf: i32 = float_suffix_kind_text(s);
    let mut out_ty: i32 = if suf == 32 { ctx.ty_f32 } else { ctx.ty_f64 };
    if expected != -1 {
      let eb: i32 = strip_range(ctx, expected);
      if eb != expected {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const float requires expected scalar f32/f64"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if !is_float_scalar_ty(ctx, eb) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const float requires expected f32/f64"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if (suf == 32 && eb != ctx.ty_f32) || (suf == 64 && eb != ctx.ty_f64) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const float suffix conflicts with expected type"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      out_ty = eb;
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: out_ty, iv: 0, bv: false, sv: float_norm_text(s), sigs: sigs0, states: states0 };
  }
  if match n { ast.ExprNode.Bool(_v) => true, _ => false } {
    if expected != -1 && expected != ctx.ty_bool {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const bool requires expected bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let b: bool = match n { ast.ExprNode.Bool(x) => x, _ => false };
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: b, sv: "", sigs: sigs0, states: states0 };
  }
  if match n { ast.ExprNode.Str(_v) => true, _ => false } {
    if expected != -1 && expected != ctx.ty_string {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const string requires expected String"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let s: String = match n { ast.ExprNode.Str(x) => x, _ => "" };
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_str(), ty: ctx.ty_string, iv: 0, bv: false, sv: s, sigs: sigs0, states: states0 };
  }
  if match n { ast.ExprNode.Block(_b) => true, _ => false } {
    let b: ast.ExprBlock = match n { ast.ExprNode.Block(x) => x, _ => ast.ExprBlock { stmts: Vec(), has_tail: false, tail: -1 } };
    let sr: ConstExecStmtsResult = const_exec_stmts(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, b.stmts, locals, 0);
    if !sr.ok {
      return EvalConstExprResult { ok: false, err: sr.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
    }

    if sr.flow == const_flow_break() {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const break outside while"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
    }
    if sr.flow == const_flow_continue() {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const continue outside while"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
    }
    if sr.flow == const_flow_return() {
      if expected != -1 && !assignable_to(ctx, expected, sr.ret_ty) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const return type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
      }
      return EvalConstExprResult {
        ok: true, err: TcError.None,
        kind: sr.ret_kind, ty: sr.ret_ty, iv: sr.ret_iv, bv: sr.ret_bv, sv: sr.ret_sv,
        sigs: sr.sigs, states: sr.states,
      };
    }

    if !b.has_tail {
      if expected == -1 || expected == ctx.ty_unit {
        // Unit-valued block (e.g. if-expression branch used as statement).
        return EvalConstExprResult { ok: true, err: TcError.None, kind: 0, ty: ctx.ty_unit, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
      }
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const block requires tail expression"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
    }
    return eval_const_expr_in_mod_locals(ctx, w, items, sr.sigs, sr.states, cur_mod, imps, exprs, file, b.tail, expected, sr.locals);
  }

  if match n { ast.ExprNode.StructLit(_ty_expr, _fields) => true, _ => false } {
    let ty_expr: i32 = match n { ast.ExprNode.StructLit(t, _fields) => t, _ => -1 };
    let fields: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_t, fs) => fs, _ => Vec() };

    let tpr: ExprTypePathResult = expr_type_path(exprs, ty_expr);
    if !tpr.ok {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const struct literal type must be a type path"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let mut sty: i32 = -1;
    if tpr.targs.len() == 0 && const_struct_path_matches_expected(ctx, cur_mod, imps, tpr.parts, expected) {
      sty = strip_range(ctx, expected);
    } else {
      let tn: ast.TypeName = ast.TypeName { parts: tpr.parts, args: tpr.targs };
      let tr: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, Vec(), tn);
      if !tr.ok {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const struct literal type resolve failed"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      sty = tr.idx;
    }
    if !is_struct_ty(ctx, sty) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const struct literal expects struct type"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    if expected != -1 && !assignable_to(ctx, expected, sty) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const struct literal type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }

    let st: ir.Ty = ir.ty_pool_get(ctx.pool, sty);
    let fs: FindStructResult = find_struct(ctx, ty_mod(st), ty_name(st));
    if !fs.found {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "unknown struct type"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    if !vis_allows(fs.sig.vis, fs.sig.mod_path, cur_mod) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "type is private"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    if fields.len() != fs.sig.fields.len() {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "struct literal field count mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }

    let mut sigs2: Vec[ConstSig] = sigs0;
    let mut states2: Vec[i32] = states0;
    let mut payload: Vec[ConstEnumPayloadField] = Vec();
    let mut i: i32 = 0;
    while i < fs.sig.fields.len() {
      let sf: StructFieldSig = fs.sig.fields.get(i);
      if !vis_allows(sf.vis, fs.sig.mod_path, cur_mod) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "field is private"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
      }

      let mut hit: i32 = 0;
      let mut eid: i32 = -1;
      let mut fi: i32 = 0;
      while fi < fields.len() {
        let f: ast.StructLitField = fields.get(fi);
        if f.name == sf.name {
          hit = hit + 1;
          eid = f.expr;
        }
        fi = fi + 1;
      }
      if hit == 0 {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "missing field in const struct literal: ".concat(sf.name)), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
      }
      if hit > 1 {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "duplicate field in const struct literal: ".concat(sf.name)), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
      }

      let vr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs2, states2, cur_mod, imps, exprs, file, eid, sf.ty, locals);
      if !vr.ok { return vr; }
      sigs2 = vr.sigs;
      states2 = vr.states;
      if !assignable_to(ctx, sf.ty, vr.ty) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const struct literal field type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
      }

      let fr: ConstToPayloadFieldResult = const_payload_field_from_eval(vr);
      if !fr.ok {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, fr.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
      }
      payload.push(fr.f);
      i = i + 1;
    }

    return EvalConstExprResult {
      ok: true, err: TcError.None,
      kind: const_kind_struct(), ty: sty, iv: 0, bv: false, sv: const_struct_pack(payload),
      sigs: sigs2, states: states2,
    };
  }

  // enum variant shorthand: `.None` (unit) / `.Some(...)` (payload)
  // expected enum type is required.
  if match n { ast.ExprNode.DotIdent(_name) => true, _ => false } {
    let vname: String = match n { ast.ExprNode.DotIdent(x) => x, _ => "" };
    let mut parts0: Vec[String] = Vec();
    parts0.push(vname);
    let cr0: ConstResolveEnumCtorResult = const_resolve_enum_ctor(ctx, w, cur_mod, imps, parts0, Vec(), expected);
    if !cr0.ok {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, cr0.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    if cr0.fields.len() != 0 {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const enum payload requires call syntax"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let packed0: String = const_enum_pack(cr0.variant, Vec());
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_enum(), ty: cr0.enum_ty, iv: cr0.vidx as i64, bv: false, sv: packed0, sigs: sigs0, states: states0 };
  }

  // enum ctor call in const: `.Some(x)` / `E.Some(x)` / `alias.E.Some(x)`.
  if match n { ast.ExprNode.MacroCall(_c, _ta, _args) => true, _ => false } {
    return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "internal: unexpanded macro call reached const eval"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
  }

  if match n { ast.ExprNode.Call(_c, _ta, _args) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(c, _ta, _args) => c, _ => -1 };
    let type_args: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_c, ta, _args) => ta, _ => Vec() };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _ta, as0) => as0, _ => Vec() };
    let cn: ast.ExprNode = ast.expr_pool_get(exprs, callee);

    // Try normal function call first.
    let mut has_fn_target: bool = false;
    let mut fn_target_mod: String = "";
    let mut fn_target_name: String = "";
    let mut unresolved_ident_fn_name: String = "";

    let mut parts2: Vec[String] = Vec();
    let mut is_ctor: bool = false;
    let mut ctor_targs: Vec[ast.TypeName] = Vec();
    if match cn { ast.ExprNode.Ident(_name) => true, _ => false } {
      let fname: String = match cn { ast.ExprNode.Ident(x) => x, _ => "" };
      if fname == "@compile_error" {
        if type_args.len() != 0 || args.len() != 1 {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "@compile_error expects exactly one String argument"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
        }
        let mar: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, args.get(0), ctx.ty_string, locals);
        if !mar.ok { return mar; }
        if mar.kind != const_kind_str() {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "@compile_error expects String argument"), kind: 0, ty: mar.ty, iv: 0, bv: false, sv: "", sigs: mar.sigs, states: mar.states };
        }
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "compile_error: ".concat(mar.sv)), kind: 0, ty: mar.ty, iv: 0, bv: false, sv: "", sigs: mar.sigs, states: mar.states };
      }
      if is_reflect_intrinsic_name(fname) {
        return eval_const_reflect_intrinsic(ctx, w, cur_mod, imps, exprs, id, file, fname, type_args, args, expected, sigs0, states0);
      }
      let nf: NamedFuncImport = find_named_func(imps.named_funcs, fname);
      if nf.local != "" {
        has_fn_target = true;
        fn_target_mod = nf.mod_path;
        fn_target_name = nf.name;
      } else if find_func(ctx, cur_mod, fname).found {
        has_fn_target = true;
        fn_target_mod = cur_mod;
        fn_target_name = fname;
      } else if find_func(ctx, "std/prelude", fname).found {
        has_fn_target = true;
        fn_target_mod = "std/prelude";
        fn_target_name = fname;
      } else if find_func(ctx, "", fname).found {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const call does not support builtin function: ".concat(fname)), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      } else {
        unresolved_ident_fn_name = fname;
      }
    } else if match cn { ast.ExprNode.DotIdent(_name) => true, _ => false } {
      let vname2: String = match cn { ast.ExprNode.DotIdent(x) => x, _ => "" };
      parts2.push(vname2);
      is_ctor = true;
    } else if match cn { ast.ExprNode.Member(_recv, _name) => true, _ => false } {
      // Value receiver method call in const context (pure subset).
      let recv_m: i32 = match cn { ast.ExprNode.Member(rm, _nm) => rm, _ => -1 };
      let mname: String = match cn { ast.ExprNode.Member(_rm, nm) => nm, _ => "" };
      let mcr: ConstMemberCallResult = eval_const_member_call(
        ctx, w, items, sigs0, states0, cur_mod, imps, exprs,
        file, id, recv_m, mname, args, expected, locals
      );
      if mcr.matched { return mcr.ev; }

      let pr2: ExprTypePathResult = expr_type_path(exprs, callee);
      if pr2.ok {
        parts2 = pr2.parts;
        ctor_targs = pr2.targs;
        is_ctor = true;
        if ctor_targs.len() == 0 && parts2.len() >= 2 {
          let basef: String = find_alias(imps.aliases, parts2.get(0));
          if basef != "" {
            let extraf: Vec[String] = slice_parts(parts2, 1, parts2.len() - 1);
            let mpathf: String = if extraf.len() == 0 { basef } else { join_mod_path(basef, extraf) };
            let fnamef: String = parts2.get(parts2.len() - 1);
            if find_func(ctx, mpathf, fnamef).found {
              has_fn_target = true;
              fn_target_mod = mpathf;
              fn_target_name = fnamef;
            }
          }
        }
      }
    }

    if has_fn_target {
      let fr_call: FindFuncResult = find_func(ctx, fn_target_mod, fn_target_name);
      if !fr_call.found {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "unknown fn: ".concat(fn_target_name)), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if !vis_allows(fr_call.sig.vis, fn_target_mod, cur_mod) {
        let qn: String = const_qname(fn_target_mod, fn_target_name);
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "function is private: ".concat(qn)), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if args.len() != fr_call.sig.params.len() {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call arity mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }

      let fdr: ConstFindFuncDeclResult = const_find_func_decl(w, fn_target_mod, fn_target_name);
      if !fdr.found {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn body unavailable"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if fdr.decl.params.len() != args.len() {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn decl/signature mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }

      let fmf: FindModResult = find_mod(w, fn_target_mod);
      if !fmf.found {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "unknown module: ".concat(fn_target_mod)), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      let mf: WorldModule = w.mods.get(fmf.idx);
      let imr: ImportsResult = build_imports(w, fn_target_mod, mf.prog.imports, fdr.decl.file);
      if !imr.ok {
        return EvalConstExprResult { ok: false, err: imr.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }

      let mut sigs2: Vec[ConstSig] = sigs0;
      let mut states2: Vec[i32] = states0;
      let mut call_ret_ty: i32 = fr_call.sig.ret;
      let mut call_param_tys: Vec[i32] = Vec();
      let mut call_arg_vals: Vec[EvalConstExprResult] = Vec();
      let mut csubs: Vec[ConstSub] = Vec();
      let is_generic_call: bool = fr_call.sig.type_params.len() != 0 || fr_call.sig.const_params.len() != 0;

      if !is_generic_call {
        if type_args.len() != 0 {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call does not accept generic args"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
        }
        let mut ai_plain: i32 = 0;
        while ai_plain < args.len() {
          let want_plain: i32 = fr_call.sig.params.get(ai_plain);
          let ar_plain: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs2, states2, cur_mod, imps, exprs, file, args.get(ai_plain), want_plain, locals);
          if !ar_plain.ok { return ar_plain; }
          sigs2 = ar_plain.sigs;
          states2 = ar_plain.states;
          if !assignable_to(ctx, want_plain, ar_plain.ty) {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn arg type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
          }
          call_param_tys.push(want_plain);
          call_arg_vals.push(ar_plain);
          ai_plain = ai_plain + 1;
        }
      } else {
        let mut explicit_targ_n: i32 = type_args.len();
        let mut first_const: i32 = -1;
        let mut xi: i32 = 0;
        while xi < type_args.len() {
          if is_const_generic_arg_tn_or_const_local(type_args.get(xi), locals) {
            first_const = xi;
            xi = type_args.len();
          } else {
            xi = xi + 1;
          }
        }
        if first_const != -1 {
          explicit_targ_n = first_const;
          let mut xj: i32 = first_const;
          while xj < type_args.len() {
            if !is_const_generic_arg_tn_or_const_local(type_args.get(xj), locals) {
              return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call generic args mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
            }
            xj = xj + 1;
          }
        }
        if !const_explicit_type_arg_arity_ok(fr_call.sig, explicit_targ_n) {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call generic args mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
        }
        let explicit_const_n: i32 = type_args.len() - explicit_targ_n;
        if explicit_const_n > fr_call.sig.const_params.len() {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call generic args mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
        }

        let mut explicit_targs: Vec[ast.TypeName] = Vec();
        let mut ci0: i32 = 0;
        while ci0 < explicit_targ_n {
          let ta0: ast.TypeName = type_args.get(ci0);
          if is_const_generic_arg_tn_or_const_local(ta0, locals) {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call generic args mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
          }
          explicit_targs.push(ta0);
          ci0 = ci0 + 1;
        }

        let mut cidx: i32 = 0;
        while cidx < fr_call.sig.const_params.len() {
          let cp: ConstParamSig = fr_call.sig.const_params.get(cidx);
          if cidx < explicit_const_n {
            let ctn: ast.TypeName = type_args.get(explicit_targ_n + cidx);
            let pr: ParseConstGenericArgResult = parse_const_generic_arg_in_const_locals(ctx, ctn, cp.ty, locals);
            if !pr.ok {
              return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call const generic arg out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
            }
            csubs.push(ConstSub { name: cp.name, ty: cp.ty, iv: pr.iv, text: pr.text });
          } else {
            if !cp.has_default {
              return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call missing const generic arg"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
            }
            csubs.push(ConstSub { name: cp.name, ty: cp.ty, iv: cp.default_iv, text: cp.default_text });
          }
          cidx = cidx + 1;
        }
        let mut subs: Vec[TySub] = Vec();
        if expected != -1 {
          let ur0: UnifyResult = unify_ty(ctx, fr_call.sig.ret, expected, subs);
          if !ur0.ok {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call result type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
          }
          subs = ur0.subs;
        }

        let mut ti: i32 = 0;
        while ti < explicit_targs.len() {
          let tr: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, Vec(), explicit_targs.get(ti));
          if !tr.ok {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call type arg resolve failed"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
          }
          let tp: String = const_explicit_type_arg_bind_name(fr_call.sig, ti);
          let cur_ty: i32 = subs_lookup(subs, tp);
          if cur_ty != -1 && cur_ty != tr.idx {
            let is_pack_bind: bool = const_has_type_param_pack(fr_call.sig) && tp == fr_call.sig.type_param_packs.get(0);
            if is_pack_bind && const_sig_allows_heterogeneous_pack_args(ctx, fr_call.sig, tp) {
              ti = ti + 1;
              continue;
            }
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call type arg mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
          }
          if cur_ty == -1 {
            subs.push(TySub { name: tp, ty: tr.idx });
          }
          ti = ti + 1;
        }

        let mut ai_gen: i32 = 0;
        while ai_gen < args.len() {
          let want0: i32 = subst_ty(ctx, fr_call.sig.params.get(ai_gen), subs);
          let want_t: ir.Ty = ir.ty_pool_get(ctx.pool, want0);
          let want: i32 = if want_t.kind == ir.TyKind.Param || ty_has_param(ctx, want0) { -1 } else { want0 };
          let ar_gen: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs2, states2, cur_mod, imps, exprs, file, args.get(ai_gen), want, locals);
          if !ar_gen.ok { return ar_gen; }
          sigs2 = ar_gen.sigs;
          states2 = ar_gen.states;
          let ur2: UnifyResult = unify_ty(ctx, fr_call.sig.params.get(ai_gen), ar_gen.ty, subs);
          if !ur2.ok {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call generic arg type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
          }
          subs = ur2.subs;
          call_arg_vals.push(ar_gen);
          ai_gen = ai_gen + 1;
        }

        let mut j: i32 = 0;
        while j < fr_call.sig.type_params.len() {
          let tpj: String = fr_call.sig.type_params.get(j);
          if subs_lookup(subs, tpj) == -1 {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call cannot infer generic args"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
          }
          j = j + 1;
        }

        let cwr: ConstWhereCheckResult = check_const_where_bounds(ctx, fr_call.sig.const_where_bounds, subs, csubs);
        if !cwr.ok {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, cwr.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
        }

        let mut bi: i32 = 0;
        while bi < fr_call.sig.type_param_bounds.len() {
          let b: TypeParamBoundSig = fr_call.sig.type_param_bounds.get(bi);
          let ty0: i32 = subs_lookup(subs, b.type_param);
          if ty0 == -1 {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call cannot infer generic args"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
          }
          let ty1: i32 = strip_range(ctx, ty0);
          let fi: FindImplForTyResult = find_impl_for_ty(ctx, b.trait_mod_path, b.trait_name, ty1);
          if fi.ambiguous {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call has ambiguous trait impl"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
          }
          if !fi.found {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call type arg does not satisfy trait bound"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
          }
          bi = bi + 1;
        }

        let mut pi_gen: i32 = 0;
        while pi_gen < fr_call.sig.params.len() {
          let pt: i32 = subst_ty(ctx, fr_call.sig.params.get(pi_gen), subs);
          if pt == ctx.ty_bad || ty_has_param(ctx, pt) {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call has unresolved generic param type"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
          }
          call_param_tys.push(pt);
          pi_gen = pi_gen + 1;
        }

        call_ret_ty = subst_ty(ctx, fr_call.sig.ret, subs);
        if call_ret_ty == ctx.ty_bad || ty_has_param(ctx, call_ret_ty) {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call has unresolved generic return type"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
        }

        let mut ck: i32 = 0;
        while ck < call_arg_vals.len() {
          if !assignable_to(ctx, call_param_tys.get(ck), call_arg_vals.get(ck).ty) {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn arg type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
          }
          ck = ck + 1;
        }
      }

      let mut call_locals: Vec[ConstLocal] = Vec();
      let mut ci_bind: i32 = 0;
      while ci_bind < fr_call.sig.const_params.len() {
        let cpb: ConstParamSig = fr_call.sig.const_params.get(ci_bind);
        let mut cfound: bool = false;
        let mut civ: i64 = 0;
        let mut ci_find: i32 = 0;
        while ci_find < csubs.len() {
          let cs_find: ConstSub = csubs.get(ci_find);
          if cs_find.name == cpb.name {
            cfound = true;
            civ = cs_find.iv;
            ci_find = csubs.len();
          } else {
            ci_find = ci_find + 1;
          }
        }
        if !cfound {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call missing const generic arg"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
        }
        let cv: EvalConstExprResult = EvalConstExprResult {
          ok: true, err: TcError.None,
          kind: const_kind_int(), ty: cpb.ty, iv: civ, bv: false, sv: "",
          sigs: sigs2, states: states2,
        };
        call_locals.push(const_local_from_value(cpb.name, false, cv));
        ci_bind = ci_bind + 1;
      }

      let mut ai0: i32 = 0;
      while ai0 < args.len() {
        let pname: String = fdr.decl.params.get(ai0).name;
        let av: EvalConstExprResult = call_arg_vals.get(ai0);
        let av2: EvalConstExprResult = EvalConstExprResult {
          ok: true, err: TcError.None,
          kind: av.kind, ty: call_param_tys.get(ai0), iv: av.iv, bv: av.bv, sv: av.sv,
          sigs: sigs2, states: states2,
        };
        call_locals.push(const_local_from_value(pname, false, av2));
        ai0 = ai0 + 1;
      }

      let sr: ConstExecStmtsResult = const_exec_stmts(ctx, w, items, sigs2, states2, fn_target_mod, imr.imps, mf.prog.exprs, fdr.decl.file, fdr.decl.body.stmts, call_locals, 0);
      if !sr.ok {
        return EvalConstExprResult { ok: false, err: sr.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
      }
      if sr.flow == const_flow_break() || sr.flow == const_flow_continue() {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn body has invalid loop control flow"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
      }
      if sr.flow == const_flow_return() {
        if !assignable_to(ctx, call_ret_ty, sr.ret_ty) {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn return type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
        }
        if expected != -1 && !assignable_to(ctx, expected, call_ret_ty) {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call result type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
        }
        return EvalConstExprResult {
          ok: true, err: TcError.None,
          kind: sr.ret_kind, ty: call_ret_ty, iv: sr.ret_iv, bv: sr.ret_bv, sv: sr.ret_sv,
          sigs: sr.sigs, states: sr.states,
        };
      }

      if call_ret_ty == ctx.ty_unit {
        if expected != -1 && !assignable_to(ctx, expected, ctx.ty_unit) {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call result type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
        }
        return EvalConstExprResult { ok: true, err: TcError.None, kind: 0, ty: ctx.ty_unit, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
      }
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const fn call requires explicit return"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
    }

    if is_ctor {
      if type_args.len() != 0 {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const enum ctor does not accept type args"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      let cr2: ConstResolveEnumCtorResult = const_resolve_enum_ctor(ctx, w, cur_mod, imps, parts2, ctor_targs, expected);
      if !cr2.ok {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, cr2.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if args.len() != cr2.fields.len() {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const enum payload arity mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }

      let mut sigs2: Vec[ConstSig] = sigs0;
      let mut states2: Vec[i32] = states0;
      let mut payload: Vec[ConstEnumPayloadField] = Vec();
      let mut ai: i32 = 0;
      while ai < args.len() {
        let want_ty: i32 = cr2.fields.get(ai);
        let ar2: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs2, states2, cur_mod, imps, exprs, file, args.get(ai), want_ty, locals);
        if !ar2.ok { return ar2; }
        sigs2 = ar2.sigs;
        states2 = ar2.states;

        let fr: ConstToPayloadFieldResult = const_payload_field_from_eval(ar2);
        if !fr.ok {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, fr.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
        }
        payload.push(fr.f);
        ai = ai + 1;
      }

      let packed: String = const_enum_pack(cr2.variant, payload);
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_enum(), ty: cr2.enum_ty, iv: cr2.vidx as i64, bv: false, sv: packed, sigs: sigs2, states: states2 };
    }

    if unresolved_ident_fn_name != "" {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "unknown fn: ".concat(unresolved_ident_fn_name)), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
  }

  // identifier: must resolve to a const
  if match n { ast.ExprNode.Ident(_x) => true, _ => false } {
    let name: String = match n { ast.ExprNode.Ident(x) => x, _ => "" };
    let li: i32 = const_find_local(locals, name);
    if li != -1 {
      let lv: ConstLocal = locals.get(li);
      if expected != -1 && !assignable_to(ctx, expected, lv.ty) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const local type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: lv.kind, ty: lv.ty, iv: lv.iv, bv: lv.bv, sv: lv.sv, sigs: sigs0, states: states0 };
    }

    let ni: NamedConstImport = find_named_const(imps.named_consts, name);
    let want_mod: String = if ni.local != "" { ni.mod_path } else { cur_mod };
    let want_name: String = if ni.local != "" { ni.name } else { name };
    let idx: i32 = const_find_item(items, want_mod, want_name);
    if idx == -1 {
      let qn2: String = const_qname(want_mod, want_name);
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "unknown const: ".concat(qn2)), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    // ensure referenced const is resolved
    let rr: ResolveConstResult = resolve_const(ctx, w, items, sigs0, states0, idx);
    if !rr.ok { return EvalConstExprResult { ok: false, err: rr.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr.sigs, states: rr.states }; }
    let cs: ConstSig = rr.sigs.get(idx);
    if !vis_allows(cs.vis, want_mod, cur_mod) {
      let qn3: String = const_qname(want_mod, want_name);
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const is private: ".concat(qn3)), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr.sigs, states: rr.states };
    }
    if expected != -1 && !assignable_to(ctx, expected, cs.ty) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr.sigs, states: rr.states };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: cs.kind, ty: cs.ty, iv: cs.iv, bv: cs.bv, sv: cs.sv, sigs: rr.sigs, states: rr.states };
  }

  // module-qualified const or enum unit value:
  // `alias.NAME` / `alias.mod.NAME` / `E.A` / `alias.E.A`
  if match n { ast.ExprNode.Member(_r, _name) => true, _ => false } {
    let recv: i32 = match n { ast.ExprNode.Member(r, _name) => r, _ => -1 };
    let mname: String = match n { ast.ExprNode.Member(_r, x) => x, _ => "" };

    // Value field access first: `v.field` where `v` is a const struct value.
    let vr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, recv, -1, locals);
    if vr.ok && vr.kind == const_kind_struct() && is_struct_ty(ctx, vr.ty) {
      let st: ir.Ty = ir.ty_pool_get(ctx.pool, vr.ty);
      let fs: FindStructResult = find_struct(ctx, ty_mod(st), ty_name(st));
      if !fs.found {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "unknown struct type"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: vr.sigs, states: vr.states };
      }
      if !vis_allows(fs.sig.vis, fs.sig.mod_path, cur_mod) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "type is private"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: vr.sigs, states: vr.states };
      }

      let decs: ConstStructDecode = const_struct_unpack(vr.sv);
      if !decs.ok || decs.fields.len() != fs.sig.fields.len() {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "bad const struct encoding"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: vr.sigs, states: vr.states };
      }

      let mut fi: i32 = 0;
      while fi < fs.sig.fields.len() {
        let sf: StructFieldSig = fs.sig.fields.get(fi);
        if sf.name == mname {
          if !vis_allows(sf.vis, fs.sig.mod_path, cur_mod) {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "field is private"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: vr.sigs, states: vr.states };
          }
          let out: EvalConstExprResult = const_payload_field_eval(vr, decs.fields.get(fi));
          if expected != -1 && !assignable_to(ctx, expected, out.ty) {
            return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const member type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: vr.sigs, states: vr.states };
          }
          return out;
        }
        fi = fi + 1;
      }
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "unknown field"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: vr.sigs, states: vr.states };
    }

    let pr: ExprTypePathResult = expr_type_path(exprs, id);
    if !pr.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "unsupported const member path"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let parts: Vec[String] = pr.parts;
    let enum_targs: Vec[ast.TypeName] = pr.targs;
    if parts.len() < 2 { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "unsupported const member path"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let base: String = find_alias(imps.aliases, parts.get(0));
    if base != "" && enum_targs.len() == 0 {
      let extra: Vec[String] = slice_parts(parts, 1, parts.len() - 1);
      let want_mod: String = if extra.len() == 0 { base } else { join_mod_path(base, extra) };
      let want_name: String = parts.get(parts.len() - 1);
      let idx2: i32 = const_find_item(items, want_mod, want_name);
      if idx2 != -1 {
        let rr2: ResolveConstResult = resolve_const(ctx, w, items, sigs0, states0, idx2);
        if !rr2.ok { return EvalConstExprResult { ok: false, err: rr2.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states }; }
        let cs2: ConstSig = rr2.sigs.get(idx2);
        if !vis_allows(cs2.vis, want_mod, cur_mod) {
          let qn4: String = const_qname(want_mod, want_name);
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const is private: ".concat(qn4)), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        if expected != -1 && !assignable_to(ctx, expected, cs2.ty) {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        return EvalConstExprResult { ok: true, err: TcError.None, kind: cs2.kind, ty: cs2.ty, iv: cs2.iv, bv: cs2.bv, sv: cs2.sv, sigs: rr2.sigs, states: rr2.states };
      }
    }

    // Fallback to enum unit value path when const lookup does not match.
    let cr3: ConstResolveEnumCtorResult = const_resolve_enum_ctor(ctx, w, cur_mod, imps, parts, enum_targs, expected);
    if !cr3.ok {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, cr3.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    if cr3.fields.len() != 0 {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const enum payload requires call syntax"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let packed3: String = const_enum_pack(cr3.variant, Vec());
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_enum(), ty: cr3.enum_ty, iv: cr3.vidx as i64, bv: false, sv: packed3, sigs: sigs0, states: states0 };
  }

  // unary
  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let op: ast.UnaryOp = match n { ast.ExprNode.Unary(o, _a) => o, _ => ast.UnaryOp.Not };
    let a: i32 = match n { ast.ExprNode.Unary(_o, x) => x, _ => -1 };
    let is_not: bool = match op { ast.UnaryOp.Not => true, _ => false };
    let is_pos: bool = match op { ast.UnaryOp.Pos => true, _ => false };
    if is_not {
      let mut a_expected0: i32 = -1;
      if expected != -1 {
        let eb0: i32 = strip_range(ctx, expected);
        if eb0 == ctx.ty_bool {
          a_expected0 = ctx.ty_bool;
        } else if is_int_like_ty(ctx, eb0) {
          a_expected0 = eb0;
        } else {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const ! expects bool or int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
        }
      }
      let ar: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, a_expected0, locals);
      if !ar.ok { return ar; }
      if ar.kind == const_kind_bool() {
        if expected != -1 && expected != ctx.ty_bool {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const ! type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
        }
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: !ar.bv, sv: "", sigs: ar.sigs, states: ar.states };
      }
      if ar.kind == const_kind_int() {
        let out_tyi: i32 = if expected != -1 { strip_range(ctx, expected) } else { strip_range(ctx, ar.ty) };
        let k0: ir.TyKind = int_kind(ctx, out_tyi);
        if !is_int_scalar_kind(k0) {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const ! expects bool or int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
        }
        // bitwise not for i64 bit-pattern using two's-complement identity: !x == -x - 1
        let raw0: i64 = ((0 as i64) - ar.iv) - (1 as i64);
        let wr0: WrapResult = wrap_value_for_type(ctx, file, out_tyi, raw0);
        if !wr0.ok {
          return EvalConstExprResult { ok: false, err: wr0.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
        }
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: out_tyi, iv: wr0.v, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
      }
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const ! expects bool or int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
    }
    if is_pos {
      let ar1: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, expected, locals);
      if !ar1.ok { return ar1; }
      let out_ty1: i32 = strip_range(ctx, ar1.ty);
      if !is_int_like_ty(ctx, out_ty1) && !is_float_scalar_ty(ctx, out_ty1) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const + expects int/float"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar1.sigs, states: ar1.states };
      }
      return ar1;
    }
    // neg
    let ar2: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, -1, locals);
    if !ar2.ok { return ar2; }
    if ar2.kind == const_kind_float() {
      let out_tyf: i32 = if expected != -1 { strip_range(ctx, expected) } else { strip_range(ctx, ar2.ty) };
      if !is_float_scalar_ty(ctx, out_tyf) {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const - expects float or signed int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states };
      }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: out_tyf, iv: 0, bv: false, sv: float_neg_text(ar2.sv), sigs: ar2.sigs, states: ar2.states };
    }

    if ar2.kind != const_kind_int() {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const - expects float or signed int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states };
    }
    let out_ty: i32 = if expected != -1 { strip_range(ctx, expected) } else { strip_range(ctx, ar2.ty) };
    let k: ir.TyKind = int_kind(ctx, out_ty);
    if !is_signed_int_kind(k) { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const - expects signed int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states }; }
    let wr: WrapResult = wrap_value_for_type(ctx, file, out_ty, -ar2.iv);
    if !wr.ok { return EvalConstExprResult { ok: false, err: wr.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states }; }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: out_ty, iv: wr.v, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states };
  }

  // cast: `expr as Type`
  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(x, _tn) => x, _ => -1 };
    let tn: ast.TypeName = match n { ast.ExprNode.As(_a2, t) => t, _ => ast.TypeName { parts: Vec(), args: Vec() } };
    let tr: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, Vec(), tn);
    let c2: Ctx = tr.ctx;
    if !tr.ok { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const expression: unknown cast type"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let to: i32 = tr.idx;
    let to_base: i32 = strip_range(c2, to);
    if is_float_scalar_ty(c2, to_base) {
      let an_f: ast.ExprNode = ast.expr_pool_get(exprs, a);
      let eval_expected_f: i32 = if match an_f { ast.ExprNode.Float(_s) => true, _ => false } { to_base } else { -1 };
      let ar_f: EvalConstExprResult = eval_const_expr_in_mod_locals(c2, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, eval_expected_f, locals);
      if !ar_f.ok { return ar_f; }
      if ar_f.kind == const_kind_float() && is_float_scalar_ty(c2, ar_f.ty) {
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: to_base, iv: 0, bv: false, sv: float_norm_text(ar_f.sv), sigs: ar_f.sigs, states: ar_f.states };
      }
      if ar_f.kind == const_kind_int() && is_int_like_ty(c2, ar_f.ty) {
        let from_base_i: i32 = strip_range(c2, ar_f.ty);
        let sv: String = const_int_to_float_text(c2, from_base_i, ar_f.iv);
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: to_base, iv: 0, bv: false, sv: sv, sigs: ar_f.sigs, states: ar_f.states };
      }
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const expression: cast expects int/float"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar_f.sigs, states: ar_f.states };
    }

    let tk: ir.TyKind = int_kind(c2, to_base);
    if !is_int_scalar_kind(tk) {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const expression: cast target must be int/@range int or f32/f64"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }

    let an: ast.ExprNode = ast.expr_pool_get(exprs, a);
    let eval_expected: i32 = if match an { ast.ExprNode.Int(_s) => true, _ => false } && is_unsigned_int_kind(tk) { to_base } else { -1 };
    let ar: EvalConstExprResult = eval_const_expr_in_mod_locals(c2, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, eval_expected, locals);
    if !ar.ok { return ar; }
    let mut v: i64 = 0;
    if ar.kind == const_kind_int() {
      let from_base: i32 = strip_range(c2, ar.ty);
      let cr: CastConstResult = cast_const_int_checked(c2, file, from_base, to_base, ar.iv);
      if !cr.ok { return EvalConstExprResult { ok: false, err: cr.err, kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states }; }
      v = cr.v;
    } else if ar.kind == const_kind_float() && is_float_scalar_ty(c2, ar.ty) {
      let cfr: CastConstFloatToIntResult = cast_const_float_to_int_checked(c2, to_base, ar.sv);
      if !cfr.ok {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, cfr.err), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
      }
      v = cfr.v;
    } else {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const expression: cast expects int/float"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
    }

    if is_range_ty(c2, to) {
      let rt: ir.Ty = ir.ty_pool_get(c2.pool, to);
      if v < rt.lo || v > rt.hi {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const expression: range check failed"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
      }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: to, iv: v, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: to_base, iv: v, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
  }

  // if expr
  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } {
    let cnd: i32 = match n { ast.ExprNode.If(c, _t, _e) => c, _ => -1 };
    let thn: i32 = match n { ast.ExprNode.If(_c, t, _e) => t, _ => -1 };
    let els: i32 = match n { ast.ExprNode.If(_c, _t, e2) => e2, _ => -1 };
    let cr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, cnd, ctx.ty_bool, locals);
    if !cr.ok { return cr; }
    if cr.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const if cond must be bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: cr.sigs, states: cr.states }; }
    if cr.bv {
      return eval_const_expr_in_mod_locals(ctx, w, items, cr.sigs, cr.states, cur_mod, imps, exprs, file, thn, expected, locals);
    }
    return eval_const_expr_in_mod_locals(ctx, w, items, cr.sigs, cr.states, cur_mod, imps, exprs, file, els, expected, locals);
  }

  // match expr (const v0 subset: wildcard/bind/bool/int/string/enum patterns).
  if match n { ast.ExprNode.Match(_scrut, _arms) => true, _ => false } {
    let scrut: i32 = match n { ast.ExprNode.Match(s, _as) => s, _ => -1 };
    let arms: Vec[ast.MatchArm] = match n { ast.ExprNode.Match(_s, as0) => as0, _ => Vec() };
    if arms.len() == 0 {
      return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const match requires at least one arm"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }

    let sr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, scrut, -1, locals);
    if !sr.ok { return sr; }

    let mut ai: i32 = 0;
    while ai < arms.len() {
      let arm: ast.MatchArm = arms.get(ai);
      let pr: ConstPatEvalResult = const_pat_matches(ctx, sr, arm.pat);
      if !pr.ok {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, pr.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
      }
      if pr.matched {
        let mut arm_locals: Vec[ConstLocal] = locals;
        let mut bi2: i32 = 0;
        while bi2 < pr.binds.len() {
          arm_locals.push(pr.binds.get(bi2));
          bi2 = bi2 + 1;
        }
        return eval_const_expr_in_mod_locals(ctx, w, items, sr.sigs, sr.states, cur_mod, imps, exprs, file, arm.expr, expected, arm_locals);
      }
      ai = ai + 1;
    }

    return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const match has no matching arm"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
  }

  // binary
  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let op: ast.BinaryOp = match n { ast.ExprNode.Binary(o, _l, _r) => o, _ => ast.BinaryOp.Add };
    let l: i32 = match n { ast.ExprNode.Binary(_o, x, _r) => x, _ => -1 };
    let r: i32 = match n { ast.ExprNode.Binary(_o, _l, x) => x, _ => -1 };

    let is_logic: bool = match op { ast.BinaryOp.AndAnd => true, ast.BinaryOp.OrOr => true, _ => false };
    if is_logic {
      let lr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, l, ctx.ty_bool, locals);
      if !lr.ok { return lr; }
      if lr.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const &&/|| expects bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: lr.sigs, states: lr.states }; }
      if match op { ast.BinaryOp.AndAnd => true, _ => false } && !lr.bv {
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: false, sv: "", sigs: lr.sigs, states: lr.states };
      }
      if match op { ast.BinaryOp.OrOr => true, _ => false } && lr.bv {
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: true, sv: "", sigs: lr.sigs, states: lr.states };
      }
      let rr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, lr.sigs, lr.states, cur_mod, imps, exprs, file, r, ctx.ty_bool, locals);
      if !rr.ok { return rr; }
      if rr.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const &&/|| expects bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr.sigs, states: rr.states }; }
      let out: bool = if match op { ast.BinaryOp.AndAnd => true, _ => false } { lr.bv && rr.bv } else { lr.bv || rr.bv };
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: out, sv: "", sigs: rr.sigs, states: rr.states };
    }

    let is_cmp: bool = match op { ast.BinaryOp.Lt => true, ast.BinaryOp.Le => true, ast.BinaryOp.Gt => true, ast.BinaryOp.Ge => true, _ => false };
    let is_eq: bool = match op { ast.BinaryOp.Eq => true, ast.BinaryOp.Ne => true, _ => false };
    let is_arith: bool = match op { ast.BinaryOp.Add => true, ast.BinaryOp.Sub => true, ast.BinaryOp.Mul => true, ast.BinaryOp.Div => true, ast.BinaryOp.Mod => true, _ => false };
    let is_bit: bool = match op { ast.BinaryOp.BitAnd => true, ast.BinaryOp.BitOr => true, ast.BinaryOp.BitXor => true, _ => false };
    let is_shift: bool = match op { ast.BinaryOp.Shl => true, ast.BinaryOp.Shr => true, _ => false };

    if is_arith || is_bit || is_shift || is_cmp {
      // For comparisons assigned to bool, infer operand type from lhs/rhs instead
      // of forcing expected=bool into numeric subexpressions.
      let is_cmp_bool_ctx: bool = is_cmp && expected == ctx.ty_bool;
      let lhs_expected: i32 = if is_cmp_bool_ctx { -1 } else { expected };
      let mut lr2: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, l, lhs_expected, locals);
      if !lr2.ok && is_cmp_bool_ctx {
        // Keep const-eval usable for literal-vs-literal int comparisons.
        lr2 = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, l, ctx.ty_i32, locals);
      }
      if !lr2.ok { return lr2; }

      let rhs_expected: i32 =
        if is_cmp_bool_ctx {
          strip_range(ctx, lr2.ty)
        } else {
          expected
        };
      let rr2: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, lr2.sigs, lr2.states, cur_mod, imps, exprs, file, r, rhs_expected, locals);
      if !rr2.ok { return rr2; }
      let out_ty: i32 = if is_cmp { strip_range(ctx, lr2.ty) } else if expected != -1 { strip_range(ctx, expected) } else { strip_range(ctx, lr2.ty) };
      if strip_range(ctx, lr2.ty) != out_ty || strip_range(ctx, rr2.ty) != out_ty {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const op type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
      }

      if is_cmp && out_ty == ctx.ty_string {
        if lr2.kind != const_kind_str() || rr2.kind != const_kind_str() {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const string compare expects string"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        let c: i32 = string_cmp_text(lr2.sv, rr2.sv);
        let outb: bool =
          match op {
            ast.BinaryOp.Lt => c < 0,
            ast.BinaryOp.Le => c <= 0,
            ast.BinaryOp.Gt => c > 0,
            _ => c >= 0,
          };
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: outb, sv: "", sigs: rr2.sigs, states: rr2.states };
      }

      if is_bit && out_ty == ctx.ty_bool {
        if lr2.kind != const_kind_bool() || rr2.kind != const_kind_bool() {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const bit op expects bool or int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        let outb2: bool =
          match op {
            ast.BinaryOp.BitAnd => lr2.bv && rr2.bv,
            ast.BinaryOp.BitOr => lr2.bv || rr2.bv,
            _ => lr2.bv != rr2.bv,
          };
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: outb2, sv: "", sigs: rr2.sigs, states: rr2.states };
      }

      if lr2.kind == const_kind_float() || rr2.kind == const_kind_float() {
        if lr2.kind != const_kind_float() || rr2.kind != const_kind_float() || !is_float_scalar_ty(ctx, out_ty) {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const float op expects f32/f64"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        let fr: ConstFloatBinaryEvalResult = const_float_binary_eval(op, lr2.sv, rr2.sv);
        if !fr.ok {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, fr.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        if fr.is_bool {
          return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: fr.out, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: out_ty, iv: 0, bv: false, sv: fr.text, sigs: rr2.sigs, states: rr2.states };
      }

      if lr2.kind != const_kind_int() || rr2.kind != const_kind_int() {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const int op expects ints"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
      }
      let k: ir.TyKind = int_kind(ctx, out_ty);
      if !is_int_scalar_kind(k) { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const int op expects int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states }; }

      if is_cmp {
        let outb: bool =
          if is_signed_int_kind(k) {
            match op {
              ast.BinaryOp.Lt => lr2.iv < rr2.iv,
              ast.BinaryOp.Le => lr2.iv <= rr2.iv,
              ast.BinaryOp.Gt => lr2.iv > rr2.iv,
              _ => lr2.iv >= rr2.iv,
            }
          } else {
            match op {
              ast.BinaryOp.Lt => u64_lt_bits(lr2.iv, rr2.iv),
              ast.BinaryOp.Le => u64_le_bits(lr2.iv, rr2.iv),
              ast.BinaryOp.Gt => u64_lt_bits(rr2.iv, lr2.iv),
              _ => u64_le_bits(rr2.iv, lr2.iv),
            }
          };
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: outb, sv: "", sigs: rr2.sigs, states: rr2.states };
      }

      let is_div: bool = match op { ast.BinaryOp.Div => true, _ => false };
      let is_mod: bool = match op { ast.BinaryOp.Mod => true, _ => false };
      if (is_div || is_mod) && rr2.iv == 0 {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const division by zero"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
      }
      if (is_div || is_mod) && is_signed_int_kind(k) {
        let min: i64 =
          if k == ir.TyKind.I8 { -128 }
          else if k == ir.TyKind.I16 { -32768 }
          else if k == ir.TyKind.I32 { -2147483647 - 1 }
          else { -9223372036854775807 - 1 };
        if lr2.iv == min && rr2.iv == -1 {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const division overflow"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
      }
      if is_shift {
        let wbits: i64 = int_bits_of_kind(k);
        if rr2.iv < 0 || rr2.iv >= wbits {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const shift count out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
      }

      let mut raw: i64 = 0;
      if is_div {
        if is_signed_int_kind(k) { raw = lr2.iv / rr2.iv; }
        else { raw = u64_div_bits(lr2.iv, rr2.iv); }
      } else if is_mod {
        if is_signed_int_kind(k) { raw = lr2.iv % rr2.iv; }
        else { raw = u64_mod_bits(lr2.iv, rr2.iv); }
      } else {
        raw = match op {
          ast.BinaryOp.Add => lr2.iv + rr2.iv,
          ast.BinaryOp.Sub => lr2.iv - rr2.iv,
          ast.BinaryOp.Mul => lr2.iv * rr2.iv,
          ast.BinaryOp.BitAnd => lr2.iv & rr2.iv,
          ast.BinaryOp.BitOr => lr2.iv | rr2.iv,
          ast.BinaryOp.BitXor => lr2.iv ^ rr2.iv,
          ast.BinaryOp.Shl => lr2.iv << rr2.iv,
          _ => lr2.iv >> rr2.iv,
        };
      }
      let wr: WrapResult = wrap_value_for_type(ctx, file, out_ty, raw);
      if !wr.ok {
        return EvalConstExprResult { ok: false, err: wr.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
      }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: out_ty, iv: wr.v, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
    }

    if is_eq {
      let lr3: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, l, -1, locals);
      if !lr3.ok { return lr3; }
      let rr3: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, lr3.sigs, lr3.states, cur_mod, imps, exprs, file, r, -1, locals);
      if !rr3.ok { return rr3; }

      let lb: i32 = strip_range(ctx, lr3.ty);
      let rb: i32 = strip_range(ctx, rr3.ty);
      if lb != rb { return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const ==/!= type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states }; }

      if is_float_scalar_ty(ctx, lb) {
        if lr3.kind != const_kind_float() || rr3.kind != const_kind_float() {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const ==/!= expects float"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states };
        }
        let fr2: ConstFloatBinaryEvalResult = const_float_binary_eval(op, lr3.sv, rr3.sv);
        if !fr2.ok || !fr2.is_bool {
          return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "const float op unsupported"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states };
        }
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: fr2.out, sv: "", sigs: rr3.sigs, states: rr3.states };
      }

      let er: ConstEqResult = const_value_eq(ctx, lr3, rr3);
      if !er.ok {
        return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, er.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states };
      }

      let ne: bool = match op { ast.BinaryOp.Ne => true, _ => false };
      let out: bool = if ne { !er.eq } else { er.eq };
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: out, sv: "", sigs: rr3.sigs, states: rr3.states };
    }

    return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "unsupported const binary op"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
  }

  return EvalConstExprResult { ok: false, err: const_expr_error(file, exprs, id, "unsupported const expression"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
}

fn eval_const_expr_in_mod(
  ctx: Ctx,
  w: World,
  items: Vec[ConstItem],
  sigs0: Vec[ConstSig],
  states0: Vec[i32],
  cur_mod: String,
  imps: Imports,
  exprs: ast.ExprPool,
  file: String,
  id: i32,
  expected: i32
) -> EvalConstExprResult {
  return eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, id, expected, Vec());
}

fn slice_parts(xs: Vec[String], lo: i32, hi: i32) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = lo;
  while i < hi {
    out.push(xs.get(i));
    i = i + 1;
  }
  return out;
}

fn resolve_const(ctx: Ctx, w: World, items: Vec[ConstItem], sigs0: Vec[ConstSig], states0: Vec[i32], idx: i32) -> ResolveConstResult {
  let mut c: Ctx = ctx;
  let st: i32 = states0.get(idx); // 0 pending, 1 resolving, 2 done
  if st == 2 { return ResolveConstResult { ok: true, err: TcError.None, sigs: sigs0, states: states0, ctx: c }; }
  if st == 1 {
    let it0: ConstItem = items.get(idx);
    return ResolveConstResult { ok: false, err: type_error(it0.decl.file, "const cycle: ".concat(const_qname(it0.mod_path, it0.decl.name))), sigs: sigs0, states: states0, ctx: c };
  }

  let mut sigs: Vec[ConstSig] = sigs0;
  let mut states: Vec[i32] = const_set_i32_at(states0, idx, 1);
  let it: ConstItem = items.get(idx);

  // Resolve declared type (v0: must be primitive or `@range(..) <int>`).
  let fm: FindModResult = find_mod(w, it.mod_path);
  if !fm.found {
    return ResolveConstResult { ok: false, err: type_error(it.decl.file, "unknown module for const"), sigs: sigs, states: states, ctx: c };
  }
  let m: WorldModule = w.mods.get(fm.idx);
  let ir0: ImportsResult = build_imports(w, it.mod_path, m.prog.imports, it.decl.file);
  if !ir0.ok { return ResolveConstResult { ok: false, err: ir0.err, sigs: sigs, states: states, ctx: c }; }
  let imps: Imports = ir0.imps;

  let tr: ResolveTyResult = resolve_type(c, w, it.mod_path, imps, Vec(), it.decl.ty);
  if !tr.ok { return ResolveConstResult { ok: false, err: type_error(it.decl.file, "type resolve failed in const"), sigs: sigs, states: states, ctx: c }; }
  c = tr.ctx;
  let ty: i32 = tr.idx;
  let ok_v0: bool =
    ty == c.ty_bool ||
    ty == c.ty_string ||
    ty == c.ty_f32 ||
    ty == c.ty_f64 ||
    is_enum_ty(c, ty) ||
    is_struct_ty(c, ty) ||
    is_int_scalar_kind(int_kind(c, ty));
  if !ok_v0 { return ResolveConstResult { ok: false, err: type_error(it.decl.file, "const type must be primitive/enum/struct in v0"), sigs: sigs, states: states, ctx: c }; }

  // Evaluate init expression.
  let ev: EvalConstExprResult = eval_const_expr_in_mod(c, w, items, sigs, states, it.mod_path, imps, m.prog.exprs, it.decl.file, it.decl.init, ty);
  if !ev.ok { return ResolveConstResult { ok: false, err: ev.err, sigs: ev.sigs, states: ev.states, ctx: c }; }
  sigs = ev.sigs;
  states = ev.states;

  let cs: ConstSig = ConstSig {
    mod_path: it.mod_path,
    name: it.decl.name,
    vis: it.decl.vis,
    is_pub: it.decl.is_pub,
    ty: ty,
    kind: ev.kind,
    iv: ev.iv,
    bv: ev.bv,
    sv: ev.sv,
  };
  sigs = const_set_sig_at(sigs, idx, cs);
  states = const_set_i32_at(states, idx, 2);
  return ResolveConstResult { ok: true, err: TcError.None, sigs: sigs, states: states, ctx: c };
}

fn const_set_i32_at(xs0: Vec[i32], idx: i32, val: i32) -> Vec[i32] {
  let mut xs: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    xs.push(if i == idx { val } else { xs0.get(i) });
    i = i + 1;
  }
  return xs;
}

fn const_placeholder() -> ConstSig {
  return ConstSig { mod_path: "", name: "", vis: ast.vis_private(), is_pub: false, ty: -1, kind: 0, iv: 0, bv: false, sv: "" };
}

fn collect_consts(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;

  // Gather all const decls across modules.
  let mut items: Vec[ConstItem] = Vec();
  let mut seen: Vec[String] = Vec();
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ci: i32 = 0;
    while ci < m.prog.consts.len() {
      let cd: ast.ConstDecl = m.prog.consts.get(ci);
      if is_reserved_intrinsic_name(cd.name) {
        return TcCtxResult { ok: false, err: type_error(cd.file, "reserved name: ".concat(cd.name)), ctx: c };
      }
      if tn_has_nonstatic_borrow(cd.ty) {
        return TcCtxResult { ok: false, err: type_error_at(cd.sp, "non-static borrowed type is not allowed in const type"), ctx: c };
      }
      let qn: String = const_qname(m.path, cd.name);
      if const_contains_str(seen, qn) {
        return TcCtxResult { ok: false, err: type_error(cd.file, "duplicate const: ".concat(cd.name)), ctx: c };
      }
      seen.push(qn);
      items.push(ConstItem { mod_path: m.path, decl: cd });
      ci = ci + 1;
    }
    mi = mi + 1;
  }

  // Pre-size sigs/states vectors.
  let mut sigs: Vec[ConstSig] = Vec();
  let mut states: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < items.len() {
    sigs.push(const_placeholder());
    states.push(0);
    i = i + 1;
  }

  // Resolve all consts (value + type).
  i = 0;
  while i < items.len() {
    let rr: ResolveConstResult = resolve_const(c, w, items, sigs, states, i);
    if !rr.ok { return TcCtxResult { ok: false, err: rr.err, ctx: rr.ctx }; }
    c = rr.ctx;
    sigs = rr.sigs;
    states = rr.states;
    i = i + 1;
  }

  c.consts = sigs;
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}
