pub struct LookupVarResult { pub found: bool, pub ty: i32, pub mutable: bool, pub moved: bool }
pub struct LookupConstResult { pub found: bool, pub ty: i32, pub has_val: bool, pub iv: i64 }
pub struct VarEntry { pub name: String, pub ty: i32, pub mutable: bool, pub depth: i32, pub moved: bool }
pub struct ConstEntry { pub name: String, pub ty: i32, pub has_val: bool, pub iv: i64, pub depth: i32 }
pub struct Locals {
  pub vars: Vec[VarEntry],
  pub consts: Vec[ConstEntry],
  pub depth: i32,
  pub type_params: Vec[String],
  pub type_param_bounds: Vec[TypeParamBoundSig],
  pub fn_ret_ty: i32,
  pub try_ret_ty: i32,
  pub loop_depth: i32,
}

pub fn locals_new() -> Locals {
  return Locals {
    vars: Vec(),
    consts: Vec(),
    depth: 0,
    type_params: Vec(),
    type_param_bounds: Vec(),
    fn_ret_ty: -1,
    try_ret_ty: -1,
    loop_depth: 0,
  };
}
pub fn locals_enter(l: Locals) -> Locals { let mut q: Locals = l; q.depth = q.depth + 1; return q; }
pub fn locals_exit(l: Locals) -> Locals { let mut q: Locals = l; q.depth = q.depth - 1; return q; }

pub fn locals_decl(l: Locals, name: String, ty: i32, mutable: bool) -> Locals {
  let mut q: Locals = l;
  q.vars.push(VarEntry { name: name, ty: ty, mutable: mutable, depth: q.depth, moved: false });
  return q;
}

pub fn locals_decl_const(l: Locals, name: String, ty: i32) -> Locals {
  let mut q: Locals = l;
  q.consts.push(ConstEntry { name: name, ty: ty, has_val: false, iv: 0, depth: q.depth });
  return q;
}

pub fn locals_decl_const_value(l: Locals, name: String, ty: i32, iv: i64) -> Locals {
  let mut q: Locals = l;
  q.consts.push(ConstEntry { name: name, ty: ty, has_val: true, iv: iv, depth: q.depth });
  return q;
}

pub fn locals_lookup(l: Locals, name: String) -> LookupVarResult {
  let vs: Vec[VarEntry] = l.vars;
  let mut i: i32 = vs.len() - 1;
  while i >= 0 {
    let v: VarEntry = vs.get(i);
    if v.depth <= l.depth && v.name == name {
      return LookupVarResult { found: true, ty: v.ty, mutable: v.mutable, moved: v.moved };
    }
    i = i - 1;
  }
  return LookupVarResult { found: false, ty: -1, mutable: false, moved: false };
}

pub fn locals_set_moved(l: Locals, name: String, moved: bool) -> Locals {
  let mut q: Locals = l;
  let mut i: i32 = q.vars.len() - 1;
  while i >= 0 {
    let v: VarEntry = q.vars.get(i);
    if v.depth <= q.depth && v.name == name {
      q.vars.set(i, VarEntry { name: v.name, ty: v.ty, mutable: v.mutable, depth: v.depth, moved: moved });
      return q;
    }
    i = i - 1;
  }
  return q;
}

pub fn locals_mark_moved(l: Locals, name: String) -> Locals {
  return locals_set_moved(l, name, true);
}

pub fn locals_clear_moved(l: Locals, name: String) -> Locals {
  return locals_set_moved(l, name, false);
}

pub fn locals_sync_moved(base: Locals, src: Locals) -> Locals {
  let mut out: Locals = base;
  let mut i: i32 = 0;
  while i < out.vars.len() {
    let v: VarEntry = out.vars.get(i);
    if v.depth <= out.depth {
      let vr: LookupVarResult = locals_lookup(src, v.name);
      if vr.found {
        out.vars.set(i, VarEntry { name: v.name, ty: v.ty, mutable: v.mutable, depth: v.depth, moved: vr.moved });
      }
    }
    i = i + 1;
  }
  return out;
}

pub fn locals_lookup_const(l: Locals, name: String) -> LookupConstResult {
  let vs: Vec[ConstEntry] = l.consts;
  let mut i: i32 = vs.len() - 1;
  while i >= 0 {
    let v: ConstEntry = vs.get(i);
    if v.depth <= l.depth && v.name == name {
      return LookupConstResult { found: true, ty: v.ty, has_val: v.has_val, iv: v.iv };
    }
    i = i - 1;
  }
  return LookupConstResult { found: false, ty: -1, has_val: false, iv: 0 };
}
