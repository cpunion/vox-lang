import "std/testing" as t
import "compiler/typecheck" as tc

fn test_typecheck_ifexpr_branch_blocks_with_stmts() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: i32 = if true {\n    let y: i32 = 1;\n    y + 1\n  } else {\n    2\n  };\n  return x;\n}\n";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_ifexpr_else_if_chain_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn sign(x: i32) -> i32 {\n  let y: i32 = if x < 0 {\n    -1\n  } else if x == 0 {\n    0\n  } else {\n    1\n  };\n  return y;\n}\nfn main() -> i32 { return sign(7); }\n";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_ifexpr_branch_without_tail_is_unit() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: i32 = if true {\n    let y: i32 = 1;\n  } else {\n    2\n  };\n  return x;\n}\n";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_ifexpr_branch_return_diverges() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(flag: bool) -> i32 {\n  let x: i32 = if flag {\n    return 7;\n  } else {\n    3\n  };\n  return x;\n}\n";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_ifexpr_both_branches_diverge() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(flag: bool) -> i32 {\n  let _x: i32 = if flag {\n    return 7;\n  } else {\n    return 9;\n  };\n  return 0;\n}\n";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_ifexpr_branch_break_continue_inside_loop() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let mut i: i32 = 0;
      while i < 10 {
        let _x: i32 = if i > 5 {
          break;
        } else if i < 0 {
          continue;
        } else {
          i
        };
        i = i + 1;
      }
      return i;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_ifexpr_break_outside_loop_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: i32 = if true {\n    break;\n  } else {\n    1\n  };\n  return x;\n}\n";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), "expected break-outside-loop error");
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "break outside loop"), msg);
}

fn test_typecheck_ifexpr_continue_outside_loop_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: i32 = if true {\n    continue;\n  } else {\n    1\n  };\n  return x;\n}\n";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), "expected continue-outside-loop error");
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "continue outside loop"), msg);
}
