import "compiler/ast" as ast
import "compiler/ir" as ir

pub struct Ctx {
  pub pool: ir.TyPool,
  pub ty_bad: i32,
  pub ty_unit: i32,
  pub ty_bool: i32,
  pub ty_i8: i32,
  pub ty_u8: i32,
  pub ty_i16: i32,
  pub ty_u16: i32,
  pub ty_i32: i32,
  pub ty_u32: i32,
  pub ty_i64: i32,
  pub ty_u64: i32,
  pub ty_isize: i32,
  pub ty_usize: i32,
  pub ty_f32: i32,
  pub ty_f64: i32,
  pub ty_string: i32,

  pub funcs: Vec[FuncSym],
  pub structs: Vec[StructSig],
  pub enums: Vec[EnumSig],
  pub traits: Vec[TraitSig],
  pub impls: Vec[ImplSig],
  pub type_aliases: Vec[TypeAliasSig],
  pub consts: Vec[ConstSig],
}

pub struct TypeAliasSig {
  pub mod_path: String,
  pub name: String,
  pub vis: i32,
  pub is_pub: bool,
  pub ty: i32,
}

// Const values are restricted to primitives + enum variants in v0.
pub struct ConstSig {
  pub mod_path: String,
  pub name: String,
  pub vis: i32,
  pub is_pub: bool,
  pub ty: i32,
  pub kind: i32, // 1=int, 2=bool, 3=str, 4=float, 5=enum
  // Int values are stored as i64 bit patterns in stage1 v0.
  // Unsigned values above i64::MAX use two's-complement representation.
  pub iv: i64,
  pub bv: bool,
  pub sv: String,
}

struct InternResult { ctx: Ctx, idx: i32 }

fn ty_eq(a: ir.Ty, b: ir.Ty) -> bool {
  return match a.kind {
    ir.TyKind.Bad => match b.kind { ir.TyKind.Bad => true, _ => false },
    ir.TyKind.Unit => match b.kind { ir.TyKind.Unit => true, _ => false },
    ir.TyKind.Bool => match b.kind { ir.TyKind.Bool => true, _ => false },
    ir.TyKind.I8 => match b.kind { ir.TyKind.I8 => true, _ => false },
    ir.TyKind.U8 => match b.kind { ir.TyKind.U8 => true, _ => false },
    ir.TyKind.I16 => match b.kind { ir.TyKind.I16 => true, _ => false },
    ir.TyKind.U16 => match b.kind { ir.TyKind.U16 => true, _ => false },
    ir.TyKind.I32 => match b.kind { ir.TyKind.I32 => true, _ => false },
    ir.TyKind.U32 => match b.kind { ir.TyKind.U32 => true, _ => false },
    ir.TyKind.I64 => match b.kind { ir.TyKind.I64 => true, _ => false },
    ir.TyKind.U64 => match b.kind { ir.TyKind.U64 => true, _ => false },
    ir.TyKind.ISize => match b.kind { ir.TyKind.ISize => true, _ => false },
    ir.TyKind.USize => match b.kind { ir.TyKind.USize => true, _ => false },
    ir.TyKind.F32 => match b.kind { ir.TyKind.F32 => true, _ => false },
    ir.TyKind.F64 => match b.kind { ir.TyKind.F64 => true, _ => false },
    ir.TyKind.String => match b.kind { ir.TyKind.String => true, _ => false },
    ir.TyKind.Param => match b.kind { ir.TyKind.Param => a.name == b.name, _ => false },
    ir.TyKind.Struct => match b.kind { ir.TyKind.Struct => a.mod_path == b.mod_path && a.name == b.name, _ => false },
    ir.TyKind.Enum => match b.kind { ir.TyKind.Enum => a.mod_path == b.mod_path && a.name == b.name, _ => false },
    ir.TyKind.Vec => match b.kind { ir.TyKind.Vec => a.elem == b.elem, _ => false },
    ir.TyKind.Range => match b.kind { ir.TyKind.Range => a.elem == b.elem && a.lo == b.lo && a.hi == b.hi, _ => false },
  };
}

fn intern_ty(ctx: Ctx, t: ir.Ty) -> InternResult {
  let mut q: Ctx = ctx;
  let mut pool: ir.TyPool = q.pool;
  let tys: Vec[ir.Ty] = pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    if ty_eq(tys.get(i), t) {
      return InternResult { ctx: q, idx: i };
    }
    i = i + 1;
  }
  let r: ir.AddTyResult = ir.ty_pool_add(pool, t);
  q.pool = r.pool;
  return InternResult { ctx: q, idx: r.idx };
}

pub fn new_ctx() -> Ctx {
  let mut c: Ctx = Ctx {
    pool: ir.ty_pool(),
    ty_bad: -1, ty_unit: -1, ty_bool: -1,
    ty_i8: -1, ty_u8: -1, ty_i16: -1, ty_u16: -1, ty_i32: -1, ty_u32: -1, ty_i64: -1, ty_u64: -1, ty_isize: -1, ty_usize: -1,
    ty_f32: -1, ty_f64: -1,
    ty_string: -1,
    funcs: Vec(), structs: Vec(), enums: Vec(), traits: Vec(), impls: Vec(), type_aliases: Vec(), consts: Vec(),
  };
  let r0: InternResult = intern_ty(c, ir.ty_bad()); c = r0.ctx; c.ty_bad = r0.idx;
  let r1: InternResult = intern_ty(c, ir.ty_unit()); c = r1.ctx; c.ty_unit = r1.idx;
  let r2: InternResult = intern_ty(c, ir.ty_bool()); c = r2.ctx; c.ty_bool = r2.idx;
  let r3: InternResult = intern_ty(c, ir.ty_i8()); c = r3.ctx; c.ty_i8 = r3.idx;
  let r4: InternResult = intern_ty(c, ir.ty_u8()); c = r4.ctx; c.ty_u8 = r4.idx;
  let r4b: InternResult = intern_ty(c, ir.ty_i16()); c = r4b.ctx; c.ty_i16 = r4b.idx;
  let r4c: InternResult = intern_ty(c, ir.ty_u16()); c = r4c.ctx; c.ty_u16 = r4c.idx;
  let r5: InternResult = intern_ty(c, ir.ty_i32()); c = r5.ctx; c.ty_i32 = r5.idx;
  let r6: InternResult = intern_ty(c, ir.ty_u32()); c = r6.ctx; c.ty_u32 = r6.idx;
  let r7: InternResult = intern_ty(c, ir.ty_i64()); c = r7.ctx; c.ty_i64 = r7.idx;
  let r8: InternResult = intern_ty(c, ir.ty_u64()); c = r8.ctx; c.ty_u64 = r8.idx;
  let r8b: InternResult = intern_ty(c, ir.ty_isize()); c = r8b.ctx; c.ty_isize = r8b.idx;
  let r9: InternResult = intern_ty(c, ir.ty_usize()); c = r9.ctx; c.ty_usize = r9.idx;
  let r10: InternResult = intern_ty(c, ir.ty_f32()); c = r10.ctx; c.ty_f32 = r10.idx;
  let r10b: InternResult = intern_ty(c, ir.ty_f64()); c = r10b.ctx; c.ty_f64 = r10b.idx;
  let r11: InternResult = intern_ty(c, ir.ty_string()); c = r11.ctx; c.ty_string = r11.idx;

  // Ensure common `Vec[T]` instantiations exist even when not explicitly mentioned
  // in type annotations, so generic inference can return `Vec[i32]` etc.
  let rv0: InternResult = intern_ty(c, ir.ty_vec(c.ty_unit)); c = rv0.ctx;
  let rv1: InternResult = intern_ty(c, ir.ty_vec(c.ty_bool)); c = rv1.ctx;
  let _rv_i8: InternResult = intern_ty(c, ir.ty_vec(c.ty_i8)); c = _rv_i8.ctx;
  let _rv_u8: InternResult = intern_ty(c, ir.ty_vec(c.ty_u8)); c = _rv_u8.ctx;
  let _rv_i16: InternResult = intern_ty(c, ir.ty_vec(c.ty_i16)); c = _rv_i16.ctx;
  let _rv_u16: InternResult = intern_ty(c, ir.ty_vec(c.ty_u16)); c = _rv_u16.ctx;
  let rv2: InternResult = intern_ty(c, ir.ty_vec(c.ty_i32)); c = rv2.ctx;
  let rv3: InternResult = intern_ty(c, ir.ty_vec(c.ty_i64)); c = rv3.ctx;
  let _rv_u32: InternResult = intern_ty(c, ir.ty_vec(c.ty_u32)); c = _rv_u32.ctx;
  let _rv_u64: InternResult = intern_ty(c, ir.ty_vec(c.ty_u64)); c = _rv_u64.ctx;
  let _rv_isize: InternResult = intern_ty(c, ir.ty_vec(c.ty_isize)); c = _rv_isize.ctx;
  let _rv_usize: InternResult = intern_ty(c, ir.ty_vec(c.ty_usize)); c = _rv_usize.ctx;
  let _rv_f32: InternResult = intern_ty(c, ir.ty_vec(c.ty_f32)); c = _rv_f32.ctx;
  let _rv_f64: InternResult = intern_ty(c, ir.ty_vec(c.ty_f64)); c = _rv_f64.ctx;
  let rv4: InternResult = intern_ty(c, ir.ty_vec(c.ty_string)); c = rv4.ctx;

  return c;
}

fn typename_is0(tn: ast.TypeName, s: String) -> bool {
  return tn.parts.len() == 1 && tn.parts.get(0) == s && tn.args.len() == 0;
}

pub fn named_lifetime_type_error(tn: ast.TypeName) -> String {
  if typename_is0(tn, "str") {
    return "bare str is not allowed; use String for owned text or &str for borrowed text";
  }
  if tn.parts.len() == 1 && tn.args.len() == 1 {
    let tag: String = tn.parts.get(0);
    if tag == "@ref_lt" || tag == "@ref_lt_mut" {
      return "named lifetime is not supported; only 'static is allowed";
    }
  }
  let mut i: i32 = 0;
  while i < tn.args.len() {
    let msg: String = named_lifetime_type_error(tn.args.get(i));
    if msg != "" { return msg; }
    i = i + 1;
  }
  return "";
}

pub fn tn_is_nonstatic_borrow_head(tn: ast.TypeName) -> bool {
  if tn.parts.len() != 1 || tn.args.len() != 1 { return false; }
  let tag: String = tn.parts.get(0);
  return tag == "@ref" || tag == "@ref_mut" || tag == "@ref_lt" || tag == "@ref_lt_mut";
}

pub fn tn_has_nonstatic_borrow(tn: ast.TypeName) -> bool {
  if tn_is_nonstatic_borrow_head(tn) { return true; }
  let mut i: i32 = 0;
  while i < tn.args.len() {
    if tn_has_nonstatic_borrow(tn.args.get(i)) { return true; }
    i = i + 1;
  }
  return false;
}

pub fn tn_nonstatic_borrow_allowed_param_type(tn: ast.TypeName) -> bool {
  if !tn_has_nonstatic_borrow(tn) { return true; }
  if tn.parts.len() != 1 || tn.args.len() != 1 { return false; }
  let tag: String = tn.parts.get(0);
  return tag == "@ref" || tag == "@ref_mut";
}

pub fn tn_nonstatic_borrow_allowed_local_type(tn: ast.TypeName) -> bool {
  return tn_nonstatic_borrow_allowed_param_type(tn);
}

pub struct ResolveTyResult { pub ctx: Ctx, pub ok: bool, pub idx: i32 }
pub struct TypeBind { pub name: String, pub ty: i32 }

fn find_type_alias(type_aliases: Vec[TypeAliasSig], mod_path: String, name: String) -> TypeAliasSig {
  let mut i: i32 = 0;
  while i < type_aliases.len() {
    let a: TypeAliasSig = type_aliases.get(i);
    if a.mod_path == mod_path && a.name == name { return a; }
    i = i + 1;
  }
  return TypeAliasSig { mod_path: "", name: "", vis: ast.vis_private(), is_pub: false, ty: -1 };
}

pub fn intern_vec(ctx: Ctx, elem: i32) -> ResolveTyResult {
  let mut c: Ctx = ctx;
  let r: InternResult = intern_ty(c, ir.ty_vec(elem));
  c = r.ctx;
  return ResolveTyResult { ctx: c, ok: true, idx: r.idx };
}

fn find_type_bind(binds: Vec[TypeBind], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < binds.len() {
    let b: TypeBind = binds.get(i);
    if b.name == name { return b.ty; }
    i = i + 1;
  }
  return -1;
}

fn has_type_param_name(type_params: Vec[String], name: String) -> bool {
  let mut i: i32 = 0;
  while i < type_params.len() {
    if type_params.get(i) == name { return true; }
    i = i + 1;
  }
  return false;
}

fn has_trait_assoc_name(as0: Vec[TraitAssocTypeSig], name: String) -> bool {
  let mut i: i32 = 0;
  while i < as0.len() {
    if as0.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn is_decimal_text_ctx(s: String) -> bool {
  if s.len() == 0 { return false; }
  let mut i: i32 = 0;
  while i < s.len() {
    let b: i32 = s.byte_at(i);
    if b < 48 || b > 57 { return false; }
    i = i + 1;
  }
  return true;
}

fn projection_assoc_bound_count(ctx: Ctx, bounds: Vec[TypeParamBoundSig], base: String, assoc: String) -> i32 {
  let mut n: i32 = 0;
  let mut i: i32 = 0;
  while i < bounds.len() {
    let b: TypeParamBoundSig = bounds.get(i);
    if b.type_param == base {
      let tf: FindTraitResult = find_trait(ctx, b.trait_mod_path, b.trait_name);
      if tf.found && has_trait_assoc_name(tf.sig.assoc_types, assoc) { n = n + 1; }
    }
    i = i + 1;
  }
  return n;
}

pub fn projection_bound_issue(ctx: Ctx, type_params: Vec[String], bounds: Vec[TypeParamBoundSig], tn: ast.TypeName) -> String {
  if tn.parts.len() == 2 && tn.args.len() == 0 {
    let base: String = tn.parts.get(0);
    let assoc: String = tn.parts.get(1);
    if has_type_param_name(type_params, base) {
      if is_decimal_text_ctx(assoc) {
        // Pack projection member (e.g. T.0) is not an associated-type projection.
      } else {
        let n: i32 = projection_assoc_bound_count(ctx, bounds, base, assoc);
        let proj: String = base.concat(".").concat(assoc);
        if n == 0 { return "unknown associated type projection: ".concat(proj); }
        if n > 1 { return "ambiguous associated type projection: ".concat(proj); }
      }
    }
  }
  let mut i: i32 = 0;
  while i < tn.args.len() {
    let e: String = projection_bound_issue(ctx, type_params, bounds, tn.args.get(i));
    if e != "" { return e; }
    i = i + 1;
  }
  return "";
}


fn binds_from_args(type_params: Vec[String], arg_tys: Vec[i32]) -> Vec[TypeBind] {
  let mut out: Vec[TypeBind] = Vec();
  let mut i: i32 = 0;
  while i < type_params.len() {
    out.push(TypeBind { name: type_params.get(i), ty: arg_tys.get(i) });
    i = i + 1;
  }
  return out;
}

fn subs_from_args(type_params: Vec[String], arg_tys: Vec[i32]) -> Vec[TySub] {
  let mut out: Vec[TySub] = Vec();
  let mut i: i32 = 0;
  while i < type_params.len() {
    out.push(TySub { name: type_params.get(i), ty: arg_tys.get(i) });
    i = i + 1;
  }
  return out;
}

struct FindStructDeclResult { found: bool, d: ast.StructDecl }
struct FindEnumDeclResult { found: bool, d: ast.EnumDecl }
struct NominalComptimeWhereResult { ok: bool, err: TcError, ctx: Ctx }
struct NominalTraitBoundsResult { ok: bool, err: TcError, ctx: Ctx }

fn find_struct_decl_in_mod(m: WorldModule, name: String) -> FindStructDeclResult {
  let mut i: i32 = 0;
  while i < m.prog.structs.len() {
    let d: ast.StructDecl = m.prog.structs.get(i);
    if d.name == name { return FindStructDeclResult { found: true, d: d }; }
    i = i + 1;
  }
  return FindStructDeclResult {
    found: false,
    d: ast.StructDecl {
      file: "",
      sp: ast.span0(),
      vis: ast.vis_private(),
      is_pub: false,
      name: "",
      type_params: Vec(),
      type_param_bounds: Vec(),
      const_where_bounds: Vec(),
      fields: Vec(),
    },
  };
}

fn find_enum_decl_in_mod(m: WorldModule, name: String) -> FindEnumDeclResult {
  let mut i: i32 = 0;
  while i < m.prog.enums.len() {
    let d: ast.EnumDecl = m.prog.enums.get(i);
    if d.name == name { return FindEnumDeclResult { found: true, d: d }; }
    i = i + 1;
  }
  return FindEnumDeclResult {
    found: false,
    d: ast.EnumDecl {
      file: "",
      sp: ast.span0(),
      vis: ast.vis_private(),
      is_pub: false,
      name: "",
      type_params: Vec(),
      type_param_bounds: Vec(),
      const_where_bounds: Vec(),
      variants: Vec(),
    },
  };
}

fn nominal_check_comptime_where(ctx0: Ctx, sp: ast.Span, tps: Vec[String], cwds: Vec[ast.ConstWhereDecl], arg_tys: Vec[i32]) -> NominalComptimeWhereResult {
  let mut c: Ctx = ctx0;
  let cwr: CollectConstWhereResult = collect_const_where_bounds(sp, tps, Vec(), cwds);
  if !cwr.ok { return NominalComptimeWhereResult { ok: false, err: cwr.err, ctx: c }; }
  let subs: Vec[TySub] = subs_from_args(tps, arg_tys);
  let ck: ConstWhereCheckResult = check_const_where_bounds(c, cwr.bounds, subs, Vec());
  if !ck.ok { return NominalComptimeWhereResult { ok: false, err: type_error_at(sp, ck.err), ctx: c }; }
  return NominalComptimeWhereResult { ok: true, err: TcError.None, ctx: c };
}

fn type_param_idx_nominal(tps: Vec[String], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < tps.len() {
    if tps.get(i) == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn nominal_check_type_param_bounds(
  ctx0: Ctx,
  w: World,
  cur_mod: String,
  imps: Imports,
  sp: ast.Span,
  tps: Vec[String],
  tpbs: Vec[ast.TypeParamBoundsDecl],
  arg_tys: Vec[i32]
) -> NominalTraitBoundsResult {
  let mut c: Ctx = ctx0;
  let mut bi: i32 = 0;
  while bi < tpbs.len() {
    let bdecl: ast.TypeParamBoundsDecl = tpbs.get(bi);
    let tpi: i32 = type_param_idx_nominal(tps, bdecl.name);
    if tpi == -1 {
      return NominalTraitBoundsResult {
        ok: false,
        err: type_error_at(sp, "unknown type param in trait bound: ".concat(bdecl.name)),
        ctx: c,
      };
    }
    let arg_ty: i32 = strip_range(c, arg_tys.get(tpi));
    let at: ir.Ty = ir.ty_pool_get(c.pool, arg_ty);
    let mut bj: i32 = 0;
    while bj < bdecl.bounds.len() {
      let rtr: ResolveTraitRefResult = resolve_trait_ref(c, w, cur_mod, imps, bdecl.bounds.get(bj));
      if !rtr.ok {
        return NominalTraitBoundsResult { ok: false, err: type_error_at(sp, "bad trait bound"), ctx: c };
      }
      let tf: FindTraitResult = find_trait(c, rtr.mod_path, rtr.name);
      if !tf.found {
        return NominalTraitBoundsResult {
          ok: false,
          err: type_error_at(sp, "unknown trait in bound: ".concat(rtr.name)),
          ctx: c,
        };
      }
      if !vis_allows(tf.sig.vis, rtr.mod_path, cur_mod) {
        return NominalTraitBoundsResult {
          ok: false,
          err: type_error_at(sp, "trait bound refers to private trait: ".concat(rtr.name)),
          ctx: c,
        };
      }
      // Keep generic nominal instantiation possible inside generic bodies.
      // Concrete checks run once type params are substituted.
      if at.kind != ir.TyKind.Param {
        let fi: FindImplForTyResult = find_impl_for_ty(c, rtr.mod_path, rtr.name, arg_ty);
        if fi.ambiguous {
          let msg0: String =
            "type argument "
              .concat(ty_inst_str(c, arg_ty))
              .concat(" has ambiguous impls for trait ")
              .concat(rtr.name)
              .concat(" (candidates: ")
              .concat(fi.candidates)
              .concat(")");
          return NominalTraitBoundsResult { ok: false, err: type_error_at(sp, msg0), ctx: c };
        }
        if !fi.found {
          let cands: String = trait_impl_candidates_text(c, rtr.mod_path, rtr.name);
          let msg1: String =
            "type argument "
              .concat(ty_inst_str(c, arg_ty))
              .concat(" does not satisfy trait bound ")
              .concat(bdecl.name)
              .concat(": ")
              .concat(rtr.name)
              .concat(" (available impls: ")
              .concat(cands)
              .concat(")");
          return NominalTraitBoundsResult { ok: false, err: type_error_at(sp, msg1), ctx: c };
        }
      }
      bj = bj + 1;
    }
    bi = bi + 1;
  }
  return NominalTraitBoundsResult { ok: true, err: TcError.None, ctx: c };
}

fn nominal_intern_struct(ctx0: Ctx, mod_path: String, name: String) -> ResolveTyResult {
  let mut c: Ctx = ctx0;
  let ir1: InternResult = intern_ty(c, ir.ty_struct(mod_path, name));
  c = ir1.ctx;
  let iv0: InternResult = intern_ty(c, ir.ty_vec(ir1.idx)); c = iv0.ctx;
  let iv1: InternResult = intern_ty(c, ir.ty_vec(iv0.idx)); c = iv1.ctx;
  return ResolveTyResult { ctx: c, ok: true, idx: ir1.idx };
}

fn nominal_intern_enum(ctx0: Ctx, mod_path: String, name: String) -> ResolveTyResult {
  let mut c: Ctx = ctx0;
  let ir1: InternResult = intern_ty(c, ir.ty_enum(mod_path, name));
  c = ir1.ctx;
  let iv0: InternResult = intern_ty(c, ir.ty_vec(ir1.idx)); c = iv0.ctx;
  let iv1: InternResult = intern_ty(c, ir.ty_vec(iv0.idx)); c = iv1.ctx;
  return ResolveTyResult { ctx: c, ok: true, idx: ir1.idx };
}

fn set_struct_fields(ctx0: Ctx, mod_path: String, name: String, fields: Vec[StructFieldSig]) -> Ctx {
  let mut c: Ctx = ctx0;
  let mut out: Vec[StructSig] = Vec();
  let mut i: i32 = 0;
  while i < c.structs.len() {
    let s: StructSig = c.structs.get(i);
    if s.mod_path == mod_path && s.name == name {
      out.push(StructSig { mod_path: s.mod_path, name: s.name, base_name: s.base_name, vis: s.vis, is_pub: s.is_pub, fields: fields });
    } else {
      out.push(s);
    }
    i = i + 1;
  }
  c.structs = out;
  return c;
}

fn set_enum_vars(ctx0: Ctx, mod_path: String, name: String, vars: Vec[EnumVariantSig]) -> Ctx {
  let mut c: Ctx = ctx0;
  let mut out: Vec[EnumSig] = Vec();
  let mut i: i32 = 0;
  while i < c.enums.len() {
    let e: EnumSig = c.enums.get(i);
    if e.mod_path == mod_path && e.name == name {
      out.push(EnumSig { mod_path: e.mod_path, name: e.name, base_name: e.base_name, vis: e.vis, is_pub: e.is_pub, vars: vars });
    } else {
      out.push(e);
    }
    i = i + 1;
  }
  c.enums = out;
  return c;
}

fn resolve_type_bound(ctx: Ctx, w: World, cur_mod: String, imps: Imports, type_params: Vec[String], binds: Vec[TypeBind], tn: ast.TypeName) -> ResolveTyResult {
  let mut c: Ctx = ctx;
  // Associated type projection over type params:
  // - Self.Item
  // - T.Item
  if tn.parts.len() == 2 && tn.args.len() == 0 {
    let base: String = tn.parts.get(0);
    let assoc: String = tn.parts.get(1);
    let proj: String = base.concat(".").concat(assoc);

    let pty: i32 = find_type_bind(binds, proj);
    if pty != -1 { return ResolveTyResult { ctx: c, ok: true, idx: pty }; }

    let bty: i32 = find_type_bind(binds, base);
    if bty != -1 {
      let bt: ir.Ty = ir.ty_pool_get(c.pool, bty);
      if bt.kind != ir.TyKind.Param { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      let ir0: InternResult = intern_ty(c, ir.ty_param(bt.name.concat(".").concat(assoc)));
      c = ir0.ctx;
      return ResolveTyResult { ctx: c, ok: true, idx: ir0.idx };
    }

    if has_type_param_name(type_params, base) {
      let ir1: InternResult = intern_ty(c, ir.ty_param(proj));
      c = ir1.ctx;
      return ResolveTyResult { ctx: c, ok: true, idx: ir1.idx };
    }
  }

  // type param (generic function): `T`
  if tn.parts.len() == 1 && tn.args.len() == 0 {
    let name0: String = tn.parts.get(0);
    let bty: i32 = find_type_bind(binds, name0);
    if bty != -1 { return ResolveTyResult { ctx: c, ok: true, idx: bty }; }
    let mut i0: i32 = 0;
    while i0 < type_params.len() {
      if type_params.get(i0) == name0 {
        let ir0: InternResult = intern_ty(c, ir.ty_param(name0));
        c = ir0.ctx;
        return ResolveTyResult { ctx: c, ok: true, idx: ir0.idx };
      }
      i0 = i0 + 1;
    }
  }

  // Reference syntax sugar lowering (stage2 transition):
  // - `&T` / `&mut T` / `&'static T` / `&'static mut T` => T
  //   (borrow semantics are not modeled yet)
  // - named lifetimes (`&'a T`) are currently rejected.
  if tn.parts.len() == 1 && tn.args.len() == 1 {
    let tag: String = tn.parts.get(0);
    if tag == "@ref" || tag == "@ref_static" || tag == "@ref_mut" || tag == "@ref_static_mut" {
      let bt: ast.TypeName = tn.args.get(0);
      if typename_is0(bt, "str") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_string }; }
      let ir: ResolveTyResult = resolve_type_bound(c, w, cur_mod, imps, type_params, binds, bt);
      c = ir.ctx;
      if !ir.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      return ResolveTyResult { ctx: c, ok: true, idx: ir.idx };
    }
  }
  if tn.parts.len() == 1 && (tn.parts.get(0) == "@ref_lt" || tn.parts.get(0) == "@ref_lt_mut") && tn.args.len() == 1 {
    return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
  }

  // primitives / unit
  if typename_is0(tn, "()") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_unit }; }
  if typename_is0(tn, "bool") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_bool }; }
  if typename_is0(tn, "i8") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_i8 }; }
  if typename_is0(tn, "u8") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_u8 }; }
  if typename_is0(tn, "i16") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_i16 }; }
  if typename_is0(tn, "u16") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_u16 }; }
  if typename_is0(tn, "i32") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_i32 }; }
  if typename_is0(tn, "u32") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_u32 }; }
  if typename_is0(tn, "i64") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_i64 }; }
  if typename_is0(tn, "u64") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_u64 }; }
  if typename_is0(tn, "isize") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_isize }; }
  if typename_is0(tn, "usize") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_usize }; }
  // Stage1: TypeId is a stable compile-time id represented as usize.
  if typename_is0(tn, "TypeId") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_usize }; }
  if typename_is0(tn, "f32") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_f32 }; }
  if typename_is0(tn, "f64") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_f64 }; }
  if typename_is0(tn, "String") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_string }; }

  // @range(lo..=hi) Base
  if tn.parts.len() == 3 && tn.parts.get(0) == "@range" && tn.args.len() == 1 {
    let pr_lo: ParseI64DecResult = parse_i64_dec(tn.parts.get(1));
    if !pr_lo.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    let pr_hi: ParseI64DecResult = parse_i64_dec(tn.parts.get(2));
    if !pr_hi.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    let lo: i64 = pr_lo.val;
    let hi: i64 = pr_hi.val;
    if lo > hi { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    let br: ResolveTyResult = resolve_type_bound(c, w, cur_mod, imps, type_params, binds, tn.args.get(0));
    c = br.ctx;
    if !br.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    let bt: ir.Ty = ir.ty_pool_get(c.pool, br.idx);
    let is_int: bool = match bt.kind {
      ir.TyKind.I8 => true,
      ir.TyKind.U8 => true,
      ir.TyKind.I16 => true,
      ir.TyKind.U16 => true,
      ir.TyKind.I32 => true,
      ir.TyKind.U32 => true,
      ir.TyKind.I64 => true,
      ir.TyKind.U64 => true,
      ir.TyKind.ISize => true,
      ir.TyKind.USize => true,
      _ => false,
    };
    if !is_int { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    // Bounds must fit the base type. (v0 simplification: u64/usize bounds are limited to i64 range.)
    if bt.kind == ir.TyKind.I8 && (lo < -128 || hi > 127) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if bt.kind == ir.TyKind.U8 && (lo < 0 || hi > 255) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if bt.kind == ir.TyKind.I16 && (lo < -32768 || hi > 32767) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if bt.kind == ir.TyKind.U16 && (lo < 0 || hi > 65535) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if bt.kind == ir.TyKind.I32 && (lo < -2147483648 || hi > 2147483647) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if bt.kind == ir.TyKind.U32 && (lo < 0 || hi > 4294967295) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if (bt.kind == ir.TyKind.U64 || bt.kind == ir.TyKind.USize) && lo < 0 { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    let ir0: InternResult = intern_ty(c, ir.ty_range(br.idx, lo, hi));
    c = ir0.ctx;
    return ResolveTyResult { ctx: c, ok: true, idx: ir0.idx };
  }

  // @field_type(T, I)
  // Type-position reflection over nominal layouts.
  if tn.parts.len() == 2 && tn.parts.get(0) == "@field_type" && tn.args.len() == 1 {
    let pr_i: ParseI64DecResult = parse_i64_dec(tn.parts.get(1));
    if !pr_i.ok || pr_i.val < 0 { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    let i: i32 = pr_i.val as i32;

    let br: ResolveTyResult = resolve_type_bound(c, w, cur_mod, imps, type_params, binds, tn.args.get(0));
    c = br.ctx;
    if !br.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    let bt_idx: i32 = strip_range(c, br.idx);
    let bt: ir.Ty = ir.ty_pool_get(c.pool, bt_idx);
    if bt.kind == ir.TyKind.Param {
      return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
    }

    if bt.kind == ir.TyKind.Struct {
      let fs: FindStructResult = find_struct(c, bt.mod_path, bt.name);
      if fs.found {
        if i < 0 || i >= fs.sig.fields.len() { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
        return ResolveTyResult { ctx: c, ok: true, idx: fs.sig.fields.get(i).ty };
      }

      // Non-generic nominal types may be referenced before collect_structs
      // has materialized signature fields. Fall back to source decl on demand.
      let fm2: FindModResult = find_mod(w, bt.mod_path);
      if !fm2.found { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      let m2: WorldModule = w.mods.get(fm2.idx);
      let fsd2: FindStructDeclResult = find_struct_decl_in_mod(m2, bt.name);
      if !fsd2.found { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      if i < 0 || i >= fsd2.d.fields.len() { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      let ir2: ImportsResult = build_imports(w, bt.mod_path, m2.prog.imports, fsd2.d.file);
      if !ir2.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      let fr2: ResolveTyResult = resolve_type_bound(c, w, bt.mod_path, ir2.imps, Vec(), Vec(), fsd2.d.fields.get(i).ty);
      c = fr2.ctx;
      if !fr2.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      return ResolveTyResult { ctx: c, ok: true, idx: fr2.idx };
    }

    if bt.kind == ir.TyKind.Enum {
      let fe: FindEnumResult = find_enum(c, bt.mod_path, bt.name);
      if fe.found {
        if i < 0 || i >= fe.sig.vars.len() { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
        let v: EnumVariantSig = fe.sig.vars.get(i);
        if v.fields.len() == 0 { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_unit }; }
        if v.fields.len() == 1 { return ResolveTyResult { ctx: c, ok: true, idx: v.fields.get(0) }; }
        // No tuple surface type in stage2; multi-payload variant type projection
        // is intentionally rejected for now.
        return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
      }

      // Same fallback strategy as struct branch above.
      let fm3: FindModResult = find_mod(w, bt.mod_path);
      if !fm3.found { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      let m3: WorldModule = w.mods.get(fm3.idx);
      let fed3: FindEnumDeclResult = find_enum_decl_in_mod(m3, bt.name);
      if !fed3.found { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      if i < 0 || i >= fed3.d.variants.len() { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      let vd3: ast.EnumVariantDecl = fed3.d.variants.get(i);
      if vd3.fields.len() == 0 { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_unit }; }
      if vd3.fields.len() != 1 { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      let ir3: ImportsResult = build_imports(w, bt.mod_path, m3.prog.imports, fed3.d.file);
      if !ir3.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      let vr3: ResolveTyResult = resolve_type_bound(c, w, bt.mod_path, ir3.imps, Vec(), Vec(), vd3.fields.get(0));
      c = vr3.ctx;
      if !vr3.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      return ResolveTyResult { ctx: c, ok: true, idx: vr3.idx };
    }

    return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
  }

  // Vec[T]
  if tn.parts.len() == 1 && tn.parts.get(0) == "Vec" && tn.args.len() == 1 {
    let r0: ResolveTyResult = resolve_type_bound(c, w, cur_mod, imps, type_params, binds, tn.args.get(0));
    c = r0.ctx;
    if !r0.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    let ir0: InternResult = intern_ty(c, ir.ty_vec(r0.idx));
    c = ir0.ctx;
    // Also pre-intern one more level: `Vec[Vec[T]]`.
    let _ir1: InternResult = intern_ty(c, ir.ty_vec(ir0.idx));
    c = _ir1.ctx;
    return ResolveTyResult { ctx: c, ok: true, idx: ir0.idx };
  }

  // nominal types: local or imported module alias
  let mut mod_path: String = cur_mod;
  let mut name: String = "";
  if tn.parts.len() == 1 {
    name = tn.parts.get(0);
    let ni: NamedTypeImport = find_named_type(imps.named_types, name);
    if ni.local != "" {
      mod_path = ni.mod_path;
      name = ni.name;
    }
  } else if tn.parts.len() == 2 {
    let mp: String = find_alias(imps.aliases, tn.parts.get(0));
    if mp == "" {
      return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
    }
    mod_path = mp;
    name = tn.parts.get(1);
  } else {
    return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
  }
  // Type aliases (type-only).
  let ta: TypeAliasSig = find_type_alias(c.type_aliases, mod_path, name);
  if ta.name != "" {
    if tn.args.len() != 0 { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if !vis_allows(ta.vis, mod_path, cur_mod) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    return ResolveTyResult { ctx: c, ok: true, idx: ta.ty };
  }

  // Search struct then enum decl in the target module.
  let fm: FindModResult = find_mod(w, mod_path);
  if !fm.found {
    return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
  }
  let m: WorldModule = w.mods.get(fm.idx);
  // struct
  let fsd: FindStructDeclResult = find_struct_decl_in_mod(m, name);
  if fsd.found {
    let sd: ast.StructDecl = fsd.d;
    if !vis_allows(sd.vis, mod_path, cur_mod) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if sd.type_params.len() == 0 {
      if tn.args.len() != 0 { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      return nominal_intern_struct(c, mod_path, sd.name);
    }
    if tn.args.len() != sd.type_params.len() { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    let mut arg_tys: Vec[i32] = Vec();
    let mut ai: i32 = 0;
    while ai < tn.args.len() {
      let ar: ResolveTyResult = resolve_type_bound(c, w, cur_mod, imps, type_params, binds, tn.args.get(ai));
      c = ar.ctx;
      if !ar.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      arg_tys.push(ar.idx);
      ai = ai + 1;
    }
    let ckw: NominalComptimeWhereResult = nominal_check_comptime_where(c, sd.sp, sd.type_params, sd.const_where_bounds, arg_tys);
    c = ckw.ctx;
    if !ckw.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    // Resolve type-param trait bounds in the nominal declaration's module scope.
    // Imported generic types can reference local traits (e.g. `T: SyncScalar`).
    let ir0: ImportsResult = build_imports(w, mod_path, m.prog.imports, sd.file);
    if !ir0.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    let imps0: Imports = ir0.imps;
    let tbk: NominalTraitBoundsResult = nominal_check_type_param_bounds(c, w, mod_path, imps0, sd.sp, sd.type_params, sd.type_param_bounds, arg_tys);
    c = tbk.ctx;
    if !tbk.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    let subs: Vec[TySub] = subs_from_args(sd.type_params, arg_tys);
    let inst: String = inst_name(c, sd.name, sd.type_params, subs);
    let fs: FindStructResult = find_struct(c, mod_path, inst);
    if fs.found { return nominal_intern_struct(c, mod_path, inst); }

    // Insert placeholder first so recursive references can resolve.
    c.structs.push(StructSig { mod_path: mod_path, name: inst, base_name: sd.name, vis: sd.vis, is_pub: sd.is_pub, fields: Vec() });
    let ir_self: ResolveTyResult = nominal_intern_struct(c, mod_path, inst);
    c = ir_self.ctx;

    let binds0: Vec[TypeBind] = binds_from_args(sd.type_params, arg_tys);

    let mut fields: Vec[StructFieldSig] = Vec();
    let mut fi: i32 = 0;
    while fi < sd.fields.len() {
      let fd: ast.FieldDecl = sd.fields.get(fi);
      let rr: ResolveTyResult = resolve_type_bound(c, w, mod_path, imps0, sd.type_params, binds0, fd.ty);
      c = rr.ctx;
      if !rr.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      fields.push(StructFieldSig { name: fd.name, ty: rr.idx, vis: fd.vis, is_pub: fd.is_pub });
      fi = fi + 1;
    }
    c = set_struct_fields(c, mod_path, inst, fields);
    return ResolveTyResult { ctx: c, ok: true, idx: ir_self.idx };
  }

  // enum
  let fed: FindEnumDeclResult = find_enum_decl_in_mod(m, name);
  if fed.found {
    let ed: ast.EnumDecl = fed.d;
    if !vis_allows(ed.vis, mod_path, cur_mod) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if ed.type_params.len() == 0 {
      if tn.args.len() != 0 { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      return nominal_intern_enum(c, mod_path, ed.name);
    }
    if tn.args.len() != ed.type_params.len() { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    let mut arg_tys: Vec[i32] = Vec();
    let mut ai: i32 = 0;
    while ai < tn.args.len() {
      let ar: ResolveTyResult = resolve_type_bound(c, w, cur_mod, imps, type_params, binds, tn.args.get(ai));
      c = ar.ctx;
      if !ar.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
      arg_tys.push(ar.idx);
      ai = ai + 1;
    }
    let ckw: NominalComptimeWhereResult = nominal_check_comptime_where(c, ed.sp, ed.type_params, ed.const_where_bounds, arg_tys);
    c = ckw.ctx;
    if !ckw.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    // Resolve type-param trait bounds in the nominal declaration's module scope.
    let ir0: ImportsResult = build_imports(w, mod_path, m.prog.imports, ed.file);
    if !ir0.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    let imps0: Imports = ir0.imps;
    let tbk: NominalTraitBoundsResult = nominal_check_type_param_bounds(c, w, mod_path, imps0, ed.sp, ed.type_params, ed.type_param_bounds, arg_tys);
    c = tbk.ctx;
    if !tbk.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    let subs: Vec[TySub] = subs_from_args(ed.type_params, arg_tys);
    let inst: String = inst_name(c, ed.name, ed.type_params, subs);
    let fe: FindEnumResult = find_enum(c, mod_path, inst);
    if fe.found { return nominal_intern_enum(c, mod_path, inst); }

    // Insert placeholder first so recursive references can resolve.
    c.enums.push(EnumSig { mod_path: mod_path, name: inst, base_name: ed.name, vis: ed.vis, is_pub: ed.is_pub, vars: Vec() });
    let ir_self: ResolveTyResult = nominal_intern_enum(c, mod_path, inst);
    c = ir_self.ctx;

    let binds0: Vec[TypeBind] = binds_from_args(ed.type_params, arg_tys);

    let mut vars: Vec[EnumVariantSig] = Vec();
    let mut vi: i32 = 0;
    while vi < ed.variants.len() {
      let vd: ast.EnumVariantDecl = ed.variants.get(vi);
      let mut ftys: Vec[i32] = Vec();
      let mut fi: i32 = 0;
      while fi < vd.fields.len() {
        let tr: ResolveTyResult = resolve_type_bound(c, w, mod_path, imps0, ed.type_params, binds0, vd.fields.get(fi));
        c = tr.ctx;
        if !tr.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
        ftys.push(tr.idx);
        fi = fi + 1;
      }
      vars.push(EnumVariantSig { name: vd.name, fields: ftys });
      vi = vi + 1;
    }
    c = set_enum_vars(c, mod_path, inst, vars);
    return ResolveTyResult { ctx: c, ok: true, idx: ir_self.idx };
  }

  return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
}

pub fn resolve_type(ctx: Ctx, w: World, cur_mod: String, imps: Imports, type_params: Vec[String], tn: ast.TypeName) -> ResolveTyResult {
  return resolve_type_bound(ctx, w, cur_mod, imps, type_params, Vec(), tn);
}

pub fn is_vec_ty(ctx: Ctx, ty_idx: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  return match t.kind { ir.TyKind.Vec => true, _ => false };
}

pub fn vec_elem(ctx: Ctx, ty_idx: i32) -> i32 {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  return t.elem;
}

pub fn is_struct_ty(ctx: Ctx, ty_idx: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  return match t.kind { ir.TyKind.Struct => true, _ => false };
}

pub fn is_enum_ty(ctx: Ctx, ty_idx: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  return match t.kind { ir.TyKind.Enum => true, _ => false };
}

pub fn ty_name(t: ir.Ty) -> String { return t.name; }
pub fn ty_mod(t: ir.Ty) -> String { return t.mod_path; }

pub fn const_kind_int() -> i32 { return 1; }
pub fn const_kind_bool() -> i32 { return 2; }
pub fn const_kind_str() -> i32 { return 3; }
pub fn const_kind_float() -> i32 { return 4; }
pub fn const_kind_enum() -> i32 { return 5; }
pub fn const_kind_struct() -> i32 { return 6; }

pub fn find_const(ctx: Ctx, mod_path: String, name: String) -> ConstSig {
  let mut i: i32 = 0;
  while i < ctx.consts.len() {
    let c: ConstSig = ctx.consts.get(i);
    if c.mod_path == mod_path && c.name == name { return c; }
    i = i + 1;
  }
  return ConstSig { mod_path: "", name: "", vis: ast.vis_private(), is_pub: false, ty: -1, kind: 0, iv: 0, bv: false, sv: "" };
}
