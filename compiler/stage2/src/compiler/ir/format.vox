// Text formatting for IR v0 (debug / testing).

fn value_fmt(v: Value) -> String {
  return match v {
    Value.Param(i) => "%p".concat(i.to_string()),
    Value.Temp(i) => "%t".concat(i.to_string()),
    Value.Slot(i) => "$v".concat(i.to_string()),
    Value.Int(n) => n.to_string(),
    Value.Float(text) => text,
    Value.Bool(b) => b.to_string(),
    // Keep it simple: escape for C and wrap in quotes. (Also valid readable IR.)
    Value.Str(s) => "\"".concat(s.escape_c()).concat("\""),
  };
}

fn ty_fmt(pool: TyPool, idx: i32) -> String {
  let t: Ty = ty_pool_get(pool, idx);
  return match t.kind {
    TyKind.Bad => "<bad>",
    TyKind.Unit => "unit",
    TyKind.Bool => "bool",
    TyKind.I8 => "i8",
    TyKind.U8 => "u8",
    TyKind.I16 => "i16",
    TyKind.U16 => "u16",
    TyKind.I32 => "i32",
    TyKind.U32 => "u32",
    TyKind.I64 => "i64",
    TyKind.U64 => "u64",
    TyKind.ISize => "isize",
    TyKind.USize => "usize",
    TyKind.F32 => "f32",
    TyKind.F64 => "f64",
    TyKind.String => "str",
    TyKind.Param => "param(".concat(t.name).concat(")"),
    TyKind.Struct => "struct(".concat(t.mod_path).concat("::").concat(t.name).concat(")"),
    TyKind.Enum => "enum(".concat(t.mod_path).concat("::").concat(t.name).concat(")"),
    TyKind.Vec => "vec(".concat(ty_fmt(pool, t.elem)).concat(")"),
    TyKind.Range => "range(".concat(ty_fmt(pool, t.elem)).concat(",").concat(t.lo.to_string()).concat("..=").concat(t.hi.to_string()).concat(")"),
  };
}

fn binop_fmt(op: BinOpKind) -> String {
  return match op {
    BinOpKind.Add => "add",
    BinOpKind.Sub => "sub",
    BinOpKind.Mul => "mul",
    BinOpKind.Div => "div",
    BinOpKind.Mod => "mod",
    BinOpKind.BitAnd => "bitand",
    BinOpKind.BitOr => "bitor",
    BinOpKind.BitXor => "bitxor",
    BinOpKind.Shl => "shl",
    BinOpKind.Shr => "shr",
  };
}

fn cmp_fmt(op: CmpKind) -> String {
  return match op {
    CmpKind.Lt => "cmp_lt",
    CmpKind.Le => "cmp_le",
    CmpKind.Gt => "cmp_gt",
    CmpKind.Ge => "cmp_ge",
    CmpKind.Eq => "cmp_eq",
    CmpKind.Ne => "cmp_ne",
  };
}

fn instr_fmt(pool: TyPool, i: Instr) -> String {
  return match i {
    Instr.Const(dst, ty, v) => value_fmt(Value.Temp(dst)).concat(" = const ").concat(ty_fmt(pool, ty)).concat(" ").concat(value_fmt(v)),
    Instr.BinOp(dst, op, ty, a, b) => value_fmt(Value.Temp(dst)).concat(" = ").concat(binop_fmt(op)).concat(" ").concat(ty_fmt(pool, ty)).concat(" ").concat(value_fmt(a)).concat(" ").concat(value_fmt(b)),
    Instr.Cmp(dst, op, ty, a, b) => value_fmt(Value.Temp(dst)).concat(" = ").concat(cmp_fmt(op)).concat(" ").concat(ty_fmt(pool, ty)).concat(" ").concat(value_fmt(a)).concat(" ").concat(value_fmt(b)),
    Instr.And(dst, a, b) => value_fmt(Value.Temp(dst)).concat(" = and ").concat(value_fmt(a)).concat(" ").concat(value_fmt(b)),
    Instr.Or(dst, a, b) => value_fmt(Value.Temp(dst)).concat(" = or ").concat(value_fmt(a)).concat(" ").concat(value_fmt(b)),
    Instr.Not(dst, a) => value_fmt(Value.Temp(dst)).concat(" = not ").concat(value_fmt(a)),

    Instr.IntCast(dst, dst_ty, src_ty, v) =>
      value_fmt(Value.Temp(dst)).concat(" = int_cast ").concat(ty_fmt(pool, dst_ty)).concat(" ").concat(ty_fmt(pool, src_ty)).concat(" ").concat(value_fmt(v)),
    Instr.IntCastChecked(dst, dst_ty, src_ty, v) =>
      value_fmt(Value.Temp(dst)).concat(" = int_cast_checked ").concat(ty_fmt(pool, dst_ty)).concat(" ").concat(ty_fmt(pool, src_ty)).concat(" ").concat(value_fmt(v)),
    Instr.FloatCast(dst, dst_ty, src_ty, v) =>
      value_fmt(Value.Temp(dst)).concat(" = float_cast ").concat(ty_fmt(pool, dst_ty)).concat(" ").concat(ty_fmt(pool, src_ty)).concat(" ").concat(value_fmt(v)),
    Instr.RangeCheck(ty, v, lo, hi) =>
      "range_check ".concat(ty_fmt(pool, ty)).concat(" ").concat(lo.to_string()).concat(" ").concat(hi.to_string()).concat(" ").concat(value_fmt(v)),

    Instr.SlotDecl(slot, ty) => value_fmt(Value.Slot(slot)).concat(" = slot ").concat(ty_fmt(pool, ty)),
    Instr.Store(slot, v) => "store ".concat(value_fmt(Value.Slot(slot))).concat(" ").concat(value_fmt(v)),
    Instr.Load(dst, ty, slot) => value_fmt(Value.Temp(dst)).concat(" = load ").concat(ty_fmt(pool, ty)).concat(" ").concat(value_fmt(Value.Slot(slot))),

    Instr.StructInit(dst, ty, _fields) => value_fmt(Value.Temp(dst)).concat(" = struct_init ").concat(ty_fmt(pool, ty)).concat(" { ... }"),
    Instr.FieldGet(dst, ty, recv, field) => value_fmt(Value.Temp(dst)).concat(" = field_get ").concat(ty_fmt(pool, ty)).concat(" ").concat(value_fmt(recv)).concat(" .").concat(field),
    Instr.StoreField(slot, field, v) => "store_field ".concat(value_fmt(Value.Slot(slot))).concat(" .").concat(field).concat(" ").concat(value_fmt(v)),

    Instr.EnumInit(dst, ty, variant, _payload) => value_fmt(Value.Temp(dst)).concat(" = enum_init ").concat(ty_fmt(pool, ty)).concat(" ").concat(variant),
    Instr.EnumTag(dst, recv) => value_fmt(Value.Temp(dst)).concat(" = enum_tag ").concat(value_fmt(recv)),
    Instr.EnumPayload(dst, ty, recv, variant, idx) =>
      value_fmt(Value.Temp(dst))
        .concat(" = enum_payload ")
        .concat(ty_fmt(pool, ty))
        .concat(" ")
        .concat(value_fmt(recv))
        .concat(" ")
        .concat(variant)
        .concat(" ")
        .concat(idx.to_string()),

    Instr.VecNew(dst, ty, _elem) => value_fmt(Value.Temp(dst)).concat(" = vec_new ").concat(ty_fmt(pool, ty)),
    Instr.VecPush(slot, _elem, v) => "vec_push ".concat(value_fmt(Value.Slot(slot))).concat(" ").concat(value_fmt(v)),
    Instr.VecInsert(slot, _elem, idx, v) => "vec_insert ".concat(value_fmt(Value.Slot(slot))).concat(" ").concat(value_fmt(idx)).concat(" ").concat(value_fmt(v)),
    Instr.VecSet(slot, _elem, idx, v) => "vec_set ".concat(value_fmt(Value.Slot(slot))).concat(" ").concat(value_fmt(idx)).concat(" ").concat(value_fmt(v)),
    Instr.VecClear(slot) => "vec_clear ".concat(value_fmt(Value.Slot(slot))),
    Instr.VecExtend(slot, other_slot) => "vec_extend ".concat(value_fmt(Value.Slot(slot))).concat(" ").concat(value_fmt(Value.Slot(other_slot))),
    Instr.VecPop(dst, ty, slot) => value_fmt(Value.Temp(dst)).concat(" = vec_pop ").concat(ty_fmt(pool, ty)).concat(" ").concat(value_fmt(Value.Slot(slot))),
    Instr.VecRemove(dst, ty, slot, idx) => value_fmt(Value.Temp(dst)).concat(" = vec_remove ").concat(ty_fmt(pool, ty)).concat(" ").concat(value_fmt(Value.Slot(slot))).concat(" ").concat(value_fmt(idx)),
    Instr.VecLen(dst, slot) => value_fmt(Value.Temp(dst)).concat(" = vec_len ").concat(value_fmt(Value.Slot(slot))),
    Instr.VecGet(dst, ty, slot, idx) => value_fmt(Value.Temp(dst)).concat(" = vec_get ").concat(ty_fmt(pool, ty)).concat(" ").concat(value_fmt(Value.Slot(slot))).concat(" ").concat(value_fmt(idx)),
    Instr.VecStrJoin(dst, slot, sep) => value_fmt(Value.Temp(dst)).concat(" = vec_str_join ").concat(value_fmt(Value.Slot(slot))).concat(" ").concat(value_fmt(sep)),

    Instr.StrLen(dst, recv) => value_fmt(Value.Temp(dst)).concat(" = str_len ").concat(value_fmt(recv)),
    Instr.StrByteAt(dst, recv, idx) => value_fmt(Value.Temp(dst)).concat(" = str_byte_at ").concat(value_fmt(recv)).concat(" ").concat(value_fmt(idx)),
    Instr.StrSlice(dst, recv, s, e) => value_fmt(Value.Temp(dst)).concat(" = str_slice ").concat(value_fmt(recv)).concat(" ").concat(value_fmt(s)).concat(" ").concat(value_fmt(e)),
    Instr.StrConcat(dst, a, b) => value_fmt(Value.Temp(dst)).concat(" = str_concat ").concat(value_fmt(a)).concat(" ").concat(value_fmt(b)),
    Instr.StrEscapeC(dst, recv) => value_fmt(Value.Temp(dst)).concat(" = str_escape_c ").concat(value_fmt(recv)),
    Instr.StrStartsWith(dst, recv, pre) => value_fmt(Value.Temp(dst)).concat(" = str_starts_with ").concat(value_fmt(recv)).concat(" ").concat(value_fmt(pre)),
    Instr.StrEndsWith(dst, recv, suf) => value_fmt(Value.Temp(dst)).concat(" = str_ends_with ").concat(value_fmt(recv)).concat(" ").concat(value_fmt(suf)),
    Instr.StrContains(dst, recv, needle) => value_fmt(Value.Temp(dst)).concat(" = str_contains ").concat(value_fmt(recv)).concat(" ").concat(value_fmt(needle)),
    Instr.StrIndexOf(dst, recv, needle) => value_fmt(Value.Temp(dst)).concat(" = str_index_of ").concat(value_fmt(recv)).concat(" ").concat(value_fmt(needle)),
    Instr.StrLastIndexOf(dst, recv, needle) => value_fmt(Value.Temp(dst)).concat(" = str_last_index_of ").concat(value_fmt(recv)).concat(" ").concat(value_fmt(needle)),

    Instr.I32ToStr(dst, v) => value_fmt(Value.Temp(dst)).concat(" = i32_to_str ").concat(value_fmt(v)),
    Instr.I64ToStr(dst, v) => value_fmt(Value.Temp(dst)).concat(" = i64_to_str ").concat(value_fmt(v)),
    Instr.U64ToStr(dst, v) => value_fmt(Value.Temp(dst)).concat(" = u64_to_str ").concat(value_fmt(v)),
    Instr.F32ToStr(dst, v) => value_fmt(Value.Temp(dst)).concat(" = f32_to_str ").concat(value_fmt(v)),
    Instr.F64ToStr(dst, v) => value_fmt(Value.Temp(dst)).concat(" = f64_to_str ").concat(value_fmt(v)),
    Instr.BoolToStr(dst, v) => value_fmt(Value.Temp(dst)).concat(" = bool_to_str ").concat(value_fmt(v)),

    Instr.Call(has_dst, dst, ret, name, _args) =>
      (if has_dst { value_fmt(Value.Temp(dst)).concat(" = ") } else { "" })
        .concat("call ").concat(ty_fmt(pool, ret)).concat(" ").concat(name).concat("(...)"),
  };
}

fn term_fmt(t: Term) -> String {
  return match t {
    Term.Ret(has, v) => if has { "ret ".concat(value_fmt(v)) } else { "ret" },
    Term.Br(target) => "br ".concat(target),
    Term.CondBr(c, a, b) => "condbr ".concat(value_fmt(c)).concat(" ").concat(a).concat(" ").concat(b),
    Term.Panic(msg) => "panic ".concat(value_fmt(msg)),
  };
}

pub fn format_program(p: Program) -> String {
  let mut lines: Vec[String] = Vec();
  lines.push("ir v0");

  // Nominal defs (keep v0 simple, no sorting).
  let mut si: i32 = 0;
  while si < p.structs.len() {
    let s: StructDecl = p.structs.get(si);
    lines.push("struct ".concat(s.name).concat(" { ... }"));
    si = si + 1;
  }
  let mut ei: i32 = 0;
  while ei < p.enums.len() {
    let e: EnumDecl = p.enums.get(ei);
    lines.push("enum ".concat(e.name).concat(" { ... }"));
    ei = ei + 1;
  }

  let mut fi: i32 = 0;
  while fi < p.funcs.len() {
    let f: Func = p.funcs.get(fi);
    lines.push("fn ".concat(f.name).concat("(...) -> ").concat(ty_fmt(p.pool, f.ret)));
    let mut bi: i32 = 0;
    while bi < f.blocks.len() {
      let b: Block = f.blocks.get(bi);
      lines.push("block ".concat(b.name).concat(":"));
      let mut ii: i32 = 0;
      while ii < b.instrs.len() {
        lines.push("  ".concat(instr_fmt(p.pool, b.instrs.get(ii))));
        ii = ii + 1;
      }
      if b.has_term {
        lines.push("  ".concat(term_fmt(b.term)));
      }
      bi = bi + 1;
    }
    fi = fi + 1;
  }

  // Join with '\n'.
  return lines.join("\n");
}
