import "std/fs" as fs
import "manifest" as mf

struct LockDep {
  name: String,
  source: String,
  path: String,
  resolved_path: String,
  git: String,
  rev: String,
  registry: String,
  version: String,
  digest: String,
}

struct ParseLockResult { ok: bool, err: String, deps: Vec[LockDep] }
struct LockVerifyResult { ok: bool, err: String }

fn lock_ok() -> LockVerifyResult { return LockVerifyResult { ok: true, err: "" }; }
fn lock_err(msg: String) -> LockVerifyResult { return LockVerifyResult { ok: false, err: msg }; }

fn empty_lock_dep() -> LockDep {
  return LockDep {
    name: "",
    source: "",
    path: "",
    resolved_path: "",
    git: "",
    rev: "",
    registry: "",
    version: "",
    digest: "",
  };
}

fn lock_index_byte(s: String, b: i32) -> i32 {
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == b { return i; }
    i = i + 1;
  }
  return -1;
}

fn lock_unquote(s0: String) -> String {
  let s: String = trim_space_main(s0);
  if s.len() >= 2 && s.byte_at(0) == 34 && s.byte_at(s.len() - 1) == 34 {
    return s.slice(1, s.len() - 1);
  }
  return s;
}

fn lock_split_lines(s: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  if s.len() == 0 {
    out.push("");
    return out;
  }
  let mut start: i32 = 0;
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 10 {
      out.push(s.slice(start, i));
      start = i + 1;
    }
    i = i + 1;
  }
  if start <= s.len() {
    out.push(s.slice(start, s.len()));
  }
  return out;
}

fn parse_lockfile(text: String) -> ParseLockResult {
  let lines: Vec[String] = lock_split_lines(text);
  let mut deps: Vec[LockDep] = Vec();
  let mut in_dep: bool = false;
  let mut cur: LockDep = empty_lock_dep();

  let mut i: i32 = 0;
  while i < lines.len() {
    let line0: String = trim_space_main(lines.get(i));
    if line0 == "" || has_prefix(line0, "#") {
      i = i + 1;
      continue;
    }
    if line0 == "[[dependency]]" {
      if in_dep {
        deps.push(cur);
      }
      cur = empty_lock_dep();
      in_dep = true;
      i = i + 1;
      continue;
    }
    if !in_dep {
      i = i + 1;
      continue;
    }
    let eq: i32 = lock_index_byte(line0, 61); // '='
    if eq == -1 {
      return ParseLockResult { ok: false, err: "invalid lock line", deps: Vec() };
    }
    let key: String = trim_space_main(line0.slice(0, eq));
    let val: String = lock_unquote(line0.slice(eq + 1, line0.len()));
    if key == "name" { cur.name = val; }
    else if key == "source" { cur.source = val; }
    else if key == "path" { cur.path = val; }
    else if key == "resolved_path" { cur.resolved_path = val; }
    else if key == "git" { cur.git = val; }
    else if key == "rev" { cur.rev = val; }
    else if key == "registry" { cur.registry = val; }
    else if key == "version" { cur.version = val; }
    else if key == "digest" { cur.digest = val; }
    i = i + 1;
  }

  if in_dep {
    deps.push(cur);
  }
  return ParseLockResult { ok: true, err: "", deps: deps };
}

fn lock_hash_byte(h0: u64, b: i32) -> u64 {
  let h1: u64 = h0 ^ (b as u64);
  return h1 * (1099511628211 as u64);
}

fn lock_hash_text(h0: u64, s: String) -> u64 {
  let mut h: u64 = h0;
  let mut i: i32 = 0;
  while i < s.len() {
    h = lock_hash_byte(h, s.byte_at(i));
    i = i + 1;
  }
  return h;
}

fn lock_insert_sorted(xs0: Vec[String], x: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut inserted: bool = false;
  let mut i: i32 = 0;
  while i < xs0.len() {
    let cur: String = xs0.get(i);
    if !inserted && x < cur {
      out.push(x);
      inserted = true;
    }
    out.push(cur);
    i = i + 1;
  }
  if !inserted { out.push(x); }
  return out;
}

fn lock_sort_strings(xs0: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    out = lock_insert_sorted(out, xs0.get(i));
    i = i + 1;
  }
  return out;
}

fn lock_dep_digest(dep_root: String) -> String {
  let mut h: u64 = 1469598103934665603 as u64;
  let mani_path: String = path_join(dep_root, "vox.toml");
  if fs.exists(mani_path) {
    h = lock_hash_text(h, "vox.toml");
    h = lock_hash_text(h, "\n");
    h = lock_hash_text(h, fs.read_to_string(mani_path));
    h = lock_hash_text(h, "\n");
  }

  let rels0: Vec[String] = fs.walk_vox_files(dep_root);
  let mut rels1: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < rels0.len() {
    let rel: String = rels0.get(i);
    if has_prefix(rel, "src/") && !is_test_path(rel) {
      rels1.push(rel);
    }
    i = i + 1;
  }
  let rels: Vec[String] = lock_sort_strings(rels1);
  let mut j: i32 = 0;
  while j < rels.len() {
    let rel: String = rels.get(j);
    h = lock_hash_text(h, rel);
    h = lock_hash_text(h, "\n");
    h = lock_hash_text(h, fs.read_to_string(path_join(dep_root, rel)));
    h = lock_hash_text(h, "\n");
    j = j + 1;
  }
  return h.to_string();
}

fn lock_dep_of(d: mf.Dependency) -> LockDep {
  return LockDep {
    name: d.name,
    source: dep_source_kind(d),
    path: if d.has_path { d.path } else { "" },
    resolved_path: d.path,
    git: if d.has_git { d.git } else { "" },
    rev: if d.has_rev { d.rev } else { "" },
    registry: if d.has_registry { d.registry } else { "" },
    version: if d.has_version { d.version } else { "" },
    digest: lock_dep_digest(d.path),
  };
}

fn lock_dep_eq(a: LockDep, b: LockDep) -> bool {
  return a.name == b.name &&
    a.source == b.source &&
    a.path == b.path &&
    a.resolved_path == b.resolved_path &&
    a.git == b.git &&
    a.rev == b.rev &&
    a.registry == b.registry &&
    a.version == b.version &&
    a.digest == b.digest;
}

fn verify_lockfile_or_ok(deps: Vec[mf.Dependency]) -> LockVerifyResult {
  if !fs.exists("vox.lock") {
    return lock_ok();
  }
  let txt: String = fs.read_to_string("vox.lock");
  let pr: ParseLockResult = parse_lockfile(txt);
  if !pr.ok {
    return lock_err(pr.err);
  }

  let mut expected: Vec[LockDep] = Vec();
  let mut i: i32 = 0;
  while i < deps.len() {
    expected.push(lock_dep_of(deps.get(i)));
    i = i + 1;
  }

  if pr.deps.len() != expected.len() {
    return lock_err("dependency count mismatch");
  }

  let mut ei: i32 = 0;
  while ei < expected.len() {
    let e: LockDep = expected.get(ei);
    let mut found: bool = false;
    let mut ai: i32 = 0;
    while ai < pr.deps.len() {
      let a: LockDep = pr.deps.get(ai);
      if lock_dep_eq(e, a) {
        found = true;
      }
      ai = ai + 1;
    }
    if !found {
      return lock_err("dependency mismatch: ".concat(e.name));
    }
    ei = ei + 1;
  }
  return lock_ok();
}
