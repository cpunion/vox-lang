import "parse" as p
import "typecheck" as tc
import "irgen" as irgen
import "codegen" as cg
import "loader" as ld

pub struct CompileResult {
  pub ok: bool,
  pub err: String,
  pub c: String,
}

pub fn compile_main_text_to_c(src: String, opts: cg.EmitOptions) -> CompileResult {
  let pr: p.ParseResult = p.parse_text_with_path("src/main.vox", src);
  if pr.err != p.ParseError.None {
    return CompileResult { ok: false, err: p.parse_error_to_string_with_source("src/main.vox", src, pr.err), c: "" };
  }

  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "main", pr.prog);

  let gr: irgen.GenResult = irgen.generate_world(w);
  if !gr.ok {
    return CompileResult { ok: false, err: gr.err, c: "" };
  }

  let c: String = cg.emit_c(gr.prog, opts);
  return CompileResult { ok: true, err: "", c: c };
}

pub fn compile_files_to_c(files: Vec[ld.SourceFile], opts: cg.EmitOptions) -> CompileResult {
  let lr: ld.LoadWorldResult = ld.world_from_files(files);
  if !lr.ok {
    return CompileResult { ok: false, err: lr.err, c: "" };
  }
  let gr: irgen.GenResult = irgen.generate_world(lr.world);
  if !gr.ok {
    return CompileResult { ok: false, err: gr.err, c: "" };
  }
  let c: String = cg.emit_c(gr.prog, opts);
  return CompileResult { ok: true, err: "", c: c };
}
