// Stage1 compiler (bootstrap target).
//
// Minimal CLI (v0):
// - emit-c <out.c> <src1.vox> <src2.vox> ...
// - build  <out.bin> <src1.vox> <src2.vox> ...

import "std/process" as proc
import "std/fs" as fs
import "loader" as ld
import "compile" as c
import "manifest" as mf
import "codegen" as cg
import "parse" as p
import "ast" as ast

fn usage() -> () {
  print("vox_stage1 usage:\n");
  print("  vox_stage1 emit-c <out.c> <src...>\n");
  print("  vox_stage1 build  <out.bin> <src...>\n");
  print("  vox_stage1 build-pkg <out.bin>   # build from ./src\n");
  print("  vox_stage1 test-pkg <out.bin>    # build+run tests from ./src and ./tests\n");
}

fn has_prefix(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

fn has_suffix(s: String, suf: String) -> bool {
  if s.len() < suf.len() { return false; }
  return s.slice(s.len() - suf.len(), s.len()) == suf;
}

fn is_test_path(p: String) -> bool {
  if has_prefix(p, "tests/") { return true; }
  if has_suffix(p, "_test.vox") { return true; }
  return false;
}

fn is_test_file_for_discovery(p: String) -> bool {
  if has_prefix(p, "tests/") { return true; }
  if has_prefix(p, "src/") && has_suffix(p, "_test.vox") { return true; }
  return false;
}

fn has_std_under_src(paths: Vec[String]) -> bool {
  let mut i: i32 = 0;
  while i < paths.len() {
    if has_prefix(paths.get(i), "src/std/") { return true; }
    i = i + 1;
  }
  return false;
}

fn filter_pkg_sources(paths: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let p: String = paths.get(i);
    if has_prefix(p, "src/") && !is_test_path(p) {
      out.push(p);
    }
    i = i + 1;
  }
  return out;
}

fn filter_pkg_test_sources(paths: Vec[String]) -> Vec[String] {
  // For tests, include src/** (including _test.vox) and tests/**.
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let p: String = paths.get(i);
    if has_prefix(p, "src/") || has_prefix(p, "tests/") {
      out.push(p);
    }
    i = i + 1;
  }
  return out;
}

fn dir_name(p: String) -> String {
  let n: i32 = p.len();
  let mut i: i32 = n - 1;
  while i >= 0 {
    if p.byte_at(i) == 47 { // '/'
      if i == 0 { return "/"; }
      return p.slice(0, i);
    }
    i = i - 1;
  }
  return ".";
}

fn path_join(a: String, b: String) -> String {
  if a == "" { return b; }
  if b == "" { return a; }
  if a.byte_at(a.len() - 1) == 47 { return a.concat(b); }
  return a.concat("/").concat(b);
}

fn stage1_root() -> String {
  // stage0 places binaries at: <pkg>/target/debug/<name>
  let exe: String = proc.exe_path();
  let d1: String = dir_name(exe);
  let d2: String = dir_name(d1);
  let d3: String = dir_name(d2);
  return d3;
}

fn qname(mod_path: String, name: String) -> String {
  if mod_path == "" || mod_path == "main" { return name; }
  let mut s: String = mod_path;
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 47 { // '/'
      s = s.slice(0, i).concat(".").concat(s.slice(i + 1, s.len()));
    }
    i = i + 1;
  }
  return s.concat("::").concat(name);
}

fn starts_with(s: String, pre: String) -> bool { return has_prefix(s, pre); }

fn discover_tests(paths: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let pth: String = paths.get(i);
    if is_test_file_for_discovery(pth) {
      let txt: String = fs.read_to_string(pth);
      let r: p.ParseResult = p.parse_text(txt);
      if r.err != p.ParseError.None {
        // Fail fast: discovery should not ignore syntax errors.
        panic("parse error in test file: ".concat(pth));
      }
      let mp: String = ld.mod_path_from_file_path(pth);
      let mut fi: i32 = 0;
      while fi < r.prog.funcs.len() {
        let fd: ast.FuncDecl = r.prog.funcs.get(fi);
        if starts_with(fd.name, "test_") {
          out.push(qname(mp, fd.name));
        }
        fi = fi + 1;
      }
    }
    i = i + 1;
  }
  return out;
}

fn load_deps_from_manifest() -> Vec[ld.SourceFile] {
  let mt: String = fs.read_to_string("vox.toml");
  let mr: mf.ParseResult = mf.parse(mt);
  if !mr.ok {
    print("invalid vox.toml: ".concat(mr.err).concat("\n"));
    return Vec();
  }
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut i: i32 = 0;
  while i < mr.m.deps.len() {
    let d: mf.Dependency = mr.m.deps.get(i);
    let dep_root: String = d.path;
    let rels: Vec[String] = fs.walk_vox_files(dep_root);
    let mut j: i32 = 0;
    while j < rels.len() {
      let rel: String = rels.get(j);
      // Dependencies: include src/** only, ignore tests/**.
      if has_prefix(rel, "src/") && !is_test_path(rel) {
        let full: String = path_join(dep_root, rel);
        let virt: String = d.name.concat("/").concat(rel);
        out.push(ld.SourceFile { path: virt, text: fs.read_to_string(full) });
      }
      j = j + 1;
    }
    i = i + 1;
  }
  return out;
}

fn load_files(paths: Vec[String]) -> Vec[ld.SourceFile] {
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let p: String = paths.get(i);
    out.push(ld.SourceFile { path: p, text: fs.read_to_string(p) });
    i = i + 1;
  }
  return out;
}

fn load_stage1_std() -> Vec[ld.SourceFile] {
  let root: String = stage1_root();
  let rels: Vec[String] = fs.walk_vox_files(root);
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut i: i32 = 0;
  while i < rels.len() {
    let rel: String = rels.get(i);
    if has_prefix(rel, "src/std/") {
      let full: String = path_join(root, rel);
      out.push(ld.SourceFile { path: rel, text: fs.read_to_string(full) });
    }
    i = i + 1;
  }
  return out;
}

fn slice_vec(xs: Vec[String], start: i32) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = start;
  while i < xs.len() { out.push(xs.get(i)); i = i + 1; }
  return out;
}

fn main() -> i32 {
  let args: Vec[String] = proc.args();
  if args.len() < 2 {
    usage();
    panic("invalid args");
    return 1;
  }
  let cmd: String = args.get(0);
  let out: String = args.get(1);
  let srcs: Vec[String] = slice_vec(args, 2);

  if cmd == "emit-c" {
    if srcs.len() == 0 { usage(); panic("missing sources"); return 1; }
    let mut files: Vec[ld.SourceFile] = load_stage1_std();
    let user: Vec[ld.SourceFile] = load_files(srcs);
    let mut ui: i32 = 0;
    while ui < user.len() { files.push(user.get(ui)); ui = ui + 1; }
    let r: c.CompileResult = c.compile_files_to_c(files, cg.EmitOptions { emit_driver_main: true, emit_test_main: false, test_funcs: Vec() });
    if !r.ok {
      panic("compile failed: ".concat(r.err));
      return 1;
    }
    fs.write_string(out, r.c);
    return 0;
  }
  if cmd == "build" {
    if srcs.len() == 0 { usage(); panic("missing sources"); return 1; }
    let mut files: Vec[ld.SourceFile] = load_stage1_std();
    let user: Vec[ld.SourceFile] = load_files(srcs);
    let mut ui: i32 = 0;
    while ui < user.len() { files.push(user.get(ui)); ui = ui + 1; }
    let r: c.CompileResult = c.compile_files_to_c(files, cg.EmitOptions { emit_driver_main: true, emit_test_main: false, test_funcs: Vec() });
    if !r.ok {
      panic("compile failed: ".concat(r.err));
      return 1;
    }
    let cpath: String = out.concat(".c");
    fs.write_string(cpath, r.c);
    let cmdline: String = "cc -std=c11 -O0 -g ".concat(cpath).concat(" -o ").concat(out);
    let code: i32 = proc.exec(cmdline);
    if code != 0 {
      panic("cc failed");
      return 1;
    }
    return 0;
  }
  if cmd == "build-pkg" {
    let all: Vec[String] = fs.walk_vox_files(".");
    let paths: Vec[String] = filter_pkg_sources(all);
    let mut files: Vec[ld.SourceFile] = if has_std_under_src(paths) { Vec() } else { load_stage1_std() };
    let deps: Vec[ld.SourceFile] = load_deps_from_manifest();
    let mut di: i32 = 0;
    while di < deps.len() { files.push(deps.get(di)); di = di + 1; }
    let user: Vec[ld.SourceFile] = load_files(paths);
    let mut ui: i32 = 0;
    while ui < user.len() { files.push(user.get(ui)); ui = ui + 1; }
    let r: c.CompileResult = c.compile_files_to_c(files, cg.EmitOptions { emit_driver_main: true, emit_test_main: false, test_funcs: Vec() });
    if !r.ok {
      panic("compile failed: ".concat(r.err));
      return 1;
    }
    let cpath: String = out.concat(".c");
    fs.write_string(cpath, r.c);
    let cmdline: String = "cc -std=c11 -O0 -g ".concat(cpath).concat(" -o ").concat(out);
    let code: i32 = proc.exec(cmdline);
    if code != 0 {
      panic("cc failed");
      return 1;
    }
    return 0;
  }
  if cmd == "test-pkg" {
    let all: Vec[String] = fs.walk_vox_files(".");
    let paths: Vec[String] = filter_pkg_test_sources(all);

    let tests: Vec[String] = discover_tests(paths);
    if tests.len() == 0 {
      print("[test] no tests found\n");
      return 0;
    }

    let mut files: Vec[ld.SourceFile] = if has_std_under_src(paths) { Vec() } else { load_stage1_std() };
    let deps: Vec[ld.SourceFile] = load_deps_from_manifest();
    let mut di: i32 = 0;
    while di < deps.len() { files.push(deps.get(di)); di = di + 1; }
    let user: Vec[ld.SourceFile] = load_files(paths);
    let mut ui: i32 = 0;
    while ui < user.len() { files.push(user.get(ui)); ui = ui + 1; }

    let r: c.CompileResult = c.compile_files_to_c(files, cg.EmitOptions { emit_driver_main: false, emit_test_main: true, test_funcs: tests });
    if !r.ok {
      panic("compile failed: ".concat(r.err));
      return 1;
    }

    let cpath: String = out.concat(".test.c");
    let bin: String = out.concat(".test");
    fs.write_string(cpath, r.c);
    let cmdline: String = "cc -std=c11 -O0 -g ".concat(cpath).concat(" -o ").concat(bin);
    let code: i32 = proc.exec(cmdline);
    if code != 0 {
      panic("cc failed");
      return 1;
    }

    // Run each test in a separate process, stage0-like.
    let mut passed: i32 = 0;
    let mut failed: i32 = 0;
    let mut ti: i32 = 0;
    while ti < tests.len() {
      let name: String = tests.get(ti);
      let rc: i32 = proc.exec(bin.concat(" ").concat(name));
      if rc != 0 {
        failed = failed + 1;
        print("[FAIL] ".concat(name).concat("\n"));
      } else {
        passed = passed + 1;
        print("[OK] ".concat(name).concat("\n"));
      }
      ti = ti + 1;
    }
    print("[test] ".concat(passed.to_string()).concat(" passed, ").concat(failed.to_string()).concat(" failed\n"));
    if failed != 0 { panic("test failed"); return 1; }
    return 0;
  }

  usage();
  panic("unknown command");
  return 1;
}
