// Stage1 compiler (bootstrap target).
//
// Minimal CLI (v0):
// - emit-c <out.c> <src1.vox> <src2.vox> ...
// - build  <out.bin> <src1.vox> <src2.vox> ...

import "std/process" as proc
import "std/fs" as fs
import "loader" as ld
import "compile" as c
import "manifest" as mf
import "codegen" as cg
import "parse" as p
import "ast" as ast

fn usage() -> () {
  print("vox_stage1 usage:\n");
  print("  vox_stage1 emit-c <out.c> <src...>\n");
  print("  vox_stage1 emit-pkg-c <out.c>   # emit C from ./src\n");
  print("  vox_stage1 build  <out.bin> <src...>\n");
  print("  vox_stage1 build-pkg <out.bin>   # build from ./src\n");
  print("  vox_stage1 test-pkg <out.bin>    # build+run tests from ./src and ./tests\n");
  print("\n");
  print("flags:\n");
  print("  --driver=user|tool  driver main mode for emitted binaries (default: user)\n");
}

fn has_prefix(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

fn host_is_windows() -> bool {
  let exe: String = proc.exe_path();
  if exe.len() < 4 { return false; }
  return exe.slice(exe.len() - 4, exe.len()) == ".exe";
}


fn is_alpha_ascii(ch: i32) -> bool {
  if ch >= 65 && ch <= 90 { return true; }
  if ch >= 97 && ch <= 122 { return true; }
  return false;
}

fn normalize_host_fs_path(p0: String) -> String {
  if !host_is_windows() { return p0; }
  if p0.len() >= 3 && p0.byte_at(0) == 47 && p0.byte_at(2) == 47 && is_alpha_ascii(p0.byte_at(1)) {
    return p0.slice(1, 2).concat(":").concat(p0.slice(2, p0.len()));
  }
  return p0;
}

fn cc_link_flags() -> String {
  if host_is_windows() { return " -lws2_32 -static -Wl,--stack,8388608"; }
  return "";
}

fn cc_cmd() -> String {
  let cc_env: String = proc.getenv("CC");
  if cc_env != "" { return cc_env; }
  if host_is_windows() { return "gcc"; }
  return "cc";
}

fn cc_common_flags() -> String {
  if host_is_windows() { return ""; }
  return " -D_POSIX_C_SOURCE=200809L -D_DEFAULT_SOURCE";
}

fn has_suffix(s: String, suf: String) -> bool {
  if s.len() < suf.len() { return false; }
  return s.slice(s.len() - suf.len(), s.len()) == suf;
}

fn is_test_path(p: String) -> bool {
  if has_prefix(p, "tests/") { return true; }
  if has_suffix(p, "_test.vox") { return true; }
  return false;
}

fn is_test_file_for_discovery(p: String) -> bool {
  if has_prefix(p, "tests/") { return true; }
  if has_prefix(p, "src/") && has_suffix(p, "_test.vox") { return true; }
  return false;
}

fn has_std_under_src(paths: Vec[String]) -> bool {
  let mut i: i32 = 0;
  while i < paths.len() {
    if has_prefix(paths.get(i), "src/std/") { return true; }
    i = i + 1;
  }
  return false;
}

fn filter_pkg_sources(paths: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let p: String = paths.get(i);
    if has_prefix(p, "src/") && !is_test_path(p) {
      out.push(p);
    }
    i = i + 1;
  }
  return out;
}

fn filter_pkg_test_sources(paths: Vec[String]) -> Vec[String] {
  // For tests, include src/** (including _test.vox) and tests/**.
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let p: String = paths.get(i);
    if has_prefix(p, "src/") || has_prefix(p, "tests/") {
      out.push(p);
    }
    i = i + 1;
  }
  return out;
}

fn dir_name(p: String) -> String {
  let n: i32 = p.len();
  let mut i: i32 = n - 1;
  while i >= 0 {
    if p.byte_at(i) == 47 || p.byte_at(i) == 92 { // '/' or '\\'
      if i == 0 { return "/"; }
      return p.slice(0, i);
    }
    i = i - 1;
  }
  return ".";
}

fn path_join(a: String, b: String) -> String {
  if a == "" { return b; }
  if b == "" { return a; }
  if a.byte_at(a.len() - 1) == 47 { return a.concat(b); }
  return a.concat("/").concat(b);
}

fn stage1_root() -> String {
  // stage0 places binaries at: <pkg>/target/debug/<name>
  let exe: String = normalize_host_fs_path(proc.exe_path());
  let d1: String = dir_name(exe);
  let d2: String = dir_name(d1);
  let d3: String = dir_name(d2);
  return d3;
}

fn qname(mod_path: String, name: String) -> String {
  if mod_path == "" || mod_path == "main" { return name; }
  let mut s: String = mod_path;
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 47 { // '/'
      s = s.slice(0, i).concat(".").concat(s.slice(i + 1, s.len()));
    }
    i = i + 1;
  }
  return s.concat("::").concat(name);
}

fn starts_with(s: String, pre: String) -> bool { return has_prefix(s, pre); }

fn discover_tests(paths: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let pth: String = paths.get(i);
    if is_test_file_for_discovery(pth) {
      let txt: String = fs.read_to_string(pth);
      let r: p.ParseResult = p.parse_text_with_path(pth, txt);
      if r.err != p.ParseError.None {
        // Fail fast: discovery should not ignore syntax errors.
        panic(p.parse_error_to_string_with_source(pth, txt, r.err));
      }
      let mp: String = ld.mod_path_from_file_path(pth);
      let mut fi: i32 = 0;
      while fi < r.prog.funcs.len() {
        let fd: ast.FuncDecl = r.prog.funcs.get(fi);
        if starts_with(fd.name, "test_") {
          out.push(qname(mp, fd.name));
        }
        fi = fi + 1;
      }
    }
    i = i + 1;
  }
  return out;
}

fn load_deps_from_manifest() -> DepsResult {
  return load_deps_from_manifest_at(".", Vec(), Vec(), Vec());
}

struct DepsResult { ok: bool, err: String, files: Vec[ld.SourceFile], seen: Vec[String], resolved: Vec[mf.Dependency] }

fn deps_ok(files: Vec[ld.SourceFile], seen: Vec[String], resolved: Vec[mf.Dependency]) -> DepsResult {
  return DepsResult { ok: true, err: "", files: files, seen: seen, resolved: resolved };
}

fn deps_err(msg: String) -> DepsResult {
  return DepsResult { ok: false, err: msg, files: Vec(), seen: Vec(), resolved: Vec() };
}

fn is_abs_path(p: String) -> bool {
  if p.len() == 0 { return false; }
  if p.byte_at(0) == 47 { return true; } // '/'
  // Windows drive prefix: "C:"
  if p.len() >= 2 && p.byte_at(1) == 58 { return true; } // ':'
  return false;
}

fn contains_str(vs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < vs.len() {
    if vs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn resolve_dep_root(base: String, p: String) -> String {
  if is_abs_path(p) { return p; }
  return path_join(base, p);
}

fn is_alnum(ch: i32) -> bool {
  if ch >= 48 && ch <= 57 { return true; } // 0..9
  if ch >= 65 && ch <= 90 { return true; } // A..Z
  if ch >= 97 && ch <= 122 { return true; } // a..z
  return false;
}

fn sanitize_path_part(s: String) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    if is_alnum(ch) || ch == 45 || ch == 95 || ch == 46 { // - _ .
      out = out.concat(s.slice(i, i + 1));
    } else {
      out = out.concat("_");
    }
    i = i + 1;
  }
  if out == "" { return "_"; }
  return out;
}

fn shell_quote(s: String) -> String {
  let mut out: String = "'";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    if ch == 39 { // '\''
      out = out.concat("'\"'\"'");
    } else {
      out = out.concat(s.slice(i, i + 1));
    }
    i = i + 1;
  }
  return out.concat("'");
}

fn is_space_ch(ch: i32) -> bool { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }

fn trim_space_main(s: String) -> String {
  if s.len() == 0 { return ""; }
  let mut i: i32 = 0;
  while i < s.len() && is_space_ch(s.byte_at(i)) { i = i + 1; }
  let mut j: i32 = s.len();
  while j > i && is_space_ch(s.byte_at(j - 1)) { j = j - 1; }
  return s.slice(i, j);
}

fn dep_cache_root(base: String) -> String {
  return path_join(base, ".vox/deps");
}

fn load_dep_sources(dep_name: String, dep_root: String) -> Vec[ld.SourceFile] {
  let rels: Vec[String] = fs.walk_vox_files(dep_root);
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut j: i32 = 0;
  while j < rels.len() {
    let rel: String = rels.get(j);
    // Dependencies: include src/** only, ignore tests/**.
    if has_prefix(rel, "src/") && !is_test_path(rel) {
      let full: String = path_join(dep_root, rel);
      let virt: String = dep_name.concat("/").concat(rel);
      out.push(ld.SourceFile { path: virt, text: fs.read_to_string(full) });
    }
    j = j + 1;
  }
  return out;
}

struct ResolveDepResult { ok: bool, err: String, dep_root: String, dep: mf.Dependency }

fn dep_res_ok(dep_root: String, dep: mf.Dependency) -> ResolveDepResult {
  return ResolveDepResult { ok: true, err: "", dep_root: dep_root, dep: dep };
}

fn dep_res_err(msg: String) -> ResolveDepResult {
  return ResolveDepResult {
    ok: false,
    err: msg,
    dep_root: "",
    dep: mf.Dependency {
      name: "",
      path: "",
      has_path: false,
      git: "",
      has_git: false,
      rev: "",
      has_rev: false,
      registry: "",
      has_registry: false,
      version: "",
      has_version: false,
    },
  };
}

fn resolve_dep_source(base: String, d: mf.Dependency) -> ResolveDepResult {
  if d.has_path {
    let dep_root: String = resolve_dep_root(base, d.path);
    if !fs.exists(path_join(dep_root, "vox.toml")) {
      return dep_res_err("dependency missing vox.toml: ".concat(d.name));
    }
    return dep_res_ok(dep_root, mf.Dependency {
      name: d.name,
      path: dep_root,
      has_path: true,
      git: d.git,
      has_git: d.has_git,
      rev: d.rev,
      has_rev: d.has_rev,
      registry: d.registry,
      has_registry: d.has_registry,
      version: d.version,
      has_version: d.has_version,
    });
  }

  if d.has_git {
    let mut git_src: String = d.git;
    if !is_abs_path(git_src) && !has_prefix(git_src, "http://") && !has_prefix(git_src, "https://") && !has_prefix(git_src, "ssh://") && !has_prefix(git_src, "git@") {
      git_src = resolve_dep_root(base, git_src);
    }
    let cache_base: String = path_join(path_join(dep_cache_root(base), "git"), sanitize_path_part(d.name).concat("-").concat(sanitize_path_part(git_src)));
    fs.mkdir_p(path_join(dep_cache_root(base), "git"));
    if !fs.exists(path_join(cache_base, ".git")) {
      let clone_cmd: String = "git clone ".concat(shell_quote(git_src)).concat(" ").concat(shell_quote(cache_base));
      if proc.exec(clone_cmd) != 0 {
        return dep_res_err("git clone failed: ".concat(d.name));
      }
    } else {
      let fetch_cmd: String = "git -C ".concat(shell_quote(cache_base)).concat(" fetch --all --tags --prune");
      proc.exec(fetch_cmd);
    }
    let mut target: String = "";
    if d.has_rev { target = d.rev; } else if d.has_version { target = d.version; }
    if target != "" {
      let checkout_cmd: String = "git -C ".concat(shell_quote(cache_base)).concat(" checkout ").concat(shell_quote(target));
      if proc.exec(checkout_cmd) != 0 {
        return dep_res_err("git checkout failed: ".concat(d.name));
      }
    }
    let rev_file: String = path_join(cache_base, ".vox_resolved_rev");
    let rev_cmd: String = "git -C ".concat(shell_quote(cache_base)).concat(" rev-parse HEAD > ").concat(shell_quote(rev_file));
    let mut resolved_rev: String = d.rev;
    let mut has_resolved_rev: bool = d.has_rev;
    if proc.exec(rev_cmd) == 0 {
      resolved_rev = trim_space_main(fs.read_to_string(rev_file));
      has_resolved_rev = resolved_rev != "";
    }
    if !fs.exists(path_join(cache_base, "vox.toml")) {
      return dep_res_err("dependency missing vox.toml: ".concat(d.name));
    }
    return dep_res_ok(cache_base, mf.Dependency {
      name: d.name,
      path: cache_base,
      has_path: true,
      git: git_src,
      has_git: true,
      rev: resolved_rev,
      has_rev: has_resolved_rev,
      registry: d.registry,
      has_registry: d.has_registry,
      version: d.version,
      has_version: d.has_version,
    });
  }

  if !d.has_version {
    return dep_res_err("dependency requires path/git/version: ".concat(d.name));
  }
  let registry_root: String = if d.has_registry { resolve_dep_root(base, d.registry) } else { path_join(dep_cache_root(base), "registry") };
  let dep_root: String = path_join(path_join(registry_root, d.name), d.version);
  if !fs.exists(path_join(dep_root, "vox.toml")) {
    return dep_res_err("registry dependency not found: ".concat(d.name).concat("@").concat(d.version));
  }
  return dep_res_ok(dep_root, mf.Dependency {
    name: d.name,
    path: dep_root,
    has_path: true,
    git: d.git,
    has_git: d.has_git,
    rev: d.rev,
    has_rev: d.has_rev,
    registry: d.registry,
    has_registry: d.has_registry,
    version: d.version,
    has_version: d.has_version,
  });
}

fn load_deps_from_manifest_at(base: String, files0: Vec[ld.SourceFile], seen0: Vec[String], resolved0: Vec[mf.Dependency]) -> DepsResult {
  let mani_path: String = path_join(base, "vox.toml");
  let mt: String = fs.read_to_string(mani_path);
  let mr: mf.ParseResult = mf.parse(mt);
  if !mr.ok { return deps_err(mr.err); }

  let mut files: Vec[ld.SourceFile] = files0;
  let mut seen: Vec[String] = seen0;
  let mut resolved: Vec[mf.Dependency] = resolved0;
  let mut local_seen: Vec[String] = Vec();

  let mut i: i32 = 0;
  while i < mr.m.deps.len() {
    let d: mf.Dependency = mr.m.deps.get(i);
    if contains_str(local_seen, d.name) {
      return deps_err("duplicate dependency: ".concat(d.name));
    }
    local_seen.push(d.name);
    if contains_str(seen, d.name) { i = i + 1; continue; }
    seen.push(d.name);

    let rr0: ResolveDepResult = resolve_dep_source(base, d);
    if !rr0.ok { return deps_err(rr0.err); }
    resolved.push(rr0.dep);
    let dep_files: Vec[ld.SourceFile] = load_dep_sources(d.name, rr0.dep_root);
    let mut di: i32 = 0;
    while di < dep_files.len() { files.push(dep_files.get(di)); di = di + 1; }

    let rr: DepsResult = load_deps_from_manifest_at(rr0.dep_root, files, seen, resolved);
    if !rr.ok { return rr; }
    files = rr.files;
    seen = rr.seen;
    resolved = rr.resolved;

    i = i + 1;
  }

  return deps_ok(files, seen, resolved);
}

fn toml_quote(s: String) -> String {
  return "\"".concat(s.escape_c()).concat("\"");
}

fn dep_source_kind(d: mf.Dependency) -> String {
  if d.has_git { return "git"; }
  if d.has_registry { return "registry"; }
  if d.has_path && !d.has_version { return "path"; }
  if d.has_path && d.has_version && !d.has_git { return "path"; }
  if d.has_version { return "registry"; }
  return "path";
}

fn write_lockfile(deps: Vec[mf.Dependency]) -> () {
  let mut out: String = "# generated by vox stage1\nversion = 1\n";
  let mut i: i32 = 0;
  while i < deps.len() {
    let d: mf.Dependency = deps.get(i);
    let digest: String = lock_dep_digest(d.path);
    out = out.concat("\n[[dependency]]\n");
    out = out.concat("name = ").concat(toml_quote(d.name)).concat("\n");
    out = out.concat("source = ").concat(toml_quote(dep_source_kind(d))).concat("\n");
    if d.has_path {
      out = out.concat("path = ").concat(toml_quote(d.path)).concat("\n");
    }
    if d.path != "" {
      out = out.concat("resolved_path = ").concat(toml_quote(d.path)).concat("\n");
    }
    if d.has_git {
      out = out.concat("git = ").concat(toml_quote(d.git)).concat("\n");
    }
    if d.has_rev {
      out = out.concat("rev = ").concat(toml_quote(d.rev)).concat("\n");
    }
    if d.has_registry {
      out = out.concat("registry = ").concat(toml_quote(d.registry)).concat("\n");
    }
    if d.has_version {
      out = out.concat("version = ").concat(toml_quote(d.version)).concat("\n");
    }
    out = out.concat("digest = ").concat(toml_quote(digest)).concat("\n");
    i = i + 1;
  }
  fs.write_string("vox.lock", out);
}

fn load_files(paths: Vec[String]) -> Vec[ld.SourceFile] {
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let p: String = paths.get(i);
    out.push(ld.SourceFile { path: p, text: fs.read_to_string(p) });
    i = i + 1;
  }
  return out;
}

fn load_stage1_std() -> Vec[ld.SourceFile] {
  let root: String = stage1_root();
  let rels: Vec[String] = fs.walk_vox_files(root);
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut i: i32 = 0;
  while i < rels.len() {
    let rel: String = rels.get(i);
    if has_prefix(rel, "src/std/") {
      let full: String = path_join(root, rel);
      out.push(ld.SourceFile { path: rel, text: fs.read_to_string(full) });
    }
    i = i + 1;
  }
  return out;
}

fn slice_vec(xs: Vec[String], start: i32) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = start;
  while i < xs.len() { out.push(xs.get(i)); i = i + 1; }
  return out;
}

fn main() -> i32 {
  let args: Vec[String] = proc.args();
  if args.len() < 2 {
    usage();
    print("invalid args\n");
    return 1;
  }
  let cmd: String = args.get(0);
  let mut driver: cg.DriverMainKind = cg.DriverMainKind.User;
  let mut i: i32 = 1;
  while i < args.len() {
    let a: String = args.get(i);
    if has_prefix(a, "--driver=") {
      let v: String = a.slice(9, a.len());
      if v == "user" { driver = cg.DriverMainKind.User; i = i + 1; continue; }
      if v == "tool" { driver = cg.DriverMainKind.Tool; i = i + 1; continue; }
      usage();
      print("unknown driver: ".concat(v).concat("\n"));
      return 1;
    }
    if has_prefix(a, "-") {
      usage();
      print("unknown flag: ".concat(a).concat("\n"));
      return 1;
    }
    break;
  }
  if i >= args.len() {
    usage();
    print("missing out path\n");
    return 1;
  }
  let out: String = args.get(i);
  let srcs: Vec[String] = slice_vec(args, i + 1);

  if cmd == "emit-c" {
    if srcs.len() == 0 { usage(); print("missing sources\n"); return 1; }
    let mut files: Vec[ld.SourceFile] = load_stage1_std();
    let user: Vec[ld.SourceFile] = load_files(srcs);
    let mut ui: i32 = 0;
    while ui < user.len() { files.push(user.get(ui)); ui = ui + 1; }
    let r: c.CompileResult = c.compile_files_to_c(files, cg.EmitOptions { emit_driver_main: true, driver_main_kind: driver, emit_test_main: false, test_funcs: Vec() });
    if !r.ok {
      print("compile failed: ".concat(r.err).concat("\n"));
      return 1;
    }
    fs.write_string(out, r.c);
    return 0;
  }
  if cmd == "build" {
    if srcs.len() == 0 { usage(); print("missing sources\n"); return 1; }
    let mut files: Vec[ld.SourceFile] = load_stage1_std();
    let user: Vec[ld.SourceFile] = load_files(srcs);
    let mut ui: i32 = 0;
    while ui < user.len() { files.push(user.get(ui)); ui = ui + 1; }
    let r: c.CompileResult = c.compile_files_to_c(files, cg.EmitOptions { emit_driver_main: true, driver_main_kind: driver, emit_test_main: false, test_funcs: Vec() });
    if !r.ok {
      print("compile failed: ".concat(r.err).concat("\n"));
      return 1;
    }
    let cpath: String = out.concat(".c");
    fs.write_string(cpath, r.c);
    let cmdline: String = cc_cmd().concat(" -std=c11 -O0 -g").concat(cc_common_flags()).concat(" ").concat(cpath).concat(" -o ").concat(out).concat(cc_link_flags());
    let code: i32 = proc.exec(cmdline);
    if code != 0 {
      print("cc failed: ".concat(cmdline).concat("\n"));
      print("cc exit: ".concat(code.to_string()).concat("\n"));
      return 1;
    }
    return 0;
  }
  if cmd == "emit-pkg-c" {
    let all: Vec[String] = fs.walk_vox_files(".");
    let paths: Vec[String] = filter_pkg_sources(all);
    let mut files: Vec[ld.SourceFile] = if has_std_under_src(paths) { Vec() } else { load_stage1_std() };
    let dr: DepsResult = load_deps_from_manifest();
    if !dr.ok {
      print("invalid vox.toml: ".concat(dr.err).concat("\n"));
      return 1;
    }
    let vr: LockVerifyResult = verify_lockfile_or_ok(dr.resolved);
    if !vr.ok {
      print("invalid vox.lock: ".concat(vr.err).concat("\n"));
      return 1;
    }
    write_lockfile(dr.resolved);
    let mut di: i32 = 0;
    while di < dr.files.len() { files.push(dr.files.get(di)); di = di + 1; }
    let user: Vec[ld.SourceFile] = load_files(paths);
    let mut ui: i32 = 0;
    while ui < user.len() { files.push(user.get(ui)); ui = ui + 1; }
    let r: c.CompileResult = c.compile_files_to_c(files, cg.EmitOptions { emit_driver_main: true, driver_main_kind: driver, emit_test_main: false, test_funcs: Vec() });
    if !r.ok {
      print("compile failed: ".concat(r.err).concat("\n"));
      return 1;
    }
    fs.write_string(out, r.c);
    return 0;
  }
  if cmd == "build-pkg" {
    let all: Vec[String] = fs.walk_vox_files(".");
    let paths: Vec[String] = filter_pkg_sources(all);
    let mut files: Vec[ld.SourceFile] = if has_std_under_src(paths) { Vec() } else { load_stage1_std() };
    let dr: DepsResult = load_deps_from_manifest();
    if !dr.ok {
      print("invalid vox.toml: ".concat(dr.err).concat("\n"));
      return 1;
    }
    let vr: LockVerifyResult = verify_lockfile_or_ok(dr.resolved);
    if !vr.ok {
      print("invalid vox.lock: ".concat(vr.err).concat("\n"));
      return 1;
    }
    write_lockfile(dr.resolved);
    let mut di: i32 = 0;
    while di < dr.files.len() { files.push(dr.files.get(di)); di = di + 1; }
    let user: Vec[ld.SourceFile] = load_files(paths);
    let mut ui: i32 = 0;
    while ui < user.len() { files.push(user.get(ui)); ui = ui + 1; }
    let r: c.CompileResult = c.compile_files_to_c(files, cg.EmitOptions { emit_driver_main: true, driver_main_kind: driver, emit_test_main: false, test_funcs: Vec() });
    if !r.ok {
      print("compile failed: ".concat(r.err).concat("\n"));
      return 1;
    }
    let cpath: String = out.concat(".c");
    fs.write_string(cpath, r.c);
    let cmdline: String = cc_cmd().concat(" -std=c11 -O0 -g").concat(cc_common_flags()).concat(" ").concat(cpath).concat(" -o ").concat(out).concat(cc_link_flags());
    let code: i32 = proc.exec(cmdline);
    if code != 0 {
      print("cc failed: ".concat(cmdline).concat("\n"));
      print("cc exit: ".concat(code.to_string()).concat("\n"));
      return 1;
    }
    return 0;
  }
  if cmd == "test-pkg" {
    let all: Vec[String] = fs.walk_vox_files(".");
    let paths: Vec[String] = filter_pkg_test_sources(all);

    let tests: Vec[String] = discover_tests(paths);
    if tests.len() == 0 {
      print("[test] no tests found\n");
      return 0;
    }

    let mut files: Vec[ld.SourceFile] = if has_std_under_src(paths) { Vec() } else { load_stage1_std() };
    let dr: DepsResult = load_deps_from_manifest();
    if !dr.ok {
      print("invalid vox.toml: ".concat(dr.err).concat("\n"));
      return 1;
    }
    let vr: LockVerifyResult = verify_lockfile_or_ok(dr.resolved);
    if !vr.ok {
      print("invalid vox.lock: ".concat(vr.err).concat("\n"));
      return 1;
    }
    write_lockfile(dr.resolved);
    let mut di: i32 = 0;
    while di < dr.files.len() { files.push(dr.files.get(di)); di = di + 1; }
    let user: Vec[ld.SourceFile] = load_files(paths);
    let mut ui: i32 = 0;
    while ui < user.len() { files.push(user.get(ui)); ui = ui + 1; }

    let r: c.CompileResult = c.compile_files_to_c(files, cg.EmitOptions { emit_driver_main: false, driver_main_kind: cg.DriverMainKind.User, emit_test_main: true, test_funcs: tests });
    if !r.ok {
      print("compile failed: ".concat(r.err).concat("\n"));
      return 1;
    }

    let cpath: String = out.concat(".test.c");
    let bin: String = out.concat(".test");
    fs.write_string(cpath, r.c);
    let cmdline: String = cc_cmd().concat(" -std=c11 -O0 -g").concat(cc_common_flags()).concat(" ").concat(cpath).concat(" -o ").concat(bin).concat(cc_link_flags());
    let code: i32 = proc.exec(cmdline);
    if code != 0 {
      print("cc failed: ".concat(cmdline).concat("\n"));
      print("cc exit: ".concat(code.to_string()).concat("\n"));
      return 1;
    }

    // Run each test in a separate process, stage0-like.
    let mut passed: i32 = 0;
    let mut failed: i32 = 0;
    let mut ti: i32 = 0;
    while ti < tests.len() {
      let name: String = tests.get(ti);
      let rc: i32 = proc.exec(bin.concat(" ").concat(name));
      if rc != 0 {
        failed = failed + 1;
        print("[FAIL] ".concat(name).concat("\n"));
      } else {
        passed = passed + 1;
        print("[OK] ".concat(name).concat("\n"));
      }
      ti = ti + 1;
    }
    print("[test] ".concat(passed.to_string()).concat(" passed, ").concat(failed.to_string()).concat(" failed\n"));
    if failed != 0 { return 1; }
    return 0;
  }

  usage();
  print("unknown command\n");
  return 1;
}
