import "ast" as ast
import "ir" as ir
import "typecheck" as tc

struct GenExprResult { ok: bool, err: String, g: Gen, val: ir.Value, ty: i32 }

fn gen_expr(g0: Gen, id: i32, expected: i32) -> GenExprResult {
  let tr: tc.ExprTyResult = tc.tc_expr(g0.ctx, g0.w, g0.mod_path, g0.imps, g0.exprs, g0.locals, id, expected);
  if !tr.ok {
    return GenExprResult { ok: false, err: tc.tc_error_to_string(tr.err), g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
  }

  let n: ast.ExprNode = ast.expr_pool_get(g0.exprs, id);
  return match n {
    ast.ExprNode.Int(v) => gen_expr_int(g0, v, tr.ty, expected),
    ast.ExprNode.Bool(b) => gen_expr_bool(g0, b, tr.ty),
    ast.ExprNode.Str(s) => gen_expr_str(g0, s, tr.ty),
    ast.ExprNode.Ident(name) => gen_expr_ident(g0, name, tr.ty),
    ast.ExprNode.DotIdent(name) => gen_expr_dot_ident(g0, name, tr.ty),
    ast.ExprNode.Block(b) => gen_expr_block(g0, b, tr.ty),
    ast.ExprNode.Unary(op, a) => gen_expr_unary(g0, op, a, tr.ty),
    ast.ExprNode.As(a, tn) => gen_expr_as(g0, a, tn, tr.ty),
    ast.ExprNode.Binary(op, l, r) => gen_expr_binary(g0, op, l, r, tr.ty),
    ast.ExprNode.If(c, t, e) => gen_expr_if(g0, c, t, e, tr.ty),
    ast.ExprNode.Member(recv, name) => gen_expr_member(g0, recv, name, tr.ty),
    ast.ExprNode.Call(callee, type_args, args) => gen_expr_call(g0, callee, type_args, args, tr.ty, expected),
    ast.ExprNode.StructLit(ty_expr, fields) => gen_expr_struct_lit(g0, ty_expr, fields, tr.ty),
    ast.ExprNode.Match(scrut, arms) => gen_expr_match(g0, scrut, arms, tr.ty),
  };
}

fn gen_expr_as(g0: Gen, a: i32, _tn: ast.TypeName, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let ar: GenExprResult = gen_expr(g, a, -1);
  if !ar.ok { return ar; }
  g = ar.g;

  let from_base: i32 = tc.strip_range(g.ctx, ar.ty);
  let to_base: i32 = tc.strip_range(g.ctx, out_ty);

  // 1) Base cast (i32<->i64). Range types are represented as their base in IR.
  let mut v: ir.Value = ar.val;
  if from_base != to_base {
    let rt: GenNewIdResult = gen_new_temp(g);
    g = rt.g;
    let tid: i32 = rt.id;

    if from_base == g.ctx.ty_i32 && to_base == g.ctx.ty_i64 {
      g = gen_emit(g, ir.Instr.IntCast(tid, to_base, from_base, ar.val));
      v = ir.v_temp(tid);
    } else if from_base == g.ctx.ty_i64 && to_base == g.ctx.ty_i32 {
      g = gen_emit(g, ir.Instr.IntCastChecked(tid, to_base, from_base, ar.val));
      v = ir.v_temp(tid);
    } else {
      return GenExprResult { ok: false, err: "unsupported cast in irgen", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
  }

  // 2) Refined cast: add a runtime range check for `@range(..)` targets.
  if tc.is_range_ty(g.ctx, out_ty) {
    let rt2: ir.Ty = ir.ty_pool_get(g.ctx.pool, out_ty);
    g = gen_emit(g, ir.Instr.RangeCheck(to_base, v, rt2.lo, rt2.hi));
  }

  return GenExprResult { ok: true, err: "", g: g, val: v, ty: out_ty };
}

fn gen_expr_block(g0: Gen, b: ast.ExprBlock, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  g.slots = slots_enter(g.slots);
  g.locals = tc.locals_enter(g.locals);

  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let r: GenStmtResult = gen_stmt(g, b.stmts.get(i));
    if !r.ok { return GenExprResult { ok: false, err: r.err, g: r.g, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    g = r.g;
    let blk: ir.Block = g.blocks.get(g.cur);
    if blk.has_term {
      return GenExprResult { ok: false, err: "terminator not allowed in expr block", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    i = i + 1;
  }

  let mut val: ir.Value = ir.v_int(0);
  if b.has_tail {
    let er: GenExprResult = gen_expr(g, b.tail, out_ty);
    if !er.ok { return er; }
    g = er.g;
    val = er.val;
  }

  g.locals = tc.locals_exit(g.locals);
  g.slots = slots_exit(g.slots);
  return GenExprResult { ok: true, err: "", g: g, val: val, ty: out_ty };
}

fn gen_expr_int(g0: Gen, text: String, ty: i32, expected: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let rt: GenNewIdResult = gen_new_temp(g);
  g = rt.g;
  let tid: i32 = rt.id;
  let use_ty: i32 = if expected != -1 { expected } else { ty };
  // Avoid `if` expression blocks containing `return` (stage1 v0 forbids terminators in expr blocks).
  let mut vv: ir.Value = ir.v_int(0);
  if use_ty == g.ctx.ty_i64 {
    let pr: tc.ParseI64DecResult = tc.parse_i64_dec(text);
    if !pr.ok { return GenExprResult { ok: false, err: "i64 literal out of range", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    vv = ir.v_i64(pr.val);
  } else {
    let pr2: tc.ParseI32DecResult = tc.parse_i32_dec(text);
    if !pr2.ok { return GenExprResult { ok: false, err: "i32 literal out of range", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    vv = ir.v_int(pr2.val);
  }
  g = gen_emit(g, ir.Instr.Const(tid, use_ty, vv));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: use_ty };
}

fn gen_expr_bool(g0: Gen, b: bool, ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let rt: GenNewIdResult = gen_new_temp(g);
  g = rt.g;
  let tid: i32 = rt.id;
  g = gen_emit(g, ir.Instr.Const(tid, ty, ir.v_bool(b)));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: ty };
}

fn gen_expr_str(g0: Gen, s: String, ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let rt: GenNewIdResult = gen_new_temp(g);
  g = rt.g;
  let tid: i32 = rt.id;
  g = gen_emit(g, ir.Instr.Const(tid, ty, ir.v_str(s)));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: ty };
}

fn gen_expr_ident(g0: Gen, name: String, ty: i32) -> GenExprResult {
  let sr: LookupSlotResult = slots_lookup(g0.slots, name);
  if !sr.found {
    // Const reference (inlined; no globals in v0).
    let ni: tc.NamedConstImport = tc.find_named_const(g0.imps.named_consts, name);
    let want_mod: String = if ni.local != "" { ni.mod_path } else { g0.mod_path };
    let want_name: String = if ni.local != "" { ni.name } else { name };
    let cs: tc.ConstSig = tc.find_const(g0.ctx, want_mod, want_name);
    if cs.name == "" { return GenExprResult { ok: false, err: "unknown var/const", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

    let mut g: Gen = g0;
    let rt: GenNewIdResult = gen_new_temp(g);
    g = rt.g;
	    let tid: i32 = rt.id;
	    let v: ir.Value =
	      if cs.kind == tc.const_kind_int() {
	      // Parentheses force this to parse as an expression in stage0:
	      // block-expr treats a leading `if` as a statement form otherwise.
	      (if cs.ty == g.ctx.ty_i64 { ir.v_i64(cs.iv_i64) } else { ir.v_int(cs.iv_i32) })
	    } else {
	      (if cs.kind == tc.const_kind_bool() { ir.v_bool(cs.bv) } else { ir.v_str(cs.sv) })
	    };
	    g = gen_emit(g, ir.Instr.Const(tid, cs.ty, v));
	    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: cs.ty };
	  }
  let mut g: Gen = g0;
  let rt: GenNewIdResult = gen_new_temp(g);
  g = rt.g;
  let tid: i32 = rt.id;
  g = gen_emit(g, ir.Instr.Load(tid, ty, sr.slot));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: ty };
}

fn gen_expr_unary(g0: Gen, op: ast.UnaryOp, a: i32, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let ar: GenExprResult = gen_expr(g, a, -1);
  if !ar.ok { return ar; }
  g = ar.g;
  let is_not: bool = match op { ast.UnaryOp.Not => true, _ => false };
  if is_not {
    let rt: GenNewIdResult = gen_new_temp(g);
    g = rt.g;
    let tid: i32 = rt.id;
    g = gen_emit(g, ir.Instr.Not(tid, ar.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  // Neg: 0 - x
  let zt: GenNewIdResult = gen_new_temp(g);
  g = zt.g;
  let z: i32 = zt.id;
  let z0: ir.Value = if out_ty == g.ctx.ty_i64 { ir.v_i64(0) } else { ir.v_int(0) };
  g = gen_emit(g, ir.Instr.Const(z, out_ty, z0));
  let rt2: GenNewIdResult = gen_new_temp(g);
  g = rt2.g;
  let tid2: i32 = rt2.id;
  g = gen_emit(g, ir.Instr.BinOp(tid2, ir.BinOpKind.Sub, out_ty, ir.v_temp(z), ar.val));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid2), ty: out_ty };
}

fn gen_expr_binary(g0: Gen, op: ast.BinaryOp, l: i32, r: i32, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let lr: GenExprResult = gen_expr(g, l, -1);
  if !lr.ok { return lr; }
  g = lr.g;

  // Short-circuit logical ops: do not evaluate RHS eagerly.
  let is_logic: bool = match op { ast.BinaryOp.AndAnd => true, ast.BinaryOp.OrOr => true, _ => false };
  if is_logic {
    return gen_expr_short_circuit_logic(g, op, lr.val, r, out_ty);
  }

  let rr: GenExprResult = gen_expr(g, r, lr.ty);
  if !rr.ok { return rr; }
  g = rr.g;

  // Special-case: enum equality against unit variants lowers to tag comparison.
  let is_eqop: bool = match op { ast.BinaryOp.Eq => true, ast.BinaryOp.Ne => true, _ => false };
  if is_eqop && tc.is_enum_ty(g.ctx, lr.ty) {
    let lt: i32 = enum_unit_tag(g, l, lr.ty);
    let rt: i32 = enum_unit_tag(g, r, lr.ty);
    if lt != -1 || rt != -1 {
      let unit_tag: i32 = if lt != -1 { lt } else { rt };
      let other: ir.Value = if lt != -1 { rr.val } else { lr.val };

      let nt: GenNewIdResult = gen_new_temp(g);
      g = nt.g;
      let tag_id: i32 = nt.id;
      g = gen_emit(g, ir.Instr.EnumTag(tag_id, other));

      let cmp: GenNewIdResult = gen_new_temp(g);
      g = cmp.g;
      let cmp_id: i32 = cmp.id;
      let ck: ir.CmpKind = if match op { ast.BinaryOp.Eq => true, _ => false } { ir.CmpKind.Eq } else { ir.CmpKind.Ne };
      g = gen_emit(g, ir.Instr.Cmp(cmp_id, ck, g.ctx.ty_i32, ir.v_temp(tag_id), ir.v_int(unit_tag)));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(cmp_id), ty: out_ty };
    }
  }

  let is_cmp: bool = match op { ast.BinaryOp.Lt => true, ast.BinaryOp.Le => true, ast.BinaryOp.Gt => true, ast.BinaryOp.Ge => true, ast.BinaryOp.Eq => true, ast.BinaryOp.Ne => true, _ => false };
  if is_cmp {
    let rt: GenNewIdResult = gen_new_temp(g);
    g = rt.g;
    let tid: i32 = rt.id;
    let ck: ir.CmpKind = match op {
      ast.BinaryOp.Lt => ir.CmpKind.Lt,
      ast.BinaryOp.Le => ir.CmpKind.Le,
      ast.BinaryOp.Gt => ir.CmpKind.Gt,
      ast.BinaryOp.Ge => ir.CmpKind.Ge,
      ast.BinaryOp.Eq => ir.CmpKind.Eq,
      _ => ir.CmpKind.Ne,
    };
    g = gen_emit(g, ir.Instr.Cmp(tid, ck, lr.ty, lr.val, rr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }

  let rt2: GenNewIdResult = gen_new_temp(g);
  g = rt2.g;
  let tid2: i32 = rt2.id;
  let bk: ir.BinOpKind = match op {
    ast.BinaryOp.Add => ir.BinOpKind.Add,
    ast.BinaryOp.Sub => ir.BinOpKind.Sub,
    ast.BinaryOp.Mul => ir.BinOpKind.Mul,
    ast.BinaryOp.Div => ir.BinOpKind.Div,
    _ => ir.BinOpKind.Mod,
  };
  g = gen_emit(g, ir.Instr.BinOp(tid2, bk, out_ty, lr.val, rr.val));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid2), ty: out_ty };
}

fn gen_expr_short_circuit_logic(g0: Gen, op: ast.BinaryOp, lhs: ir.Value, rhs_id: i32, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  if out_ty != g.ctx.ty_bool { return GenExprResult { ok: false, err: "logical op must be bool", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

  // Use a slot for the result (matches if-expr lowering pattern).
  let rs: GenNewIdResult = gen_new_slot(g);
  g = rs.g;
  let res_slot: i32 = rs.id;
  g = gen_emit(g, ir.Instr.SlotDecl(res_slot, out_ty));
  g = gen_emit(g, ir.Instr.Store(res_slot, ir.v_bool(false)));

  let base: i32 = g.blocks.len();
  let r_rhs: GenNewIdResult = gen_new_block(g, "logic_rhs_".concat(base.to_string()));
  g = r_rhs.g;
  let rhs_idx: i32 = r_rhs.id;
  let r_sc: GenNewIdResult = gen_new_block(g, "logic_sc_".concat(base.to_string()));
  g = r_sc.g;
  let sc_idx: i32 = r_sc.id;
  let r_end: GenNewIdResult = gen_new_block(g, "logic_end_".concat(base.to_string()));
  g = r_end.g;
  let end_idx: i32 = r_end.id;

  let is_and: bool = match op { ast.BinaryOp.AndAnd => true, _ => false };
  if is_and {
    g = gen_term(g, ir.Term.CondBr(lhs, g.blocks.get(rhs_idx).name, g.blocks.get(sc_idx).name));
  } else {
    g = gen_term(g, ir.Term.CondBr(lhs, g.blocks.get(sc_idx).name, g.blocks.get(rhs_idx).name));
  }

  // Short-circuit block.
  g = gen_set_block(g, sc_idx);
  if is_and {
    g = gen_emit(g, ir.Instr.Store(res_slot, ir.v_bool(false)));
  } else {
    g = gen_emit(g, ir.Instr.Store(res_slot, ir.v_bool(true)));
  }
  g = gen_term(g, ir.Term.Br(g.blocks.get(end_idx).name));

  // RHS block.
  g = gen_set_block(g, rhs_idx);
  let rr: GenExprResult = gen_expr(g, rhs_id, g.ctx.ty_bool);
  if !rr.ok { return rr; }
  g = rr.g;
  g = gen_emit(g, ir.Instr.Store(res_slot, rr.val));
  if !g.blocks.get(g.cur).has_term {
    g = gen_term(g, ir.Term.Br(g.blocks.get(end_idx).name));
  }

  // End block.
  g = gen_set_block(g, end_idx);
  let rt: GenNewIdResult = gen_new_temp(g);
  g = rt.g;
  let tid: i32 = rt.id;
  g = gen_emit(g, ir.Instr.Load(tid, out_ty, res_slot));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
}

fn enum_unit_tag(g0: Gen, id: i32, enum_ty: i32) -> i32 {
  if !tc.is_enum_ty(g0.ctx, enum_ty) { return -1; }
  let n: ast.ExprNode = ast.expr_pool_get(g0.exprs, id);

  if match n { ast.ExprNode.Call(_c, _ta, _args) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(c, _ta, _args) => c, _ => -1 };
    let targs: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_c, ta, _args) => ta, _ => Vec() };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _ta, a) => a, _ => Vec() };
    if targs.len() == 0 && args.len() == 0 { return enum_unit_tag(g0, callee, enum_ty); }
    return -1;
  }

  let var_name: String = match n {
    ast.ExprNode.DotIdent(s) => s,
    ast.ExprNode.Member(_recv, s) => s,
    _ => "",
  };
  if var_name == "" { return -1; }

  let et: ir.Ty = ir.ty_pool_get(g0.ctx.pool, enum_ty);
  if et.kind != ir.TyKind.Enum { return -1; }
  let fe: tc.FindEnumResult = tc.find_enum(g0.ctx, tc.ty_mod(et), tc.ty_name(et));
  if !fe.found { return -1; }
  let es: tc.EnumSig = fe.sig;
  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: tc.EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != 0 { return -1; }
      return vi;
    }
    vi = vi + 1;
  }
  return -1;
}

// Implementations live in gen_cf.vox / gen_member_struct.vox / gen_call_match.vox.
