import "ast" as ast
import "ir" as ir
import "typecheck" as tc

struct VecRecvSlotResult { ok: bool, err: String, g: Gen, slot: i32 }
struct MatchArmInfo {
  blk: i32,
  has_tag: bool,
  tag: i32,
  variant: String,
  bind_scrut: String,
  bind_scrut_ty: i32,
  lit_kind: i32, // 0 none, 1 int, 2 str
  lit_i32: i32,
  lit_str: String,
  binds: Vec[String],
  bind_tys: Vec[i32],
  is_wild: bool,
  expr: i32,
}

fn match_arm_info_wild(blk: i32, expr: i32) -> MatchArmInfo {
  return MatchArmInfo { blk: blk, has_tag: false, tag: 0, variant: "", bind_scrut: "", bind_scrut_ty: 0, lit_kind: 0, lit_i32: 0, lit_str: "", binds: Vec(), bind_tys: Vec(), is_wild: true, expr: expr };
}

fn match_arm_info_other(blk: i32, expr: i32) -> MatchArmInfo {
  return MatchArmInfo { blk: blk, has_tag: false, tag: 0, variant: "", bind_scrut: "", bind_scrut_ty: 0, lit_kind: 0, lit_i32: 0, lit_str: "", binds: Vec(), bind_tys: Vec(), is_wild: false, expr: expr };
}

fn match_arm_info_bind(blk: i32, expr: i32, name: String, scrut_ty: i32) -> MatchArmInfo {
  // Bind pattern: `name => ...` always matches and binds the scrutinee.
  return MatchArmInfo { blk: blk, has_tag: false, tag: 0, variant: "", bind_scrut: name, bind_scrut_ty: scrut_ty, lit_kind: 0, lit_i32: 0, lit_str: "", binds: Vec(), bind_tys: Vec(), is_wild: true, expr: expr };
}

fn match_arm_info_enum(blk: i32, expr: i32, es: tc.EnumSig, vname: String, binders: Vec[String]) -> MatchArmInfo {
  let mut tag: i32 = -1;
  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    if es.vars.get(vi).name == vname { tag = vi; }
    vi = vi + 1;
  }
  let mut tys: Vec[i32] = Vec();
  if tag != -1 {
    let vsig: tc.EnumVariantSig = es.vars.get(tag);
    let mut bi: i32 = 0;
    while bi < binders.len() && bi < vsig.fields.len() { tys.push(vsig.fields.get(bi)); bi = bi + 1; }
  }
  return MatchArmInfo { blk: blk, has_tag: true, tag: tag, variant: vname, bind_scrut: "", bind_scrut_ty: 0, lit_kind: 0, lit_i32: 0, lit_str: "", binds: binders, bind_tys: tys, is_wild: false, expr: expr };
}

fn match_arm_info_int(blk: i32, expr: i32, v: i32) -> MatchArmInfo {
  return MatchArmInfo { blk: blk, has_tag: false, tag: 0, variant: "", bind_scrut: "", bind_scrut_ty: 0, lit_kind: 1, lit_i32: v, lit_str: "", binds: Vec(), bind_tys: Vec(), is_wild: false, expr: expr };
}

fn match_arm_info_str(blk: i32, expr: i32, s: String) -> MatchArmInfo {
  return MatchArmInfo { blk: blk, has_tag: false, tag: 0, variant: "", bind_scrut: "", bind_scrut_ty: 0, lit_kind: 2, lit_i32: 0, lit_str: s, binds: Vec(), bind_tys: Vec(), is_wild: false, expr: expr };
}

fn find_named_func_import(named: Vec[tc.NamedFuncImport], local: String) -> tc.NamedFuncImport {
  let mut i: i32 = 0;
  while i < named.len() {
    let it: tc.NamedFuncImport = named.get(i);
    if it.local == local { return it; }
    i = i + 1;
  }
  return tc.NamedFuncImport { local: "", mod_path: "", name: "" };
}

fn find_named_type_import(named: Vec[tc.NamedTypeImport], local: String) -> tc.NamedTypeImport {
  let mut i: i32 = 0;
  while i < named.len() {
    let it: tc.NamedTypeImport = named.get(i);
    if it.local == local { return it; }
    i = i + 1;
  }
  return tc.NamedTypeImport { local: "", mod_path: "", name: "", kind: 0 };
}

fn vec_recv_slot(g0: Gen, recv_id: i32, recv_ty: i32) -> VecRecvSlotResult {
  let n: ast.ExprNode = ast.expr_pool_get(g0.exprs, recv_id);
  if match n { ast.ExprNode.Ident(_x) => true, _ => false } {
    let name: String = match n { ast.ExprNode.Ident(s) => s, _ => "" };
    let sr: LookupSlotResult = slots_lookup(g0.slots, name);
    if sr.found { return VecRecvSlotResult { ok: true, err: "", g: g0, slot: sr.slot }; }
  }

  // materialize: eval receiver and store to temp slot
  let er: GenExprResult = gen_expr(g0, recv_id, recv_ty);
  if !er.ok { return VecRecvSlotResult { ok: false, err: er.err, g: er.g, slot: -1 }; }
  let mut g: Gen = er.g;
  let ns: GenNewIdResult = gen_new_slot(g);
  g = ns.g;
  let sid: i32 = ns.id;
  g = gen_emit(g, ir.Instr.SlotDecl(sid, recv_ty));
  g = gen_emit(g, ir.Instr.Store(sid, er.val));
  return VecRecvSlotResult { ok: true, err: "", g: g, slot: sid };
}

fn gen_expr_call(g0: Gen, callee: i32, type_args: Vec[ast.TypeName], args: Vec[i32], out_ty: i32, expected: i32) -> GenExprResult {
  let cn: ast.ExprNode = ast.expr_pool_get(g0.exprs, callee);
  let is_member: bool = match cn { ast.ExprNode.Member(_r, _n) => true, _ => false };
  let ta: Vec[ast.TypeName] = type_args;

  if is_member {
    let recv_id: i32 = match cn { ast.ExprNode.Member(r, _n) => r, _ => -1 };
    let mname: String = match cn { ast.ExprNode.Member(_r, n) => n, _ => "" };
    let rr: tc.ExprTyResult = tc.tc_expr(g0.ctx, g0.w, g0.mod_path, g0.imps, g0.exprs, g0.locals, recv_id, -1);
    if rr.ok && tc.is_vec_ty(g0.ctx, rr.ty) {
      return gen_call_vec_method(g0, recv_id, rr.ty, mname, args, out_ty);
    }
    if rr.ok && rr.ty == g0.ctx.ty_string {
      return gen_call_string_method(g0, recv_id, mname, args, out_ty);
    }
    if rr.ok && (rr.ty == g0.ctx.ty_i32 || rr.ty == g0.ctx.ty_i64 || rr.ty == g0.ctx.ty_bool) {
      return gen_call_prim_method(g0, recv_id, rr.ty, mname, out_ty);
    }
  }

  // Enum ctor shorthand: `.Variant(...)`
  if match cn { ast.ExprNode.DotIdent(_x) => true, _ => false } {
    if ta.len() != 0 { return GenExprResult { ok: false, err: "enum shorthand does not accept type args", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let vname: String = match cn { ast.ExprNode.DotIdent(s) => s, _ => "" };
    return gen_call_enum_ctor_shorthand(g0, vname, args, out_ty);
  }

  // Path calls: function / enum ctor / Vec()
  let pr: tc.ExprPartsResult = tc.expr_parts(g0.exprs, callee);
  if !pr.ok { return GenExprResult { ok: false, err: "bad callee", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  let parts: Vec[String] = pr.parts;

  // Vec()
  if parts.len() == 1 && parts.get(0) == "Vec" {
    if expected == -1 { return GenExprResult { ok: false, err: "Vec() needs expected type", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    if !tc.is_vec_ty(g0.ctx, expected) { return GenExprResult { ok: false, err: "Vec() expected Vec[T]", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let elem: i32 = tc.vec_elem(g0.ctx, expected);
    let mut g: Gen = g0;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.VecNew(tid, expected, elem));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: expected };
  }

  // Unqualified function call (with prelude fallback).
  if parts.len() == 1 {
    let name: String = parts.get(0);
    let nf: tc.NamedFuncImport = find_named_func_import(g0.imps.named_funcs, name);
    if nf.local != "" {
      let frx: tc.FindFuncResult = tc.find_func(g0.ctx, nf.mod_path, nf.name);
      if frx.found { return gen_call_func(g0, nf.mod_path, nf.name, frx.sig, ta, args, out_ty); }
      return GenExprResult { ok: false, err: "unknown fn", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
    }
    let fr0: tc.FindFuncResult = tc.find_func(g0.ctx, g0.mod_path, name);
    if fr0.found { return gen_call_func(g0, g0.mod_path, name, fr0.sig, ta, args, out_ty); }
    let prelude: String = "std/prelude";
    let fr1: tc.FindFuncResult = tc.find_func(g0.ctx, prelude, name);
    if fr1.found { return gen_call_func(g0, prelude, name, fr1.sig, ta, args, out_ty); }
    let fr2: tc.FindFuncResult = tc.find_func(g0.ctx, "", name);
    if fr2.found { return gen_call_func(g0, "", name, fr2.sig, ta, args, out_ty); }
    return GenExprResult { ok: false, err: "unknown fn", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
  }

  // Qualified calls.
  if parts.len() == 2 {
    let mp: String = tc.find_alias(g0.imps.aliases, parts.get(0));
    if mp != "" {
      let fr: tc.FindFuncResult = tc.find_func(g0.ctx, mp, parts.get(1));
      if !fr.found { return GenExprResult { ok: false, err: "unknown fn", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
      return gen_call_func(g0, mp, parts.get(1), fr.sig, ta, args, out_ty);
    }
    // Otherwise: `Enum.Variant(...)` in current module, or via a named imported enum type.
    let nt: tc.NamedTypeImport = find_named_type_import(g0.imps.named_types, parts.get(0));
    if nt.local != "" {
      return gen_call_enum_ctor(g0, nt.mod_path, nt.name, parts.get(1), args, out_ty);
    }
    return gen_call_enum_ctor(g0, g0.mod_path, parts.get(0), parts.get(1), args, out_ty);
  }
  if parts.len() == 3 {
    let mp: String = tc.find_alias(g0.imps.aliases, parts.get(0));
    if mp == "" { return GenExprResult { ok: false, err: "unknown module alias", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    return gen_call_enum_ctor(g0, mp, parts.get(1), parts.get(2), args, out_ty);
  }

  return GenExprResult { ok: false, err: "unsupported call path", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
}

fn subs_lookup(subs: Vec[tc.TySub], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < subs.len() {
    let s: tc.TySub = subs.get(i);
    if s.name == name { return s.ty; }
    i = i + 1;
  }
  return -1;
}

fn pending_has(p: Vec[PendingInst], qn: String) -> bool {
  let mut i: i32 = 0;
  while i < p.len() {
    if p.get(i).qname == qn { return true; }
    i = i + 1;
  }
  return false;
}

fn pending_add(p0: Vec[PendingInst], pi: PendingInst) -> Vec[PendingInst] {
  if pending_has(p0, pi.qname) { return p0; }
  let mut p: Vec[PendingInst] = p0;
  p.push(pi);
  return p;
}

fn gen_call_func(g0: Gen, target_mod: String, name: String, sig: tc.FuncSig, type_args: Vec[ast.TypeName], args: Vec[i32], out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  if args.len() != sig.params.len() { return GenExprResult { ok: false, err: "arity mismatch", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

  if sig.type_params.len() == 0 {
    if type_args.len() != 0 { return GenExprResult { ok: false, err: "non-generic fn with type args", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

    let mut vs: Vec[ir.Value] = Vec();
    let mut i: i32 = 0;
    while i < args.len() {
      let want: i32 = sig.params.get(i);
      let er: GenExprResult = gen_expr(g, args.get(i), want);
      if !er.ok { return er; }
      g = er.g;
      vs.push(er.val);
      i = i + 1;
    }

    let qn: String = qname(target_mod, name);
    if out_ty == g.ctx.ty_unit {
      g = gen_emit(g, ir.Instr.Call(false, 0, out_ty, qn, vs));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
    }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Call(true, tid, out_ty, qn, vs));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }

  // Generic call: infer substitutions and call a monomorphized instantiation.
  if type_args.len() != 0 && type_args.len() != sig.type_params.len() {
    return GenExprResult { ok: false, err: "type arg arity mismatch", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let mut subs: Vec[tc.TySub] = Vec();
  // Return type is known at IRGen time; use it as a constraint.
  let ur0: tc.UnifyResult = tc.unify_ty(g.ctx, sig.ret, out_ty, subs);
  if !ur0.ok { return GenExprResult { ok: false, err: "cannot infer generic return", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  subs = ur0.subs;

  // Explicit type args.
  let mut ti: i32 = 0;
  while ti < type_args.len() {
    let tr: tc.ResolveTyResult = tc.resolve_type(g.ctx, g.w, g.mod_path, g.imps, Vec(), type_args.get(ti));
    g.ctx = tr.ctx;
    if !tr.ok { return GenExprResult { ok: false, err: "bad type arg", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let tp: String = sig.type_params.get(ti);
    let cur: i32 = subs_lookup(subs, tp);
    if cur != -1 && cur != tr.idx { return GenExprResult { ok: false, err: "type arg conflict", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if cur == -1 { subs.push(tc.TySub { name: tp, ty: tr.idx }); }
    ti = ti + 1;
  }

  // Infer from args while generating their IR values.
  let mut vs2: Vec[ir.Value] = Vec();
  let mut i2: i32 = 0;
  while i2 < args.len() {
    let want0: i32 = tc.subst_ty(g.ctx, sig.params.get(i2), subs);
    if want0 == g.ctx.ty_bad { return GenExprResult { ok: false, err: "bad generic arg type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let want_t: ir.Ty = ir.ty_pool_get(g.ctx.pool, want0);
    let want: i32 = if want_t.kind == ir.TyKind.Param { -1 } else { want0 };
    let er2: GenExprResult = gen_expr(g, args.get(i2), want);
    if !er2.ok { return er2; }
    g = er2.g;
    vs2.push(er2.val);
    let ur2: tc.UnifyResult = tc.unify_ty(g.ctx, sig.params.get(i2), er2.ty, subs);
    if !ur2.ok { return GenExprResult { ok: false, err: "cannot infer generic arg", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    subs = ur2.subs;
    i2 = i2 + 1;
  }

  // Ensure all type params are bound.
  let mut j: i32 = 0;
  while j < sig.type_params.len() {
    let tp2: String = sig.type_params.get(j);
    if subs_lookup(subs, tp2) == -1 { return GenExprResult { ok: false, err: "unbound type param", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    j = j + 1;
  }

  // Concrete signature.
  let mut ps: Vec[i32] = Vec();
  let mut pi: i32 = 0;
  while pi < sig.params.len() {
    let pty: i32 = tc.subst_ty(g.ctx, sig.params.get(pi), subs);
    if pty == g.ctx.ty_bad { return GenExprResult { ok: false, err: "bad substituted param type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    ps.push(pty);
    pi = pi + 1;
  }
  let rty: i32 = tc.subst_ty(g.ctx, sig.ret, subs);
  if rty == g.ctx.ty_bad { return GenExprResult { ok: false, err: "bad substituted ret type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  let inst_sig: tc.FuncSig = tc.FuncSig { params: ps, ret: rty, is_pub: sig.is_pub, type_params: Vec() };

  let inst: String = tc.inst_name(g.ctx, name, sig.type_params, subs);
  let inst_qn: String = qname(target_mod, inst);
  g.pending = pending_add(g.pending, PendingInst { qname: inst_qn, mod_path: target_mod, base_name: name, inst_name: inst, sig: inst_sig, subs: subs });

  if out_ty == g.ctx.ty_unit {
    g = gen_emit(g, ir.Instr.Call(false, 0, out_ty, inst_qn, vs2));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
  }
  let nt2: GenNewIdResult = gen_new_temp(g);
  g = nt2.g;
  let tid2: i32 = nt2.id;
  g = gen_emit(g, ir.Instr.Call(true, tid2, out_ty, inst_qn, vs2));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid2), ty: out_ty };
}

fn gen_call_enum_ctor(g0: Gen, enum_mod: String, enum_name: String, var_name: String, args: Vec[i32], out_ty: i32) -> GenExprResult {
  let fe: tc.FindEnumResult = tc.find_enum(g0.ctx, enum_mod, enum_name);
  if !fe.found { return GenExprResult { ok: false, err: "unknown enum", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  let es: tc.EnumSig = fe.sig;
  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: tc.EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != args.len() { return GenExprResult { ok: false, err: "ctor arity mismatch", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
      let mut g: Gen = g0;
      let mut payload: Vec[ir.Value] = Vec();
      let mut ai: i32 = 0;
      while ai < args.len() {
        let want: i32 = v.fields.get(ai);
        let er: GenExprResult = gen_expr(g, args.get(ai), want);
        if !er.ok { return er; }
        g = er.g;
        payload.push(er.val);
        ai = ai + 1;
      }
      let nt: GenNewIdResult = gen_new_temp(g);
      g = nt.g;
      let tid: i32 = nt.id;
      g = gen_emit(g, ir.Instr.EnumInit(tid, out_ty, var_name, payload));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
    }
    vi = vi + 1;
  }
  return GenExprResult { ok: false, err: "unknown enum variant", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
}

fn gen_call_enum_ctor_shorthand(g0: Gen, var_name: String, args: Vec[i32], out_ty: i32) -> GenExprResult {
  let et: ir.Ty = ir.ty_pool_get(g0.ctx.pool, out_ty);
  if et.kind != ir.TyKind.Enum { return GenExprResult { ok: false, err: "enum shorthand needs enum expected type", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  return gen_call_enum_ctor(g0, tc.ty_mod(et), tc.ty_name(et), var_name, args, out_ty);
}

fn gen_expr_dot_ident(g0: Gen, name: String, out_ty: i32) -> GenExprResult {
  // `.Variant` value (unit variant only).
  return gen_call_enum_ctor_shorthand(g0, name, Vec(), out_ty);
}

fn gen_call_vec_method(g0: Gen, recv_id: i32, recv_ty: i32, mname: String, args: Vec[i32], out_ty: i32) -> GenExprResult {
  let elem: i32 = tc.vec_elem(g0.ctx, recv_ty);

  if mname == "push" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "Vec.push arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let valr: GenExprResult = gen_expr(g0, args.get(0), elem);
    if !valr.ok { return valr; }
    let mut g: Gen = valr.g;

    // Receiver must be a place: local var or direct struct field.
    let rn: ast.ExprNode = ast.expr_pool_get(g.exprs, recv_id);
    if match rn { ast.ExprNode.Ident(_x) => true, _ => false } {
      let nm: String = match rn { ast.ExprNode.Ident(s) => s, _ => "" };
      let sr: LookupSlotResult = slots_lookup(g.slots, nm);
      if !sr.found { return GenExprResult { ok: false, err: "unknown vec var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      g = gen_emit(g, ir.Instr.VecPush(sr.slot, elem, valr.val));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
    }

    // field place: ident.field
    if match rn { ast.ExprNode.Member(_r, _n) => true, _ => false } {
      let base_id: i32 = match rn { ast.ExprNode.Member(b, _n) => b, _ => -1 };
      let field: String = match rn { ast.ExprNode.Member(_r, f) => f, _ => "" };
      let bn: ast.ExprNode = ast.expr_pool_get(g.exprs, base_id);
      if !match bn { ast.ExprNode.Ident(_x) => true, _ => false } {
        return GenExprResult { ok: false, err: "Vec.push field base must be ident", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
      }
      let bname: String = match bn { ast.ExprNode.Ident(s) => s, _ => "" };
      let br: LookupSlotResult = slots_lookup(g.slots, bname);
      if !br.found { return GenExprResult { ok: false, err: "unknown base var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

      // Load struct, extract vec field into temp slot, push, then write back.
      let t_struct: GenNewIdResult = gen_new_temp(g);
      g = t_struct.g;
      let tid_s: i32 = t_struct.id;
      g = gen_emit(g, ir.Instr.Load(tid_s, br.ty, br.slot));

      let t_vec: GenNewIdResult = gen_new_temp(g);
      g = t_vec.g;
      let tid_v: i32 = t_vec.id;
      g = gen_emit(g, ir.Instr.FieldGet(tid_v, recv_ty, ir.v_temp(tid_s), field));

      let sl: GenNewIdResult = gen_new_slot(g);
      g = sl.g;
      let vec_slot: i32 = sl.id;
      g = gen_emit(g, ir.Instr.SlotDecl(vec_slot, recv_ty));
      g = gen_emit(g, ir.Instr.Store(vec_slot, ir.v_temp(tid_v)));
      g = gen_emit(g, ir.Instr.VecPush(vec_slot, elem, valr.val));

      let t_vec2: GenNewIdResult = gen_new_temp(g);
      g = t_vec2.g;
      let tid_v2: i32 = t_vec2.id;
      g = gen_emit(g, ir.Instr.Load(tid_v2, recv_ty, vec_slot));
      g = gen_emit(g, ir.Instr.StoreField(br.slot, field, ir.v_temp(tid_v2)));

      return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
    }

    return GenExprResult { ok: false, err: "Vec.push recv must be place", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  if mname == "len" {
    if args.len() != 0 { return GenExprResult { ok: false, err: "Vec.len arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let rr: VecRecvSlotResult = vec_recv_slot(g0, recv_id, recv_ty);
    if !rr.ok { return GenExprResult { ok: false, err: rr.err, g: rr.g, val: ir.v_int(0), ty: rr.g.ctx.ty_bad }; }
    let mut g: Gen = rr.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.VecLen(tid, rr.slot));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }

  if mname == "get" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "Vec.get arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let rr: VecRecvSlotResult = vec_recv_slot(g0, recv_id, recv_ty);
    if !rr.ok { return GenExprResult { ok: false, err: rr.err, g: rr.g, val: ir.v_int(0), ty: rr.g.ctx.ty_bad }; }
    let mut g: Gen = rr.g;
    let idxr: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_i32);
    if !idxr.ok { return idxr; }
    g = idxr.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.VecGet(tid, elem, rr.slot, idxr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }

  if mname == "join" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "Vec.join arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let rr: VecRecvSlotResult = vec_recv_slot(g0, recv_id, recv_ty);
    if !rr.ok { return GenExprResult { ok: false, err: rr.err, g: rr.g, val: ir.v_int(0), ty: rr.g.ctx.ty_bad }; }
    let mut g: Gen = rr.g;
    let sepr: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_string);
    if !sepr.ok { return sepr; }
    g = sepr.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.VecStrJoin(tid, rr.slot, sepr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }

  return GenExprResult { ok: false, err: "unsupported Vec method", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
}

fn gen_call_string_method(g0: Gen, recv_id: i32, mname: String, args: Vec[i32], out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let rr: GenExprResult = gen_expr(g, recv_id, g.ctx.ty_string);
  if !rr.ok { return rr; }
  g = rr.g;

  if mname == "len" {
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrLen(tid, rr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "byte_at" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "String.byte_at arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let idxr: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_i32);
    if !idxr.ok { return idxr; }
    g = idxr.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrByteAt(tid, rr.val, idxr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "slice" {
    if args.len() != 2 { return GenExprResult { ok: false, err: "String.slice arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let sr: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_i32);
    if !sr.ok { return sr; }
    g = sr.g;
    let er: GenExprResult = gen_expr(g, args.get(1), g.ctx.ty_i32);
    if !er.ok { return er; }
    g = er.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrSlice(tid, rr.val, sr.val, er.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "concat" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "String.concat arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let or: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_string);
    if !or.ok { return or; }
    g = or.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrConcat(tid, rr.val, or.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "escape_c" {
    if args.len() != 0 { return GenExprResult { ok: false, err: "String.escape_c arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrEscapeC(tid, rr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  return GenExprResult { ok: false, err: "unsupported String method", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
}

fn gen_call_prim_method(g0: Gen, recv_id: i32, recv_ty: i32, mname: String, out_ty: i32) -> GenExprResult {
  if mname != "to_string" { return GenExprResult { ok: false, err: "unsupported prim method", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  let mut g: Gen = g0;
  let rr: GenExprResult = gen_expr(g, recv_id, recv_ty);
  if !rr.ok { return rr; }
  g = rr.g;
  let nt: GenNewIdResult = gen_new_temp(g);
  g = nt.g;
  let tid: i32 = nt.id;
  if recv_ty == g.ctx.ty_i32 { g = gen_emit(g, ir.Instr.I32ToStr(tid, rr.val)); }
  else if recv_ty == g.ctx.ty_i64 { g = gen_emit(g, ir.Instr.I64ToStr(tid, rr.val)); }
  else { g = gen_emit(g, ir.Instr.BoolToStr(tid, rr.val)); }
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
}

fn gen_expr_match(g0: Gen, scrut: i32, arms: Vec[ast.MatchArm], out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let sr: GenExprResult = gen_expr(g, scrut, -1);
  if !sr.ok { return sr; }
  g = sr.g;

  let sty: tc.ExprTyResult = tc.tc_expr(g.ctx, g.w, g.mod_path, g.imps, g.exprs, g.locals, scrut, -1);
  if !sty.ok { return GenExprResult { ok: false, err: "bad match scrut", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

  let is_enum: bool = tc.is_enum_ty(g.ctx, sty.ty);
  let is_i32: bool = sty.ty == g.ctx.ty_i32;
  let is_str: bool = sty.ty == g.ctx.ty_string;
  if !is_enum && !is_i32 && !is_str { return GenExprResult { ok: false, err: "match scrut must be enum/i32/String", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

  let mut es: tc.EnumSig = tc.EnumSig { mod_path: "", name: "", is_pub: false, vars: Vec() };
  let mut tag_id: i32 = -1;
  if is_enum {
    let et: ir.Ty = ir.ty_pool_get(g.ctx.pool, sty.ty);
    let fe: tc.FindEnumResult = tc.find_enum(g.ctx, tc.ty_mod(et), tc.ty_name(et));
    if !fe.found { return GenExprResult { ok: false, err: "unknown enum", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    es = fe.sig;
    // tag temp
    let ttag: GenNewIdResult = gen_new_temp(g);
    g = ttag.g;
    tag_id = ttag.id;
    g = gen_emit(g, ir.Instr.EnumTag(tag_id, sr.val));
  }

  let mut res_slot: i32 = -1;
  if out_ty != g.ctx.ty_unit {
    let ns: GenNewIdResult = gen_new_slot(g);
    g = ns.g;
    res_slot = ns.id;
    g = gen_emit(g, ir.Instr.SlotDecl(res_slot, out_ty));
    let zr: GenExprResult = gen_zero_value(g, out_ty);
    if !zr.ok { return zr; }
    g = zr.g;
    g = gen_emit(g, ir.Instr.Store(res_slot, zr.val));
  }

  let base: i32 = g.blocks.len();
  let endr: GenNewIdResult = gen_new_block(g, "match_end_".concat(base.to_string()));
  g = endr.g;
  let end_idx: i32 = endr.id;

  let mut infos: Vec[MatchArmInfo] = Vec();
  let mut wild_idx: i32 = -1;
  let mut ai: i32 = 0;
  while ai < arms.len() {
    let a: ast.MatchArm = arms.get(ai);
    let nb: GenNewIdResult = gen_new_block(g, "match_arm_".concat((base + ai).to_string()));
    g = nb.g;
    let blk: i32 = nb.id;
    let info: MatchArmInfo = match a.pat {
      ast.Pat.Wild => match_arm_info_wild(blk, a.expr),
      ast.Pat.Bind(name) => match_arm_info_bind(blk, a.expr, name, sty.ty),
      ast.Pat.Int(v) => match_arm_info_int(blk, a.expr, v),
      ast.Pat.Str(s) => match_arm_info_str(blk, a.expr, s),
      ast.Pat.EnumVariant(_ep, vname, binders) => match_arm_info_enum(blk, a.expr, es, vname, binders),
      _ => match_arm_info_other(blk, a.expr),
    };
    if info.is_wild { wild_idx = blk; }
    infos.push(info);
    ai = ai + 1;
  }

  // Decision chain from current block.
  let mut di: i32 = 0;
  while di < infos.len() {
    let info: MatchArmInfo = infos.get(di);
    let has_test: bool = info.has_tag || info.lit_kind != 0;
    if !has_test { di = di + 1; continue; }
    let nextb: GenNewIdResult = gen_new_block(g, "match_decide_".concat((base + di).to_string()));
    g = nextb.g;
    let next_idx: i32 = nextb.id;
    let cmp: GenNewIdResult = gen_new_temp(g);
    g = cmp.g;
    let cmp_id: i32 = cmp.id;
    if info.has_tag {
      if tag_id == -1 { return GenExprResult { ok: false, err: "internal: missing tag temp", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      g = gen_emit(g, ir.Instr.Cmp(cmp_id, ir.CmpKind.Eq, g.ctx.ty_i32, ir.v_temp(tag_id), ir.v_int(info.tag)));
      g = gen_term(g, ir.Term.CondBr(ir.v_temp(cmp_id), g.blocks.get(info.blk).name, g.blocks.get(next_idx).name));
    } else if info.lit_kind == 1 {
      g = gen_emit(g, ir.Instr.Cmp(cmp_id, ir.CmpKind.Eq, g.ctx.ty_i32, sr.val, ir.v_int(info.lit_i32)));
      g = gen_term(g, ir.Term.CondBr(ir.v_temp(cmp_id), g.blocks.get(info.blk).name, g.blocks.get(next_idx).name));
    } else {
      g = gen_emit(g, ir.Instr.Cmp(cmp_id, ir.CmpKind.Eq, g.ctx.ty_string, sr.val, ir.v_str(info.lit_str)));
      g = gen_term(g, ir.Term.CondBr(ir.v_temp(cmp_id), g.blocks.get(info.blk).name, g.blocks.get(next_idx).name));
    }
    g = gen_set_block(g, next_idx);
    di = di + 1;
  }

  // Default
  if wild_idx != -1 { g = gen_term(g, ir.Term.Br(g.blocks.get(wild_idx).name)); }
  else { g = gen_term(g, ir.Term.Br(g.blocks.get(end_idx).name)); }

  // Arms
  let mut ii: i32 = 0;
  while ii < infos.len() {
    let info: MatchArmInfo = infos.get(ii);
    g = gen_set_block(g, info.blk);
    g.slots = slots_enter(g.slots);
    g.locals = tc.locals_enter(g.locals);

    if info.bind_scrut != "" {
      let ns0: GenNewIdResult = gen_new_slot(g);
      g = ns0.g;
      let sid0: i32 = ns0.id;
      g = gen_emit(g, ir.Instr.SlotDecl(sid0, info.bind_scrut_ty));
      g = gen_emit(g, ir.Instr.Store(sid0, sr.val));
      g.slots = slots_decl(g.slots, info.bind_scrut, sid0, info.bind_scrut_ty, false);
      g.locals = tc.locals_decl(g.locals, info.bind_scrut, info.bind_scrut_ty, false);
    }

    let mut bi: i32 = 0;
    while bi < info.binds.len() && bi < info.bind_tys.len() {
      let nt: GenNewIdResult = gen_new_temp(g);
      g = nt.g;
      let tid: i32 = nt.id;
      if !is_enum { return GenExprResult { ok: false, err: "enum payload on non-enum match", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      g = gen_emit(g, ir.Instr.EnumPayload(tid, info.bind_tys.get(bi), sr.val, info.variant, bi));
      let ns: GenNewIdResult = gen_new_slot(g);
      g = ns.g;
      let sid: i32 = ns.id;
      g = gen_emit(g, ir.Instr.SlotDecl(sid, info.bind_tys.get(bi)));
      g = gen_emit(g, ir.Instr.Store(sid, ir.v_temp(tid)));
      g.slots = slots_decl(g.slots, info.binds.get(bi), sid, info.bind_tys.get(bi), false);
      g.locals = tc.locals_decl(g.locals, info.binds.get(bi), info.bind_tys.get(bi), false);
      bi = bi + 1;
    }
    let vr: GenExprResult = gen_expr(g, info.expr, out_ty);
    if !vr.ok { return vr; }
    g = vr.g;
    if res_slot != -1 { g = gen_emit(g, ir.Instr.Store(res_slot, vr.val)); }
    g.locals = tc.locals_exit(g.locals);
    g.slots = slots_exit(g.slots);
    g = gen_term(g, ir.Term.Br(g.blocks.get(end_idx).name));
    ii = ii + 1;
  }

  g = gen_set_block(g, end_idx);
  if res_slot == -1 { return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty }; }
  let nt2: GenNewIdResult = gen_new_temp(g);
  g = nt2.g;
  let tid2: i32 = nt2.id;
  g = gen_emit(g, ir.Instr.Load(tid2, out_ty, res_slot));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid2), ty: out_ty };
}
