import "std/testing" as t
import "parse" as p
import "typecheck" as tc
import "irgen" as g
import "ir" as ir

fn add_mod(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn starts_with(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

fn test_irgen_smoke_return_const() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> i32 { return 0; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  t.assert_eq(r.prog.funcs.len(), 1);
  let f = r.prog.funcs.get(0);
  t.assert_eq(f.blocks.len(), 1);
}

fn test_irgen_nested_field_assign_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct I { x: i32 }\nstruct O { i: I }\nfn main() -> i32 { let mut o: O = O { i: I { x: 1 } }; o.i.x = 2; o.i.x += 3; return o.i.x; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "store_field"));
}

fn test_irgen_const_float_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const A: f64 = 1.5\nfn main() -> f64 { return A; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const f64 1.5"));
}

fn test_irgen_const_float_arith_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const A: f64 = 1.0 + 2.0\nfn main() -> f64 { return A; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const f64 3.0"));
}

fn test_irgen_const_float_mod_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const A: f64 = 5.5 % 2.0\nfn main() -> f64 { return A; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const f64 1.5"));
}

fn test_irgen_const_int_float_cast_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const A: f64 = 7 as f64\nconst B: i32 = 7.9 as i32\nfn main() -> i32 { return A as i32 + B; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const f64 7.0"));
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_fn_call_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn add2(x: i32) -> i32 { return x + 2; }\nconst N: i32 = add2(5)\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_fn_call_named_import_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "pub fn plus(a: i32, b: i32) -> i32 { return a + b; }");
  w = add_mod(w, "main", "import { plus } from \"dep\"\nconst N: i32 = plus(3, 4)\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_fn_call_generic_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn id[T](x: T) -> T { return x; }\nconst N: i32 = id(7)\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_fn_call_const_generic_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nconst M: i32 = addn[3](4)\nfn main() -> i32 { return M; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_fn_call_const_generic_comptime_where_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0, comptime N <= 8 { return x + N; }\nconst M: i32 = addn[3](4)\nfn main() -> i32 { return M; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_fn_call_const_generic_comptime_where_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0, comptime N <= 8 { return x + N; }\nconst M: i32 = addn[0](4)\nfn main() -> i32 { return M; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "constraint failed"));
}

fn test_irgen_const_fn_call_const_generic_comptime_where_rhs_param_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn addnm[const N: i32, const M: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nconst V: i32 = addnm[3, 5](4)\nfn main() -> i32 { return V; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_fn_call_const_generic_comptime_where_rhs_param_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn addnm[const N: i32, const M: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nconst V: i32 = addnm[5, 3](4)\nfn main() -> i32 { return V; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "constraint failed"));
}

fn test_irgen_const_fn_call_const_generic_default_violates_comptime_where_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn addn[const N: i32 = 0](x: i32) -> i32 where comptime N > 0 { return x + N; }\nconst M: i32 = 1\nfn main() -> i32 { return M; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "default violates comptime where"));
}

fn test_irgen_const_unary_not_int_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const N: i32 = !0\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 -1"));
}

fn test_irgen_const_fn_call_generic_trait_bound_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn id[T: Eq](x: T) -> T { return x; }\nconst N: i32 = id(7)\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_block_expr_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const N: i32 = { let a: i32 = 2; let b: i32 = a + 3; b * 2 }\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 10"));
}

fn test_irgen_const_block_shadowing_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const N: i32 = { let x: i32 = 1; let x: i32 = 2; x }\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 2"));
}

fn test_irgen_const_block_if_stmt_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const N: i32 = { let x: i32 = 1; if true { let y: i32 = 2; } else { let z: i32 = 3; }; x + 4 }\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 5"));
}

fn test_irgen_const_block_while_break_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const N: i32 = { while true { break; } 7 }\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_block_return_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const N: i32 = { return 9; 1 }\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 9"));
}

fn test_irgen_const_logic_short_circuit_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const A: bool = false && (1 / 0 == 0)\nconst B: bool = true || (1 / 0 == 0)\nfn main() -> i32 { return if A || B { 1 } else { 0 }; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 1"));
}

fn test_irgen_const_struct_member_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct P { x: i32, y: i32 }\nconst P0: P = P { x: 3, y: 4 }\nconst N: i32 = P0.x + P0.y\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32"));
}

fn test_irgen_const_typed_path_generic_struct_lit_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct Pair[T] { a: T, b: T }\nconst P0: Pair[i32] = Pair[i32] { a: 3, b: 4 }\nconst N: i32 = P0.a + P0.b\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_block_assign_field_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct P { x: i32 }\nconst N: i32 = { let mut p: P = P { x: 1 }; p.x = 7; p.x }\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_block_branch_assign_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const N: i32 = { let mut x: i32 = 1; if true { x = 3; } else { x = 4; }; x }\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32"));
}

fn test_irgen_const_enum_unit_match_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "enum E { A, B }\nconst X: E = .A\nconst N: i32 = match X { .A => 1, .B => 0 }\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 1"));
}

fn test_irgen_const_enum_payload_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "enum E { A(i32), B }\nconst X: E = .A(7)\nfn main() -> i32 { let y: E = X; return match y { E.A(v) => v, E.B => 0 }; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "enum_init"));
  t.assert(contains(s, "7"));
}

fn test_irgen_const_typed_path_generic_enum_ctor_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "enum Option[T] { Some(T), None }\nconst A: Option[i32] = Option[i32].Some(7)\nconst B: Option[i32] = Option[i32].None\nfn main() -> i32 { let _a: Option[i32] = A; let _b: Option[i32] = B; return 0; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "enum_init"));
}

fn test_irgen_const_enum_payload_multi_bind_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "enum E { A(i32, i32), B }\nconst X: E = .A(7, 2)\nconst N: i32 = match X { .A(a, b) => a - b, .B => 0 }\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 5"));
}

fn test_irgen_const_enum_ctor_qualified_path_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "enum E { A(i32), B }\nconst X: E = E.A(7)\nfn main() -> i32 { return match X { .A(v) => v, .B => 0 }; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "enum_init"));
  t.assert(contains(s, "7"));
}

fn test_irgen_union_type_alias_match_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Value = I32: i32 | Str: String\nfn main(x: Value) -> i32 { return match x { .I32(v) => v, .Str(_s) => 0 }; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "enum_tag"));
  t.assert(contains(s, "enum_payload"));
}

fn test_irgen_const_union_match_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Value = I32: i32 | Str: String\nconst X: Value = Value.I32(7)\nconst N: i32 = match X { .I32(v) => v, .Str(_s) => 0 }\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_bitwise_and_shift_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let a: i32 = 6 & 3;\n  let b: i32 = 1 << 4;\n  let c: i32 = b >> 2;\n  return (a | c) ^ 1;\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "bitand i32"));
  t.assert(contains(s, "bitor i32"));
  t.assert(contains(s, "bitxor i32"));
  t.assert(contains(s, "shl i32"));
  t.assert(contains(s, "shr i32"));
}

fn test_irgen_bool_bitwise_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> bool { let a: bool = true; let b: bool = false; return (a ^ b) | (a & b); }";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "bitand bool"));
  t.assert(contains(s, "bitor bool"));
  t.assert(contains(s, "bitxor bool"));
}

fn test_irgen_unary_not_int_lowers_to_bitxor() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 { let x: i32 = !1; return x; }";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 -1"));
  t.assert(contains(s, "bitxor i32"));
}

fn test_irgen_unary_plus_noop_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 { let x: i32 = +1; return x; }";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 1"));
}

fn test_irgen_string_ordered_compare_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(a: String, b: String) -> i32 { if a < b { return 1; } return 0; }";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_lt str"));
}

fn test_irgen_float_to_string_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: f64 = 1.25;\n  let s: String = x.to_string();\n  return s.len();\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "f64_to_str"));
}

fn test_irgen_string_to_string_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let s: String = \"vox\";\n  let t2: String = s.to_string();\n  return t2.len();\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}

fn test_irgen_float_cast_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: f64 = 1.5;\n  let y: f32 = x as f32;\n  let z: f64 = y as f64;\n  if z > 0.0 { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "float_cast f32 f64"));
  t.assert(contains(s, "float_cast f64 f32"));
}

fn test_irgen_int_float_cast_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: i32 = 7;\n  let y: f64 = x as f64;\n  let z: i32 = y as i32;\n  return z;\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "float_cast f64 i32"));
  t.assert(contains(s, "int_cast_checked i32 f64"));
}

fn prog_has_func(p: ir.Program, name: String) -> bool {
  let mut i: i32 = 0;
  while i < p.funcs.len() {
    if p.funcs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn prog_has_struct(p: ir.Program, name: String) -> bool {
  let mut i: i32 = 0;
  while i < p.structs.len() {
    if p.structs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn prog_has_enum(p: ir.Program, name: String) -> bool {
  let mut i: i32 = 0;
  while i < p.enums.len() {
    if p.enums.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn test_irgen_monomorphizes_generic_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn id[T](x: T) -> T { return x; } fn main() -> i32 { return id(1); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  // Emit main + the instantiated `id[T=i32]`.
  t.assert_eq(r.prog.funcs.len(), 2);
  t.assert(prog_has_func(r.prog, "main"));
  t.assert(prog_has_func(r.prog, "id$gT_3di32"));
  t.assert(!prog_has_func(r.prog, "id"));
}

fn test_irgen_monomorphizes_multiple_instantiations() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn id[T](x: T) -> T { return x; }\nfn main() -> i32 {\n  let a: i32 = id(1);\n  let b: i64 = id[i64](1);\n  return a;\n}\n");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  t.assert_eq(r.prog.funcs.len(), 3);
  t.assert(prog_has_func(r.prog, "main"));
  t.assert(prog_has_func(r.prog, "id$gT_3di32"));
  t.assert(prog_has_func(r.prog, "id$gT_3di64"));
}

fn test_irgen_monomorphizes_generic_body_with_type_params() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn mk[T](x: T) -> Vec[T] {\n  let mut v: Vec[T] = Vec();\n  v.push(x);\n  return v;\n}\nfn main() -> i32 {\n  let v = mk(1);\n  return v.len();\n}\n");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "mk$gT_3di32"));
}

fn test_irgen_monomorphizes_const_generic_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn addn[const N: i32](x: i32) -> i32 { return x + N; } fn main() -> i32 { return addn[3](1); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert_eq(r.prog.funcs.len(), 2);
  t.assert(prog_has_func(r.prog, "main"));
  t.assert(prog_has_func(r.prog, "addn$gN_3d3_3ai32"));
  t.assert(!prog_has_func(r.prog, "addn"));
}

fn test_irgen_monomorphizes_const_generic_default_arg_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; } fn main() -> i32 { return addn(1); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "addn$gN_3d3_3ai32"));
}

fn test_irgen_monomorphizes_const_generic_default_arg_override() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; }\nfn main() -> i32 {\n  let a: i32 = addn(1);\n  let b: i32 = addn[9](1);\n  return a + b;\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "addn$gN_3d3_3ai32"));
  t.assert(prog_has_func(r.prog, "addn$gN_3d9_3ai32"));
}

fn test_irgen_monomorphizes_const_generic_multiple_instantiations() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn main() -> i32 {\n  let a: i32 = addn[1](1);\n  let b: i32 = addn[2](1);\n  return a + b;\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "addn$gN_3d1_3ai32"));
  t.assert(prog_has_func(r.prog, "addn$gN_3d2_3ai32"));
}

fn test_irgen_monomorphizes_generic_nominal_types() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Pair[T] { a: T, b: T }\nenum Option[T] { Some(T), None }\nfn main() -> i32 {\n  let p: Pair[i32] = Pair { a: 1, b: 2 };\n  let o: Option[i32] = Option.Some(p.a + p.b);\n  return match o { Option.Some(v) => v, Option.None => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(prog_has_struct(r.prog, "Pair$gT_3di32"));
  t.assert(prog_has_enum(r.prog, "Option$gT_3di32"));
}

fn test_irgen_monomorphizes_typed_path_generic_nominal_types() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Pair[T] { a: T, b: T }\nenum Option[T] { Some(T), None }\nfn main() -> i32 {\n  let p = Pair[i32] { a: 1, b: 2 };\n  let o = Option[i32].Some(p.a + p.b);\n  let n = Option[i32].None;\n  let y: i32 = match n { Option.Some(v) => v, Option.None => 0 };\n  return match o { Option.Some(v) => v + y, Option.None => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(prog_has_struct(r.prog, "Pair$gT_3di32"));
  t.assert(prog_has_enum(r.prog, "Option$gT_3di32"));
}

fn test_irgen_generic_trait_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }\nfn main() -> i32 { return if same(\"a\", \"b\") { 1 } else { 0 }; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
}

fn test_irgen_enum_unit_equality_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let x: E = E.A(1);\n  if x == E.None { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}

fn test_irgen_enum_payload_equality_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let a: E = E.A(1);\n  let b: E = E.A(1);\n  return if a == b { 1 } else { 0 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_eq enum(main::E)"));
}

fn test_irgen_struct_equality_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct S { a: i32, b: String }\nfn main() -> i32 {\n  let x: S = S { a: 1, b: \"x\" };\n  let y: S = S { a: 1, b: \"x\" };\n  return if x == y { 1 } else { 0 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_eq struct(main::S)"));
}

fn test_irgen_const_struct_equality_folds() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct S { a: i32, b: String }\nconst X: S = S { a: 1, b: \"x\" }\nconst Y: S = S { a: 1, b: \"x\" }\nconst B: bool = X == Y\nfn main() -> i32 { return if B { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(!contains(s, "cmp_eq struct(main::S)"));
}

fn test_irgen_const_enum_payload_equality_folds() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32, String), None }\nconst X: E = E.A(7, \"x\")\nconst Y: E = E.A(7, \"x\")\nconst B: bool = X == Y\nfn main() -> i32 { return if B { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(!contains(s, "cmp_eq enum(main::E)"));
}

fn test_irgen_ifexpr_branch_return_diverges_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(flag: bool) -> i32 {\n  let x: i32 = if flag {\n    return 7;\n  } else {\n    3\n  };\n  return x;\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_irgen_ifexpr_branch_break_in_loop_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let mut i: i32 = 0;\n  while i < 10 {\n    let _x: i32 = if i > 5 {\n      break;\n    } else {\n      i\n    };\n    i = i + 1;\n  }\n  return i;\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_irgen_ifexpr_else_if_chain_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn sign(x: i32) -> i32 {\n  let y: i32 = if x < 0 {\n    -1\n  } else if x == 0 {\n    0\n  } else {\n    1\n  };\n  return y;\n}\nfn main() -> i32 { return sign(7); }";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "condbr"));
}

fn test_irgen_match_bind_pattern_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let x: E = E.A(1);\n  return match x {\n    v => match v {\n      E.A(n) => n,\n      E.None => 0,\n    },\n  };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}

fn test_irgen_match_int_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  return match x { 0 => 1, 1 => 2, _ => 3 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}

fn test_irgen_match_negative_int_pattern_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  return match x { -1 => 0, _ => 1 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "-1"));
}

fn test_irgen_match_nested_variant_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum O { Some(i32), None }\nenum R { Ok(O), Err(i32) }\nfn main(x: R) -> i32 {\n  return match x {\n    R.Ok(O.Some(v)) => v,\n    R.Ok(O.None) => 0,\n    R.Err(_) => -1,\n  };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "enum_tag"));
  t.assert(contains(s, "enum_payload"));
}

fn test_irgen_match_u32_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u32) -> i32 {\n  return match x { 0 => 1, 1 => 2, _ => 3 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_eq u32"));
}

fn test_irgen_match_u8_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u8) -> i32 {\n  return match x { 0 => 1, 1 => 2, _ => 3 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_eq u8"));
}

fn test_irgen_match_u64_max_pattern_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u64) -> i32 {\n  return match x { 18446744073709551615 => 1, _ => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_eq u64"));
}

fn test_irgen_match_i64_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i64) -> i32 {\n  return match x { 3000000000 => 1, _ => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}

fn test_irgen_match_string_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(s: String) -> i32 {\n  return match s { \"a\" => 1, _ => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}

fn test_irgen_match_bool_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(b: bool) -> i32 {\n  return match b { true => 1, false => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_eq bool"));
}

fn test_irgen_rejects_return_without_expr_in_i32_fn() -> () {
  let mut w: tc.World = tc.world();
  // Put the error at a stable location: line 2, col 1.
  w = add_mod(w, "main", "fn main() -> i32 {\nreturn;\n}");
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
}

fn test_irgen_trait_static_call_lowers_to_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I {\n  fn show(x: I) -> String { return \"ok\"; }\n}\nfn main() -> i32 {\n  let x: I = I { v: 1 };\n  let s: String = Show.show(x);\n  return s.len();\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show$0"));
}

fn test_irgen_generic_impl_trait_static_call_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String; }\nimpl[T] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }\nfn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(7); let s: String = Show.show(v); return s.len(); }";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show$"));
}

fn test_irgen_generic_impl_trait_method_sugar_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String; }\nimpl[T] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }\nfn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(7); let s: String = v.show(); return s.len(); }";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show$"));
}

fn test_irgen_generic_impl_bound_rejected_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Mark { fn mark(x: Self) -> bool; }\ntrait Show { fn show(x: Self) -> String; }\nimpl[T: Mark] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }\nfn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(7); let s: String = Show.show(v); return s.len(); }";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "does not satisfy trait bound"));
}

fn test_irgen_trait_method_sugar_lowers_to_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I {\n  fn show(x: I) -> String { return \"ok\"; }\n}\nfn main() -> i32 {\n  let x: I = I { v: 1 };\n  let s: String = x.show();\n  return s.len();\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show$0"));
}

fn test_irgen_trait_default_method_lowers_to_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String { return \"ok\"; } }\nstruct I { v: i32 }\nimpl Show for I {}\nfn main() -> i32 {\n  let x: I = I { v: 1 };\n  let s: String = x.show();\n  return s.len();\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show"));
}

fn test_irgen_trait_default_method_external_trait_uses_trait_module_scope() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "fn dep_tag() -> String { return \"dep\"; }\npub trait Show { fn show(x: Self) -> String { return dep_tag(); } }");
  w = add_mod(w, "main", "import \"dep\" as d\nstruct I { v: i32 }\nimpl d.Show for I {}\nfn main() -> i32 { let x: I = I { v: 1 }; let s: String = x.show(); return s.len(); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "dep::dep_tag"));
  t.assert(contains(s, "impl$dep$Show$show"));
}

fn test_irgen_trait_generic_method_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }");
  w = add_mod(w, "main", "trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Wrap for I { fn wrap[T: Eq](x: I, v: T) -> T { return v; } }\nfn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = Wrap.wrap[i32](x, 7); let b: i32 = I { v: 2 }.wrap[i32](9); return a + b; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Wrap$wrap$"));
  t.assert(contains(s, "$gT_3di32"));
}

fn test_irgen_trait_const_generic_method_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }\nstruct I { v: i32 }\nimpl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }\nfn main() -> i32 { let x: I = I { v: 1 }; return AddN.addn[3](x, 4); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$AddN$addn$"));
  t.assert(contains(s, "$gN_3d3_3ai32"));
}

fn test_irgen_trait_generic_default_method_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }");
  w = add_mod(w, "main", "trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T { return v; } }\nstruct I { v: i32 }\nimpl Wrap for I {}\nfn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = Wrap.wrap[i32](x, 7); let b: i32 = I { v: 2 }.wrap[i32](9); return a + b; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Wrap$wrap$"));
  t.assert(contains(s, "$gT_3di32"));
}

fn test_irgen_generic_bound_trait_method_sugar_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "trait Show { fn show(x: Self) -> String; }\nimpl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }\nfn f[T: Show](x: T) -> String { return x.show(); }\nfn main() -> i32 { let s: String = f(7); return s.len(); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show"));
  t.assert(contains(s, "f$gT_3di32"));
}

fn test_irgen_trait_static_call_lowers_impl_method_body() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddOne { fn add_one(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl AddOne for I {\n  fn add_one(x: I) -> i32 { return x.v + 1; }\n}\nfn main() -> i32 {\n  let x: I = I { v: 1 };\n  return AddOne.add_one(x);\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "impl$main$AddOne$add_one$0"));
}

fn test_irgen_prelude_trait_fallback_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }");
  w = add_mod(w, "main", "fn main() -> i32 { return if Eq.eq(1, 1) { 1 } else { 0 }; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "std.prelude::impl$std.prelude$Eq$eq"));
}

fn test_irgen_prelude_trait_default_method_fallback_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "fn tag() -> String { return \"pre\"; }\npub trait Show { fn show(x: Self) -> String { return tag(); } }");
  w = add_mod(w, "main", "struct I { v: i32 }\nimpl Show for I {}\nfn main() -> i32 { let s: String = I { v: 1 }.show(); return s.len(); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "std.prelude::tag"));
  t.assert(contains(s, "impl$std.prelude$Show$show"));
}
