import "std/testing" as t
import "parse" as p
import "typecheck" as tc
import "irgen" as g
import "ir" as ir

fn add_mod(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn starts_with(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

fn test_irgen_smoke_return_const() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> i32 { return 0; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  t.assert_eq(r.prog.funcs.len(), 1);
  let f = r.prog.funcs.get(0);
  t.assert_eq(f.blocks.len(), 1);
}

fn prog_has_func(p: ir.Program, name: String) -> bool {
  let mut i: i32 = 0;
  while i < p.funcs.len() {
    if p.funcs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn test_irgen_monomorphizes_generic_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn id[T](x: T) -> T { return x; } fn main() -> i32 { return id(1); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  // Emit main + the instantiated `id[T=i32]`.
  t.assert_eq(r.prog.funcs.len(), 2);
  t.assert(prog_has_func(r.prog, "main"));
  t.assert(prog_has_func(r.prog, "id$gT_3di32"));
  t.assert(!prog_has_func(r.prog, "id"));
}

fn test_irgen_monomorphizes_multiple_instantiations() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn id[T](x: T) -> T { return x; }\nfn main() -> i32 {\n  let a: i32 = id(1);\n  let b: i64 = id[i64](1);\n  return a;\n}\n");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  t.assert_eq(r.prog.funcs.len(), 3);
  t.assert(prog_has_func(r.prog, "main"));
  t.assert(prog_has_func(r.prog, "id$gT_3di32"));
  t.assert(prog_has_func(r.prog, "id$gT_3di64"));
}

fn test_irgen_monomorphizes_generic_body_with_type_params() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn mk[T](x: T) -> Vec[T] {\n  let mut v: Vec[T] = Vec();\n  v.push(x);\n  return v;\n}\nfn main() -> i32 {\n  let v = mk(1);\n  return v.len();\n}\n");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "mk$gT_3di32"));
}

fn test_irgen_enum_unit_equality_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let x: E = E.A(1);\n  if x == E.None { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}

fn test_irgen_match_bind_pattern_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let x: E = E.A(1);\n  return match x {\n    v => match v {\n      E.A(n) => n,\n      E.None => 0,\n    },\n  };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}

fn test_irgen_match_int_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  return match x { 0 => 1, 1 => 2, _ => 3 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}

fn test_irgen_match_negative_int_pattern_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  return match x { -1 => 0, _ => 1 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "-1"));
}

fn test_irgen_match_nested_variant_patterns_lowers() -> () {
  // Stage0/Stage1 v0: exhaustiveness checking is variant-based; require a catch-all arm per variant.
  let mut w: tc.World = tc.world();
  let src: String = "enum O { Some(i32), None }\nenum R { Ok(O), Err(i32) }\nfn main(x: R) -> i32 {\n  return match x {\n    R.Ok(O.Some(v)) => v,\n    R.Ok(O.None) => 0,\n    R.Ok(_o) => 0,\n    R.Err(_) => -1,\n  };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "enum_tag"));
  t.assert(contains(s, "enum_payload"));
}

fn test_irgen_match_u32_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u32) -> i32 {\n  return match x { 0 => 1, 1 => 2, _ => 3 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_eq u32"));
}

fn test_irgen_match_u8_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u8) -> i32 {\n  return match x { 0 => 1, 1 => 2, _ => 3 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_eq u8"));
}

fn test_irgen_match_i64_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i64) -> i32 {\n  return match x { 3000000000 => 1, _ => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}

fn test_irgen_match_string_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(s: String) -> i32 {\n  return match s { \"a\" => 1, _ => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}

fn test_irgen_rejects_return_without_expr_in_i32_fn() -> () {
  let mut w: tc.World = tc.world();
  // Put the error at a stable location: line 2, col 1.
  w = add_mod(w, "main", "fn main() -> i32 {\nreturn;\n}");
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
}
