import "ast" as ast
import "ir" as ir
import "typecheck" as tc

fn gen_stmt_let(g0: Gen, mutable: bool, name: String, has_ann: bool, ann: ast.TypeName, init: i32) -> GenStmtResult {
  let mut g: Gen = g0;
  let mut expected: i32 = -1;
  if has_ann {
    let rr: tc.ResolveTyResult = tc.resolve_type(g.ctx, g.w, g.mod_path, g.aliases, ann);
    if !rr.ok { return GenStmtResult { ok: false, err: "bad let annotation", g: g }; }
    g.ctx = rr.ctx;
    expected = rr.idx;
  }
  let er: GenExprResult = gen_expr(g, init, expected);
  if !er.ok { return GenStmtResult { ok: false, err: er.err, g: er.g }; }
  g = er.g;
  let ty: i32 = if expected != -1 { expected } else { er.ty };

  let rs: GenNewIdResult = gen_new_slot(g);
  g = rs.g;
  let sid: i32 = rs.id;
  g = gen_emit(g, ir.Instr.SlotDecl(sid, ty));
  g = gen_emit(g, ir.Instr.Store(sid, er.val));

  g.slots = slots_decl(g.slots, name, sid, ty, mutable);
  g.locals = tc.locals_decl(g.locals, name, ty, mutable);
  return GenStmtResult { ok: true, err: "", g: g };
}

fn gen_stmt_assign(g0: Gen, name: String, rhs: i32) -> GenStmtResult {
  let mut g: Gen = g0;
  let sr: LookupSlotResult = slots_lookup(g.slots, name);
  if !sr.found { return GenStmtResult { ok: false, err: "unknown var", g: g }; }
  if !sr.mutable { return GenStmtResult { ok: false, err: "assign to immutable var", g: g }; }
  let er: GenExprResult = gen_expr(g, rhs, sr.ty);
  if !er.ok { return GenStmtResult { ok: false, err: er.err, g: er.g }; }
  g = er.g;
  g = gen_emit(g, ir.Instr.Store(sr.slot, er.val));
  return GenStmtResult { ok: true, err: "", g: g };
}

fn gen_stmt_expr(g0: Gen, eid: i32) -> GenStmtResult {
  let er: GenExprResult = gen_expr(g0, eid, -1);
  if !er.ok { return GenStmtResult { ok: false, err: er.err, g: er.g }; }
  return GenStmtResult { ok: true, err: "", g: er.g };
}

fn gen_stmt_return(g0: Gen, has: bool, eid: i32) -> GenStmtResult {
  let mut g: Gen = g0;
  if !has {
    g = gen_term(g, ir.Term.Ret(false, ir.v_int(0)));
    return GenStmtResult { ok: true, err: "", g: g };
  }
  let er: GenExprResult = gen_expr(g, eid, g.ret_ty);
  if !er.ok { return GenStmtResult { ok: false, err: er.err, g: er.g }; }
  g = er.g;
  g = gen_term(g, ir.Term.Ret(true, er.val));
  return GenStmtResult { ok: true, err: "", g: g };
}

// Control-flow lowering lives in gen_cf.vox.
