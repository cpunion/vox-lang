import "ast" as ast
import "ir" as ir
import "typecheck" as tc

fn subs_lookup_inst(subs: Vec[tc.TySub], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < subs.len() {
    let s: tc.TySub = subs.get(i);
    if s.name == name { return s.ty; }
    i = i + 1;
  }
  return -1;
}

fn resolve_type_inst(ctx: tc.Ctx, w: tc.World, mod_path: String, aliases: Vec[tc.ImportAlias], subs: Vec[tc.TySub], tn: ast.TypeName) -> tc.ResolveTyResult {
  // Substitute type params inside monomorphized generic function bodies.
  if tn.parts.len() == 1 && tn.args.len() == 0 {
    let n: String = tn.parts.get(0);
    let idx: i32 = subs_lookup_inst(subs, n);
    if idx != -1 { return tc.ResolveTyResult { ctx: ctx, ok: true, idx: idx }; }
  }
  // Vec[T]
  if tn.parts.len() == 1 && tn.args.len() == 1 && tn.parts.get(0) == "Vec" {
    let r0: tc.ResolveTyResult = resolve_type_inst(ctx, w, mod_path, aliases, subs, tn.args.get(0));
    if !r0.ok { return r0; }
    return tc.intern_vec(r0.ctx, r0.idx);
  }
  // Fallback for nominal / primitive types.
  return tc.resolve_type(ctx, w, mod_path, aliases, Vec(), tn);
}

fn gen_stmt_let(g0: Gen, mutable: bool, name: String, has_ann: bool, ann: ast.TypeName, init: i32) -> GenStmtResult {
  let mut g: Gen = g0;
  let mut expected: i32 = -1;
  if has_ann {
    let rr: tc.ResolveTyResult = resolve_type_inst(g.ctx, g.w, g.mod_path, g.aliases, g.type_subs, ann);
    if !rr.ok { return GenStmtResult { ok: false, err: "bad let annotation", g: g }; }
    g.ctx = rr.ctx;
    expected = rr.idx;
  }
  let er: GenExprResult = gen_expr(g, init, expected);
  if !er.ok { return GenStmtResult { ok: false, err: er.err, g: er.g }; }
  g = er.g;
  let ty: i32 = if expected != -1 { expected } else { er.ty };

  let rs: GenNewIdResult = gen_new_slot(g);
  g = rs.g;
  let sid: i32 = rs.id;
  g = gen_emit(g, ir.Instr.SlotDecl(sid, ty));
  g = gen_emit(g, ir.Instr.Store(sid, er.val));

  g.slots = slots_decl(g.slots, name, sid, ty, mutable);
  g.locals = tc.locals_decl(g.locals, name, ty, mutable);
  return GenStmtResult { ok: true, err: "", g: g };
}

fn gen_stmt_assign(g0: Gen, name: String, rhs: i32) -> GenStmtResult {
  let mut g: Gen = g0;
  let sr: LookupSlotResult = slots_lookup(g.slots, name);
  if !sr.found { return GenStmtResult { ok: false, err: "unknown var", g: g }; }
  if !sr.mutable { return GenStmtResult { ok: false, err: "assign to immutable var", g: g }; }
  let er: GenExprResult = gen_expr(g, rhs, sr.ty);
  if !er.ok { return GenStmtResult { ok: false, err: er.err, g: er.g }; }
  g = er.g;
  g = gen_emit(g, ir.Instr.Store(sr.slot, er.val));
  return GenStmtResult { ok: true, err: "", g: g };
}

fn gen_stmt_assign_field(g0: Gen, recv: String, field: String, rhs: i32) -> GenStmtResult {
  let mut g: Gen = g0;
  let sr: LookupSlotResult = slots_lookup(g.slots, recv);
  if !sr.found { return GenStmtResult { ok: false, err: "unknown var", g: g }; }
  if !sr.mutable { return GenStmtResult { ok: false, err: "assign to immutable var", g: g }; }

  let rt: ir.Ty = ir.ty_pool_get(g.ctx.pool, sr.ty);
  if rt.kind != ir.TyKind.Struct { return GenStmtResult { ok: false, err: "field assign recv must be struct", g: g }; }
  let fs: tc.FindStructResult = tc.find_struct(g.ctx, rt.mod_path, rt.name);
  if !fs.found { return GenStmtResult { ok: false, err: "unknown struct type", g: g }; }
  if fs.sig.mod_path != g.mod_path && !fs.sig.is_pub { return GenStmtResult { ok: false, err: "type is private", g: g }; }

  let mut found: bool = false;
  let mut fty: i32 = g.ctx.ty_bad;
  let mut fpub: bool = false;
  let mut i: i32 = 0;
  while i < fs.sig.fields.len() {
    let f: tc.StructFieldSig = fs.sig.fields.get(i);
    if f.name == field {
      found = true;
      fty = f.ty;
      fpub = f.is_pub;
      break;
    }
    i = i + 1;
  }
  if !found { return GenStmtResult { ok: false, err: "unknown field", g: g }; }
  if fs.sig.mod_path != g.mod_path && !fpub { return GenStmtResult { ok: false, err: "field is private", g: g }; }

  let er: GenExprResult = gen_expr(g, rhs, fty);
  if !er.ok { return GenStmtResult { ok: false, err: er.err, g: er.g }; }
  g = er.g;
  g = gen_emit(g, ir.Instr.StoreField(sr.slot, field, er.val));
  return GenStmtResult { ok: true, err: "", g: g };
}

fn gen_stmt_expr(g0: Gen, eid: i32) -> GenStmtResult {
  let er: GenExprResult = gen_expr(g0, eid, -1);
  if !er.ok { return GenStmtResult { ok: false, err: er.err, g: er.g }; }
  return GenStmtResult { ok: true, err: "", g: er.g };
}

fn gen_stmt_return(g0: Gen, has: bool, eid: i32) -> GenStmtResult {
  let mut g: Gen = g0;
  if !has {
    g = gen_term(g, ir.Term.Ret(false, ir.v_int(0)));
    return GenStmtResult { ok: true, err: "", g: g };
  }
  let er: GenExprResult = gen_expr(g, eid, g.ret_ty);
  if !er.ok { return GenStmtResult { ok: false, err: er.err, g: er.g }; }
  g = er.g;
  g = gen_term(g, ir.Term.Ret(true, er.val));
  return GenStmtResult { ok: true, err: "", g: g };
}

// Control-flow lowering lives in gen_cf.vox.
