import "ast" as ast
import "ir" as ir
import "typecheck" as tc

fn gen_func_impl(ctx: tc.Ctx, w: tc.World, mod_path: String, imps: tc.Imports, exprs: ast.ExprPool, fd: ast.FuncDecl, fn_name: String, sig: tc.FuncSig, type_subs: Vec[tc.TySub]) -> GenFuncResult {
  let mut g: Gen = Gen{
    ctx: ctx,
    w: w,
    mod_path: mod_path,
    imps: imps,
    exprs: exprs,
    tmp_id: 0,
    slot_id: 0,
    blocks: Vec(),
    cur: -1,
    slots: slots_new(),
    locals: tc.locals_new(),
    loops: Vec(),
    ret_ty: sig.ret,
    pending: Vec(),
    type_subs: type_subs,
  };

  // Create entry block.
  let r0: GenNewIdResult = gen_new_block(g, "entry");
  g = r0.g;
  g = gen_set_block(g, r0.id);

  let mut f: ir.Func = ir.Func { name: qname(mod_path, fn_name), params: Vec(), ret: sig.ret, blocks: Vec() };

  // Params: declare slots and store params.
  let mut pi: i32 = 0;
  while pi < fd.params.len() {
    let p: ast.Param = fd.params.get(pi);
    let pty: i32 = sig.params.get(pi);
    f.params.push(ir.Param { name: p.name, ty: pty });

    let rs: GenNewIdResult = gen_new_slot(g);
    g = rs.g;
    let sid: i32 = rs.id;
    g = gen_emit(g, ir.Instr.SlotDecl(sid, pty));
    g = gen_emit(g, ir.Instr.Store(sid, ir.v_param(pi)));
    g.slots = slots_decl(g.slots, p.name, sid, pty, false);
    g.locals = tc.locals_decl(g.locals, p.name, pty, false);
    pi = pi + 1;
  }

  // Body.
  let rb: GenStmtResult = gen_block(g, fd.body);
  if !rb.ok { return GenFuncResult { ok: false, err: rb.err, ctx: g.ctx, f: f, pending: Vec() }; }
  g = rb.g;

  // Ensure terminator.
  let cur_blk: ir.Block = g.blocks.get(g.cur);
  if !cur_blk.has_term {
    if sig.ret == ctx.ty_unit {
      g = gen_term(g, ir.Term.Ret(false, ir.v_int(0)));
    } else {
      // v0: default zero for integer-like returns.
      let rt: GenNewIdResult = gen_new_temp(g);
      g = rt.g;
      let tid: i32 = rt.id;
      g = gen_emit(g, ir.Instr.Const(tid, sig.ret, ir.v_int(0)));
      g = gen_term(g, ir.Term.Ret(true, ir.v_temp(tid)));
    }
  }

  f.blocks = g.blocks;
  return GenFuncResult { ok: true, err: "", ctx: g.ctx, f: f, pending: g.pending };
}

fn gen_func(ctx: tc.Ctx, w: tc.World, mod_path: String, imps: tc.Imports, exprs: ast.ExprPool, fd: ast.FuncDecl) -> GenFuncResult {
  let fr: tc.FindFuncResult = tc.find_func(ctx, mod_path, fd.name);
  if !fr.found { return GenFuncResult { ok: false, err: "missing fn sig", ctx: ctx, f: ir.Func { name: "", params: Vec(), ret: ctx.ty_bad, blocks: Vec() }, pending: Vec() }; }
  return gen_func_impl(ctx, w, mod_path, imps, exprs, fd, fd.name, fr.sig, Vec());
}

fn gen_func_inst(ctx: tc.Ctx, w: tc.World, mod_path: String, imps: tc.Imports, exprs: ast.ExprPool, fd: ast.FuncDecl, inst_name: String, inst_sig: tc.FuncSig, subs: Vec[tc.TySub]) -> GenFuncResult {
  return gen_func_impl(ctx, w, mod_path, imps, exprs, fd, inst_name, inst_sig, subs);
}

struct GenStmtResult { ok: bool, err: String, g: Gen }

fn gen_block(g0: Gen, b: ast.Block) -> GenStmtResult {
  let mut g: Gen = g0;
  g.slots = slots_enter(g.slots);
  g.locals = tc.locals_enter(g.locals);
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let r: GenStmtResult = gen_stmt(g, b.stmts.get(i));
    if !r.ok { return r; }
    g = r.g;
    let blk: ir.Block = g.blocks.get(g.cur);
    if blk.has_term { break; }
    i = i + 1;
  }
  g.locals = tc.locals_exit(g.locals);
  g.slots = slots_exit(g.slots);
  return GenStmtResult { ok: true, err: "", g: g };
}

fn gen_stmt(g0: Gen, st: ast.Stmt) -> GenStmtResult {
  let mut g: Gen = g0;
  return match st {
    ast.Stmt.Let(mutable, name, has_ann, ann, init) => gen_stmt_let(g, mutable, name, has_ann, ann, init),
    ast.Stmt.Assign(name, rhs) => gen_stmt_assign(g, name, rhs),
    ast.Stmt.AssignField(recv, field, rhs) => gen_stmt_assign_field(g, recv, field, rhs),
    ast.Stmt.Expr(eid) => gen_stmt_expr(g, eid),
    ast.Stmt.If(cond, then_b, has_else, else_b) => gen_stmt_if(g, cond, then_b, has_else, else_b),
    ast.Stmt.While(cond, body) => gen_stmt_while(g, cond, body),
    ast.Stmt.Break => gen_stmt_break(g),
    ast.Stmt.Continue => gen_stmt_continue(g),
    ast.Stmt.Return(has, eid) => gen_stmt_return(g, has, eid),
  };
}
