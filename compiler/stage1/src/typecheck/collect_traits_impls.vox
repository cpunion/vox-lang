import "ast" as ast
import "ir" as ir

struct ResolveTraitRefResult { ok: bool, mod_path: String, name: String }

fn vec_self() -> Vec[String] {
  let mut v: Vec[String] = Vec();
  v.push("Self");
  return v;
}

fn vec_self_tps(tps: Vec[String]) -> Vec[String] {
  let mut v: Vec[String] = vec_self();
  let mut i: i32 = 0;
  while i < tps.len() {
    v.push(tps.get(i));
    i = i + 1;
  }
  return v;
}

fn type_name1(s: String) -> ast.TypeName {
  let mut ps: Vec[String] = Vec();
  ps.push(s);
  return ast.TypeName { parts: ps, args: Vec() };
}

fn type_param_pos(tps: Vec[String], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < tps.len() {
    if tps.get(i) == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn resolve_trait_ref(ctx: Ctx, _w: World, cur_mod: String, imps: Imports, tn: ast.TypeName) -> ResolveTraitRefResult {
  if tn.args.len() != 0 { return ResolveTraitRefResult { ok: false, mod_path: "", name: "" }; }
  if tn.parts.len() == 1 {
    let name0: String = tn.parts.get(0);
    let ni: NamedTypeImport = find_named_type(imps.named_types, name0);
    if ni.local != "" {
      if ni.kind != named_type_kind_trait() { return ResolveTraitRefResult { ok: false, mod_path: "", name: "" }; }
      return ResolveTraitRefResult { ok: true, mod_path: ni.mod_path, name: ni.name };
    }
    let fl: FindTraitResult = find_trait(ctx, cur_mod, name0);
    if fl.found { return ResolveTraitRefResult { ok: true, mod_path: cur_mod, name: name0 }; }
    let prelude: String = "std/prelude";
    let fp: FindTraitResult = find_trait(ctx, prelude, name0);
    if fp.found && fp.sig.is_pub {
      return ResolveTraitRefResult { ok: true, mod_path: prelude, name: name0 };
    }
    return ResolveTraitRefResult { ok: true, mod_path: cur_mod, name: name0 };
  }
  if tn.parts.len() == 2 {
    let mp: String = find_alias(imps.aliases, tn.parts.get(0));
    if mp == "" { return ResolveTraitRefResult { ok: false, mod_path: "", name: "" }; }
    return ResolveTraitRefResult { ok: true, mod_path: mp, name: tn.parts.get(1) };
  }
  return ResolveTraitRefResult { ok: false, mod_path: "", name: "" };
}

fn has_trait_name(ctx: Ctx, mod_path: String, name: String) -> bool {
  let mut i: i32 = 0;
  while i < ctx.traits.len() {
    let t: TraitSig = ctx.traits.get(i);
    if t.mod_path == mod_path && t.name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn has_super_sig(ss: Vec[TraitSuperSig], mod_path: String, name: String) -> bool {
  let mut i: i32 = 0;
  while i < ss.len() {
    let s: TraitSuperSig = ss.get(i);
    if s.mod_path == mod_path && s.name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn trait_method_exists(ms: Vec[TraitMethodSig], name: String) -> bool {
  let mut i: i32 = 0;
  while i < ms.len() {
    if ms.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn trait_method_param_names(ps: Vec[ast.Param]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < ps.len() {
    out.push(ps.get(i).name);
    i = i + 1;
  }
  return out;
}

fn impl_method_decl_idx(ds: Vec[ast.FuncDecl], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < ds.len() {
    if ds.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn fresh_impl_lowered_name(c: Ctx, mod_path: String, ts: TraitSig, method: String, seed: i32) -> String {
  let mut n: i32 = seed;
  while true {
    let lowered: String = impl_lowered_name(ts, method, n);
    let ex: FindFuncResult = find_func(c, mod_path, lowered);
    if !ex.found { return lowered; }
    n = n + 1;
  }
  return impl_lowered_name(ts, method, seed);
}

fn impl_method_decl_name_unique(ds: Vec[ast.FuncDecl], name: String, idx: i32) -> bool {
  let mut i: i32 = 0;
  while i < ds.len() {
    if i != idx && ds.get(i).name == name { return false; }
    i = i + 1;
  }
  return true;
}

fn impl_lowered_name(ts: TraitSig, method: String, nth: i32) -> String {
  let mut m: String = ts.mod_path;
  let mut i: i32 = 0;
  while i < m.len() {
    if m.byte_at(i) == 47 { m = m.slice(0, i).concat(".").concat(m.slice(i + 1, m.len())); }
    i = i + 1;
  }
  return "impl$".concat(m).concat("$").concat(ts.name).concat("$").concat(method).concat("$").concat(nth.to_string());
}

fn trait_method_sig_for(ctx: Ctx, ms: TraitMethodSig, for_ty: i32) -> FuncSig {
  let mut subs: Vec[TySub] = Vec();
  subs.push(TySub { name: "Self", ty: for_ty });

  let mut ps: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < ms.sig.params.len() {
    ps.push(subst_ty(ctx, ms.sig.params.get(i), subs));
    i = i + 1;
  }
  let ret: i32 = subst_ty(ctx, ms.sig.ret, subs);
  return FuncSig {
    params: ps,
    ret: ret,
    is_pub: false,
    type_params: ms.sig.type_params,
    type_param_bounds: ms.sig.type_param_bounds,
  };
}

fn impl_decl_file(w: World, mod_path: String, decl_idx: i32) -> String {
  let fm: FindModResult = find_mod(w, mod_path);
  if !fm.found { return ""; }
  let m: WorldModule = w.mods.get(fm.idx);
  if decl_idx < 0 || decl_idx >= m.prog.impls.len() { return ""; }
  return m.prog.impls.get(decl_idx).file;
}

fn collect_traits(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ti: i32 = 0;
    while ti < m.prog.traits.len() {
      let td: ast.TraitDecl = m.prog.traits.get(ti);
      if is_reserved_intrinsic_name(td.name) {
        return TcCtxResult { ok: false, err: type_error(td.file, "reserved name: ".concat(td.name)), ctx: c };
      }
      if has_trait_name(c, m.path, td.name) {
        return TcCtxResult { ok: false, err: type_error(td.file, "duplicate trait: ".concat(td.name)), ctx: c };
      }

      let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, td.file);
      if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
      let imps: Imports = ir.imps;

      let mut supers: Vec[TraitSuperSig] = Vec();
      let mut si: i32 = 0;
      while si < td.supers.len() {
        let sr: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, td.supers.get(si));
        if !sr.ok { return TcCtxResult { ok: false, err: type_error(td.file, "bad supertrait path"), ctx: c }; }
        let sf: FindTraitResult = find_trait(c, sr.mod_path, sr.name);
        if !sf.found { return TcCtxResult { ok: false, err: type_error(td.file, "unknown supertrait"), ctx: c }; }
        if sr.mod_path != m.path && !sf.sig.is_pub {
          return TcCtxResult { ok: false, err: type_error(td.file, "supertrait is private"), ctx: c };
        }
        if sr.mod_path == m.path && sr.name == td.name {
          return TcCtxResult { ok: false, err: type_error(td.file, "trait cannot inherit from itself"), ctx: c };
        }
        if !has_super_sig(supers, sr.mod_path, sr.name) {
          supers.push(TraitSuperSig { mod_path: sr.mod_path, name: sr.name });
        }
        si = si + 1;
      }

      let mut ms: Vec[TraitMethodSig] = Vec();
      let mut fi: i32 = 0;
      while fi < td.methods.len() {
        let md: ast.TraitMethodDecl = td.methods.get(fi);
        if trait_method_exists(ms, md.name) {
          return TcCtxResult { ok: false, err: type_error(td.file, "duplicate trait method: ".concat(md.name)), ctx: c };
        }

        let tps_self: Vec[String] = vec_self_tps(md.type_params);
        let mut ps: Vec[i32] = Vec();
        let mut pi: i32 = 0;
        while pi < md.params.len() {
          let pr: ast.Param = md.params.get(pi);
          let tr: ResolveTyResult = resolve_type(c, w, m.path, imps, tps_self, pr.ty);
          c = tr.ctx;
          if !tr.ok {
            return TcCtxResult { ok: false, err: type_error(td.file, "type resolve failed in trait method param"), ctx: c };
          }
          ps.push(tr.idx);
          pi = pi + 1;
        }
        let rr: ResolveTyResult = resolve_type(c, w, m.path, imps, tps_self, md.ret);
        c = rr.ctx;
        if !rr.ok {
          return TcCtxResult { ok: false, err: type_error(td.file, "type resolve failed in trait method ret"), ctx: c };
        }

        let mut tbs: Vec[TypeParamBoundSig] = Vec();
        let mut bi: i32 = 0;
        while bi < md.type_param_bounds.len() {
          let bdecl: ast.TypeParamBoundsDecl = md.type_param_bounds.get(bi);
          if !contains_str_local(md.type_params, bdecl.name) {
            return TcCtxResult { ok: false, err: type_error(td.file, "unknown type param in trait method bound: ".concat(bdecl.name)), ctx: c };
          }
          let mut bj: i32 = 0;
          while bj < bdecl.bounds.len() {
            let rtr: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, bdecl.bounds.get(bj));
            if !rtr.ok {
              return TcCtxResult { ok: false, err: type_error(td.file, "bad trait method bound"), ctx: c };
            }
            let tf2: FindTraitResult = find_trait(c, rtr.mod_path, rtr.name);
            if !tf2.found {
              return TcCtxResult { ok: false, err: type_error(td.file, "unknown trait in method bound"), ctx: c };
            }
            if rtr.mod_path != m.path && !tf2.sig.is_pub {
              return TcCtxResult { ok: false, err: type_error(td.file, "trait method bound refers to private trait"), ctx: c };
            }
            if !has_bound_sig(tbs, bdecl.name, rtr.mod_path, rtr.name) {
              tbs.push(TypeParamBoundSig { type_param: bdecl.name, trait_mod_path: rtr.mod_path, trait_name: rtr.name });
            }
            bj = bj + 1;
          }
          bi = bi + 1;
        }
        ms.push(TraitMethodSig {
          name: md.name,
          sig: FuncSig { params: ps, ret: rr.idx, is_pub: true, type_params: md.type_params, type_param_bounds: tbs },
          has_default: md.has_body,
          default_mod_path: m.path,
          default_file: td.file,
          default_params: trait_method_param_names(md.params),
          default_body: md.body,
        });
        fi = fi + 1;
      }

      c.traits.push(TraitSig { mod_path: m.path, name: td.name, is_pub: td.is_pub, supers: supers, methods: ms });
      ti = ti + 1;
    }
    mi = mi + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn collect_impls(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ii: i32 = 0;
    while ii < m.prog.impls.len() {
      let id: ast.ImplDecl = m.prog.impls.get(ii);
      let imr: ImportsResult = build_imports(w, m.path, m.prog.imports, id.file);
      if !imr.ok { return TcCtxResult { ok: false, err: imr.err, ctx: c }; }
      let imps: Imports = imr.imps;

      let trr: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, id.trait_name);
      if !trr.ok {
        return TcCtxResult { ok: false, err: type_error(id.file, "bad trait path in impl"), ctx: c };
      }
      let tf: FindTraitResult = find_trait(c, trr.mod_path, trr.name);
      if !tf.found {
        return TcCtxResult { ok: false, err: type_error(id.file, "unknown trait in impl"), ctx: c };
      }
      if trr.mod_path != m.path && !tf.sig.is_pub {
        return TcCtxResult { ok: false, err: type_error(id.file, "trait is private"), ctx: c };
      }

      let fr: ResolveTyResult = resolve_type(c, w, m.path, imps, Vec(), id.for_ty);
      c = fr.ctx;
      if !fr.ok {
        return TcCtxResult { ok: false, err: type_error(id.file, "bad impl target type"), ctx: c };
      }
      let for_ty: i32 = strip_range(c, fr.idx);
      let for_t: ir.Ty = ir.ty_pool_get(c.pool, for_ty);
      let trait_local: bool = trr.mod_path == m.path;
      let type_local: bool = ty_mod(for_t) == m.path;
      if !trait_local && !type_local {
        return TcCtxResult { ok: false, err: type_error(id.file, "orphan impl is not allowed"), ctx: c };
      }

      let dup: FindImplResult = find_impl(c, trr.mod_path, trr.name, for_ty);
      if dup.found {
        return TcCtxResult { ok: false, err: type_error(id.file, "duplicate impl"), ctx: c };
      }

      let mut ims: Vec[ImplMethodSig] = Vec();
      let mut tm: i32 = 0;
      while tm < tf.sig.methods.len() {
        let tms: TraitMethodSig = tf.sig.methods.get(tm);
        let mdi: i32 = impl_method_decl_idx(id.methods, tms.name);
        if mdi == -1 {
          if !tms.has_default {
            return TcCtxResult { ok: false, err: type_error(id.file, "impl missing trait method: ".concat(tms.name)), ctx: c };
          }

          let want0: FuncSig = trait_method_sig_for(c, tms, for_ty);
          let lowered0: String = fresh_impl_lowered_name(c, m.path, tf.sig, tms.name, c.impls.len() * 1000 + 500 + tm);
          c.funcs.push(FuncSym { mod_path: m.path, name: lowered0, sig: want0 });
          ims.push(ImplMethodSig {
            name: tms.name,
            lowered_name: lowered0,
            sig: want0,
            from_default: true,
            default_mod_path: tms.default_mod_path,
            default_file: tms.default_file,
            default_params: tms.default_params,
            default_body: tms.default_body,
          });
          tm = tm + 1;
          continue;
        }
        if !impl_method_decl_name_unique(id.methods, tms.name, mdi) {
          return TcCtxResult { ok: false, err: type_error(id.file, "duplicate impl method: ".concat(tms.name)), ctx: c };
        }

        let md: ast.FuncDecl = id.methods.get(mdi);
        let want: FuncSig = trait_method_sig_for(c, tms, for_ty);
        if md.type_params.len() != want.type_params.len() {
          return TcCtxResult { ok: false, err: type_error(md.file, "impl method type param count mismatch"), ctx: c };
        }

        // Impl method generic param names may differ from trait method names;
        // map impl names to trait names positionally for type/bound comparison.
        let mut impl_to_trait_tps: Vec[TySub] = Vec();
        let mut tpi: i32 = 0;
        while tpi < md.type_params.len() {
          let trtp: ResolveTyResult = resolve_type(c, w, m.path, imps, want.type_params, type_name1(want.type_params.get(tpi)));
          c = trtp.ctx;
          if !trtp.ok { return TcCtxResult { ok: false, err: type_error(md.file, "impl method type param resolve failed"), ctx: c }; }
          impl_to_trait_tps.push(TySub { name: md.type_params.get(tpi), ty: trtp.idx });
          tpi = tpi + 1;
        }

        let mut got_tbs: Vec[TypeParamBoundSig] = Vec();
        let mut bi2: i32 = 0;
        while bi2 < md.type_param_bounds.len() {
          let bdecl2: ast.TypeParamBoundsDecl = md.type_param_bounds.get(bi2);
          if !contains_str_local(md.type_params, bdecl2.name) {
            return TcCtxResult { ok: false, err: type_error(md.file, "unknown type param in impl method bound: ".concat(bdecl2.name)), ctx: c };
          }
          let bpos: i32 = type_param_pos(md.type_params, bdecl2.name);
          if bpos < 0 { return TcCtxResult { ok: false, err: type_error(md.file, "unknown type param in impl method bound: ".concat(bdecl2.name)), ctx: c }; }
          let btp: String = want.type_params.get(bpos);
          let mut bj2: i32 = 0;
          while bj2 < bdecl2.bounds.len() {
            let rtr2: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, bdecl2.bounds.get(bj2));
            if !rtr2.ok { return TcCtxResult { ok: false, err: type_error(md.file, "bad impl method bound"), ctx: c }; }
            let tf3: FindTraitResult = find_trait(c, rtr2.mod_path, rtr2.name);
            if !tf3.found { return TcCtxResult { ok: false, err: type_error(md.file, "unknown trait in impl method bound"), ctx: c }; }
            if rtr2.mod_path != m.path && !tf3.sig.is_pub {
              return TcCtxResult { ok: false, err: type_error(md.file, "impl method bound refers to private trait"), ctx: c };
            }
            if !has_bound_sig(got_tbs, btp, rtr2.mod_path, rtr2.name) {
              got_tbs.push(TypeParamBoundSig { type_param: btp, trait_mod_path: rtr2.mod_path, trait_name: rtr2.name });
            }
            bj2 = bj2 + 1;
          }
          bi2 = bi2 + 1;
        }
        if got_tbs.len() != want.type_param_bounds.len() {
          return TcCtxResult { ok: false, err: type_error(md.file, "impl method type param bounds mismatch"), ctx: c };
        }
        let mut bi3: i32 = 0;
        while bi3 < got_tbs.len() {
          let b: TypeParamBoundSig = got_tbs.get(bi3);
          if !has_bound_sig(want.type_param_bounds, b.type_param, b.trait_mod_path, b.trait_name) {
            return TcCtxResult { ok: false, err: type_error(md.file, "impl method type param bounds mismatch"), ctx: c };
          }
          bi3 = bi3 + 1;
        }

        if md.params.len() != want.params.len() {
          return TcCtxResult { ok: false, err: type_error(md.file, "impl method param count mismatch"), ctx: c };
        }

        let mut pi: i32 = 0;
        while pi < md.params.len() {
          let pr: ast.Param = md.params.get(pi);
          let rr: ResolveTyResult = resolve_type(c, w, m.path, imps, md.type_params, pr.ty);
          c = rr.ctx;
          if !rr.ok { return TcCtxResult { ok: false, err: type_error(md.file, "impl method param type resolve failed"), ctx: c }; }
          let gotp: i32 = subst_ty(c, rr.idx, impl_to_trait_tps);
          if gotp != want.params.get(pi) { return TcCtxResult { ok: false, err: type_error(md.file, "impl method param type mismatch"), ctx: c }; }
          pi = pi + 1;
        }
        let ret_r: ResolveTyResult = resolve_type(c, w, m.path, imps, md.type_params, md.ret);
        c = ret_r.ctx;
        if !ret_r.ok { return TcCtxResult { ok: false, err: type_error(md.file, "impl method ret type resolve failed"), ctx: c }; }
        if subst_ty(c, ret_r.idx, impl_to_trait_tps) != want.ret { return TcCtxResult { ok: false, err: type_error(md.file, "impl method ret type mismatch"), ctx: c }; }

        let lowered: String = fresh_impl_lowered_name(c, m.path, tf.sig, tms.name, c.impls.len() * 1000 + mdi);
        c.funcs.push(FuncSym { mod_path: m.path, name: lowered, sig: want });
        ims.push(ImplMethodSig {
          name: tms.name,
          lowered_name: lowered,
          sig: want,
          from_default: false,
          default_mod_path: "",
          default_file: "",
          default_params: Vec(),
          default_body: ast.Block { stmts: Vec() },
        });
        tm = tm + 1;
      }

      // Reject methods that are not part of the trait.
      let mut extra_i: i32 = 0;
      while extra_i < id.methods.len() {
        let md2: ast.FuncDecl = id.methods.get(extra_i);
        let tmf: FindTraitMethodResult = find_trait_method(tf.sig, md2.name);
        if !tmf.found {
          return TcCtxResult { ok: false, err: type_error(md2.file, "impl method not in trait: ".concat(md2.name)), ctx: c };
        }
        extra_i = extra_i + 1;
      }

      c.impls.push(ImplSig {
        mod_path: m.path,
        decl_idx: ii,
        trait_mod_path: trr.mod_path,
        trait_name: trr.name,
        for_ty: for_ty,
        methods: ims,
      });
      ii = ii + 1;
    }
    mi = mi + 1;
  }

  // Validate supertrait requirements after all impls are collected (order-independent).
  let mut ii2: i32 = 0;
  while ii2 < c.impls.len() {
    let isg: ImplSig = c.impls.get(ii2);
    let tf2: FindTraitResult = find_trait(c, isg.trait_mod_path, isg.trait_name);
    if !tf2.found {
      return TcCtxResult { ok: false, err: type_error(impl_decl_file(w, isg.mod_path, isg.decl_idx), "unknown trait in impl"), ctx: c };
    }
    let mut si2: i32 = 0;
    while si2 < tf2.sig.supers.len() {
      let sup: TraitSuperSig = tf2.sig.supers.get(si2);
      let fi2: FindImplResult = find_impl(c, sup.mod_path, sup.name, isg.for_ty);
      if !fi2.found {
        let msg: String = "impl of ".concat(isg.trait_name).concat(" requires supertrait ").concat(sup.name);
        return TcCtxResult { ok: false, err: type_error(impl_decl_file(w, isg.mod_path, isg.decl_idx), msg), ctx: c };
      }
      si2 = si2 + 1;
    }
    ii2 = ii2 + 1;
  }

  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}
