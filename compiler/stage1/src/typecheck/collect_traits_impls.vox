import "ast" as ast
import "ir" as ir

struct ResolveTraitRefResult { ok: bool, mod_path: String, name: String }

fn vec_self() -> Vec[String] {
  let mut v: Vec[String] = Vec();
  v.push("Self");
  return v;
}

fn vec_self_tps(tps: Vec[String]) -> Vec[String] {
  let mut v: Vec[String] = vec_self();
  let mut i: i32 = 0;
  while i < tps.len() {
    v.push(tps.get(i));
    i = i + 1;
  }
  return v;
}

fn type_name1(s: String) -> ast.TypeName {
  let mut ps: Vec[String] = Vec();
  ps.push(s);
  return ast.TypeName { parts: ps, args: Vec() };
}

fn type_param_pos(tps: Vec[String], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < tps.len() {
    if tps.get(i) == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn resolve_trait_ref(ctx: Ctx, _w: World, cur_mod: String, imps: Imports, tn: ast.TypeName) -> ResolveTraitRefResult {
  if tn.args.len() != 0 { return ResolveTraitRefResult { ok: false, mod_path: "", name: "" }; }
  if tn.parts.len() == 1 {
    let name0: String = tn.parts.get(0);
    let ni: NamedTypeImport = find_named_type(imps.named_types, name0);
    if ni.local != "" {
      if ni.kind != named_type_kind_trait() { return ResolveTraitRefResult { ok: false, mod_path: "", name: "" }; }
      return ResolveTraitRefResult { ok: true, mod_path: ni.mod_path, name: ni.name };
    }
    let fl: FindTraitResult = find_trait(ctx, cur_mod, name0);
    if fl.found { return ResolveTraitRefResult { ok: true, mod_path: cur_mod, name: name0 }; }
    let prelude: String = "std/prelude";
    let fp: FindTraitResult = find_trait(ctx, prelude, name0);
    if fp.found && vis_allows(fp.sig.vis, prelude, cur_mod) {
      return ResolveTraitRefResult { ok: true, mod_path: prelude, name: name0 };
    }
    return ResolveTraitRefResult { ok: true, mod_path: cur_mod, name: name0 };
  }
  if tn.parts.len() == 2 {
    let mp: String = find_alias(imps.aliases, tn.parts.get(0));
    if mp == "" { return ResolveTraitRefResult { ok: false, mod_path: "", name: "" }; }
    return ResolveTraitRefResult { ok: true, mod_path: mp, name: tn.parts.get(1) };
  }
  return ResolveTraitRefResult { ok: false, mod_path: "", name: "" };
}

fn has_trait_name(ctx: Ctx, mod_path: String, name: String) -> bool {
  let mut i: i32 = 0;
  while i < ctx.traits.len() {
    let t: TraitSig = ctx.traits.get(i);
    if t.mod_path == mod_path && t.name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn has_super_sig(ss: Vec[TraitSuperSig], mod_path: String, name: String) -> bool {
  let mut i: i32 = 0;
  while i < ss.len() {
    let s: TraitSuperSig = ss.get(i);
    if s.mod_path == mod_path && s.name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn trait_method_exists(ms: Vec[TraitMethodSig], name: String) -> bool {
  let mut i: i32 = 0;
  while i < ms.len() {
    if ms.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn trait_assoc_type_exists(as0: Vec[TraitAssocTypeSig], name: String) -> bool {
  let mut i: i32 = 0;
  while i < as0.len() {
    if as0.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn impl_assoc_type_exists(as0: Vec[ImplAssocTypeSig], name: String) -> bool {
  let mut i: i32 = 0;
  while i < as0.len() {
    if as0.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn type_unknown_self_assoc(tn: ast.TypeName, assocs: Vec[TraitAssocTypeSig]) -> String {
  if tn.args.len() == 0 && tn.parts.len() == 2 && tn.parts.get(0) == "Self" {
    let a: String = tn.parts.get(1);
    if !trait_assoc_type_exists(assocs, a) { return a; }
  }
  let mut i: i32 = 0;
  while i < tn.args.len() {
    let r: String = type_unknown_self_assoc(tn.args.get(i), assocs);
    if r != "" { return r; }
    i = i + 1;
  }
  return "";
}

fn impl_self_assoc_binds(for_ty: i32, assocs: Vec[ImplAssocTypeSig]) -> Vec[TypeBind] {
  let mut out: Vec[TypeBind] = Vec();
  out.push(TypeBind { name: "Self", ty: for_ty });
  let mut i: i32 = 0;
  while i < assocs.len() {
    let a: ImplAssocTypeSig = assocs.get(i);
    out.push(TypeBind { name: "Self.".concat(a.name), ty: a.ty });
    i = i + 1;
  }
  return out;
}

fn trait_method_param_names(ps: Vec[ast.Param]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < ps.len() {
    out.push(ps.get(i).name);
    i = i + 1;
  }
  return out;
}

fn impl_method_decl_idx(ds: Vec[ast.FuncDecl], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < ds.len() {
    if ds.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn fresh_impl_lowered_name(c: Ctx, mod_path: String, ts: TraitSig, method: String, seed: i32) -> String {
  let mut n: i32 = seed;
  while true {
    let lowered: String = impl_lowered_name(ts, method, n);
    let ex: FindFuncResult = find_func(c, mod_path, lowered);
    if !ex.found { return lowered; }
    n = n + 1;
  }
  return impl_lowered_name(ts, method, seed);
}

fn impl_method_decl_name_unique(ds: Vec[ast.FuncDecl], name: String, idx: i32) -> bool {
  let mut i: i32 = 0;
  while i < ds.len() {
    if i != idx && ds.get(i).name == name { return false; }
    i = i + 1;
  }
  return true;
}

fn impl_lowered_name(ts: TraitSig, method: String, nth: i32) -> String {
  let mut m: String = ts.mod_path;
  let mut i: i32 = 0;
  while i < m.len() {
    if m.byte_at(i) == 47 { m = m.slice(0, i).concat(".").concat(m.slice(i + 1, m.len())); }
    i = i + 1;
  }
  return "impl$".concat(m).concat("$").concat(ts.name).concat("$").concat(method).concat("$").concat(nth.to_string());
}

fn trait_method_sig_for(ctx: Ctx, ms: TraitMethodSig, for_ty: i32, assocs: Vec[ImplAssocTypeSig]) -> FuncSig {
  let mut subs: Vec[TySub] = Vec();
  subs.push(TySub { name: "Self", ty: for_ty });
  let mut ai: i32 = 0;
  while ai < assocs.len() {
    let a: ImplAssocTypeSig = assocs.get(ai);
    subs.push(TySub { name: "Self.".concat(a.name), ty: a.ty });
    ai = ai + 1;
  }

  let mut ps: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < ms.sig.params.len() {
    ps.push(subst_ty(ctx, ms.sig.params.get(i), subs));
    i = i + 1;
  }
  let ret: i32 = subst_ty(ctx, ms.sig.ret, subs);
  return FuncSig {
    params: ps,
    ret: ret,
    vis: ast.vis_private(),
    is_pub: false,
    type_params: ms.sig.type_params,
    type_param_bounds: ms.sig.type_param_bounds,
  };
}

fn concat_strs(a: Vec[String], b: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < a.len() { out.push(a.get(i)); i = i + 1; }
  let mut j: i32 = 0;
  while j < b.len() { out.push(b.get(j)); j = j + 1; }
  return out;
}

fn concat_bounds(a: Vec[TypeParamBoundSig], b: Vec[TypeParamBoundSig]) -> Vec[TypeParamBoundSig] {
  let mut out: Vec[TypeParamBoundSig] = Vec();
  let mut i: i32 = 0;
  while i < a.len() { out.push(a.get(i)); i = i + 1; }
  let mut j: i32 = 0;
  while j < b.len() {
    let bj: TypeParamBoundSig = b.get(j);
    if !has_bound_sig(out, bj.type_param, bj.trait_mod_path, bj.trait_name) {
      out.push(bj);
    }
    j = j + 1;
  }
  return out;
}

fn impl_method_emit_sig(head_tps: Vec[String], head_tpbs: Vec[TypeParamBoundSig], want: FuncSig) -> FuncSig {
  return FuncSig {
    params: want.params,
    ret: want.ret,
    vis: ast.vis_private(),
    is_pub: false,
    type_params: concat_strs(head_tps, want.type_params),
    type_param_bounds: concat_bounds(head_tpbs, want.type_param_bounds),
  };
}

fn impl_for_ty_overlap(ctx: Ctx, a: i32, b: i32) -> bool {
  let ur1: UnifyResult = unify_ty(ctx, a, b, Vec());
  if ur1.ok { return true; }
  let ur2: UnifyResult = unify_ty(ctx, b, a, Vec());
  return ur2.ok;
}

fn impl_decl_file(w: World, mod_path: String, decl_idx: i32) -> String {
  let fm: FindModResult = find_mod(w, mod_path);
  if !fm.found { return ""; }
  let m: WorldModule = w.mods.get(fm.idx);
  if decl_idx < 0 || decl_idx >= m.prog.impls.len() { return ""; }
  return m.prog.impls.get(decl_idx).file;
}

struct FindWorldTraitDeclResult { found: bool, vis: i32, is_pub: bool, file: String }

fn find_world_trait_decl(w: World, mod_path: String, name: String) -> FindWorldTraitDeclResult {
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    if m.path == mod_path {
      let mut ti: i32 = 0;
      while ti < m.prog.traits.len() {
        let td: ast.TraitDecl = m.prog.traits.get(ti);
        if td.name == name { return FindWorldTraitDeclResult { found: true, vis: td.vis, is_pub: td.is_pub, file: td.file }; }
        ti = ti + 1;
      }
    }
    mi = mi + 1;
  }
  return FindWorldTraitDeclResult { found: false, vis: ast.vis_private(), is_pub: false, file: "" };
}

fn find_trait_idx(ts: Vec[TraitSig], mod_path: String, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < ts.len() {
    let t: TraitSig = ts.get(i);
    if t.mod_path == mod_path && t.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn set_trait_sig(ctx: Ctx, idx: i32, sig: TraitSig) -> Ctx {
  let mut c: Ctx = ctx;
  let mut out: Vec[TraitSig] = Vec();
  let mut i: i32 = 0;
  while i < c.traits.len() {
    if i == idx {
      out.push(sig);
    } else {
      out.push(c.traits.get(i));
    }
    i = i + 1;
  }
  c.traits = out;
  return c;
}

fn contains_i32_local(xs: Vec[i32], x: i32) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == x { return true; }
    i = i + 1;
  }
  return false;
}

fn trait_has_super_cycle(ctx: Ctx, start_idx: i32) -> bool {
  let mut seen: Vec[i32] = Vec();
  let mut work: Vec[i32] = Vec();
  work.push(start_idx);
  let mut wi: i32 = 0;
  while wi < work.len() {
    let cur: i32 = work.get(wi);
    wi = wi + 1;
    let ts: TraitSig = ctx.traits.get(cur);
    let mut si: i32 = 0;
    while si < ts.supers.len() {
      let sup: TraitSuperSig = ts.supers.get(si);
      let next: i32 = find_trait_idx(ctx.traits, sup.mod_path, sup.name);
      if next == start_idx { return true; }
      if next >= 0 && !contains_i32_local(seen, next) {
        seen.push(next);
        work.push(next);
      }
      si = si + 1;
    }
  }
  return false;
}

fn collect_traits(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;

  // Pass 1: register trait names/visibility so supertraits can forward-reference.
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ti: i32 = 0;
    while ti < m.prog.traits.len() {
      let td: ast.TraitDecl = m.prog.traits.get(ti);
      if is_reserved_intrinsic_name(td.name) {
        return TcCtxResult { ok: false, err: type_error(td.file, "reserved name: ".concat(td.name)), ctx: c };
      }
      if has_trait_name(c, m.path, td.name) {
        return TcCtxResult { ok: false, err: type_error(td.file, "duplicate trait: ".concat(td.name)), ctx: c };
      }
      c.traits.push(TraitSig { mod_path: m.path, name: td.name, vis: td.vis, is_pub: td.is_pub, supers: Vec(), assoc_types: Vec(), methods: Vec() });
      ti = ti + 1;
    }
    mi = mi + 1;
  }

  // Pass 2: resolve supertraits and method signatures.
  mi = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ti: i32 = 0;
    while ti < m.prog.traits.len() {
      let td: ast.TraitDecl = m.prog.traits.get(ti);
      let idx: i32 = find_trait_idx(c.traits, m.path, td.name);
      if idx < 0 { return TcCtxResult { ok: false, err: type_error(td.file, "internal: trait placeholder missing"), ctx: c }; }

      let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, td.file);
      if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
      let imps: Imports = ir.imps;

      let mut supers: Vec[TraitSuperSig] = Vec();
      let mut si: i32 = 0;
      while si < td.supers.len() {
        let sr: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, td.supers.get(si));
        if !sr.ok { return TcCtxResult { ok: false, err: type_error(td.file, "bad supertrait path"), ctx: c }; }
        let sfw: FindWorldTraitDeclResult = find_world_trait_decl(w, sr.mod_path, sr.name);
        if !sfw.found { return TcCtxResult { ok: false, err: type_error(td.file, "unknown supertrait"), ctx: c }; }
        if !vis_allows(sfw.vis, sr.mod_path, m.path) {
          return TcCtxResult { ok: false, err: type_error(td.file, "supertrait is private"), ctx: c };
        }
        if sr.mod_path == m.path && sr.name == td.name {
          return TcCtxResult { ok: false, err: type_error(td.file, "trait cannot inherit from itself"), ctx: c };
        }
        if !has_super_sig(supers, sr.mod_path, sr.name) {
          supers.push(TraitSuperSig { mod_path: sr.mod_path, name: sr.name });
        }
        si = si + 1;
      }

      let mut assocs: Vec[TraitAssocTypeSig] = Vec();
      let mut ai: i32 = 0;
      while ai < td.assoc_types.len() {
        let ad: ast.TraitAssocTypeDecl = td.assoc_types.get(ai);
        if trait_assoc_type_exists(assocs, ad.name) {
          return TcCtxResult { ok: false, err: type_error(td.file, "duplicate trait associated type: ".concat(ad.name)), ctx: c };
        }
        assocs.push(TraitAssocTypeSig { name: ad.name });
        ai = ai + 1;
      }

      // Make current trait associated types visible while checking its methods.
      // This allows bounds like `T: ThisTrait` to resolve `T.Assoc` correctly.
      c = set_trait_sig(c, idx, TraitSig {
        mod_path: m.path,
        name: td.name,
        vis: td.vis,
        is_pub: td.is_pub,
        supers: supers,
        assoc_types: assocs,
        methods: Vec(),
      });

      let mut ms: Vec[TraitMethodSig] = Vec();
      let mut fi: i32 = 0;
      while fi < td.methods.len() {
        let md: ast.TraitMethodDecl = td.methods.get(fi);
        if trait_method_exists(ms, md.name) {
          return TcCtxResult { ok: false, err: type_error(td.file, "duplicate trait method: ".concat(md.name)), ctx: c };
        }
        if trait_assoc_type_exists(assocs, md.name) {
          return TcCtxResult { ok: false, err: type_error(td.file, "trait method conflicts with associated type: ".concat(md.name)), ctx: c };
        }

        let tps_self: Vec[String] = vec_self_tps(md.type_params);
        let mut ps: Vec[i32] = Vec();
        let mut pi: i32 = 0;
        while pi < md.params.len() {
          let pr: ast.Param = md.params.get(pi);
          let bad_assoc0: String = type_unknown_self_assoc(pr.ty, assocs);
          if bad_assoc0 != "" {
            return TcCtxResult { ok: false, err: type_error(td.file, "unknown associated type in trait method: ".concat(bad_assoc0)), ctx: c };
          }
          let tr: ResolveTyResult = resolve_type(c, w, m.path, imps, tps_self, pr.ty);
          c = tr.ctx;
          if !tr.ok {
            return TcCtxResult { ok: false, err: type_error(td.file, "type resolve failed in trait method param"), ctx: c };
          }
          ps.push(tr.idx);
          pi = pi + 1;
        }
        let bad_assoc1: String = type_unknown_self_assoc(md.ret, assocs);
        if bad_assoc1 != "" {
          return TcCtxResult { ok: false, err: type_error(td.file, "unknown associated type in trait method: ".concat(bad_assoc1)), ctx: c };
        }
        let rr: ResolveTyResult = resolve_type(c, w, m.path, imps, tps_self, md.ret);
        c = rr.ctx;
        if !rr.ok {
          return TcCtxResult { ok: false, err: type_error(td.file, "type resolve failed in trait method ret"), ctx: c };
        }

        let mut tbs: Vec[TypeParamBoundSig] = Vec();
        let mut bi: i32 = 0;
        while bi < md.type_param_bounds.len() {
          let bdecl: ast.TypeParamBoundsDecl = md.type_param_bounds.get(bi);
          if !contains_str_local(md.type_params, bdecl.name) {
            return TcCtxResult { ok: false, err: type_error(td.file, "unknown type param in trait method bound: ".concat(bdecl.name)), ctx: c };
          }
          let mut bj: i32 = 0;
          while bj < bdecl.bounds.len() {
            let rtr: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, bdecl.bounds.get(bj));
            if !rtr.ok {
              return TcCtxResult { ok: false, err: type_error(td.file, "bad trait method bound"), ctx: c };
            }
            let tf2: FindTraitResult = find_trait(c, rtr.mod_path, rtr.name);
            if !tf2.found {
              return TcCtxResult { ok: false, err: type_error(td.file, "unknown trait in method bound"), ctx: c };
            }
            if !vis_allows(tf2.sig.vis, rtr.mod_path, m.path) {
              return TcCtxResult { ok: false, err: type_error(td.file, "trait method bound refers to private trait"), ctx: c };
            }
            if !has_bound_sig(tbs, bdecl.name, rtr.mod_path, rtr.name) {
              tbs.push(TypeParamBoundSig { type_param: bdecl.name, trait_mod_path: rtr.mod_path, trait_name: rtr.name });
            }
            bj = bj + 1;
          }
          bi = bi + 1;
        }
        let mut pji: i32 = 0;
        while pji < md.params.len() {
          let prj: ast.Param = md.params.get(pji);
          let perr0: String = projection_bound_issue(c, md.type_params, tbs, prj.ty);
          if perr0 != "" {
            return TcCtxResult { ok: false, err: type_error(td.file, perr0), ctx: c };
          }
          pji = pji + 1;
        }
        let perr1: String = projection_bound_issue(c, md.type_params, tbs, md.ret);
        if perr1 != "" {
          return TcCtxResult { ok: false, err: type_error(td.file, perr1), ctx: c };
        }
        ms.push(TraitMethodSig {
          name: md.name,
          sig: FuncSig { params: ps, ret: rr.idx, vis: ast.vis_pub(), is_pub: true, type_params: md.type_params, type_param_bounds: tbs },
          has_default: md.has_body,
          default_mod_path: m.path,
          default_file: td.file,
          default_params: trait_method_param_names(md.params),
          default_body: md.body,
        });
        fi = fi + 1;
      }

      c = set_trait_sig(c, idx, TraitSig { mod_path: m.path, name: td.name, vis: td.vis, is_pub: td.is_pub, supers: supers, assoc_types: assocs, methods: ms });
      ti = ti + 1;
    }
    mi = mi + 1;
  }

  // Reject supertrait cycles.
  let mut ci: i32 = 0;
  while ci < c.traits.len() {
    if trait_has_super_cycle(c, ci) {
      let ts: TraitSig = c.traits.get(ci);
      let tdecl: FindWorldTraitDeclResult = find_world_trait_decl(w, ts.mod_path, ts.name);
      let file: String = if tdecl.found { tdecl.file } else { "" };
      return TcCtxResult { ok: false, err: type_error(file, "supertrait cycle detected: ".concat(ts.name)), ctx: c };
    }
    ci = ci + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn collect_impls(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ii: i32 = 0;
    while ii < m.prog.impls.len() {
      let id: ast.ImplDecl = m.prog.impls.get(ii);
      let imr: ImportsResult = build_imports(w, m.path, m.prog.imports, id.file);
      if !imr.ok { return TcCtxResult { ok: false, err: imr.err, ctx: c }; }
      let imps: Imports = imr.imps;

      let trr: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, id.trait_name);
      if !trr.ok {
        return TcCtxResult { ok: false, err: type_error(id.file, "bad trait path in impl"), ctx: c };
      }
      let tf: FindTraitResult = find_trait(c, trr.mod_path, trr.name);
      if !tf.found {
        return TcCtxResult { ok: false, err: type_error(id.file, "unknown trait in impl"), ctx: c };
      }
      if !vis_allows(tf.sig.vis, trr.mod_path, m.path) {
        return TcCtxResult { ok: false, err: type_error(id.file, "trait is private"), ctx: c };
      }

      let mut head_tpbs: Vec[TypeParamBoundSig] = Vec();
      let mut bi0: i32 = 0;
      while bi0 < id.type_param_bounds.len() {
        let bdecl0: ast.TypeParamBoundsDecl = id.type_param_bounds.get(bi0);
        if !contains_str_local(id.type_params, bdecl0.name) {
          return TcCtxResult { ok: false, err: type_error(id.file, "unknown type param in impl bound: ".concat(bdecl0.name)), ctx: c };
        }
        let mut bj0: i32 = 0;
        while bj0 < bdecl0.bounds.len() {
          let rtr0: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, bdecl0.bounds.get(bj0));
          if !rtr0.ok { return TcCtxResult { ok: false, err: type_error(id.file, "bad impl type bound"), ctx: c }; }
          let tf0: FindTraitResult = find_trait(c, rtr0.mod_path, rtr0.name);
          if !tf0.found { return TcCtxResult { ok: false, err: type_error(id.file, "unknown trait in impl bound"), ctx: c }; }
          if !vis_allows(tf0.sig.vis, rtr0.mod_path, m.path) {
            return TcCtxResult { ok: false, err: type_error(id.file, "impl bound refers to private trait"), ctx: c };
          }
          if !has_bound_sig(head_tpbs, bdecl0.name, rtr0.mod_path, rtr0.name) {
            head_tpbs.push(TypeParamBoundSig { type_param: bdecl0.name, trait_mod_path: rtr0.mod_path, trait_name: rtr0.name });
          }
          bj0 = bj0 + 1;
        }
        bi0 = bi0 + 1;
      }

      let fr: ResolveTyResult = resolve_type(c, w, m.path, imps, id.type_params, id.for_ty);
      c = fr.ctx;
      if !fr.ok {
        return TcCtxResult { ok: false, err: type_error(id.file, "bad impl target type"), ctx: c };
      }
      let for_ty: i32 = strip_range(c, fr.idx);
      let for_t: ir.Ty = ir.ty_pool_get(c.pool, for_ty);
      let trait_local: bool = trr.mod_path == m.path;
      let type_local: bool = ty_mod(for_t) == m.path;
      if !trait_local && !type_local {
        return TcCtxResult { ok: false, err: type_error(id.file, "orphan impl is not allowed"), ctx: c };
      }

      let mut di: i32 = 0;
      while di < c.impls.len() {
        let ds: ImplSig = c.impls.get(di);
        if ds.trait_mod_path == trr.mod_path && ds.trait_name == trr.name {
          if impl_for_ty_overlap(c, ds.for_ty, for_ty) {
            return TcCtxResult { ok: false, err: type_error(id.file, "duplicate impl"), ctx: c };
          }
        }
        di = di + 1;
      }

      let mut impl_assocs: Vec[ImplAssocTypeSig] = Vec();
      let mut ai2: i32 = 0;
      while ai2 < id.assoc_types.len() {
        let ad2: ast.ImplAssocTypeBinding = id.assoc_types.get(ai2);
        if impl_assoc_type_exists(impl_assocs, ad2.name) {
          return TcCtxResult { ok: false, err: type_error(id.file, "duplicate impl associated type: ".concat(ad2.name)), ctx: c };
        }
        if !trait_assoc_type_exists(tf.sig.assoc_types, ad2.name) {
          return TcCtxResult { ok: false, err: type_error(id.file, "impl associated type not in trait: ".concat(ad2.name)), ctx: c };
        }
        let ar2: ResolveTyResult = resolve_type(c, w, m.path, imps, id.type_params, ad2.ty);
        c = ar2.ctx;
        if !ar2.ok {
          return TcCtxResult { ok: false, err: type_error(id.file, "impl associated type resolve failed: ".concat(ad2.name)), ctx: c };
        }
        impl_assocs.push(ImplAssocTypeSig { name: ad2.name, ty: ar2.idx });
        ai2 = ai2 + 1;
      }
      let mut ai3: i32 = 0;
      while ai3 < tf.sig.assoc_types.len() {
        let ta: TraitAssocTypeSig = tf.sig.assoc_types.get(ai3);
        if !impl_assoc_type_exists(impl_assocs, ta.name) {
          return TcCtxResult { ok: false, err: type_error(id.file, "impl missing associated type: ".concat(ta.name)), ctx: c };
        }
        ai3 = ai3 + 1;
      }

      let mut ims: Vec[ImplMethodSig] = Vec();
      let mut tm: i32 = 0;
      while tm < tf.sig.methods.len() {
        let tms: TraitMethodSig = tf.sig.methods.get(tm);
        let mdi: i32 = impl_method_decl_idx(id.methods, tms.name);
        if mdi == -1 {
          if !tms.has_default {
            let ms: String = trait_method_candidates_text(tf.sig);
            let msg: String = "impl missing trait method: ".concat(tms.name).concat(" (required methods: ").concat(ms).concat(")");
            return TcCtxResult { ok: false, err: type_error(id.file, msg), ctx: c };
          }

          let want0: FuncSig = trait_method_sig_for(c, tms, for_ty, impl_assocs);
          let emit0: FuncSig = impl_method_emit_sig(id.type_params, head_tpbs, want0);
          let lowered0: String = fresh_impl_lowered_name(c, m.path, tf.sig, tms.name, c.impls.len() * 1000 + 500 + tm);
          c.funcs.push(FuncSym { mod_path: m.path, name: lowered0, sig: emit0 });
          ims.push(ImplMethodSig {
            name: tms.name,
            lowered_name: lowered0,
            sig: emit0,
            from_default: true,
            default_mod_path: tms.default_mod_path,
            default_file: tms.default_file,
            default_params: tms.default_params,
            default_body: tms.default_body,
          });
          tm = tm + 1;
          continue;
        }
        if !impl_method_decl_name_unique(id.methods, tms.name, mdi) {
          return TcCtxResult { ok: false, err: type_error(id.file, "duplicate impl method: ".concat(tms.name)), ctx: c };
        }

        let md: ast.FuncDecl = id.methods.get(mdi);
        let want: FuncSig = trait_method_sig_for(c, tms, for_ty, impl_assocs);
        let mut hpi: i32 = 0;
        while hpi < id.type_params.len() {
          if contains_str_local(md.type_params, id.type_params.get(hpi)) {
            return TcCtxResult { ok: false, err: type_error(md.file, "impl method type param duplicates impl type param"), ctx: c };
          }
          hpi = hpi + 1;
        }
        if md.type_params.len() != want.type_params.len() {
          return TcCtxResult { ok: false, err: type_error(md.file, "impl method type param count mismatch"), ctx: c };
        }

        // Impl method generic param names may differ from trait method names;
        // map impl names to trait names positionally for type/bound comparison.
        let mut impl_to_trait_tps: Vec[TySub] = Vec();
        let mut tpi: i32 = 0;
        while tpi < md.type_params.len() {
          let trtp: ResolveTyResult = resolve_type(c, w, m.path, imps, want.type_params, type_name1(want.type_params.get(tpi)));
          c = trtp.ctx;
          if !trtp.ok { return TcCtxResult { ok: false, err: type_error(md.file, "impl method type param resolve failed"), ctx: c }; }
          impl_to_trait_tps.push(TySub { name: md.type_params.get(tpi), ty: trtp.idx });
          tpi = tpi + 1;
        }

        let mut got_tbs: Vec[TypeParamBoundSig] = Vec();
        let mut bi2: i32 = 0;
        while bi2 < md.type_param_bounds.len() {
          let bdecl2: ast.TypeParamBoundsDecl = md.type_param_bounds.get(bi2);
          if !contains_str_local(md.type_params, bdecl2.name) {
            return TcCtxResult { ok: false, err: type_error(md.file, "unknown type param in impl method bound: ".concat(bdecl2.name)), ctx: c };
          }
          let bpos: i32 = type_param_pos(md.type_params, bdecl2.name);
          if bpos < 0 { return TcCtxResult { ok: false, err: type_error(md.file, "unknown type param in impl method bound: ".concat(bdecl2.name)), ctx: c }; }
          let btp: String = want.type_params.get(bpos);
          let mut bj2: i32 = 0;
          while bj2 < bdecl2.bounds.len() {
            let rtr2: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, bdecl2.bounds.get(bj2));
            if !rtr2.ok { return TcCtxResult { ok: false, err: type_error(md.file, "bad impl method bound"), ctx: c }; }
            let tf3: FindTraitResult = find_trait(c, rtr2.mod_path, rtr2.name);
            if !tf3.found { return TcCtxResult { ok: false, err: type_error(md.file, "unknown trait in impl method bound"), ctx: c }; }
            if !vis_allows(tf3.sig.vis, rtr2.mod_path, m.path) {
              return TcCtxResult { ok: false, err: type_error(md.file, "impl method bound refers to private trait"), ctx: c };
            }
            if !has_bound_sig(got_tbs, btp, rtr2.mod_path, rtr2.name) {
              got_tbs.push(TypeParamBoundSig { type_param: btp, trait_mod_path: rtr2.mod_path, trait_name: rtr2.name });
            }
            bj2 = bj2 + 1;
          }
          bi2 = bi2 + 1;
        }
        let mut bi3: i32 = 0;
        while bi3 < want.type_param_bounds.len() {
          let b: TypeParamBoundSig = want.type_param_bounds.get(bi3);
          if !has_bound_sig(got_tbs, b.type_param, b.trait_mod_path, b.trait_name) {
            let msg: String = "impl method missing type bound: ".concat(b.type_param).concat(": ").concat(b.trait_name);
            return TcCtxResult { ok: false, err: type_error(md.file, msg), ctx: c };
          }
          bi3 = bi3 + 1;
        }
        let mut bi4: i32 = 0;
        while bi4 < got_tbs.len() {
          let b2: TypeParamBoundSig = got_tbs.get(bi4);
          if !has_bound_sig(want.type_param_bounds, b2.type_param, b2.trait_mod_path, b2.trait_name) {
            let msg2: String = "impl method has extra type bound: ".concat(b2.type_param).concat(": ").concat(b2.trait_name);
            return TcCtxResult { ok: false, err: type_error(md.file, msg2), ctx: c };
          }
          bi4 = bi4 + 1;
        }

        if md.params.len() != want.params.len() {
          return TcCtxResult { ok: false, err: type_error(md.file, "impl method param count mismatch"), ctx: c };
        }

        let mut pi: i32 = 0;
        while pi < md.params.len() {
          let pr: ast.Param = md.params.get(pi);
          let rr: ResolveTyResult = resolve_type_bound(c, w, m.path, imps, concat_strs(id.type_params, md.type_params), impl_self_assoc_binds(for_ty, impl_assocs), pr.ty);
          c = rr.ctx;
          if !rr.ok { return TcCtxResult { ok: false, err: type_error(md.file, "impl method param type resolve failed"), ctx: c }; }
          let gotp: i32 = subst_ty(c, rr.idx, impl_to_trait_tps);
          if gotp != want.params.get(pi) { return TcCtxResult { ok: false, err: type_error(md.file, "impl method param type mismatch"), ctx: c }; }
          pi = pi + 1;
        }
        let ret_r: ResolveTyResult = resolve_type_bound(c, w, m.path, imps, concat_strs(id.type_params, md.type_params), impl_self_assoc_binds(for_ty, impl_assocs), md.ret);
        c = ret_r.ctx;
        if !ret_r.ok { return TcCtxResult { ok: false, err: type_error(md.file, "impl method ret type resolve failed"), ctx: c }; }
        if subst_ty(c, ret_r.idx, impl_to_trait_tps) != want.ret { return TcCtxResult { ok: false, err: type_error(md.file, "impl method ret type mismatch"), ctx: c }; }

        let emit_sig: FuncSig = impl_method_emit_sig(id.type_params, head_tpbs, want);
        let lowered: String = fresh_impl_lowered_name(c, m.path, tf.sig, tms.name, c.impls.len() * 1000 + mdi);
        c.funcs.push(FuncSym { mod_path: m.path, name: lowered, sig: emit_sig });
        ims.push(ImplMethodSig {
          name: tms.name,
          lowered_name: lowered,
          sig: emit_sig,
          from_default: false,
          default_mod_path: "",
          default_file: "",
          default_params: Vec(),
          default_body: ast.Block { stmts: Vec() },
        });
        tm = tm + 1;
      }

      // Reject methods that are not part of the trait.
      let mut extra_i: i32 = 0;
      while extra_i < id.methods.len() {
        let md2: ast.FuncDecl = id.methods.get(extra_i);
        let tmf: FindTraitMethodResult = find_trait_method(tf.sig, md2.name);
        if !tmf.found {
          let ms2: String = trait_method_candidates_text(tf.sig);
          let msg2: String = "impl method not in trait: ".concat(md2.name).concat(" (available methods: ").concat(ms2).concat(")");
          return TcCtxResult { ok: false, err: type_error(md2.file, msg2), ctx: c };
        }
        extra_i = extra_i + 1;
      }

      c.impls.push(ImplSig {
        mod_path: m.path,
        decl_idx: ii,
        trait_mod_path: trr.mod_path,
        trait_name: trr.name,
        for_ty: for_ty,
        assoc_types: impl_assocs,
        methods: ims,
      });
      ii = ii + 1;
    }
    mi = mi + 1;
  }

  // Validate supertrait requirements after all impls are collected (order-independent).
  let mut ii2: i32 = 0;
  while ii2 < c.impls.len() {
    let isg: ImplSig = c.impls.get(ii2);
    let tf2: FindTraitResult = find_trait(c, isg.trait_mod_path, isg.trait_name);
    if !tf2.found {
      return TcCtxResult { ok: false, err: type_error(impl_decl_file(w, isg.mod_path, isg.decl_idx), "unknown trait in impl"), ctx: c };
    }
    let mut si2: i32 = 0;
    while si2 < tf2.sig.supers.len() {
      let sup: TraitSuperSig = tf2.sig.supers.get(si2);
      let mut has_sup: bool = false;
      let mut sj: i32 = 0;
      while sj < c.impls.len() {
        let cand: ImplSig = c.impls.get(sj);
        if cand.trait_mod_path == sup.mod_path && cand.trait_name == sup.name {
          if impl_for_ty_overlap(c, cand.for_ty, isg.for_ty) {
            has_sup = true;
            sj = c.impls.len();
          }
        }
        sj = sj + 1;
      }
      if !has_sup {
        let msg: String = "impl of ".concat(isg.trait_name).concat(" requires supertrait ").concat(sup.name);
        return TcCtxResult { ok: false, err: type_error(impl_decl_file(w, isg.mod_path, isg.decl_idx), msg), ctx: c };
      }
      si2 = si2 + 1;
    }
    ii2 = ii2 + 1;
  }

  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}
