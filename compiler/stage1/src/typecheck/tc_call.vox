import "ast" as ast
import "ir" as ir

fn trait_is_or_extends(ctx: Ctx, mod_path: String, name: String, want_mod: String, want_name: String) -> bool {
  if mod_path == want_mod && name == want_name { return true; }
  let tf: FindTraitResult = find_trait(ctx, mod_path, name);
  if !tf.found { return false; }
  let mut i: i32 = 0;
  while i < tf.sig.supers.len() {
    let s: TraitSuperSig = tf.sig.supers.get(i);
    if trait_is_or_extends(ctx, s.mod_path, s.name, want_mod, want_name) { return true; }
    i = i + 1;
  }
  return false;
}

struct BoundMethodCand {
  trait_mod_path: String,
  trait_name: String,
  sig: FuncSig,
}

struct BoundMethodSearch {
  seen_traits: Vec[String],
  cands: Vec[BoundMethodCand],
}

fn contains_str_tc_call(xs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn method_cand_key(mod_path: String, trait_name: String) -> String {
  return mod_path.concat("::").concat(trait_name);
}

fn has_method_cand(xs: Vec[BoundMethodCand], mod_path: String, trait_name: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    let c: BoundMethodCand = xs.get(i);
    if c.trait_mod_path == mod_path && c.trait_name == trait_name { return true; }
    i = i + 1;
  }
  return false;
}

fn search_bound_method_in_trait(ctx: Ctx, mod_path: String, trait_name: String, method: String, s0: BoundMethodSearch) -> BoundMethodSearch {
  let mut s: BoundMethodSearch = s0;
  let key: String = method_cand_key(mod_path, trait_name);
  if contains_str_tc_call(s.seen_traits, key) { return s; }
  s.seen_traits.push(key);

  let tf: FindTraitResult = find_trait(ctx, mod_path, trait_name);
  if !tf.found { return s; }
  let tm: FindTraitMethodResult = find_trait_method(tf.sig, method);
  if tm.found && !has_method_cand(s.cands, mod_path, trait_name) {
    s.cands.push(BoundMethodCand { trait_mod_path: mod_path, trait_name: trait_name, sig: tm.m.sig });
  }

  let mut i: i32 = 0;
  while i < tf.sig.supers.len() {
    let sup: TraitSuperSig = tf.sig.supers.get(i);
    s = search_bound_method_in_trait(ctx, sup.mod_path, sup.name, method, s);
    i = i + 1;
  }
  return s;
}

fn find_bound_trait_methods(ctx: Ctx, l0: Locals, type_param: String, method: String) -> BoundMethodSearch {
  let mut s: BoundMethodSearch = BoundMethodSearch { seen_traits: Vec(), cands: Vec() };
  let mut i: i32 = 0;
  while i < l0.type_param_bounds.len() {
    let b: TypeParamBoundSig = l0.type_param_bounds.get(i);
    if b.type_param == type_param {
      s = search_bound_method_in_trait(ctx, b.trait_mod_path, b.trait_name, method, s);
    }
    i = i + 1;
  }
  return s;
}

fn method_cands_text(xs: Vec[BoundMethodCand], method: String) -> String {
  if xs.len() == 0 { return "<none>"; }
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < xs.len() {
    if i > 0 { out = out.concat(", "); }
    let c: BoundMethodCand = xs.get(i);
    out = out.concat(c.trait_name).concat(".").concat(method);
    if i >= 7 { return out.concat(", ..."); }
    i = i + 1;
  }
  return out;
}

fn locals_has_type_param_bound(ctx: Ctx, l0: Locals, type_param: String, trait_mod: String, trait_name: String) -> bool {
  let mut i: i32 = 0;
  while i < l0.type_param_bounds.len() {
    let b: TypeParamBoundSig = l0.type_param_bounds.get(i);
    if b.type_param == type_param && trait_is_or_extends(ctx, b.trait_mod_path, b.trait_name, trait_mod, trait_name) {
      return true;
    }
    i = i + 1;
  }
  return false;
}

fn subst_self_in_sig(ctx: Ctx, sig: FuncSig, recv_ty: i32) -> FuncSig {
  let mut self_subs: Vec[TySub] = Vec();
  self_subs.push(TySub { name: "Self", ty: recv_ty });
  let mut ps: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < sig.params.len() {
    ps.push(subst_ty(ctx, sig.params.get(i), self_subs));
    i = i + 1;
  }
  let rr: i32 = subst_ty(ctx, sig.ret, self_subs);
  return FuncSig { params: ps, ret: rr, is_pub: sig.is_pub, type_params: sig.type_params, type_param_bounds: sig.type_param_bounds };
}

fn tc_expr_call(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, callee: i32, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  // Method calls: `recv.method(...)` for built-in types.
  let cn: ast.ExprNode = ast.expr_pool_get(exprs, callee);
  let is_member: bool = match cn { ast.ExprNode.Member(_, _) => true, _ => false };
  if is_member {
    let recv_id: i32 = match cn { ast.ExprNode.Member(r, _) => r, _ => -1 };
    let mname: String = match cn { ast.ExprNode.Member(_, n) => n, _ => "" };

    let rr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, recv_id, -1);
    if rr.ok && is_vec_ty(ctx, rr.ty) {
      return tc_call_vec_method(ctx, w, mod_path, imps, exprs, l0, rr.ty, mname, args, expected);
    }
    if rr.ok && rr.ty == ctx.ty_string {
      return tc_call_string_method(ctx, w, mod_path, imps, exprs, l0, recv_id, mname, args, expected);
    }
    if rr.ok && mname == "to_string" && (rr.ty == ctx.ty_bool || is_int_like_ty(ctx, rr.ty) || is_float_ty(ctx, rr.ty)) {
      return tc_call_prim_method(ctx, w, mod_path, imps, exprs, l0, recv_id, rr.ty, mname, args, expected);
    }
    if rr.ok {
      let rty: i32 = strip_range(ctx, rr.ty);
      let rt: ir.Ty = ir.ty_pool_get(ctx.pool, rty);
      if rt.kind == ir.TyKind.Param {
        let bm: BoundMethodSearch = find_bound_trait_methods(ctx, l0, rt.name, mname);
        if bm.cands.len() > 1 {
          let msg0: String = "ambiguous trait method call: ".concat(mname).concat(" (candidates: ").concat(method_cands_text(bm.cands, mname)).concat(")");
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg0) };
        }
        if bm.cands.len() == 1 {
          let c0: BoundMethodCand = bm.cands.get(0);
          let msig0: FuncSig = subst_self_in_sig(ctx, c0.sig, rty);
          let mut all_args0: Vec[i32] = Vec();
          all_args0.push(recv_id);
          let mut aj: i32 = 0;
          while aj < args.len() { all_args0.push(args.get(aj)); aj = aj + 1; }
          return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, c0.trait_mod_path, msig0, type_args, all_args0, expected);
        }
      }

      let dm: FindTraitDispatchMethodResult = find_trait_dispatch_method(ctx, mod_path, strip_range(ctx, rr.ty), mname);
      if dm.ambiguous {
        let msg: String = "ambiguous trait method call: ".concat(mname).concat(" (candidates: ").concat(dm.candidates).concat(")");
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg) };
      }
      if dm.found {
        let mut all_args: Vec[i32] = Vec();
        all_args.push(recv_id);
        let mut ai: i32 = 0;
        while ai < args.len() { all_args.push(args.get(ai)); ai = ai + 1; }
        return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, dm.impl_mod_path, dm.m.sig, type_args, all_args, expected);
      }
    }
  }

  // Enum variant shorthand: `.Variant(...)` (enum type must be known from context).
  if match cn { ast.ExprNode.DotIdent(_x) => true, _ => false } {
    if type_args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let et: ir.Ty = ir.ty_pool_get(ctx.pool, expected);
    if et.kind != ir.TyKind.Enum { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let fe: FindEnumResult = find_enum(ctx, ty_mod(et), ty_name(et));
    if !fe.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let es: EnumSig = fe.sig;
    let var_name: String = match cn { ast.ExprNode.DotIdent(s) => s, _ => "" };

    let mut vi: i32 = 0;
    while vi < es.vars.len() {
      let v: EnumVariantSig = es.vars.get(vi);
      if v.name == var_name {
        if v.fields.len() != args.len() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        let mut ai: i32 = 0;
        while ai < args.len() {
          let want: i32 = v.fields.get(ai);
          let ar: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(ai), want);
          if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
          if ar.ty != want { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
          ai = ai + 1;
        }
        return ExprTyResult { ok: true, ty: expected, err: TcError.None };
      }
      vi = vi + 1;
    }
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
  }

  // Path-based calls: `name(...)`, `alias.name(...)`, `Enum.Variant(...)`.
  let pr: ExprPartsResult = expr_parts(exprs, callee);
  if !pr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let parts: Vec[String] = pr.parts;

  // Special: `Vec()` constructor requires expected type `Vec[T]`.
  if parts.len() == 1 && parts.get(0) == "Vec" {
    if type_args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "Vec() requires expected type Vec[T]") }; }
    if !is_vec_ty(ctx, expected) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "Vec() requires expected type Vec[T]") }; }
    return ExprTyResult { ok: true, ty: expected, err: TcError.None };
  }

  // Resolve function call.
  if parts.len() == 1 {
    return tc_call_func_unqualified(ctx, w, mod_path, imps, exprs, l0, call_sp, parts.get(0), type_args, args, expected);
  }
  if parts.len() == 2 {
    let mp: String = find_alias(imps.aliases, parts.get(0));
    if mp != "" {
      return tc_call_func_qualified(ctx, w, mod_path, imps, exprs, l0, call_sp, mp, parts.get(1), type_args, args, expected);
    }
    // Otherwise: `Trait.method(...)` or `Enum.Variant(...)` in current module,
    // or via a named imported type.
    let nt: NamedTypeImport = find_named_type(imps.named_types, parts.get(0));
    if nt.local != "" {
      if nt.kind == named_type_kind_trait() {
        return tc_call_trait_static(ctx, w, mod_path, imps, exprs, l0, call_sp, nt.mod_path, nt.name, parts.get(1), type_args, args, expected);
      }
      if nt.kind != named_type_kind_enum() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      return tc_call_enum_ctor(ctx, w, mod_path, imps, exprs, l0, nt.mod_path, nt.name, parts.get(1), args, expected);
    }

    let ft: FindTraitResult = find_trait(ctx, mod_path, parts.get(0));
    let fe: FindEnumResult = find_enum(ctx, mod_path, parts.get(0));
    if ft.found && fe.found {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "ambiguous call target: ".concat(parts.get(0))) };
    }
    if ft.found {
      return tc_call_trait_static(ctx, w, mod_path, imps, exprs, l0, call_sp, mod_path, parts.get(0), parts.get(1), type_args, args, expected);
    }
    if !fe.found {
      let prelude: String = "std/prelude";
      let fp: FindTraitResult = find_trait(ctx, prelude, parts.get(0));
      if fp.found && fp.sig.is_pub {
        return tc_call_trait_static(ctx, w, mod_path, imps, exprs, l0, call_sp, prelude, parts.get(0), parts.get(1), type_args, args, expected);
      }
    }
    return tc_call_enum_ctor(ctx, w, mod_path, imps, exprs, l0, mod_path, parts.get(0), parts.get(1), args, expected);
  }
  if parts.len() == 3 {
    let mp: String = find_alias(imps.aliases, parts.get(0));
    if mp == "" { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let ft: FindTraitResult = find_trait(ctx, mp, parts.get(1));
    let fe: FindEnumResult = find_enum(ctx, mp, parts.get(1));
    if ft.found && fe.found {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "ambiguous call target: ".concat(parts.get(1))) };
    }
    if ft.found {
      return tc_call_trait_static(ctx, w, mod_path, imps, exprs, l0, call_sp, mp, parts.get(1), parts.get(2), type_args, args, expected);
    }
    return tc_call_enum_ctor(ctx, w, mod_path, imps, exprs, l0, mp, parts.get(1), parts.get(2), args, expected);
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}

fn tc_call_vec_method(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, recv_ty: i32, mname: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  let elem: i32 = vec_elem(ctx, recv_ty);

  if mname == "push" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let ar: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), elem);
    if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_unit { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_unit, err: TcError.None };
  }

  if mname == "len" {
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_i32 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None };
  }

  if mname == "get" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let idxr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_i32);
    if !idxr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != elem { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: elem, err: TcError.None };
  }

  if mname == "join" {
    // Stage0 parity: only Vec[String].join(String) -> String.
    if elem != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let sepr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_string);
    if !sepr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}

fn tc_call_string_method(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, recv_id: i32, mname: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  let _rr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, recv_id, ctx.ty_string);

  if mname == "len" {
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_i32 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None };
  }
  if mname == "byte_at" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let idxr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_i32);
    if !idxr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_i32 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None };
  }
  if mname == "slice" {
    if args.len() != 2 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let sr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_i32);
    if !sr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(1), ctx.ty_i32);
    if !er.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }
  if mname == "concat" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let or: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_string);
    if !or.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }
  if mname == "escape_c" {
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}

fn tc_call_prim_method(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, recv_id: i32, recv_ty: i32, mname: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  if mname != "to_string" { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let rr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, recv_id, recv_ty);
  if !rr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
}

fn tc_call_func_unqualified(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, name: String, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  let nf: NamedFuncImport = find_named_func(imps.named_funcs, name);
  if nf.local != "" {
    let frx: FindFuncResult = find_func(ctx, nf.mod_path, nf.name);
    if !frx.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown fn: ".concat(name)) }; }
    return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, nf.mod_path, frx.sig, type_args, args, expected);
  }
  // Prefer local module, otherwise prelude fallback.
  let fr0: FindFuncResult = find_func(ctx, mod_path, name);
  if fr0.found {
    return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, mod_path, fr0.sig, type_args, args, expected);
  }
  let prelude: String = "std/prelude";
  let fr1: FindFuncResult = find_func(ctx, prelude, name);
  if fr1.found {
    if !fr1.sig.is_pub { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, prelude, fr1.sig, type_args, args, expected);
  }
  // Builtins live in the root namespace.
  let fr2: FindFuncResult = find_func(ctx, "", name);
  if fr2.found {
    if is_reserved_intrinsic_name(name) && !is_std_module(mod_path) {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
    }
    return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, "", fr2.sig, type_args, args, expected);
  }
  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown fn: ".concat(name)) };
}

fn tc_call_func_qualified(ctx: Ctx, w: World, cur_mod: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, target_mod: String, name: String, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  let fr: FindFuncResult = find_func(ctx, target_mod, name);
  if !fr.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown fn: ".concat(name)) }; }
  if target_mod != cur_mod && !fr.sig.is_pub { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return tc_call_func_sig(ctx, w, cur_mod, imps, exprs, l0, call_sp, target_mod, fr.sig, type_args, args, expected);
}

fn tc_call_func_sig(ctx: Ctx, w: World, cur_mod: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, target_mod: String, sig: FuncSig, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  let _tm: String = target_mod; // reserved for future: implicit receiver / UFCS.
  if args.len() != sig.params.len() {
    let msg: String =
      "wrong number of args: expected ".concat(sig.params.len().to_string())
        .concat(", got ").concat(args.len().to_string());
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg) };
  }

  if sig.type_params.len() == 0 {
    if type_args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let mut i: i32 = 0;
    while i < args.len() {
      let want: i32 = sig.params.get(i);
      let ar: ExprTyResult = tc_expr(ctx, w, cur_mod, imps, exprs, l0, args.get(i), want);
      if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      if !assignable_to(ctx, want, ar.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      i = i + 1;
    }
    if expected != -1 && !assignable_to(ctx, expected, sig.ret) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: sig.ret, err: TcError.None };
  }

  // Generic call: infer type parameters (with optional explicit type args).
  if type_args.len() != 0 && type_args.len() != sig.type_params.len() {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
  }

  let mut subs: Vec[TySub] = Vec();
  // Use expected return type as a constraint when available.
  if expected != -1 {
    let ur0: UnifyResult = unify_ty(ctx, sig.ret, expected, subs);
    if !ur0.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    subs = ur0.subs;
  }

  // Explicit type args win (when provided).
  let mut ti: i32 = 0;
  while ti < type_args.len() {
    let tr: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, l0.type_params, type_args.get(ti));
    if !tr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let tp: String = sig.type_params.get(ti);
    let cur: i32 = subs_lookup(subs, tp);
    if cur != -1 && cur != tr.idx { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if cur == -1 { subs.push(TySub { name: tp, ty: tr.idx }); }
    ti = ti + 1;
  }

  // Infer from arguments.
  let mut i: i32 = 0;
  while i < args.len() {
    let want0: i32 = subst_ty(ctx, sig.params.get(i), subs);
    let want_t: ir.Ty = ir.ty_pool_get(ctx.pool, want0);
    let want: i32 = if want_t.kind == ir.TyKind.Param { -1 } else { want0 };
    let ar: ExprTyResult = tc_expr(ctx, w, cur_mod, imps, exprs, l0, args.get(i), want);
    if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let ur2: UnifyResult = unify_ty(ctx, sig.params.get(i), ar.ty, subs);
    if !ur2.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    subs = ur2.subs;
    i = i + 1;
  }

  // Ensure all type params are bound.
  let mut j: i32 = 0;
  while j < sig.type_params.len() {
    let tp: String = sig.type_params.get(j);
    if subs_lookup(subs, tp) == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    j = j + 1;
  }

  // Check trait bounds for inferred/explicit type args.
  let mut bi: i32 = 0;
  while bi < sig.type_param_bounds.len() {
    let b: TypeParamBoundSig = sig.type_param_bounds.get(bi);
    let ty0: i32 = subs_lookup(subs, b.type_param);
    if ty0 == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let ty1: i32 = strip_range(ctx, ty0);
    let fi: FindImplResult = find_impl(ctx, b.trait_mod_path, b.trait_name, ty1);
    if !fi.found {
      let tt: ir.Ty = ir.ty_pool_get(ctx.pool, ty1);
      if tt.kind == ir.TyKind.Param {
        if locals_has_type_param_bound(ctx, l0, tt.name, b.trait_mod_path, b.trait_name) {
          bi = bi + 1;
          continue;
        }
      }
      let tname: String = ty_inst_str(ctx, ty1);
      let cands: String = trait_impl_candidates_text(ctx, b.trait_mod_path, b.trait_name);
      let msg: String = "type argument ".concat(tname).concat(" does not satisfy trait bound ").concat(b.type_param).concat(": ").concat(b.trait_name).concat(" (available impls: ").concat(cands).concat(")");
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg) };
    }
    bi = bi + 1;
  }

  let out_ty: i32 = subst_ty(ctx, sig.ret, subs);
  if out_ty == ctx.ty_bad { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if expected != -1 && !assignable_to(ctx, expected, out_ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
}

fn tc_call_trait_static(ctx: Ctx, w: World, cur_mod: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, trait_mod: String, trait_name: String, method: String, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  let tf: FindTraitResult = find_trait(ctx, trait_mod, trait_name);
  if !tf.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown trait: ".concat(trait_name)) }; }
  if trait_mod != cur_mod && !tf.sig.is_pub {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "trait is private: ".concat(trait_name)) };
  }

  let tm: FindTraitMethodResult = find_trait_method(tf.sig, method);
  if !tm.found {
    let ms: String = trait_method_candidates_text(tf.sig);
    let msg: String = "unknown trait method: ".concat(trait_name).concat(".").concat(method).concat(" (available methods: ").concat(ms).concat(")");
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg) };
  }
  if args.len() == 0 {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "trait static call requires receiver arg") };
  }

  let ar0: ExprTyResult = tc_expr(ctx, w, cur_mod, imps, exprs, l0, args.get(0), -1);
  if !ar0.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: ar0.err }; }
  let recv_ty: i32 = strip_range(ctx, ar0.ty);
  let rt: ir.Ty = ir.ty_pool_get(ctx.pool, recv_ty);
  if rt.kind == ir.TyKind.Param {
    if !locals_has_type_param_bound(ctx, l0, rt.name, trait_mod, trait_name) {
      let msg0: String = "type parameter ".concat(rt.name).concat(" does not satisfy trait bound: ").concat(trait_name);
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg0) };
    }
    let msig: FuncSig = subst_self_in_sig(ctx, tm.m.sig, recv_ty);
    return tc_call_func_sig(ctx, w, cur_mod, imps, exprs, l0, call_sp, trait_mod, msig, type_args, args, expected);
  }

  let fi: FindImplResult = find_impl(ctx, trait_mod, trait_name, recv_ty);
  if !fi.found {
    let recv: String = ty_inst_str(ctx, recv_ty);
    let cands2: String = trait_impl_candidates_text(ctx, trait_mod, trait_name);
    let msg2: String = "no impl for trait call: ".concat(trait_name).concat(" for ").concat(recv).concat(" (available impls: ").concat(cands2).concat(")");
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg2) };
  }
  let im: FindImplMethodResult = find_impl_method(fi.sig, method);
  if !im.found {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "impl missing trait method: ".concat(method)) };
  }
  return tc_call_func_sig(ctx, w, cur_mod, imps, exprs, l0, call_sp, fi.sig.mod_path, im.m.sig, type_args, args, expected);
}

fn tc_call_enum_ctor(ctx: Ctx, w: World, cur_mod: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, enum_mod: String, enum_name: String, var_name: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  let fe: FindEnumResult = find_enum(ctx, enum_mod, enum_name);
  if !fe.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let es: EnumSig = fe.sig;
  if enum_mod != cur_mod && !es.is_pub { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != args.len() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      let mut ai: i32 = 0;
      while ai < args.len() {
        let want: i32 = v.fields.get(ai);
        let ar: ExprTyResult = tc_expr(ctx, w, cur_mod, imps, exprs, l0, args.get(ai), want);
        if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        if !assignable_to(ctx, want, ar.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        ai = ai + 1;
      }

      let out_ty: i32 = if expected != -1 { expected } else { find_enum_ty_idx(ctx, enum_mod, enum_name) };
      if out_ty == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      if expected != -1 && expected != out_ty { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
    }
    vi = vi + 1;
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}
