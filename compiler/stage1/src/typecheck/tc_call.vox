import "ast" as ast
import "ir" as ir

fn trait_is_or_extends(ctx: Ctx, mod_path: String, name: String, want_mod: String, want_name: String) -> bool {
  if mod_path == want_mod && name == want_name { return true; }
  let tf: FindTraitResult = find_trait(ctx, mod_path, name);
  if !tf.found { return false; }
  let mut i: i32 = 0;
  while i < tf.sig.supers.len() {
    let s: TraitSuperSig = tf.sig.supers.get(i);
    if trait_is_or_extends(ctx, s.mod_path, s.name, want_mod, want_name) { return true; }
    i = i + 1;
  }
  return false;
}

struct BoundMethodCand {
  trait_mod_path: String,
  trait_name: String,
  sig: FuncSig,
}

struct BoundMethodSearch {
  seen_traits: Vec[String],
  cands: Vec[BoundMethodCand],
}

fn contains_str_tc_call(xs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn compile_error_arg_text(exprs: ast.ExprPool, id: i32) -> String {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);
  return match n { ast.ExprNode.Str(s) => s, _ => "compile_error triggered" };
}

fn method_cand_key(mod_path: String, trait_name: String) -> String {
  return mod_path.concat("::").concat(trait_name);
}

fn has_method_cand(xs: Vec[BoundMethodCand], mod_path: String, trait_name: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    let c: BoundMethodCand = xs.get(i);
    if c.trait_mod_path == mod_path && c.trait_name == trait_name { return true; }
    i = i + 1;
  }
  return false;
}

fn search_bound_method_in_trait(ctx: Ctx, mod_path: String, trait_name: String, method: String, s0: BoundMethodSearch) -> BoundMethodSearch {
  let mut s: BoundMethodSearch = s0;
  let key: String = method_cand_key(mod_path, trait_name);
  if contains_str_tc_call(s.seen_traits, key) { return s; }
  s.seen_traits.push(key);

  let tf: FindTraitResult = find_trait(ctx, mod_path, trait_name);
  if !tf.found { return s; }
  let tm: FindTraitMethodResult = find_trait_method(tf.sig, method);
  if tm.found && !has_method_cand(s.cands, mod_path, trait_name) {
    s.cands.push(BoundMethodCand { trait_mod_path: mod_path, trait_name: trait_name, sig: tm.m.sig });
  }

  let mut i: i32 = 0;
  while i < tf.sig.supers.len() {
    let sup: TraitSuperSig = tf.sig.supers.get(i);
    s = search_bound_method_in_trait(ctx, sup.mod_path, sup.name, method, s);
    i = i + 1;
  }
  return s;
}

fn find_bound_trait_methods(ctx: Ctx, l0: Locals, type_param: String, method: String) -> BoundMethodSearch {
  let mut s: BoundMethodSearch = BoundMethodSearch { seen_traits: Vec(), cands: Vec() };
  let mut i: i32 = 0;
  while i < l0.type_param_bounds.len() {
    let b: TypeParamBoundSig = l0.type_param_bounds.get(i);
    if b.type_param == type_param {
      s = search_bound_method_in_trait(ctx, b.trait_mod_path, b.trait_name, method, s);
    }
    i = i + 1;
  }
  return s;
}

fn method_cands_text(xs: Vec[BoundMethodCand], method: String) -> String {
  if xs.len() == 0 { return "<none>"; }
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < xs.len() {
    if i > 0 { out = out.concat(", "); }
    let c: BoundMethodCand = xs.get(i);
    out = out.concat(c.trait_name).concat(".").concat(method);
    if i >= 7 { return out.concat(", ..."); }
    i = i + 1;
  }
  return out;
}

fn bounds_text(l0: Locals, type_param: String) -> String {
  let mut out: String = "";
  let mut seen: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < l0.type_param_bounds.len() {
    let b: TypeParamBoundSig = l0.type_param_bounds.get(i);
    if b.type_param == type_param && !contains_str_tc_call(seen, b.trait_name) {
      if out.len() > 0 { out = out.concat(" + "); }
      out = out.concat(b.trait_name);
      seen.push(b.trait_name);
    }
    i = i + 1;
  }
  if out.len() == 0 { return "<none>"; }
  return out;
}

fn is_vec_builtin_method(name: String) -> bool {
  return name == "push" || name == "len" || name == "get" || name == "join";
}

fn is_string_builtin_method(name: String) -> bool {
  return name == "len" || name == "byte_at" || name == "slice" || name == "concat" || name == "escape_c" || name == "to_string";
}

fn locals_has_type_param_bound(ctx: Ctx, l0: Locals, type_param: String, trait_mod: String, trait_name: String) -> bool {
  let mut i: i32 = 0;
  while i < l0.type_param_bounds.len() {
    let b: TypeParamBoundSig = l0.type_param_bounds.get(i);
    if b.type_param == type_param && trait_is_or_extends(ctx, b.trait_mod_path, b.trait_name, trait_mod, trait_name) {
      return true;
    }
    i = i + 1;
  }
  return false;
}

fn find_param_ty_idx(ctx: Ctx, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < ctx.pool.tys.len() {
    let t: ir.Ty = ir.ty_pool_get(ctx.pool, i);
    if t.kind == ir.TyKind.Param && t.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_vec_ty_idx_local(ctx: Ctx, elem: i32) -> i32 {
  let mut i: i32 = 0;
  while i < ctx.pool.tys.len() {
    let t: ir.Ty = ir.ty_pool_get(ctx.pool, i);
    if t.kind == ir.TyKind.Vec && t.elem == elem { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_range_ty_idx_local(ctx: Ctx, elem: i32, lo: i64, hi: i64) -> i32 {
  let mut i: i32 = 0;
  while i < ctx.pool.tys.len() {
    let t: ir.Ty = ir.ty_pool_get(ctx.pool, i);
    if t.kind == ir.TyKind.Range && t.elem == elem && t.lo == lo && t.hi == hi { return i; }
    i = i + 1;
  }
  return -1;
}

fn has_self_assoc_prefix(name: String) -> bool {
  return name.len() > 5 && name.slice(0, 5) == "Self.";
}

fn subst_self_ty(ctx: Ctx, ty: i32, recv_ty: i32) -> i32 {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty);
  if t.kind == ir.TyKind.Param {
    if t.name == "Self" { return recv_ty; }
    if has_self_assoc_prefix(t.name) {
      let rt: ir.Ty = ir.ty_pool_get(ctx.pool, recv_ty);
      if rt.kind == ir.TyKind.Param {
        let want: String = rt.name.concat(t.name.slice(4, t.name.len()));
        let pty: i32 = find_param_ty_idx(ctx, want);
        if pty != -1 { return pty; }
      }
    }
    return ty;
  }
  if t.kind == ir.TyKind.Vec {
    let e: i32 = subst_self_ty(ctx, t.elem, recv_ty);
    if e == t.elem { return ty; }
    let v: i32 = find_vec_ty_idx_local(ctx, e);
    if v != -1 { return v; }
    return ctx.ty_bad;
  }
  if t.kind == ir.TyKind.Range {
    let e2: i32 = subst_self_ty(ctx, t.elem, recv_ty);
    if e2 == t.elem { return ty; }
    let r: i32 = find_range_ty_idx_local(ctx, e2, t.lo, t.hi);
    if r != -1 { return r; }
    return ctx.ty_bad;
  }
  return ty;
}

fn subst_self_in_sig(ctx: Ctx, sig: FuncSig, recv_ty: i32) -> FuncSig {
  let mut ps: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < sig.params.len() {
    ps.push(subst_self_ty(ctx, sig.params.get(i), recv_ty));
    i = i + 1;
  }
  let rr: i32 = subst_self_ty(ctx, sig.ret, recv_ty);
  return FuncSig { params: ps, ret: rr, vis: sig.vis, is_pub: sig.is_pub, type_params: sig.type_params, const_params: sig.const_params, type_param_bounds: sig.type_param_bounds, const_where_bounds: sig.const_where_bounds };
}

struct AssocProjSubsResult { ok: bool, err: TcError, subs: Vec[TySub] }

fn impl_assoc_ty(sig: ImplSig, assoc: String) -> i32 {
  let mut i: i32 = 0;
  while i < sig.assoc_types.len() {
    let a: ImplAssocTypeSig = sig.assoc_types.get(i);
    if a.name == assoc { return a.ty; }
    i = i + 1;
  }
  return -1;
}

fn add_assoc_proj_subs(ctx: Ctx, l0: Locals, call_sp: ast.Span, sig: FuncSig, subs0: Vec[TySub]) -> AssocProjSubsResult {
  let mut subs: Vec[TySub] = subs0;
  let mut bi: i32 = 0;
  while bi < sig.type_param_bounds.len() {
    let b: TypeParamBoundSig = sig.type_param_bounds.get(bi);
    let ty0: i32 = subs_lookup(subs, b.type_param);
    if ty0 == -1 {
      bi = bi + 1;
      continue;
    }
    let ty1: i32 = strip_range(ctx, ty0);
    let tt: ir.Ty = ir.ty_pool_get(ctx.pool, ty1);
    if tt.kind == ir.TyKind.Param && locals_has_type_param_bound(ctx, l0, tt.name, b.trait_mod_path, b.trait_name) {
      bi = bi + 1;
      continue;
    }
    let fi: FindImplForTyResult = find_impl_for_ty(ctx, b.trait_mod_path, b.trait_name, ty1);
    if fi.ambiguous || !fi.found {
      bi = bi + 1;
      continue;
    }

    let tf: FindTraitResult = find_trait(ctx, b.trait_mod_path, b.trait_name);
    if !tf.found {
      bi = bi + 1;
      continue;
    }
    let mut ai: i32 = 0;
    while ai < tf.sig.assoc_types.len() {
      let an: String = tf.sig.assoc_types.get(ai).name;
      let aty: i32 = impl_assoc_ty(fi.sig, an);
      if aty != -1 {
        let key: String = b.type_param.concat(".").concat(an);
        let cur: i32 = subs_lookup(subs, key);
        if cur == -1 {
          subs.push(TySub { name: key, ty: aty });
        } else {
          if cur != aty {
            let msg: String = "ambiguous associated type projection at call: ".concat(key);
            return AssocProjSubsResult { ok: false, err: type_error_at(call_sp, msg), subs: subs };
          }
        }
      }
      ai = ai + 1;
    }
    bi = bi + 1;
  }
  return AssocProjSubsResult { ok: true, err: TcError.None, subs: subs };
}

fn tc_expr_call(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, callee: i32, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  // Method calls: `recv.method(...)` for built-in types.
  let cn: ast.ExprNode = ast.expr_pool_get(exprs, callee);
  let is_member: bool = match cn { ast.ExprNode.Member(_, _) => true, _ => false };
  if is_member {
    let recv_id: i32 = match cn { ast.ExprNode.Member(r, _) => r, _ => -1 };
    let mname: String = match cn { ast.ExprNode.Member(_, n) => n, _ => "" };

    let rr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, recv_id, -1);
    if rr.ok && is_vec_ty(ctx, rr.ty) && is_vec_builtin_method(mname) {
      return tc_call_vec_method(ctx, w, mod_path, imps, exprs, l0, rr.ty, mname, args, expected);
    }
    if rr.ok && rr.ty == ctx.ty_string && is_string_builtin_method(mname) {
      return tc_call_string_method(ctx, w, mod_path, imps, exprs, l0, recv_id, mname, args, expected);
    }
    if rr.ok && mname == "to_string" && (rr.ty == ctx.ty_bool || rr.ty == ctx.ty_string || is_int_like_ty(ctx, rr.ty) || is_float_ty(ctx, rr.ty)) {
      return tc_call_prim_method(ctx, w, mod_path, imps, exprs, l0, recv_id, rr.ty, mname, args, expected);
    }
    if rr.ok {
      let rty: i32 = strip_range(ctx, rr.ty);
      let rt: ir.Ty = ir.ty_pool_get(ctx.pool, rty);
      if rt.kind == ir.TyKind.Param {
        let bm: BoundMethodSearch = find_bound_trait_methods(ctx, l0, rt.name, mname);
        if bm.cands.len() > 1 {
          let msg0: String = "ambiguous trait method call: ".concat(mname).concat(" (candidates: ").concat(method_cands_text(bm.cands, mname)).concat(")");
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg0) };
        }
        if bm.cands.len() == 1 {
          let c0: BoundMethodCand = bm.cands.get(0);
          let msig0: FuncSig = subst_self_in_sig(ctx, c0.sig, rty);
          let mut all_args0: Vec[i32] = Vec();
          all_args0.push(recv_id);
          let mut aj: i32 = 0;
          while aj < args.len() { all_args0.push(args.get(aj)); aj = aj + 1; }
          return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, c0.trait_mod_path, msig0, type_args, all_args0, expected);
        }
        let msg1: String = "trait method not in bounds: ".concat(rt.name).concat(".").concat(mname).concat(" (bounds: ").concat(bounds_text(l0, rt.name)).concat(")");
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg1) };
      }

      let dm: FindTraitDispatchMethodResult = find_trait_dispatch_method(ctx, mod_path, strip_range(ctx, rr.ty), mname);
      if dm.ambiguous {
        let msg: String = "ambiguous trait method call: ".concat(mname).concat(" (candidates: ").concat(dm.candidates).concat(")");
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg) };
      }
      if dm.found {
        let mut all_args: Vec[i32] = Vec();
        all_args.push(recv_id);
        let mut ai: i32 = 0;
        while ai < args.len() { all_args.push(args.get(ai)); ai = ai + 1; }
        return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, dm.impl_mod_path, dm.m.sig, type_args, all_args, expected);
      }
    }
  }

  // Enum variant shorthand: `.Variant(...)` (enum type must be known from context).
  if match cn { ast.ExprNode.DotIdent(_x) => true, _ => false } {
    if type_args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let et: ir.Ty = ir.ty_pool_get(ctx.pool, expected);
    if et.kind != ir.TyKind.Enum { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let fe: FindEnumResult = find_enum(ctx, ty_mod(et), ty_name(et));
    if !fe.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let es: EnumSig = fe.sig;
    let var_name: String = match cn { ast.ExprNode.DotIdent(s) => s, _ => "" };

    let mut vi: i32 = 0;
    while vi < es.vars.len() {
      let v: EnumVariantSig = es.vars.get(vi);
      if v.name == var_name {
        if v.fields.len() != args.len() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        let mut ai: i32 = 0;
        while ai < args.len() {
          let want: i32 = v.fields.get(ai);
          let ar: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(ai), want);
          if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
          if ar.ty != want { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
          ai = ai + 1;
        }
        return ExprTyResult { ok: true, ty: expected, err: TcError.None };
      }
      vi = vi + 1;
    }
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
  }

  // Path-based calls: `name(...)`, `alias.name(...)`, `Enum.Variant(...)`.
  // Typed path support:
  // - `Option[i32].Some(1)` => parts: ["Option","Some"], path_targs: [i32]
  let pr: ExprTypePathResult = expr_type_path(exprs, callee);
  if !pr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let parts: Vec[String] = pr.parts;
  let path_targs: Vec[ast.TypeName] = pr.targs;

  // Special: `Vec()` constructor requires expected type `Vec[T]`.
  if parts.len() == 1 && parts.get(0) == "Vec" {
    if path_targs.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if type_args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "Vec() requires expected type Vec[T]") }; }
    if !is_vec_ty(ctx, expected) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "Vec() requires expected type Vec[T]") }; }
    return ExprTyResult { ok: true, ty: expected, err: TcError.None };
  }

  // Resolve function call.
  if parts.len() == 1 {
    if path_targs.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return tc_call_func_unqualified(ctx, w, mod_path, imps, exprs, l0, call_sp, parts.get(0), type_args, args, expected);
  }
  if parts.len() == 2 {
    // typed path + module alias cannot be a function call target.
    if path_targs.len() != 0 {
      let ntx: NamedTypeImport = find_named_type(imps.named_types, parts.get(0));
      if ntx.local != "" && ntx.kind != named_type_kind_enum() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      let mut enum_ty_parts: Vec[String] = Vec();
      enum_ty_parts.push(parts.get(0));
      let enum_mod0: String = if ntx.local != "" { ntx.mod_path } else { mod_path };
      let enum_name0: String = if ntx.local != "" { ntx.name } else { parts.get(0) };
      return tc_call_enum_ctor(ctx, w, mod_path, imps, exprs, l0, enum_mod0, enum_name0, parts.get(1), enum_ty_parts, path_targs, args, expected);
    }
    let mp: String = find_alias(imps.aliases, parts.get(0));
    if mp != "" {
      return tc_call_func_qualified(ctx, w, mod_path, imps, exprs, l0, call_sp, mp, parts.get(1), type_args, args, expected);
    }
    // Otherwise: `Trait.method(...)` or `Enum.Variant(...)` in current module,
    // or via a named imported type.
    let nt: NamedTypeImport = find_named_type(imps.named_types, parts.get(0));
    if nt.local != "" {
      if nt.kind == named_type_kind_trait() {
        if path_targs.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        return tc_call_trait_static(ctx, w, mod_path, imps, exprs, l0, call_sp, nt.mod_path, nt.name, parts.get(1), type_args, args, expected);
      }
      if nt.kind != named_type_kind_enum() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      let mut enum_ty_parts0: Vec[String] = Vec();
      enum_ty_parts0.push(parts.get(0));
      return tc_call_enum_ctor(ctx, w, mod_path, imps, exprs, l0, nt.mod_path, nt.name, parts.get(1), enum_ty_parts0, path_targs, args, expected);
    }

    let ft: FindTraitResult = find_trait(ctx, mod_path, parts.get(0));
    let fe: FindEnumResult = find_enum(ctx, mod_path, parts.get(0));
    if ft.found && fe.found && path_targs.len() == 0 {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "ambiguous call target: ".concat(parts.get(0))) };
    }
    if ft.found && path_targs.len() == 0 {
      return tc_call_trait_static(ctx, w, mod_path, imps, exprs, l0, call_sp, mod_path, parts.get(0), parts.get(1), type_args, args, expected);
    }
    if !fe.found && path_targs.len() == 0 {
      let prelude: String = "std/prelude";
      let fp: FindTraitResult = find_trait(ctx, prelude, parts.get(0));
      if fp.found && vis_allows(fp.sig.vis, prelude, mod_path) {
        return tc_call_trait_static(ctx, w, mod_path, imps, exprs, l0, call_sp, prelude, parts.get(0), parts.get(1), type_args, args, expected);
      }
    }
    let mut enum_ty_parts1: Vec[String] = Vec();
    enum_ty_parts1.push(parts.get(0));
    return tc_call_enum_ctor(ctx, w, mod_path, imps, exprs, l0, mod_path, parts.get(0), parts.get(1), enum_ty_parts1, path_targs, args, expected);
  }
  if parts.len() == 3 {
    let mp: String = find_alias(imps.aliases, parts.get(0));
    if mp == "" { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if path_targs.len() != 0 {
      let mut enum_ty_parts2: Vec[String] = Vec();
      enum_ty_parts2.push(parts.get(0));
      enum_ty_parts2.push(parts.get(1));
      return tc_call_enum_ctor(ctx, w, mod_path, imps, exprs, l0, mp, parts.get(1), parts.get(2), enum_ty_parts2, path_targs, args, expected);
    }
    let ft: FindTraitResult = find_trait(ctx, mp, parts.get(1));
    let fe: FindEnumResult = find_enum(ctx, mp, parts.get(1));
    if ft.found && fe.found {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "ambiguous call target: ".concat(parts.get(1))) };
    }
    if ft.found {
      return tc_call_trait_static(ctx, w, mod_path, imps, exprs, l0, call_sp, mp, parts.get(1), parts.get(2), type_args, args, expected);
    }
    let mut enum_ty_parts3: Vec[String] = Vec();
    enum_ty_parts3.push(parts.get(0));
    enum_ty_parts3.push(parts.get(1));
    return tc_call_enum_ctor(ctx, w, mod_path, imps, exprs, l0, mp, parts.get(1), parts.get(2), enum_ty_parts3, path_targs, args, expected);
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}

fn tc_call_vec_method(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, recv_ty: i32, mname: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  let elem: i32 = vec_elem(ctx, recv_ty);

  if mname == "push" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let ar: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), elem);
    if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_unit { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_unit, err: TcError.None };
  }

  if mname == "len" {
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_i32 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None };
  }

  if mname == "get" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let idxr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_i32);
    if !idxr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != elem { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: elem, err: TcError.None };
  }

  if mname == "join" {
    // Stage0 parity: only Vec[String].join(String) -> String.
    if elem != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let sepr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_string);
    if !sepr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}

fn tc_call_string_method(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, recv_id: i32, mname: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  let _rr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, recv_id, ctx.ty_string);

  if mname == "len" {
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_i32 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None };
  }
  if mname == "byte_at" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let idxr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_i32);
    if !idxr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_i32 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None };
  }
  if mname == "slice" {
    if args.len() != 2 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let sr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_i32);
    if !sr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(1), ctx.ty_i32);
    if !er.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }
  if mname == "concat" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let or: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_string);
    if !or.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }
  if mname == "escape_c" {
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }
  if mname == "to_string" {
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}

fn tc_call_prim_method(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, recv_id: i32, recv_ty: i32, mname: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  if mname != "to_string" { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let rr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, recv_id, recv_ty);
  if !rr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
}

fn tc_call_func_unqualified(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, name: String, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  if name == "@compile_error" {
    if type_args.len() != 0 || args.len() != 1 {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "@compile_error expects exactly one String argument") };
    }
    let ar: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_string);
    if !ar.ok { return ar; }
    let msg: String = compile_error_arg_text(exprs, args.get(0));
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "compile_error: ".concat(msg)) };
  }

  let nf: NamedFuncImport = find_named_func(imps.named_funcs, name);
  if nf.local != "" {
    let frx: FindFuncResult = find_func(ctx, nf.mod_path, nf.name);
    if !frx.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown fn: ".concat(name)) }; }
    return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, nf.mod_path, frx.sig, type_args, args, expected);
  }
  // Prefer local module, otherwise prelude fallback.
  let fr0: FindFuncResult = find_func(ctx, mod_path, name);
  if fr0.found {
    return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, mod_path, fr0.sig, type_args, args, expected);
  }
  let prelude: String = "std/prelude";
  let fr1: FindFuncResult = find_func(ctx, prelude, name);
  if fr1.found {
    if !vis_allows(fr1.sig.vis, prelude, mod_path) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, prelude, fr1.sig, type_args, args, expected);
  }
  // Builtins live in the root namespace.
  let fr2: FindFuncResult = find_func(ctx, "", name);
  if fr2.found {
    if is_reserved_intrinsic_name(name) && !is_std_module(mod_path) {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
    }
    return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, "", fr2.sig, type_args, args, expected);
  }
  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown fn: ".concat(name)) };
}

fn tc_call_func_qualified(ctx: Ctx, w: World, cur_mod: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, target_mod: String, name: String, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  let fr: FindFuncResult = find_func(ctx, target_mod, name);
  if !fr.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown fn: ".concat(name)) }; }
  if !vis_allows(fr.sig.vis, target_mod, cur_mod) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return tc_call_func_sig(ctx, w, cur_mod, imps, exprs, l0, call_sp, target_mod, fr.sig, type_args, args, expected);
}

fn tc_call_func_sig(ctx: Ctx, w: World, cur_mod: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, target_mod: String, sig: FuncSig, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  let _tm: String = target_mod; // reserved for future: implicit receiver / UFCS.
  if args.len() != sig.params.len() {
    let msg: String =
      "wrong number of args: expected ".concat(sig.params.len().to_string())
        .concat(", got ").concat(args.len().to_string());
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg) };
  }

  if sig.type_params.len() == 0 && sig.const_params.len() == 0 {
    if type_args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let mut i: i32 = 0;
    while i < args.len() {
      let want: i32 = sig.params.get(i);
      let ar: ExprTyResult = tc_expr(ctx, w, cur_mod, imps, exprs, l0, args.get(i), want);
      if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      if !assignable_to(ctx, want, ar.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      i = i + 1;
    }
    if expected != -1 && !assignable_to(ctx, expected, sig.ret) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: sig.ret, err: TcError.None };
  }

  // Generic call args:
  // - type args prefix: `T, U`
  // - const args suffix: `3, -5`
  // Missing const args are filled from const param defaults when available.
  let mut explicit_targ_n: i32 = type_args.len();
  let mut first_const: i32 = -1;
  let mut xi: i32 = 0;
  while xi < type_args.len() {
    if is_const_generic_arg_tn(type_args.get(xi)) {
      first_const = xi;
      xi = type_args.len();
    } else {
      xi = xi + 1;
    }
  }
  if first_const != -1 {
    explicit_targ_n = first_const;
    let mut xj: i32 = first_const;
    while xj < type_args.len() {
      if !is_const_generic_arg_tn(type_args.get(xj)) {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
      }
      xj = xj + 1;
    }
  }
  if explicit_targ_n > sig.type_params.len() {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
  }
  let explicit_const_n: i32 = type_args.len() - explicit_targ_n;
  if explicit_const_n > sig.const_params.len() {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
  }

  let mut explicit_targs: Vec[ast.TypeName] = Vec();
  let mut ci0: i32 = 0;
  while ci0 < explicit_targ_n {
    let ta0: ast.TypeName = type_args.get(ci0);
    if is_const_generic_arg_tn(ta0) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    explicit_targs.push(ta0);
    ci0 = ci0 + 1;
  }

  let mut cidx: i32 = 0;
  let mut csubs: Vec[ConstSub] = Vec();
  while cidx < sig.const_params.len() {
    let cp: ConstParamSig = sig.const_params.get(cidx);
    if cidx < explicit_const_n {
      let ctn: ast.TypeName = type_args.get(explicit_targ_n + cidx);
      let pr: ParseConstGenericArgResult = parse_const_generic_arg(ctx, ctn, cp.ty);
      if !pr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      csubs.push(ConstSub { name: cp.name, ty: cp.ty, iv: pr.iv, text: pr.text });
    } else {
      if !cp.has_default { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      csubs.push(ConstSub { name: cp.name, ty: cp.ty, iv: cp.default_iv, text: cp.default_text });
    }
    cidx = cidx + 1;
  }
  let cwr: ConstWhereCheckResult = check_const_where_bounds(sig.const_where_bounds, csubs);
  if !cwr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, cwr.err) }; }

  let mut subs: Vec[TySub] = Vec();
  // Use expected return type as a constraint when available.
  if expected != -1 {
    let ur0: UnifyResult = unify_ty(ctx, sig.ret, expected, subs);
    if !ur0.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    subs = ur0.subs;
  }

  // Explicit type args win (when provided).
  let mut ti: i32 = 0;
  while ti < explicit_targs.len() {
    let tr: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, l0.type_params, explicit_targs.get(ti));
    if !tr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let tp: String = sig.type_params.get(ti);
    let cur: i32 = subs_lookup(subs, tp);
    if cur != -1 && cur != tr.idx { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if cur == -1 { subs.push(TySub { name: tp, ty: tr.idx }); }
    ti = ti + 1;
  }

  // Infer from arguments.
  let mut i: i32 = 0;
  while i < args.len() {
    let want0: i32 = subst_ty(ctx, sig.params.get(i), subs);
    let want_t: ir.Ty = ir.ty_pool_get(ctx.pool, want0);
    let want: i32 = if want_t.kind == ir.TyKind.Param || ty_has_param(ctx, want0) { -1 } else { want0 };
    let ar: ExprTyResult = tc_expr(ctx, w, cur_mod, imps, exprs, l0, args.get(i), want);
    if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let ur2: UnifyResult = unify_ty(ctx, sig.params.get(i), ar.ty, subs);
    if !ur2.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    subs = ur2.subs;
    i = i + 1;
  }

  // Ensure all type params are bound.
  let mut j: i32 = 0;
  while j < sig.type_params.len() {
    let tp: String = sig.type_params.get(j);
    if subs_lookup(subs, tp) == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    j = j + 1;
  }

  // Check trait bounds for inferred/explicit type args.
  let mut bi: i32 = 0;
  while bi < sig.type_param_bounds.len() {
    let b: TypeParamBoundSig = sig.type_param_bounds.get(bi);
    let ty0: i32 = subs_lookup(subs, b.type_param);
    if ty0 == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let ty1: i32 = strip_range(ctx, ty0);
    let fi: FindImplForTyResult = find_impl_for_ty(ctx, b.trait_mod_path, b.trait_name, ty1);
    if fi.ambiguous {
      let tname0: String = ty_inst_str(ctx, ty1);
      let msg0: String = "type argument ".concat(tname0).concat(" has ambiguous impls for trait ").concat(b.trait_name).concat(" (candidates: ").concat(fi.candidates).concat(")");
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg0) };
    }
    if !fi.found {
      let tt: ir.Ty = ir.ty_pool_get(ctx.pool, ty1);
      if tt.kind == ir.TyKind.Param {
        if locals_has_type_param_bound(ctx, l0, tt.name, b.trait_mod_path, b.trait_name) {
          bi = bi + 1;
          continue;
        }
      }
      let tname: String = ty_inst_str(ctx, ty1);
      let cands: String = trait_impl_candidates_text(ctx, b.trait_mod_path, b.trait_name);
      let msg: String = "type argument ".concat(tname).concat(" does not satisfy trait bound ").concat(b.type_param).concat(": ").concat(b.trait_name).concat(" (available impls: ").concat(cands).concat(")");
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg) };
    }
    bi = bi + 1;
  }

  let asr: AssocProjSubsResult = add_assoc_proj_subs(ctx, l0, call_sp, sig, subs);
  if !asr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: asr.err }; }
  subs = asr.subs;

  let out_ty: i32 = subst_ty(ctx, sig.ret, subs);
  if out_ty == ctx.ty_bad { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if expected != -1 && !assignable_to(ctx, expected, out_ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
}

fn tc_call_trait_static(ctx: Ctx, w: World, cur_mod: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, trait_mod: String, trait_name: String, method: String, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  let tf: FindTraitResult = find_trait(ctx, trait_mod, trait_name);
  if !tf.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown trait: ".concat(trait_name)) }; }
  if !vis_allows(tf.sig.vis, trait_mod, cur_mod) {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "trait is private: ".concat(trait_name)) };
  }

  let tm: FindTraitMethodResult = find_trait_method(tf.sig, method);
  if !tm.found {
    let ms: String = trait_method_candidates_text(tf.sig);
    let msg: String = "unknown trait method: ".concat(trait_name).concat(".").concat(method).concat(" (available methods: ").concat(ms).concat(")");
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg) };
  }
  if args.len() == 0 {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "trait static call requires receiver arg") };
  }

  let ar0: ExprTyResult = tc_expr(ctx, w, cur_mod, imps, exprs, l0, args.get(0), -1);
  if !ar0.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: ar0.err }; }
  let recv_ty: i32 = strip_range(ctx, ar0.ty);
  let rt: ir.Ty = ir.ty_pool_get(ctx.pool, recv_ty);
  if rt.kind == ir.TyKind.Param {
    if !locals_has_type_param_bound(ctx, l0, rt.name, trait_mod, trait_name) {
      let msg0: String = "type parameter ".concat(rt.name).concat(" does not satisfy trait bound: ").concat(trait_name);
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg0) };
    }
    let msig: FuncSig = subst_self_in_sig(ctx, tm.m.sig, recv_ty);
    return tc_call_func_sig(ctx, w, cur_mod, imps, exprs, l0, call_sp, trait_mod, msig, type_args, args, expected);
  }

  let fi: FindImplForTyResult = find_impl_for_ty(ctx, trait_mod, trait_name, recv_ty);
  if fi.ambiguous {
    let recv0: String = ty_inst_str(ctx, recv_ty);
    let msg0: String = "ambiguous impl for trait call: ".concat(trait_name).concat(" for ").concat(recv0).concat(" (candidates: ").concat(fi.candidates).concat(")");
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg0) };
  }
  if !fi.found {
    let recv: String = ty_inst_str(ctx, recv_ty);
    let cands2: String = trait_impl_candidates_text(ctx, trait_mod, trait_name);
    let msg2: String = "no impl for trait call: ".concat(trait_name).concat(" for ").concat(recv).concat(" (available impls: ").concat(cands2).concat(")");
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg2) };
  }
  let im: FindImplMethodResult = find_impl_method(fi.sig, method);
  if !im.found {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "impl missing trait method: ".concat(method)) };
  }
  return tc_call_func_sig(ctx, w, cur_mod, imps, exprs, l0, call_sp, fi.sig.mod_path, im.m.sig, type_args, args, expected);
}

fn find_enum_for_ctor(ctx: Ctx, enum_mod: String, enum_name: String, expected: i32) -> FindEnumResult {
  let fe0: FindEnumResult = find_enum(ctx, enum_mod, enum_name);
  if fe0.found { return fe0; }
  if expected == -1 || !is_enum_ty(ctx, expected) { return fe0; }

  let et: ir.Ty = ir.ty_pool_get(ctx.pool, expected);
  if ty_mod(et) != enum_mod { return fe0; }
  let fe1: FindEnumResult = find_enum(ctx, enum_mod, ty_name(et));
  if !fe1.found { return fe0; }
  if fe1.sig.base_name == enum_name || fe1.sig.name == enum_name { return fe1; }
  return fe0;
}

fn tc_call_enum_ctor(ctx: Ctx, w: World, cur_mod: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, enum_mod: String, enum_name: String, var_name: String, enum_type_parts: Vec[String], enum_targs: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  let mut out_ty_hint: i32 = -1;
  let mut fe: FindEnumResult = find_enum_for_ctor(ctx, enum_mod, enum_name, expected);
  if enum_targs.len() != 0 {
    let tn: ast.TypeName = ast.TypeName { parts: enum_type_parts, args: enum_targs };
    let tr: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, l0.type_params, tn);
    if !tr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if tr.idx < 0 || tr.idx >= ctx.pool.tys.len() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if !is_enum_ty(ctx, tr.idx) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    out_ty_hint = tr.idx;
    let et: ir.Ty = ir.ty_pool_get(ctx.pool, tr.idx);
    fe = find_enum(ctx, ty_mod(et), ty_name(et));
  }
  if !fe.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let es: EnumSig = fe.sig;
  if !vis_allows(es.vis, es.mod_path, cur_mod) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != args.len() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      let mut ai: i32 = 0;
      while ai < args.len() {
        let want: i32 = v.fields.get(ai);
        let ar: ExprTyResult = tc_expr(ctx, w, cur_mod, imps, exprs, l0, args.get(ai), want);
        if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        if !assignable_to(ctx, want, ar.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        ai = ai + 1;
      }

      let out_ty: i32 = if out_ty_hint != -1 { out_ty_hint } else { if expected != -1 { expected } else { find_enum_ty_idx(ctx, es.mod_path, es.name) } };
      if out_ty == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      if expected != -1 && !assignable_to(ctx, expected, out_ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
    }
    vi = vi + 1;
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}
