import "ast" as ast
import "ir" as ir

fn tc_expr_call(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, callee: i32, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  // Method calls: `recv.method(...)` for built-in types.
  let cn: ast.ExprNode = ast.expr_pool_get(exprs, callee);
  let is_member: bool = match cn { ast.ExprNode.Member(_, _) => true, _ => false };
  if is_member {
    let recv_id: i32 = match cn { ast.ExprNode.Member(r, _) => r, _ => -1 };
    let mname: String = match cn { ast.ExprNode.Member(_, n) => n, _ => "" };

    let rr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, recv_id, -1);
    if rr.ok && is_vec_ty(ctx, rr.ty) {
      return tc_call_vec_method(ctx, w, mod_path, imps, exprs, l0, rr.ty, mname, args, expected);
    }
    if rr.ok && rr.ty == ctx.ty_string {
      return tc_call_string_method(ctx, w, mod_path, imps, exprs, l0, recv_id, mname, args, expected);
    }
    if rr.ok && (rr.ty == ctx.ty_bool || is_int_like_ty(ctx, rr.ty) || is_float_ty(ctx, rr.ty)) {
      return tc_call_prim_method(ctx, w, mod_path, imps, exprs, l0, recv_id, rr.ty, mname, args, expected);
    }
  }

  // Enum variant shorthand: `.Variant(...)` (enum type must be known from context).
  if match cn { ast.ExprNode.DotIdent(_x) => true, _ => false } {
    if type_args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let et: ir.Ty = ir.ty_pool_get(ctx.pool, expected);
    if et.kind != ir.TyKind.Enum { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let fe: FindEnumResult = find_enum(ctx, ty_mod(et), ty_name(et));
    if !fe.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let es: EnumSig = fe.sig;
    let var_name: String = match cn { ast.ExprNode.DotIdent(s) => s, _ => "" };

    let mut vi: i32 = 0;
    while vi < es.vars.len() {
      let v: EnumVariantSig = es.vars.get(vi);
      if v.name == var_name {
        if v.fields.len() != args.len() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        let mut ai: i32 = 0;
        while ai < args.len() {
          let want: i32 = v.fields.get(ai);
          let ar: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(ai), want);
          if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
          if ar.ty != want { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
          ai = ai + 1;
        }
        return ExprTyResult { ok: true, ty: expected, err: TcError.None };
      }
      vi = vi + 1;
    }
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
  }

  // Path-based calls: `name(...)`, `alias.name(...)`, `Enum.Variant(...)`.
  let pr: ExprPartsResult = expr_parts(exprs, callee);
  if !pr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let parts: Vec[String] = pr.parts;

  // Special: `Vec()` constructor requires expected type `Vec[T]`.
  if parts.len() == 1 && parts.get(0) == "Vec" {
    if type_args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "Vec() requires expected type Vec[T]") }; }
    if !is_vec_ty(ctx, expected) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "Vec() requires expected type Vec[T]") }; }
    return ExprTyResult { ok: true, ty: expected, err: TcError.None };
  }

  // Resolve function call.
  if parts.len() == 1 {
    return tc_call_func_unqualified(ctx, w, mod_path, imps, exprs, l0, call_sp, parts.get(0), type_args, args, expected);
  }
  if parts.len() == 2 {
    let mp: String = find_alias(imps.aliases, parts.get(0));
    if mp != "" {
      return tc_call_func_qualified(ctx, w, mod_path, imps, exprs, l0, call_sp, mp, parts.get(1), type_args, args, expected);
    }
    // Otherwise: `Trait.method(...)` or `Enum.Variant(...)` in current module,
    // or via a named imported type.
    let nt: NamedTypeImport = find_named_type(imps.named_types, parts.get(0));
    if nt.local != "" {
      if nt.kind == named_type_kind_trait() {
        return tc_call_trait_static(ctx, w, mod_path, imps, exprs, l0, call_sp, nt.mod_path, nt.name, parts.get(1), type_args, args, expected);
      }
      if nt.kind != named_type_kind_enum() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      return tc_call_enum_ctor(ctx, w, mod_path, imps, exprs, l0, nt.mod_path, nt.name, parts.get(1), args, expected);
    }

    let ft: FindTraitResult = find_trait(ctx, mod_path, parts.get(0));
    let fe: FindEnumResult = find_enum(ctx, mod_path, parts.get(0));
    if ft.found && fe.found {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "ambiguous call target: ".concat(parts.get(0))) };
    }
    if ft.found {
      return tc_call_trait_static(ctx, w, mod_path, imps, exprs, l0, call_sp, mod_path, parts.get(0), parts.get(1), type_args, args, expected);
    }
    if !fe.found {
      let prelude: String = "std/prelude";
      let fp: FindTraitResult = find_trait(ctx, prelude, parts.get(0));
      if fp.found && fp.sig.is_pub {
        return tc_call_trait_static(ctx, w, mod_path, imps, exprs, l0, call_sp, prelude, parts.get(0), parts.get(1), type_args, args, expected);
      }
    }
    return tc_call_enum_ctor(ctx, w, mod_path, imps, exprs, l0, mod_path, parts.get(0), parts.get(1), args, expected);
  }
  if parts.len() == 3 {
    let mp: String = find_alias(imps.aliases, parts.get(0));
    if mp == "" { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let ft: FindTraitResult = find_trait(ctx, mp, parts.get(1));
    let fe: FindEnumResult = find_enum(ctx, mp, parts.get(1));
    if ft.found && fe.found {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "ambiguous call target: ".concat(parts.get(1))) };
    }
    if ft.found {
      return tc_call_trait_static(ctx, w, mod_path, imps, exprs, l0, call_sp, mp, parts.get(1), parts.get(2), type_args, args, expected);
    }
    return tc_call_enum_ctor(ctx, w, mod_path, imps, exprs, l0, mp, parts.get(1), parts.get(2), args, expected);
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}

fn tc_call_vec_method(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, recv_ty: i32, mname: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  let elem: i32 = vec_elem(ctx, recv_ty);

  if mname == "push" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let ar: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), elem);
    if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_unit { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_unit, err: TcError.None };
  }

  if mname == "len" {
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_i32 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None };
  }

  if mname == "get" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let idxr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_i32);
    if !idxr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != elem { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: elem, err: TcError.None };
  }

  if mname == "join" {
    // Stage0 parity: only Vec[String].join(String) -> String.
    if elem != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let sepr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_string);
    if !sepr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}

fn tc_call_string_method(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, recv_id: i32, mname: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  let _rr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, recv_id, ctx.ty_string);

  if mname == "len" {
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_i32 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None };
  }
  if mname == "byte_at" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let idxr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_i32);
    if !idxr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_i32 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None };
  }
  if mname == "slice" {
    if args.len() != 2 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let sr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_i32);
    if !sr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(1), ctx.ty_i32);
    if !er.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }
  if mname == "concat" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let or: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, args.get(0), ctx.ty_string);
    if !or.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }
  if mname == "escape_c" {
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}

fn tc_call_prim_method(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, recv_id: i32, recv_ty: i32, mname: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  if mname != "to_string" { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let rr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, recv_id, recv_ty);
  if !rr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
}

fn tc_call_func_unqualified(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, name: String, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  let nf: NamedFuncImport = find_named_func(imps.named_funcs, name);
  if nf.local != "" {
    let frx: FindFuncResult = find_func(ctx, nf.mod_path, nf.name);
    if !frx.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown fn: ".concat(name)) }; }
    return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, nf.mod_path, frx.sig, type_args, args, expected);
  }
  // Prefer local module, otherwise prelude fallback.
  let fr0: FindFuncResult = find_func(ctx, mod_path, name);
  if fr0.found {
    return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, mod_path, fr0.sig, type_args, args, expected);
  }
  let prelude: String = "std/prelude";
  let fr1: FindFuncResult = find_func(ctx, prelude, name);
  if fr1.found {
    if !fr1.sig.is_pub { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, prelude, fr1.sig, type_args, args, expected);
  }
  // Builtins live in the root namespace.
  let fr2: FindFuncResult = find_func(ctx, "", name);
  if fr2.found {
    if is_reserved_intrinsic_name(name) && !is_std_module(mod_path) {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
    }
    return tc_call_func_sig(ctx, w, mod_path, imps, exprs, l0, call_sp, "", fr2.sig, type_args, args, expected);
  }
  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown fn: ".concat(name)) };
}

fn tc_call_func_qualified(ctx: Ctx, w: World, cur_mod: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, target_mod: String, name: String, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  let fr: FindFuncResult = find_func(ctx, target_mod, name);
  if !fr.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown fn: ".concat(name)) }; }
  if target_mod != cur_mod && !fr.sig.is_pub { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return tc_call_func_sig(ctx, w, cur_mod, imps, exprs, l0, call_sp, target_mod, fr.sig, type_args, args, expected);
}

fn tc_call_func_sig(ctx: Ctx, w: World, cur_mod: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, target_mod: String, sig: FuncSig, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  let _tm: String = target_mod; // reserved for future: implicit receiver / UFCS.
  if args.len() != sig.params.len() {
    let msg: String =
      "wrong number of args: expected ".concat(sig.params.len().to_string())
        .concat(", got ").concat(args.len().to_string());
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, msg) };
  }

  if sig.type_params.len() == 0 {
    if type_args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let mut i: i32 = 0;
    while i < args.len() {
      let want: i32 = sig.params.get(i);
      let ar: ExprTyResult = tc_expr(ctx, w, cur_mod, imps, exprs, l0, args.get(i), want);
      if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      if !assignable_to(ctx, want, ar.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      i = i + 1;
    }
    if expected != -1 && !assignable_to(ctx, expected, sig.ret) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: sig.ret, err: TcError.None };
  }

  // Generic call: infer type parameters (with optional explicit type args).
  if type_args.len() != 0 && type_args.len() != sig.type_params.len() {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
  }

  let mut subs: Vec[TySub] = Vec();
  // Use expected return type as a constraint when available.
  if expected != -1 {
    let ur0: UnifyResult = unify_ty(ctx, sig.ret, expected, subs);
    if !ur0.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    subs = ur0.subs;
  }

  // Explicit type args win (when provided).
  let mut ti: i32 = 0;
  while ti < type_args.len() {
    let tr: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, Vec(), type_args.get(ti));
    if !tr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let tp: String = sig.type_params.get(ti);
    let cur: i32 = subs_lookup(subs, tp);
    if cur != -1 && cur != tr.idx { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if cur == -1 { subs.push(TySub { name: tp, ty: tr.idx }); }
    ti = ti + 1;
  }

  // Infer from arguments.
  let mut i: i32 = 0;
  while i < args.len() {
    let want0: i32 = subst_ty(ctx, sig.params.get(i), subs);
    let want_t: ir.Ty = ir.ty_pool_get(ctx.pool, want0);
    let want: i32 = if want_t.kind == ir.TyKind.Param { -1 } else { want0 };
    let ar: ExprTyResult = tc_expr(ctx, w, cur_mod, imps, exprs, l0, args.get(i), want);
    if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let ur2: UnifyResult = unify_ty(ctx, sig.params.get(i), ar.ty, subs);
    if !ur2.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    subs = ur2.subs;
    i = i + 1;
  }

  // Ensure all type params are bound.
  let mut j: i32 = 0;
  while j < sig.type_params.len() {
    let tp: String = sig.type_params.get(j);
    if subs_lookup(subs, tp) == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    j = j + 1;
  }

  let out_ty: i32 = subst_ty(ctx, sig.ret, subs);
  if out_ty == ctx.ty_bad { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if expected != -1 && !assignable_to(ctx, expected, out_ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
}

fn tc_call_trait_static(ctx: Ctx, w: World, cur_mod: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, call_sp: ast.Span, trait_mod: String, trait_name: String, method: String, type_args: Vec[ast.TypeName], args: Vec[i32], expected: i32) -> ExprTyResult {
  if type_args.len() != 0 {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "trait static call does not accept type args") };
  }
  let tf: FindTraitResult = find_trait(ctx, trait_mod, trait_name);
  if !tf.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown trait: ".concat(trait_name)) }; }
  if trait_mod != cur_mod && !tf.sig.is_pub {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "trait is private: ".concat(trait_name)) };
  }

  let tm: FindTraitMethodResult = find_trait_method(tf.sig, method);
  if !tm.found {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "unknown trait method: ".concat(method)) };
  }
  if args.len() == 0 {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "trait static call requires receiver arg") };
  }

  let ar0: ExprTyResult = tc_expr(ctx, w, cur_mod, imps, exprs, l0, args.get(0), -1);
  if !ar0.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: ar0.err }; }
  let recv_ty: i32 = strip_range(ctx, ar0.ty);

  let fi: FindImplResult = find_impl(ctx, trait_mod, trait_name, recv_ty);
  if !fi.found {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "no impl for trait call") };
  }
  let im: FindImplMethodResult = find_impl_method(fi.sig, method);
  if !im.found {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(call_sp, "impl missing trait method: ".concat(method)) };
  }
  return tc_call_func_sig(ctx, w, cur_mod, imps, exprs, l0, call_sp, fi.sig.mod_path, im.m.sig, Vec(), args, expected);
}

fn tc_call_enum_ctor(ctx: Ctx, w: World, cur_mod: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, enum_mod: String, enum_name: String, var_name: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  let fe: FindEnumResult = find_enum(ctx, enum_mod, enum_name);
  if !fe.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let es: EnumSig = fe.sig;
  if enum_mod != cur_mod && !es.is_pub { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != args.len() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      let mut ai: i32 = 0;
      while ai < args.len() {
        let want: i32 = v.fields.get(ai);
        let ar: ExprTyResult = tc_expr(ctx, w, cur_mod, imps, exprs, l0, args.get(ai), want);
        if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        if !assignable_to(ctx, want, ar.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        ai = ai + 1;
      }

      let out_ty: i32 = if expected != -1 { expected } else { find_enum_ty_idx(ctx, enum_mod, enum_name) };
      if out_ty == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      if expected != -1 && expected != out_ty { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
    }
    vi = vi + 1;
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}
