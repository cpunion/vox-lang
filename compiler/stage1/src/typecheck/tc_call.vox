import "ast" as ast
import "ir" as ir

fn tc_expr_call(ctx: Ctx, w: World, mod_path: String, aliases: Vec[ImportAlias], exprs: ast.ExprPool, l0: Locals, callee: i32, args: Vec[i32], expected: i32) -> ExprTyResult {
  // Method calls: `recv.method(...)` for built-in types.
  let cn: ast.ExprNode = ast.expr_pool_get(exprs, callee);
  let is_member: bool = match cn { ast.ExprNode.Member(_, _) => true, _ => false };
  if is_member {
    let recv_id: i32 = match cn { ast.ExprNode.Member(r, _) => r, _ => -1 };
    let mname: String = match cn { ast.ExprNode.Member(_, n) => n, _ => "" };

    let rr: ExprTyResult = tc_expr(ctx, w, mod_path, aliases, exprs, l0, recv_id, -1);
    if rr.ok && is_vec_ty(ctx, rr.ty) {
      return tc_call_vec_method(ctx, w, mod_path, aliases, exprs, l0, rr.ty, mname, args, expected);
    }
  }

  // Path-based calls: `name(...)`, `alias.name(...)`, `Enum.Variant(...)`.
  let pr: ExprPartsResult = expr_parts(exprs, callee);
  if !pr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
  let parts: Vec[String] = pr.parts;

  // Special: `Vec()` constructor requires expected type `Vec[T]`.
  if parts.len() == 1 && parts.get(0) == "Vec" {
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    if expected == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    if !is_vec_ty(ctx, expected) { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    return ExprTyResult { ok: true, ty: expected };
  }

  // Resolve function call.
  if parts.len() == 1 {
    return tc_call_func_unqualified(ctx, w, mod_path, aliases, exprs, l0, parts.get(0), args, expected);
  }
  if parts.len() == 2 {
    let mp: String = find_alias(aliases, parts.get(0));
    if mp != "" {
      return tc_call_func_qualified(ctx, w, mod_path, aliases, exprs, l0, mp, parts.get(1), args, expected);
    }
    // Otherwise: `Enum.Variant(...)` in current module.
    return tc_call_enum_ctor(ctx, w, mod_path, aliases, exprs, l0, mod_path, parts.get(0), parts.get(1), args, expected);
  }
  if parts.len() == 3 {
    let mp: String = find_alias(aliases, parts.get(0));
    if mp == "" { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    return tc_call_enum_ctor(ctx, w, mod_path, aliases, exprs, l0, mp, parts.get(1), parts.get(2), args, expected);
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad };
}

fn tc_call_vec_method(ctx: Ctx, w: World, mod_path: String, aliases: Vec[ImportAlias], exprs: ast.ExprPool, l0: Locals, recv_ty: i32, mname: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  let elem: i32 = vec_elem(ctx, recv_ty);

  if mname == "push" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    let ar: ExprTyResult = tc_expr(ctx, w, mod_path, aliases, exprs, l0, args.get(0), elem);
    if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    if expected != -1 && expected != ctx.ty_unit { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    return ExprTyResult { ok: true, ty: ctx.ty_unit };
  }

  if mname == "len" {
    if args.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    if expected != -1 && expected != ctx.ty_i32 { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    return ExprTyResult { ok: true, ty: ctx.ty_i32 };
  }

  if mname == "get" {
    if args.len() != 1 { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    let idxr: ExprTyResult = tc_expr(ctx, w, mod_path, aliases, exprs, l0, args.get(0), ctx.ty_i32);
    if !idxr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    if expected != -1 && expected != elem { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    return ExprTyResult { ok: true, ty: elem };
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad };
}

fn tc_call_func_unqualified(ctx: Ctx, w: World, mod_path: String, aliases: Vec[ImportAlias], exprs: ast.ExprPool, l0: Locals, name: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  // Prefer local module, otherwise prelude fallback.
  let fr0: FindFuncResult = find_func(ctx, mod_path, name);
  if fr0.found {
    return tc_call_func_sig(ctx, w, mod_path, aliases, exprs, l0, mod_path, fr0.sig, args, expected);
  }
  let prelude: String = "std/prelude";
  let fr1: FindFuncResult = find_func(ctx, prelude, name);
  if fr1.found {
    if !fr1.sig.is_pub { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    return tc_call_func_sig(ctx, w, mod_path, aliases, exprs, l0, prelude, fr1.sig, args, expected);
  }
  return ExprTyResult { ok: false, ty: ctx.ty_bad };
}

fn tc_call_func_qualified(ctx: Ctx, w: World, cur_mod: String, aliases: Vec[ImportAlias], exprs: ast.ExprPool, l0: Locals, target_mod: String, name: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  let fr: FindFuncResult = find_func(ctx, target_mod, name);
  if !fr.found { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
  if target_mod != cur_mod && !fr.sig.is_pub { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
  return tc_call_func_sig(ctx, w, cur_mod, aliases, exprs, l0, target_mod, fr.sig, args, expected);
}

fn tc_call_func_sig(ctx: Ctx, w: World, cur_mod: String, aliases: Vec[ImportAlias], exprs: ast.ExprPool, l0: Locals, target_mod: String, sig: FuncSig, args: Vec[i32], expected: i32) -> ExprTyResult {
  let _tm: String = target_mod; // reserved for future: implicit receiver / UFCS.
  if sig.type_params != 0 {
    // v0: no generic instantiation in typechecker yet.
    return ExprTyResult { ok: false, ty: ctx.ty_bad };
  }
  if args.len() != sig.params.len() { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
  let mut i: i32 = 0;
  while i < args.len() {
    let want: i32 = sig.params.get(i);
    let ar: ExprTyResult = tc_expr(ctx, w, cur_mod, aliases, exprs, l0, args.get(i), want);
    if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    if ar.ty != want { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    i = i + 1;
  }
  if expected != -1 && expected != sig.ret { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
  return ExprTyResult { ok: true, ty: sig.ret };
}

fn tc_call_enum_ctor(ctx: Ctx, w: World, cur_mod: String, aliases: Vec[ImportAlias], exprs: ast.ExprPool, l0: Locals, enum_mod: String, enum_name: String, var_name: String, args: Vec[i32], expected: i32) -> ExprTyResult {
  let fe: FindEnumResult = find_enum(ctx, enum_mod, enum_name);
  if !fe.found { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
  let es: EnumSig = fe.sig;
  if enum_mod != cur_mod && !es.is_pub { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }

  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != args.len() { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
      let mut ai: i32 = 0;
      while ai < args.len() {
        let want: i32 = v.fields.get(ai);
        let ar: ExprTyResult = tc_expr(ctx, w, cur_mod, aliases, exprs, l0, args.get(ai), want);
        if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
        if ar.ty != want { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
        ai = ai + 1;
      }

      let out_ty: i32 = if expected != -1 { expected } else { find_enum_ty_idx(ctx, enum_mod, enum_name) };
      if out_ty == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
      if expected != -1 && expected != out_ty { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
      return ExprTyResult { ok: true, ty: out_ty };
    }
    vi = vi + 1;
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad };
}

