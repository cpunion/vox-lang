import "ast" as ast
import "ir" as ir

pub struct TySub { pub name: String, pub ty: i32 }
pub struct ConstSub { pub name: String, pub ty: i32, pub iv: i64, pub text: String }

pub struct UnifyResult { pub ok: bool, pub subs: Vec[TySub] }
pub struct ParseConstGenericArgResult { pub ok: bool, pub iv: i64, pub text: String }

pub fn is_const_generic_arg_tn(tn: ast.TypeName) -> bool {
  return tn.parts.len() == 2 && tn.parts.get(0) == "@const" && tn.args.len() == 0;
}

pub fn const_generic_arg_text(tn: ast.TypeName) -> String {
  if !is_const_generic_arg_tn(tn) { return ""; }
  return tn.parts.get(1);
}

fn is_unsigned_int_kind_gen(k: ir.TyKind) -> bool {
  return match k {
    ir.TyKind.U8 => true,
    ir.TyKind.U16 => true,
    ir.TyKind.U32 => true,
    ir.TyKind.U64 => true,
    ir.TyKind.USize => true,
    _ => false,
  };
}

fn const_i64_in_range_for_kind(iv: i64, k: ir.TyKind) -> bool {
  if k == ir.TyKind.I8 { return iv >= -128 && iv <= 127; }
  if k == ir.TyKind.U8 { return iv >= 0 && iv <= 255; }
  if k == ir.TyKind.I16 { return iv >= -32768 && iv <= 32767; }
  if k == ir.TyKind.U16 { return iv >= 0 && iv <= 65535; }
  if k == ir.TyKind.I32 { return iv >= -2147483648 && iv <= 2147483647; }
  if k == ir.TyKind.U32 { return iv >= 0 && iv <= 4294967295; }
  if k == ir.TyKind.I64 { return true; }
  if k == ir.TyKind.ISize { return true; }
  if k == ir.TyKind.U64 { return true; }
  if k == ir.TyKind.USize { return true; }
  return false;
}

pub fn parse_const_generic_arg(ctx: Ctx, tn: ast.TypeName, want_ty: i32) -> ParseConstGenericArgResult {
  let text: String = const_generic_arg_text(tn);
  if text == "" { return ParseConstGenericArgResult { ok: false, iv: 0, text: "" }; }
  let bty: i32 = strip_range(ctx, want_ty);
  let bt: ir.Ty = ir.ty_pool_get(ctx.pool, bty);
  let kind: ir.TyKind = bt.kind;
  if !is_int_like_ty(ctx, bty) { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }

  if is_unsigned_int_kind_gen(kind) {
    if text.len() > 0 && text.byte_at(0) == 45 { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
    let pu: ParseU64DecResult = parse_u64_dec(text);
    if !pu.ok { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
    if !const_i64_in_range_for_kind(pu.val, kind) { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
    return ParseConstGenericArgResult { ok: true, iv: pu.val, text: text };
  }

  let ps: ParseI64DecResult = parse_i64_dec(text);
  if !ps.ok { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
  if !const_i64_in_range_for_kind(ps.val, kind) { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
  return ParseConstGenericArgResult { ok: true, iv: ps.val, text: text };
}

fn subs_lookup(subs: Vec[TySub], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < subs.len() {
    let s: TySub = subs.get(i);
    if s.name == name { return s.ty; }
    i = i + 1;
  }
  return -1;
}

fn subs_add(subs0: Vec[TySub], name: String, ty: i32) -> Vec[TySub] {
  let mut subs: Vec[TySub] = subs0;
  subs.push(TySub { name: name, ty: ty });
  return subs;
}

fn is_param_ty(t: ir.Ty) -> bool { return match t.kind { ir.TyKind.Param => true, _ => false }; }
fn is_vec_ty2(t: ir.Ty) -> bool { return match t.kind { ir.TyKind.Vec => true, _ => false }; }

pub fn ty_has_param(ctx: Ctx, ty_idx: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  if t.kind == ir.TyKind.Param { return true; }
  if t.kind == ir.TyKind.Vec { return ty_has_param(ctx, t.elem); }
  if t.kind == ir.TyKind.Range { return ty_has_param(ctx, t.elem); }
  return false;
}

pub fn unify_ty(ctx: Ctx, pattern: i32, got: i32, subs0: Vec[TySub]) -> UnifyResult {
  let pt: ir.Ty = ir.ty_pool_get(ctx.pool, pattern);
  if is_param_ty(pt) {
    let cur: i32 = subs_lookup(subs0, pt.name);
    if cur == -1 { return UnifyResult { ok: true, subs: subs_add(subs0, pt.name, got) }; }
    if cur == got { return UnifyResult { ok: true, subs: subs0 }; }
    // Allow a refined int type to satisfy an already-bound base int param (widening).
    if assignable_to(ctx, cur, got) { return UnifyResult { ok: true, subs: subs0 }; }
    return UnifyResult { ok: false, subs: subs0 };
  }

  if is_vec_ty2(pt) {
    let gt: ir.Ty = ir.ty_pool_get(ctx.pool, got);
    if !is_vec_ty2(gt) { return UnifyResult { ok: false, subs: subs0 }; }
    return unify_ty(ctx, pt.elem, gt.elem, subs0);
  }

  if pattern == got { return UnifyResult { ok: true, subs: subs0 }; }
  return UnifyResult { ok: false, subs: subs0 };
}

fn find_vec_ty_idx(ctx: Ctx, elem: i32) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    if t.kind == ir.TyKind.Vec && t.elem == elem { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_range_ty_idx_subst(ctx: Ctx, elem: i32, lo: i64, hi: i64) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    if t.kind == ir.TyKind.Range && t.elem == elem && t.lo == lo && t.hi == hi { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_dot_pos_subst(s: String) -> i32 {
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 46 { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_param_ty_idx_subst(ctx: Ctx, name: String) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    if t.kind == ir.TyKind.Param && t.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn subst_proj_param(ctx: Ctx, name: String, subs: Vec[TySub]) -> i32 {
  // Projection-like type parameter names are represented as flat params:
  //   "U.Item", "U.Item.Sub", ...
  // If base `U` is substituted to param `T`, rewrite to `T.Item...`.
  let dot: i32 = find_dot_pos_subst(name);
  if dot <= 0 { return -1; }
  let base: String = name.slice(0, dot);
  let suffix: String = name.slice(dot, name.len());

  let bty: i32 = subs_lookup(subs, base);
  if bty == -1 { return -1; }
  let bt: ir.Ty = ir.ty_pool_get(ctx.pool, bty);
  if bt.kind != ir.TyKind.Param { return -1; }

  let want: String = bt.name.concat(suffix);
  let sub2: i32 = subs_lookup(subs, want);
  if sub2 != -1 { return sub2; }

  return find_param_ty_idx_subst(ctx, want);
}

pub fn subst_ty(ctx: Ctx, ty_idx: i32, subs: Vec[TySub]) -> i32 {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  if t.kind == ir.TyKind.Param {
    let r: i32 = subs_lookup(subs, t.name);
    if r != -1 { return r; }
    let rp: i32 = subst_proj_param(ctx, t.name, subs);
    if rp != -1 { return rp; }
    return ty_idx;
  }
  if t.kind == ir.TyKind.Vec {
    let e: i32 = subst_ty(ctx, t.elem, subs);
    if e == t.elem { return ty_idx; }
    let vidx: i32 = find_vec_ty_idx(ctx, e);
    if vidx == -1 { return ctx.ty_bad; }
    return vidx;
  }
  if t.kind == ir.TyKind.Range {
    let e2: i32 = subst_ty(ctx, t.elem, subs);
    if e2 == t.elem { return ty_idx; }
    let ridx: i32 = find_range_ty_idx_subst(ctx, e2, t.lo, t.hi);
    if ridx == -1 { return ctx.ty_bad; }
    return ridx;
  }
  return ty_idx;
}

pub fn ty_inst_str(ctx: Ctx, ty_idx: i32) -> String {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  if t.kind == ir.TyKind.Unit { return "()"; }
  if t.kind == ir.TyKind.Bool { return "bool"; }
  if t.kind == ir.TyKind.I8 { return "i8"; }
  if t.kind == ir.TyKind.U8 { return "u8"; }
  if t.kind == ir.TyKind.I16 { return "i16"; }
  if t.kind == ir.TyKind.U16 { return "u16"; }
  if t.kind == ir.TyKind.I32 { return "i32"; }
  if t.kind == ir.TyKind.U32 { return "u32"; }
  if t.kind == ir.TyKind.I64 { return "i64"; }
  if t.kind == ir.TyKind.U64 { return "u64"; }
  if t.kind == ir.TyKind.ISize { return "isize"; }
  if t.kind == ir.TyKind.USize { return "usize"; }
  if t.kind == ir.TyKind.F32 { return "f32"; }
  if t.kind == ir.TyKind.F64 { return "f64"; }
  if t.kind == ir.TyKind.String { return "String"; }
  if t.kind == ir.TyKind.Param { return t.name; }
  if t.kind == ir.TyKind.Vec { return "Vec[".concat(ty_inst_str(ctx, t.elem)).concat("]"); }
  if t.kind == ir.TyKind.Struct || t.kind == ir.TyKind.Enum {
    // Use `mod::Name` with '/' normalized to '.' for readability.
    if t.mod_path == "" || t.mod_path == "main" { return t.name; }
    let mut s: String = t.mod_path;
    let mut i: i32 = 0;
    while i < s.len() {
      if s.byte_at(i) == 47 { s = s.slice(0, i).concat(".").concat(s.slice(i + 1, s.len())); }
      i = i + 1;
    }
    return s.concat("::").concat(t.name);
  }
  return "<bad>";
}

fn hex2(b: i32) -> String {
  let hex: String = "0123456789abcdef";
  let hi: i32 = b / 16;
  let lo: i32 = b % 16;
  return hex.slice(hi, hi + 1).concat(hex.slice(lo, lo + 1));
}

pub fn mangle_ident(s: String) -> String {
  // Keep [A-Za-z0-9], hex-escape everything else. Prefix with 'g'.
  let mut out: String = "g";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    let ok: bool = (ch >= 97 && ch <= 122) || (ch >= 65 && ch <= 90) || (ch >= 48 && ch <= 57);
    if ok {
      out = out.concat(s.slice(i, i + 1));
    } else {
      out = out.concat("_").concat(hex2(ch));
    }
    i = i + 1;
  }
  return out;
}

pub fn inst_suffix(ctx: Ctx, type_params: Vec[String], subs: Vec[TySub]) -> String {
  return inst_suffix_ex(ctx, type_params, Vec(), subs, Vec());
}

fn const_sub_lookup(csubs: Vec[ConstSub], name: String) -> ConstSub {
  let mut i: i32 = 0;
  while i < csubs.len() {
    let cs: ConstSub = csubs.get(i);
    if cs.name == name { return cs; }
    i = i + 1;
  }
  return ConstSub { name: "", ty: -1, iv: 0, text: "" };
}

pub fn inst_suffix_ex(ctx: Ctx, type_params: Vec[String], const_params: Vec[ConstParamSig], subs: Vec[TySub], csubs: Vec[ConstSub]) -> String {
  let mut raw: String = "";
  let mut i: i32 = 0;
  while i < type_params.len() {
    let tp: String = type_params.get(i);
    let ty: i32 = subs_lookup(subs, tp);
    raw = raw.concat(tp).concat("=").concat(ty_inst_str(ctx, ty));
    if i + 1 < type_params.len() { raw = raw.concat(","); }
    i = i + 1;
  }
  let mut j: i32 = 0;
  while j < const_params.len() {
    if raw != "" { raw = raw.concat(","); }
    let cp: ConstParamSig = const_params.get(j);
    let cs: ConstSub = const_sub_lookup(csubs, cp.name);
    if cs.name == "" {
      raw = raw.concat(cp.name).concat("=<missing>");
    } else {
      raw = raw.concat(cp.name)
        .concat("=").concat(cs.text)
        .concat(":").concat(ty_inst_str(ctx, cp.ty));
    }
    j = j + 1;
  }
  return mangle_ident(raw);
}

pub fn inst_name(ctx: Ctx, base: String, type_params: Vec[String], subs: Vec[TySub]) -> String {
  return inst_name_ex(ctx, base, type_params, Vec(), subs, Vec());
}

pub fn inst_name_ex(ctx: Ctx, base: String, type_params: Vec[String], const_params: Vec[ConstParamSig], subs: Vec[TySub], csubs: Vec[ConstSub]) -> String {
  return base.concat("$").concat(inst_suffix_ex(ctx, type_params, const_params, subs, csubs));
}
