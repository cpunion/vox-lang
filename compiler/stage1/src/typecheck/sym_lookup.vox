pub struct FindFuncResult { pub found: bool, pub sig: FuncSig }

pub fn find_func(ctx: Ctx, mod_path: String, name: String) -> FindFuncResult {
  let fs: Vec[FuncSym] = ctx.funcs;
  let mut i: i32 = 0;
  while i < fs.len() {
    let f: FuncSym = fs.get(i);
    if f.mod_path == mod_path && f.name == name {
      return FindFuncResult { found: true, sig: f.sig };
    }
    i = i + 1;
  }
  return FindFuncResult { found: false, sig: FuncSig { params: Vec(), ret: ctx.ty_bad, is_pub: false, type_params: Vec(), type_param_bounds: Vec() } };
}

pub struct FindStructResult { pub found: bool, pub sig: StructSig }
pub fn find_struct(ctx: Ctx, mod_path: String, name: String) -> FindStructResult {
  let ss: Vec[StructSig] = ctx.structs;
  let mut i: i32 = 0;
  while i < ss.len() {
    let s: StructSig = ss.get(i);
    if s.mod_path == mod_path && s.name == name {
      return FindStructResult { found: true, sig: s };
    }
    i = i + 1;
  }
  return FindStructResult { found: false, sig: StructSig { mod_path: "", name: "", is_pub: false, fields: Vec() } };
}

pub struct FindEnumResult { pub found: bool, pub sig: EnumSig }
pub fn find_enum(ctx: Ctx, mod_path: String, name: String) -> FindEnumResult {
  let es: Vec[EnumSig] = ctx.enums;
  let mut i: i32 = 0;
  while i < es.len() {
    let e: EnumSig = es.get(i);
    if e.mod_path == mod_path && e.name == name {
      return FindEnumResult { found: true, sig: e };
    }
    i = i + 1;
  }
  return FindEnumResult { found: false, sig: EnumSig { mod_path: "", name: "", is_pub: false, vars: Vec() } };
}

pub struct FindTraitResult { pub found: bool, pub sig: TraitSig }
pub fn find_trait(ctx: Ctx, mod_path: String, name: String) -> FindTraitResult {
  let ts: Vec[TraitSig] = ctx.traits;
  let mut i: i32 = 0;
  while i < ts.len() {
    let t: TraitSig = ts.get(i);
    if t.mod_path == mod_path && t.name == name {
      return FindTraitResult { found: true, sig: t };
    }
    i = i + 1;
  }
  return FindTraitResult { found: false, sig: TraitSig { mod_path: "", name: "", is_pub: false, methods: Vec() } };
}

pub struct FindTraitMethodResult { pub found: bool, pub m: TraitMethodSig }
pub fn find_trait_method(ts: TraitSig, name: String) -> FindTraitMethodResult {
  let mut i: i32 = 0;
  while i < ts.methods.len() {
    let m: TraitMethodSig = ts.methods.get(i);
    if m.name == name { return FindTraitMethodResult { found: true, m: m }; }
    i = i + 1;
  }
  return FindTraitMethodResult { found: false, m: TraitMethodSig { name: "", sig: FuncSig { params: Vec(), ret: -1, is_pub: false, type_params: Vec(), type_param_bounds: Vec() } } };
}

pub struct FindImplResult { pub found: bool, pub sig: ImplSig }
pub fn find_impl(ctx: Ctx, trait_mod: String, trait_name: String, for_ty: i32) -> FindImplResult {
  let is: Vec[ImplSig] = ctx.impls;
  let mut i: i32 = 0;
  while i < is.len() {
    let it: ImplSig = is.get(i);
    if it.trait_mod_path == trait_mod && it.trait_name == trait_name && it.for_ty == for_ty {
      return FindImplResult { found: true, sig: it };
    }
    i = i + 1;
  }
  return FindImplResult { found: false, sig: ImplSig { mod_path: "", decl_idx: -1, trait_mod_path: "", trait_name: "", for_ty: -1, methods: Vec() } };
}

pub struct FindImplMethodResult { pub found: bool, pub m: ImplMethodSig }
pub fn find_impl_method(isg: ImplSig, name: String) -> FindImplMethodResult {
  let mut i: i32 = 0;
  while i < isg.methods.len() {
    let m: ImplMethodSig = isg.methods.get(i);
    if m.name == name { return FindImplMethodResult { found: true, m: m }; }
    i = i + 1;
  }
  return FindImplMethodResult { found: false, m: ImplMethodSig { name: "", lowered_name: "", sig: FuncSig { params: Vec(), ret: -1, is_pub: false, type_params: Vec(), type_param_bounds: Vec() } } };
}
