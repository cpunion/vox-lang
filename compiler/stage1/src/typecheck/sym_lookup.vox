import "ast" as ast

pub struct FindFuncResult { pub found: bool, pub sig: FuncSig }

pub fn find_func(ctx: Ctx, mod_path: String, name: String) -> FindFuncResult {
  let fs: Vec[FuncSym] = ctx.funcs;
  let mut i: i32 = 0;
  while i < fs.len() {
    let f: FuncSym = fs.get(i);
    if f.mod_path == mod_path && f.name == name {
      return FindFuncResult { found: true, sig: f.sig };
    }
    i = i + 1;
  }
  return FindFuncResult { found: false, sig: FuncSig { params: Vec(), ret: ctx.ty_bad, vis: ast.vis_private(), is_pub: false, type_params: Vec(), const_params: Vec(), type_param_bounds: Vec() } };
}

pub struct FindStructResult { pub found: bool, pub sig: StructSig }
pub fn find_struct(ctx: Ctx, mod_path: String, name: String) -> FindStructResult {
  let ss: Vec[StructSig] = ctx.structs;
  let mut i: i32 = 0;
  while i < ss.len() {
    let s: StructSig = ss.get(i);
    if s.mod_path == mod_path && s.name == name {
      return FindStructResult { found: true, sig: s };
    }
    i = i + 1;
  }
  return FindStructResult { found: false, sig: StructSig { mod_path: "", name: "", base_name: "", vis: ast.vis_private(), is_pub: false, fields: Vec() } };
}

pub struct FindEnumResult { pub found: bool, pub sig: EnumSig }
pub fn find_enum(ctx: Ctx, mod_path: String, name: String) -> FindEnumResult {
  let es: Vec[EnumSig] = ctx.enums;
  let mut i: i32 = 0;
  while i < es.len() {
    let e: EnumSig = es.get(i);
    if e.mod_path == mod_path && e.name == name {
      return FindEnumResult { found: true, sig: e };
    }
    i = i + 1;
  }
  return FindEnumResult { found: false, sig: EnumSig { mod_path: "", name: "", base_name: "", vis: ast.vis_private(), is_pub: false, vars: Vec() } };
}

pub struct FindTraitResult { pub found: bool, pub sig: TraitSig }
pub fn find_trait(ctx: Ctx, mod_path: String, name: String) -> FindTraitResult {
  let ts: Vec[TraitSig] = ctx.traits;
  let mut i: i32 = 0;
  while i < ts.len() {
    let t: TraitSig = ts.get(i);
    if t.mod_path == mod_path && t.name == name {
      return FindTraitResult { found: true, sig: t };
    }
    i = i + 1;
  }
  return FindTraitResult { found: false, sig: TraitSig { mod_path: "", name: "", vis: ast.vis_private(), is_pub: false, supers: Vec(), assoc_types: Vec(), methods: Vec() } };
}

pub struct FindTraitMethodResult { pub found: bool, pub m: TraitMethodSig }
pub fn find_trait_method(ts: TraitSig, name: String) -> FindTraitMethodResult {
  let mut i: i32 = 0;
  while i < ts.methods.len() {
    let m: TraitMethodSig = ts.methods.get(i);
    if m.name == name { return FindTraitMethodResult { found: true, m: m }; }
    i = i + 1;
  }
  return FindTraitMethodResult { found: false, m: TraitMethodSig { name: "", sig: FuncSig { params: Vec(), ret: -1, vis: ast.vis_private(), is_pub: false, type_params: Vec(), const_params: Vec(), type_param_bounds: Vec() }, has_default: false, default_mod_path: "", default_file: "", default_params: Vec(), default_body: ast.Block { stmts: Vec() } } };
}

pub struct FindImplResult { pub found: bool, pub sig: ImplSig }
pub fn find_impl(ctx: Ctx, trait_mod: String, trait_name: String, for_ty: i32) -> FindImplResult {
  let is: Vec[ImplSig] = ctx.impls;
  let mut i: i32 = 0;
  while i < is.len() {
    let it: ImplSig = is.get(i);
    if it.trait_mod_path == trait_mod && it.trait_name == trait_name && it.for_ty == for_ty {
      return FindImplResult { found: true, sig: it };
    }
    i = i + 1;
  }
  return FindImplResult { found: false, sig: ImplSig { mod_path: "", decl_idx: -1, trait_mod_path: "", trait_name: "", for_ty: -1, assoc_types: Vec(), methods: Vec() } };
}

pub struct FindImplForTyResult {
  pub found: bool,
  pub ambiguous: bool,
  pub candidates: String,
  pub sig: ImplSig,
}

fn impl_match_candidates_text(ctx: Ctx, trait_mod: String, trait_name: String, recv_ty: i32) -> String {
  let mut out: String = "";
  let mut n: i32 = 0;
  let mut i: i32 = 0;
  while i < ctx.impls.len() {
    let isg: ImplSig = ctx.impls.get(i);
    if isg.trait_mod_path == trait_mod && isg.trait_name == trait_name {
      let ur: UnifyResult = unify_ty(ctx, isg.for_ty, recv_ty, Vec());
      if ur.ok {
        if n > 0 { out = out.concat(", "); }
        out = out.concat(ty_inst_str(ctx, isg.for_ty));
        n = n + 1;
        if n >= 8 { return out.concat(", ..."); }
      }
    }
    i = i + 1;
  }
  if n == 0 { return "<none>"; }
  return out;
}

pub fn find_impl_for_ty(ctx: Ctx, trait_mod: String, trait_name: String, recv_ty: i32) -> FindImplForTyResult {
  let mut found: bool = false;
  let mut out: ImplSig = ImplSig { mod_path: "", decl_idx: -1, trait_mod_path: "", trait_name: "", for_ty: -1, assoc_types: Vec(), methods: Vec() };
  let mut i: i32 = 0;
  while i < ctx.impls.len() {
    let isg: ImplSig = ctx.impls.get(i);
    if isg.trait_mod_path == trait_mod && isg.trait_name == trait_name {
      let ur: UnifyResult = unify_ty(ctx, isg.for_ty, recv_ty, Vec());
      if ur.ok {
        if found {
          let cands: String = impl_match_candidates_text(ctx, trait_mod, trait_name, recv_ty);
          return FindImplForTyResult { found: false, ambiguous: true, candidates: cands, sig: out };
        }
        found = true;
        out = isg;
      }
    }
    i = i + 1;
  }
  return FindImplForTyResult { found: found, ambiguous: false, candidates: "", sig: out };
}

pub struct FindImplMethodResult { pub found: bool, pub m: ImplMethodSig }
pub fn find_impl_method(isg: ImplSig, name: String) -> FindImplMethodResult {
  let mut i: i32 = 0;
  while i < isg.methods.len() {
    let m: ImplMethodSig = isg.methods.get(i);
    if m.name == name { return FindImplMethodResult { found: true, m: m }; }
    i = i + 1;
  }
  return FindImplMethodResult { found: false, m: ImplMethodSig { name: "", lowered_name: "", sig: FuncSig { params: Vec(), ret: -1, vis: ast.vis_private(), is_pub: false, type_params: Vec(), const_params: Vec(), type_param_bounds: Vec() }, from_default: false, default_mod_path: "", default_file: "", default_params: Vec(), default_body: ast.Block { stmts: Vec() } } };
}

pub struct FindTraitDispatchMethodResult {
  pub found: bool,
  pub ambiguous: bool,
  pub candidates: String,
  pub impl_mod_path: String,
  pub m: ImplMethodSig,
}

pub fn trait_impl_candidates_text(ctx: Ctx, trait_mod: String, trait_name: String) -> String {
  let mut out: String = "";
  let mut n: i32 = 0;
  let mut i: i32 = 0;
  while i < ctx.impls.len() {
    let isg: ImplSig = ctx.impls.get(i);
    if isg.trait_mod_path == trait_mod && isg.trait_name == trait_name {
      if n > 0 { out = out.concat(", "); }
      out = out.concat(ty_inst_str(ctx, isg.for_ty));
      n = n + 1;
      if n >= 8 { return out.concat(", ..."); }
    }
    i = i + 1;
  }
  if n == 0 { return "<none>"; }
  return out;
}

pub fn trait_method_candidates_text(ts: TraitSig) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < ts.methods.len() {
    if i > 0 { out = out.concat(", "); }
    out = out.concat(ts.methods.get(i).name);
    if i >= 7 { return out.concat(", ..."); }
    i = i + 1;
  }
  if out.len() == 0 { return "<none>"; }
  return out;
}

pub fn find_trait_dispatch_method(ctx: Ctx, cur_mod: String, recv_ty: i32, name: String) -> FindTraitDispatchMethodResult {
  let mut found: bool = false;
  let mut first_trait: String = "";
  let mut out_mod: String = "";
  let mut out_m: ImplMethodSig = ImplMethodSig { name: "", lowered_name: "", sig: FuncSig { params: Vec(), ret: -1, vis: ast.vis_private(), is_pub: false, type_params: Vec(), const_params: Vec(), type_param_bounds: Vec() }, from_default: false, default_mod_path: "", default_file: "", default_params: Vec(), default_body: ast.Block { stmts: Vec() } };

  let mut i: i32 = 0;
  while i < ctx.impls.len() {
    let isg: ImplSig = ctx.impls.get(i);
    let ur: UnifyResult = unify_ty(ctx, isg.for_ty, recv_ty, Vec());
    if !ur.ok { i = i + 1; continue; }
    let mf: FindImplMethodResult = find_impl_method(isg, name);
    if !mf.found { i = i + 1; continue; }
    let tf: FindTraitResult = find_trait(ctx, isg.trait_mod_path, isg.trait_name);
    if !tf.found { i = i + 1; continue; }
    if !vis_allows(tf.sig.vis, isg.trait_mod_path, cur_mod) { i = i + 1; continue; }

    if found {
      let cands: String = first_trait.concat(".").concat(name).concat(", ").concat(isg.trait_name).concat(".").concat(name);
      return FindTraitDispatchMethodResult { found: false, ambiguous: true, candidates: cands, impl_mod_path: "", m: out_m };
    }
    found = true;
    first_trait = isg.trait_name;
    out_mod = isg.mod_path;
    out_m = mf.m;
    i = i + 1;
  }
  return FindTraitDispatchMethodResult { found: found, ambiguous: false, candidates: "", impl_mod_path: out_mod, m: out_m };
}
