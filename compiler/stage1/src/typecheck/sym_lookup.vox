struct FindFuncResult { found: bool, sig: FuncSig }

fn find_func(ctx: Ctx, mod_path: String, name: String) -> FindFuncResult {
  let fs: Vec[FuncSym] = ctx.funcs;
  let mut i: i32 = 0;
  while i < fs.len() {
    let f: FuncSym = fs.get(i);
    if f.mod_path == mod_path && f.name == name {
      return FindFuncResult { found: true, sig: f.sig };
    }
    i = i + 1;
  }
  return FindFuncResult { found: false, sig: FuncSig { params: Vec(), ret: ctx.ty_bad, is_pub: false, type_params: 0 } };
}

struct FindStructResult { found: bool, sig: StructSig }
fn find_struct(ctx: Ctx, mod_path: String, name: String) -> FindStructResult {
  let ss: Vec[StructSig] = ctx.structs;
  let mut i: i32 = 0;
  while i < ss.len() {
    let s: StructSig = ss.get(i);
    if s.mod_path == mod_path && s.name == name {
      return FindStructResult { found: true, sig: s };
    }
    i = i + 1;
  }
  return FindStructResult { found: false, sig: StructSig { mod_path: "", name: "", is_pub: false, fields: Vec() } };
}

struct FindEnumResult { found: bool, sig: EnumSig }
fn find_enum(ctx: Ctx, mod_path: String, name: String) -> FindEnumResult {
  let es: Vec[EnumSig] = ctx.enums;
  let mut i: i32 = 0;
  while i < es.len() {
    let e: EnumSig = es.get(i);
    if e.mod_path == mod_path && e.name == name {
      return FindEnumResult { found: true, sig: e };
    }
    i = i + 1;
  }
  return FindEnumResult { found: false, sig: EnumSig { mod_path: "", name: "", is_pub: false, vars: Vec() } };
}
