import "std/testing" as t
import "parse" as p
import "typecheck" as tc

fn eh_parse_prog(src: String) -> p.ParseResult { return p.parse_text(src); }

fn eh_add_mod(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = eh_parse_prog(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn test_typecheck_question_propagation_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String =
    "enum Result[T, E] { Ok(T), Err(E) }\n"
      .concat("fn get(flag: bool) -> Result[i32, String] {\n")
      .concat("  if flag { return .Ok(7); }\n")
      .concat("  return .Err(\"bad\");\n")
      .concat("}\n")
      .concat("fn main(flag: bool) -> Result[i32, String] {\n")
      .concat("  let v: i32 = get(flag)?;\n")
      .concat("  return .Ok(v + 1);\n")
      .concat("}");
  w = eh_add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(r.ok);
}

fn test_typecheck_try_block_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String =
    "enum Result[T, E] { Ok(T), Err(E) }\n"
      .concat("fn get() -> Result[i32, String] { return .Ok(3); }\n")
      .concat("fn main() -> Result[i32, String] {\n")
      .concat("  let r: Result[i32, String] = try {\n")
      .concat("    let v: i32 = get()?;\n")
      .concat("    .Ok(v + 2)\n")
      .concat("  };\n")
      .concat("  return r;\n")
      .concat("}");
  w = eh_add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(r.ok);
}

fn test_typecheck_question_requires_result_return_type() -> () {
  let mut w: tc.World = tc.world();
  let src: String =
    "enum Result[T, E] { Ok(T), Err(E) }\n"
      .concat("fn get() -> Result[i32, String] { return .Ok(1); }\n")
      .concat("fn main() -> i32 {\n")
      .concat("  let v: i32 = get()?;\n")
      .concat("  return v;\n")
      .concat("}");
  w = eh_add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!r.ok);
}
