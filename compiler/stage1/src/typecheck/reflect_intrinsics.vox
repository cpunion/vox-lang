import "ir" as ir

pub struct ReflectIntResult { pub ok: bool, pub err: String, pub iv: i64 }
pub struct ReflectTextResult { pub ok: bool, pub err: String, pub text: String }
pub struct ReflectBoolResult { pub ok: bool, pub err: String, pub bv: bool }

struct TyLayoutResult { ok: bool, err: String, size: i64, align: i64 }

pub fn is_reflect_intrinsic_name(name: String) -> bool {
  return
    name == "@size_of" ||
    name == "@align_of" ||
    name == "@type" ||
    name == "@type_name" ||
    name == "@field_count" ||
    name == "@field_name" ||
    name == "@field_type" ||
    name == "@is_integer" ||
    name == "@is_signed_int" ||
    name == "@is_unsigned_int" ||
    name == "@is_float" ||
    name == "@is_bool" ||
    name == "@is_string" ||
    name == "@is_struct" ||
    name == "@is_enum" ||
    name == "@is_vec" ||
    name == "@is_range";
}

fn layout_ok(size: i64, align: i64) -> TyLayoutResult {
  return TyLayoutResult { ok: true, err: "", size: size, align: align };
}

fn layout_err(msg: String) -> TyLayoutResult {
  return TyLayoutResult { ok: false, err: msg, size: 0, align: 1 };
}

fn contains_str_reflect(xs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn max_i64_reflect(a: i64, b: i64) -> i64 { return if a > b { a } else { b }; }

fn align_up_i64(v: i64, a0: i64) -> i64 {
  let a: i64 = if a0 <= 1 { 1 } else { a0 };
  let r: i64 = v % a;
  if r == 0 { return v; }
  return v + (a - r);
}

fn scalar_layout(k: ir.TyKind) -> TyLayoutResult {
  if k == ir.TyKind.Bool || k == ir.TyKind.I8 || k == ir.TyKind.U8 { return layout_ok(1, 1); }
  if k == ir.TyKind.I16 || k == ir.TyKind.U16 { return layout_ok(2, 2); }
  if k == ir.TyKind.I32 || k == ir.TyKind.U32 || k == ir.TyKind.F32 { return layout_ok(4, 4); }
  if k == ir.TyKind.I64 || k == ir.TyKind.U64 || k == ir.TyKind.ISize || k == ir.TyKind.USize || k == ir.TyKind.F64 {
    return layout_ok(8, 8);
  }
  return layout_err("not scalar");
}

fn nominal_key(prefix: String, mod_path: String, name: String) -> String {
  return prefix.concat(":").concat(mod_path).concat("::").concat(name);
}

fn layout_fields_seen(ctx: Ctx, fields: Vec[i32], seen: Vec[String]) -> TyLayoutResult {
  if fields.len() == 0 { return layout_ok(1, 1); }
  let mut size: i64 = 0;
  let mut align: i64 = 1;
  let mut i: i32 = 0;
  while i < fields.len() {
    let lr: TyLayoutResult = layout_of_ty_seen(ctx, fields.get(i), seen);
    if !lr.ok { return lr; }
    size = align_up_i64(size, lr.align);
    size = size + lr.size;
    align = max_i64_reflect(align, lr.align);
    i = i + 1;
  }
  size = align_up_i64(size, align);
  return layout_ok(size, align);
}

fn layout_struct_seen(ctx: Ctx, mod_path: String, name: String, seen0: Vec[String]) -> TyLayoutResult {
  let key: String = nominal_key("S", mod_path, name);
  if contains_str_reflect(seen0, key) {
    return layout_err("cyclic nominal layout");
  }
  let fs: FindStructResult = find_struct(ctx, mod_path, name);
  if !fs.found {
    return layout_err("unknown struct layout");
  }
  let mut seen: Vec[String] = seen0;
  seen.push(key);
  let mut tys: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < fs.sig.fields.len() {
    tys.push(fs.sig.fields.get(i).ty);
    i = i + 1;
  }
  return layout_fields_seen(ctx, tys, seen);
}

fn layout_enum_seen(ctx: Ctx, mod_path: String, name: String, seen0: Vec[String]) -> TyLayoutResult {
  let key: String = nominal_key("E", mod_path, name);
  if contains_str_reflect(seen0, key) {
    return layout_err("cyclic nominal layout");
  }
  let fe: FindEnumResult = find_enum(ctx, mod_path, name);
  if !fe.found {
    return layout_err("unknown enum layout");
  }

  let mut seen: Vec[String] = seen0;
  seen.push(key);

  let mut has_payload: bool = false;
  let mut vi: i32 = 0;
  while vi < fe.sig.vars.len() {
    if fe.sig.vars.get(vi).fields.len() != 0 { has_payload = true; }
    vi = vi + 1;
  }
  if !has_payload {
    // typedef struct { int32_t tag; } E;
    return layout_ok(4, 4);
  }

  // typedef struct { int32_t tag; union { struct {...} V; ... } payload; } E;
  let mut payload_size: i64 = 1;
  let mut payload_align: i64 = 1;
  vi = 0;
  while vi < fe.sig.vars.len() {
    let vr: EnumVariantSig = fe.sig.vars.get(vi);
    let lr: TyLayoutResult = layout_fields_seen(ctx, vr.fields, seen);
    if !lr.ok { return lr; }
    payload_size = max_i64_reflect(payload_size, lr.size);
    payload_align = max_i64_reflect(payload_align, lr.align);
    vi = vi + 1;
  }

  let outer_align: i64 = max_i64_reflect(4, payload_align);
  let payload_off: i64 = align_up_i64(4, payload_align);
  let outer_size: i64 = align_up_i64(payload_off + payload_size, outer_align);
  return layout_ok(outer_size, outer_align);
}

fn layout_of_ty_seen(ctx: Ctx, ty: i32, seen: Vec[String]) -> TyLayoutResult {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);

  let sl: TyLayoutResult = scalar_layout(t.kind);
  if sl.ok { return sl; }

  if t.kind == ir.TyKind.Unit { return layout_ok(0, 1); }
  if t.kind == ir.TyKind.String { return layout_ok(8, 8); } // const char*
  if t.kind == ir.TyKind.Vec { return layout_ok(24, 8); }   // vox_vec
  if t.kind == ir.TyKind.Struct { return layout_struct_seen(ctx, t.mod_path, t.name, seen); }
  if t.kind == ir.TyKind.Enum { return layout_enum_seen(ctx, t.mod_path, t.name, seen); }
  if t.kind == ir.TyKind.Param {
    return layout_err("intrinsic requires concrete type");
  }
  return layout_err("unsupported type for intrinsic");
}

pub fn intrinsic_size_of(ctx: Ctx, ty: i32) -> ReflectIntResult {
  let lr: TyLayoutResult = layout_of_ty_seen(ctx, ty, Vec());
  if !lr.ok { return ReflectIntResult { ok: false, err: lr.err, iv: 0 }; }
  return ReflectIntResult { ok: true, err: "", iv: lr.size };
}

pub fn intrinsic_align_of(ctx: Ctx, ty: i32) -> ReflectIntResult {
  let lr: TyLayoutResult = layout_of_ty_seen(ctx, ty, Vec());
  if !lr.ok { return ReflectIntResult { ok: false, err: lr.err, iv: 0 }; }
  return ReflectIntResult { ok: true, err: "", iv: lr.align };
}

pub fn intrinsic_type_name_of(ctx: Ctx, ty: i32) -> ReflectTextResult {
  if ty < 0 || ty >= ctx.pool.tys.len() {
    return ReflectTextResult { ok: false, err: "bad type for intrinsic", text: "" };
  }
  return ReflectTextResult { ok: true, err: "", text: ty_inst_str(ctx, ty) };
}

pub fn intrinsic_type_id_of(ctx: Ctx, ty: i32) -> ReflectIntResult {
  if ty < 0 || ty >= ctx.pool.tys.len() {
    return ReflectIntResult { ok: false, err: "bad type for intrinsic", iv: 0 };
  }
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return ReflectIntResult { ok: false, err: "intrinsic requires concrete type", iv: 0 };
  }
  return ReflectIntResult { ok: true, err: "", iv: ty as i64 };
}

pub fn intrinsic_field_count_of(ctx: Ctx, ty: i32) -> ReflectIntResult {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return ReflectIntResult { ok: false, err: "intrinsic requires concrete type", iv: 0 };
  }
  if t.kind == ir.TyKind.Struct {
    let fs: FindStructResult = find_struct(ctx, t.mod_path, t.name);
    if !fs.found { return ReflectIntResult { ok: false, err: "unknown struct layout", iv: 0 }; }
    return ReflectIntResult { ok: true, err: "", iv: fs.sig.fields.len() as i64 };
  }
  if t.kind == ir.TyKind.Enum {
    let fe: FindEnumResult = find_enum(ctx, t.mod_path, t.name);
    if !fe.found { return ReflectIntResult { ok: false, err: "unknown enum layout", iv: 0 }; }
    return ReflectIntResult { ok: true, err: "", iv: fe.sig.vars.len() as i64 };
  }
  return ReflectIntResult { ok: false, err: "field_count expects struct or enum", iv: 0 };
}

pub fn intrinsic_field_name_of(ctx: Ctx, ty: i32, idx: i64) -> ReflectTextResult {
  if idx < 0 { return ReflectTextResult { ok: false, err: "field_name index out of range", text: "" }; }
  let i: i32 = idx as i32;
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return ReflectTextResult { ok: false, err: "intrinsic requires concrete type", text: "" };
  }
  if t.kind == ir.TyKind.Struct {
    let fs: FindStructResult = find_struct(ctx, t.mod_path, t.name);
    if !fs.found { return ReflectTextResult { ok: false, err: "unknown struct layout", text: "" }; }
    if i < 0 || i >= fs.sig.fields.len() {
      return ReflectTextResult { ok: false, err: "field_name index out of range", text: "" };
    }
    return ReflectTextResult { ok: true, err: "", text: fs.sig.fields.get(i).name };
  }
  if t.kind == ir.TyKind.Enum {
    let fe: FindEnumResult = find_enum(ctx, t.mod_path, t.name);
    if !fe.found { return ReflectTextResult { ok: false, err: "unknown enum layout", text: "" }; }
    if i < 0 || i >= fe.sig.vars.len() {
      return ReflectTextResult { ok: false, err: "field_name index out of range", text: "" };
    }
    return ReflectTextResult { ok: true, err: "", text: fe.sig.vars.get(i).name };
  }
  return ReflectTextResult { ok: false, err: "field_name expects struct or enum", text: "" };
}

fn enum_variant_type_text(ctx: Ctx, v: EnumVariantSig) -> String {
  if v.fields.len() == 0 { return "()"; }
  if v.fields.len() == 1 { return ty_inst_str(ctx, v.fields.get(0)); }
  let mut out: String = "(";
  let mut i: i32 = 0;
  while i < v.fields.len() {
    if i > 0 { out = out.concat(", "); }
    out = out.concat(ty_inst_str(ctx, v.fields.get(i)));
    i = i + 1;
  }
  return out.concat(")");
}

pub fn intrinsic_field_type_of(ctx: Ctx, ty: i32, idx: i64) -> ReflectTextResult {
  if idx < 0 { return ReflectTextResult { ok: false, err: "field_type index out of range", text: "" }; }
  let i: i32 = idx as i32;
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return ReflectTextResult { ok: false, err: "intrinsic requires concrete type", text: "" };
  }
  if t.kind == ir.TyKind.Struct {
    let fs: FindStructResult = find_struct(ctx, t.mod_path, t.name);
    if !fs.found { return ReflectTextResult { ok: false, err: "unknown struct layout", text: "" }; }
    if i < 0 || i >= fs.sig.fields.len() {
      return ReflectTextResult { ok: false, err: "field_type index out of range", text: "" };
    }
    return ReflectTextResult { ok: true, err: "", text: ty_inst_str(ctx, fs.sig.fields.get(i).ty) };
  }
  if t.kind == ir.TyKind.Enum {
    let fe: FindEnumResult = find_enum(ctx, t.mod_path, t.name);
    if !fe.found { return ReflectTextResult { ok: false, err: "unknown enum layout", text: "" }; }
    if i < 0 || i >= fe.sig.vars.len() {
      return ReflectTextResult { ok: false, err: "field_type index out of range", text: "" };
    }
    return ReflectTextResult { ok: true, err: "", text: enum_variant_type_text(ctx, fe.sig.vars.get(i)) };
  }
  return ReflectTextResult { ok: false, err: "field_type expects struct or enum", text: "" };
}

fn reflect_bool_ok(v: bool) -> ReflectBoolResult {
  return ReflectBoolResult { ok: true, err: "", bv: v };
}

fn reflect_bool_err(msg: String) -> ReflectBoolResult {
  return ReflectBoolResult { ok: false, err: msg, bv: false };
}

pub fn intrinsic_is_integer_of(ctx: Ctx, ty: i32) -> ReflectBoolResult {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return reflect_bool_err("intrinsic requires concrete type");
  }
  return reflect_bool_ok(is_int_like_ty(ctx, base));
}

pub fn intrinsic_is_signed_int_of(ctx: Ctx, ty: i32) -> ReflectBoolResult {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return reflect_bool_err("intrinsic requires concrete type");
  }
  let out: bool =
    t.kind == ir.TyKind.I8 ||
    t.kind == ir.TyKind.I16 ||
    t.kind == ir.TyKind.I32 ||
    t.kind == ir.TyKind.I64 ||
    t.kind == ir.TyKind.ISize;
  return reflect_bool_ok(out);
}

pub fn intrinsic_is_unsigned_int_of(ctx: Ctx, ty: i32) -> ReflectBoolResult {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return reflect_bool_err("intrinsic requires concrete type");
  }
  let out: bool =
    t.kind == ir.TyKind.U8 ||
    t.kind == ir.TyKind.U16 ||
    t.kind == ir.TyKind.U32 ||
    t.kind == ir.TyKind.U64 ||
    t.kind == ir.TyKind.USize;
  return reflect_bool_ok(out);
}

pub fn intrinsic_is_float_of(ctx: Ctx, ty: i32) -> ReflectBoolResult {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return reflect_bool_err("intrinsic requires concrete type");
  }
  return reflect_bool_ok(is_float_ty(ctx, base));
}

pub fn intrinsic_is_bool_of(ctx: Ctx, ty: i32) -> ReflectBoolResult {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return reflect_bool_err("intrinsic requires concrete type");
  }
  return reflect_bool_ok(base == ctx.ty_bool);
}

pub fn intrinsic_is_string_of(ctx: Ctx, ty: i32) -> ReflectBoolResult {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return reflect_bool_err("intrinsic requires concrete type");
  }
  return reflect_bool_ok(base == ctx.ty_string);
}

pub fn intrinsic_is_struct_of(ctx: Ctx, ty: i32) -> ReflectBoolResult {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return reflect_bool_err("intrinsic requires concrete type");
  }
  return reflect_bool_ok(t.kind == ir.TyKind.Struct);
}

pub fn intrinsic_is_enum_of(ctx: Ctx, ty: i32) -> ReflectBoolResult {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return reflect_bool_err("intrinsic requires concrete type");
  }
  return reflect_bool_ok(t.kind == ir.TyKind.Enum);
}

pub fn intrinsic_is_vec_of(ctx: Ctx, ty: i32) -> ReflectBoolResult {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return reflect_bool_err("intrinsic requires concrete type");
  }
  return reflect_bool_ok(t.kind == ir.TyKind.Vec);
}

pub fn intrinsic_is_range_of(ctx: Ctx, ty: i32) -> ReflectBoolResult {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.Param {
    return reflect_bool_err("intrinsic requires concrete type");
  }
  return reflect_bool_ok(t.kind == ir.TyKind.Range);
}
