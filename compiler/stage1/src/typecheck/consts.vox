import "ast" as ast
import "ir" as ir

struct ConstItem { mod_path: String, decl: ast.ConstDecl }

fn const_qname(mod_path: String, name: String) -> String { return mod_path.concat("::").concat(name); }

fn const_find_item(items: Vec[ConstItem], mod_path: String, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < items.len() {
    let it: ConstItem = items.get(i);
    if it.mod_path == mod_path && it.decl.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn const_set_sig_at(xs0: Vec[ConstSig], idx: i32, val: ConstSig) -> Vec[ConstSig] {
  let mut xs: Vec[ConstSig] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    xs.push(if i == idx { val } else { xs0.get(i) });
    i = i + 1;
  }
  return xs;
}

fn const_contains_str(xs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn join_mod_path(base: String, segs: Vec[String]) -> String {
  let mut out: String = base;
  let mut i: i32 = 0;
  while i < segs.len() {
    out = out.concat("/").concat(segs.get(i));
    i = i + 1;
  }
  return out;
}

struct EvalConstExprResult { ok: bool, err: TcError, kind: i32, ty: i32, iv: i64, bv: bool, sv: String, sigs: Vec[ConstSig], states: Vec[i32] }
struct ResolveConstResult { ok: bool, err: TcError, sigs: Vec[ConstSig], states: Vec[i32] }

fn is_int_scalar_kind(k: ir.TyKind) -> bool {
  return match k {
    ir.TyKind.I8 => true,
    ir.TyKind.U8 => true,
    ir.TyKind.I16 => true,
    ir.TyKind.U16 => true,
    ir.TyKind.I32 => true,
    ir.TyKind.U32 => true,
    ir.TyKind.I64 => true,
    ir.TyKind.U64 => true,
    ir.TyKind.ISize => true,
    ir.TyKind.USize => true,
    _ => false,
  };
}

fn is_signed_int_kind(k: ir.TyKind) -> bool {
  return match k { ir.TyKind.I8 => true, ir.TyKind.I16 => true, ir.TyKind.I32 => true, ir.TyKind.I64 => true, ir.TyKind.ISize => true, _ => false };
}

fn is_unsigned_int_kind(k: ir.TyKind) -> bool {
  return match k { ir.TyKind.U8 => true, ir.TyKind.U16 => true, ir.TyKind.U32 => true, ir.TyKind.U64 => true, ir.TyKind.USize => true, _ => false };
}

fn int_bits_of_kind(k: ir.TyKind) -> i64 {
  return match k {
    ir.TyKind.I8 => 8,
    ir.TyKind.U8 => 8,
    ir.TyKind.I16 => 16,
    ir.TyKind.U16 => 16,
    ir.TyKind.I32 => 32,
    ir.TyKind.U32 => 32,
    ir.TyKind.I64 => 64,
    ir.TyKind.U64 => 64,
    ir.TyKind.ISize => 64,
    ir.TyKind.USize => 64,
    _ => 0,
  };
}

fn int_kind(ctx: Ctx, ty: i32) -> ir.TyKind {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  return t.kind;
}

fn is_float_scalar_ty(ctx: Ctx, ty: i32) -> bool {
  let b: i32 = strip_range(ctx, ty);
  return b == ctx.ty_f32 || b == ctx.ty_f64;
}

fn is_digit_byte(b: i32) -> bool { return b >= 48 && b <= 57; }

struct ParseSignedI32Result { ok: bool, val: i32 }

fn zeros_text(n: i32) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < n {
    out = out.concat("0");
    i = i + 1;
  }
  return out;
}

pub fn float_suffix_kind_text(s: String) -> i32 {
  // 0 = none, 32 = f32, 64 = f64
  if s.len() < 3 { return 0; }
  if s.byte_at(s.len() - 3) != 102 { return 0; } // 'f'
  let b1: i32 = s.byte_at(s.len() - 2);
  let b2: i32 = s.byte_at(s.len() - 1);
  if b1 == 51 && b2 == 50 { return 32; } // f32
  if b1 == 54 && b2 == 52 { return 64; } // f64
  return 0;
}

pub fn float_strip_suffix_text(s: String) -> String {
  let k: i32 = float_suffix_kind_text(s);
  if k == 0 { return s; }
  return s.slice(0, s.len() - 3);
}

fn parse_signed_i32_dec(s: String) -> ParseSignedI32Result {
  if s.len() == 0 { return ParseSignedI32Result { ok: false, val: 0 }; }
  let mut i: i32 = 0;
  let mut neg: bool = false;
  if s.byte_at(0) == 45 { neg = true; i = 1; } else if s.byte_at(0) == 43 { i = 1; }
  if i >= s.len() { return ParseSignedI32Result { ok: false, val: 0 }; }
  let ds: String = s.slice(i, s.len());
  let pr: ParseI32DecResult = parse_i32_dec(ds);
  if !pr.ok { return ParseSignedI32Result { ok: false, val: 0 }; }
  if neg { return ParseSignedI32Result { ok: true, val: 0 - pr.val }; }
  return ParseSignedI32Result { ok: true, val: pr.val };
}

fn float_norm_text(s0: String) -> String {
  // Canonical form used for const float equality:
  // - optional leading '-'
  // - at least one digit before dot
  // - at least one digit after dot
  // - trim leading zeros in integer part and trailing zeros in fraction.
  // Also accepts exponent (`1e3`, `1.2e-3`) and suffix (`f32`/`f64`).
  let mut s: String = float_strip_suffix_text(s0);
  let mut neg: bool = false;
  if s.len() > 0 && s.byte_at(0) == 45 { // '-'
    neg = true;
    s = s.slice(1, s.len());
  }

  // Split exponent part if present.
  let mut exp_shift: i32 = 0;
  let mut epos: i32 = -1;
  let mut ei: i32 = 0;
  while ei < s.len() {
    let b: i32 = s.byte_at(ei);
    if b == 101 || b == 69 { // 'e' / 'E'
      epos = ei;
      ei = s.len();
    } else {
      ei = ei + 1;
    }
  }
  if epos != -1 {
    let expt: String = s.slice(epos + 1, s.len());
    let pr: ParseSignedI32Result = parse_signed_i32_dec(expt);
    if pr.ok {
      exp_shift = pr.val;
      s = s.slice(0, epos);
    }
  }

  let mut dot: i32 = -1;
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 46 { dot = i; }
    i = i + 1;
  }
  let mut intp: String = "";
  let mut frac: String = "";
  if dot == -1 { intp = s; } else { intp = s.slice(0, dot); frac = s.slice(dot + 1, s.len()); }
  if intp.len() == 0 { intp = "0"; }

  // Re-scale by exponent by moving decimal point.
  let mut digits: String = intp.concat(frac);
  if digits.len() == 0 { digits = "0"; }
  let shift: i32 = exp_shift - frac.len();
  if shift >= 0 {
    intp = digits.concat(zeros_text(shift));
    frac = "0";
  } else {
    let split: i32 = digits.len() + shift; // shift is negative
    if split <= 0 {
      intp = "0";
      frac = zeros_text(0 - split).concat(digits);
    } else {
      intp = digits.slice(0, split);
      frac = digits.slice(split, digits.len());
    }
  }
  if frac.len() == 0 { frac = "0"; }

  // trim int leading zeros
  let mut ii: i32 = 0;
  while ii < intp.len() && intp.byte_at(ii) == 48 { ii = ii + 1; }
  if ii >= intp.len() { intp = "0"; } else { intp = intp.slice(ii, intp.len()); }

  // trim frac trailing zeros
  let mut fj: i32 = frac.len() - 1;
  while fj >= 0 && frac.byte_at(fj) == 48 { fj = fj - 1; }
  if fj < 0 { frac = "0"; } else { frac = frac.slice(0, fj + 1); }

  let mut out: String = intp.concat(".").concat(frac);
  if out == "0.0" { return "0.0"; }
  if neg { out = "-".concat(out); }
  return out;
}

fn float_neg_text(s: String) -> String {
  let n: String = float_norm_text(s);
  if n == "0.0" { return n; }
  if n.len() > 0 && n.byte_at(0) == 45 { return n.slice(1, n.len()); }
  return "-".concat(n);
}

fn signed_min_of_kind(k: ir.TyKind) -> i64 {
  if k == ir.TyKind.I8 { return -128; }
  if k == ir.TyKind.I16 { return -32768; }
  if k == ir.TyKind.I32 { return -2147483647 - 1; }
  return -9223372036854775807 - 1;
}

fn signed_max_of_kind(k: ir.TyKind) -> i64 {
  if k == ir.TyKind.I8 { return 127; }
  if k == ir.TyKind.I16 { return 32767; }
  if k == ir.TyKind.I32 { return 2147483647; }
  return 9223372036854775807;
}

fn unsigned_max_bits_of_kind(k: ir.TyKind) -> i64 {
  if k == ir.TyKind.U8 { return 255; }
  if k == ir.TyKind.U16 { return 65535; }
  if k == ir.TyKind.U32 { return 4294967295; }
  // u64/usize max as full 64-bit ones.
  return -1;
}

fn u64_lt_bits(a: i64, b: i64) -> bool {
  let an: bool = a < 0;
  let bn: bool = b < 0;
  if an != bn {
    return !an && bn;
  }
  return a < b;
}

fn u64_le_bits(a: i64, b: i64) -> bool {
  return !u64_lt_bits(b, a);
}

fn u64_div_bits(a0: i64, b0: i64) -> i64 {
  // Bit-by-bit long division on u64 values represented as i64 bit patterns.
  let mut a: i64 = a0;
  let b: i64 = b0;
  let mut q: i64 = 0;
  let mut rem: i64 = 0;
  let mut i: i32 = 0;
  while i < 64 {
    let top1: bool = a < 0;
    rem = rem << 1;
    if top1 { rem = rem | 1; }
    a = a << 1;
    q = q << 1;
    if !u64_lt_bits(rem, b) {
      rem = rem - b;
      q = q | 1;
    }
    i = i + 1;
  }
  return q;
}

fn u64_mod_bits(a0: i64, b0: i64) -> i64 {
  let mut a: i64 = a0;
  let b: i64 = b0;
  let mut rem: i64 = 0;
  let mut i: i32 = 0;
  while i < 64 {
    let top1: bool = a < 0;
    rem = rem << 1;
    if top1 { rem = rem | 1; }
    a = a << 1;
    if !u64_lt_bits(rem, b) {
      rem = rem - b;
    }
    i = i + 1;
  }
  return rem;
}

fn wrap_signed_i8(v: i64) -> i64 {
  let m: i64 = 256;
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  if x >= 128 { x = x - m; }
  return x;
}

fn wrap_unsigned_u8(v: i64) -> i64 {
  let m: i64 = 256;
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  return x;
}

fn wrap_signed_i16(v: i64) -> i64 {
  let m: i64 = 65536;
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  if x >= 32768 { x = x - m; }
  return x;
}

fn wrap_unsigned_u16(v: i64) -> i64 {
  let m: i64 = 65536;
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  return x;
}

fn wrap_signed_i32(v: i64) -> i64 {
  let m: i64 = 4294967296; // 2^32
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  if x >= 2147483648 { x = x - m; } // 2^31
  return x;
}

fn wrap_unsigned_u32(v: i64) -> i64 {
  let m: i64 = 4294967296; // 2^32
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  return x;
}

struct WrapResult { ok: bool, err: TcError, v: i64 }

fn wrap_value_for_type(ctx: Ctx, file: String, ty: i32, v: i64) -> WrapResult {
  let k: ir.TyKind = int_kind(ctx, ty);
  if !is_int_scalar_kind(k) { return WrapResult { ok: false, err: type_error(file, "expected int type"), v: 0 }; }
  if k == ir.TyKind.I8 { return WrapResult { ok: true, err: TcError.None, v: wrap_signed_i8(v) }; }
  if k == ir.TyKind.U8 { return WrapResult { ok: true, err: TcError.None, v: wrap_unsigned_u8(v) }; }
  if k == ir.TyKind.I16 { return WrapResult { ok: true, err: TcError.None, v: wrap_signed_i16(v) }; }
  if k == ir.TyKind.U16 { return WrapResult { ok: true, err: TcError.None, v: wrap_unsigned_u16(v) }; }
  if k == ir.TyKind.I32 { return WrapResult { ok: true, err: TcError.None, v: wrap_signed_i32(v) }; }
  if k == ir.TyKind.U32 { return WrapResult { ok: true, err: TcError.None, v: wrap_unsigned_u32(v) }; }
  if k == ir.TyKind.I64 || k == ir.TyKind.ISize { return WrapResult { ok: true, err: TcError.None, v: v }; }
  if k == ir.TyKind.U64 || k == ir.TyKind.USize { return WrapResult { ok: true, err: TcError.None, v: v }; }
  return WrapResult { ok: false, err: type_error(file, "expected int type"), v: 0 };
}

struct CastConstResult { ok: bool, err: TcError, v: i64 }

fn cast_const_int_checked(ctx: Ctx, file: String, from_ty: i32, to_ty: i32, v: i64) -> CastConstResult {
  let fk: ir.TyKind = int_kind(ctx, from_ty);
  let tk: ir.TyKind = int_kind(ctx, to_ty);
  if !is_int_scalar_kind(fk) || !is_int_scalar_kind(tk) {
    return CastConstResult { ok: false, err: type_error(file, "const expression: int cast overflow"), v: 0 };
  }

  let msg: String = if (fk == ir.TyKind.I64 || fk == ir.TyKind.ISize) && tk == ir.TyKind.I32 { "const expression: i64 to i32 overflow" } else { "const expression: int cast overflow" };

  let wr_from: WrapResult = wrap_value_for_type(ctx, file, from_ty, v);
  if !wr_from.ok { return CastConstResult { ok: false, err: wr_from.err, v: 0 }; }
  let x: i64 = wr_from.v;

  if is_signed_int_kind(fk) {
    if is_signed_int_kind(tk) {
      let lo: i64 = signed_min_of_kind(tk);
      let hi: i64 = signed_max_of_kind(tk);
      if x < lo || x > hi { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
      let wr_to: WrapResult = wrap_value_for_type(ctx, file, to_ty, x);
      if !wr_to.ok { return CastConstResult { ok: false, err: wr_to.err, v: 0 }; }
      return CastConstResult { ok: true, err: TcError.None, v: wr_to.v };
    }
    if x < 0 { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
    let umax0: i64 = unsigned_max_bits_of_kind(tk);
    if u64_lt_bits(umax0, x) { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
    let wr_to0: WrapResult = wrap_value_for_type(ctx, file, to_ty, x);
    if !wr_to0.ok { return CastConstResult { ok: false, err: wr_to0.err, v: 0 }; }
    return CastConstResult { ok: true, err: TcError.None, v: wr_to0.v };
  }

  // from unsigned
  if is_signed_int_kind(tk) {
    let smax: i64 = signed_max_of_kind(tk);
    if u64_lt_bits(smax, x) { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
    let wr_to1: WrapResult = wrap_value_for_type(ctx, file, to_ty, x);
    if !wr_to1.ok { return CastConstResult { ok: false, err: wr_to1.err, v: 0 }; }
    return CastConstResult { ok: true, err: TcError.None, v: wr_to1.v };
  }
  let umax: i64 = unsigned_max_bits_of_kind(tk);
  if u64_lt_bits(umax, x) { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
  let wr_to2: WrapResult = wrap_value_for_type(ctx, file, to_ty, x);
  if !wr_to2.ok { return CastConstResult { ok: false, err: wr_to2.err, v: 0 }; }
  return CastConstResult { ok: true, err: TcError.None, v: wr_to2.v };
}

struct ConstLocal { name: String, kind: i32, ty: i32, iv: i64, bv: bool, sv: String }

fn const_find_local(locals: Vec[ConstLocal], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < locals.len() {
    if locals.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn const_local_from_value(name: String, v: EvalConstExprResult) -> ConstLocal {
  return ConstLocal { name: name, kind: v.kind, ty: v.ty, iv: v.iv, bv: v.bv, sv: v.sv };
}

struct ConstPatEvalResult {
  ok: bool,
  matched: bool,
  binds: Vec[ConstLocal],
  err: String,
}

fn const_pat_err(msg: String) -> ConstPatEvalResult {
  return ConstPatEvalResult {
    ok: false, matched: false, binds: Vec(),
    err: msg,
  };
}

fn const_pat_nomatch() -> ConstPatEvalResult {
  return ConstPatEvalResult {
    ok: true, matched: false, binds: Vec(),
    err: "",
  };
}

fn const_pat_match_no_bind() -> ConstPatEvalResult {
  return ConstPatEvalResult {
    ok: true, matched: true, binds: Vec(),
    err: "",
  };
}

fn const_pat_match_bind(name: String, v: EvalConstExprResult) -> ConstPatEvalResult {
  let mut bs: Vec[ConstLocal] = Vec();
  bs.push(const_local_from_value(name, v));
  return ConstPatEvalResult {
    ok: true, matched: true, binds: bs,
    err: "",
  };
}

fn const_pat_match_with_binds(bs: Vec[ConstLocal]) -> ConstPatEvalResult {
  return ConstPatEvalResult { ok: true, matched: true, binds: bs, err: "" };
}

fn const_bind_name_exists(bs: Vec[ConstLocal], name: String) -> bool {
  let mut i: i32 = 0;
  while i < bs.len() {
    if bs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn const_find_enum_variant_idx(ctx: Ctx, ty: i32, vname: String) -> i32 {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind != ir.TyKind.Enum { return -1; }
  let fe: FindEnumResult = find_enum(ctx, ty_mod(t), ty_name(t));
  if !fe.found { return -1; }
  let mut i: i32 = 0;
  while i < fe.sig.vars.len() {
    if fe.sig.vars.get(i).name == vname { return i; }
    i = i + 1;
  }
  return -1;
}

struct ConstFindVariantResult { ok: bool, idx: i32, fields: Vec[i32] }

fn const_find_enum_variant(ctx: Ctx, enum_ty: i32, vname: String) -> ConstFindVariantResult {
  let base: i32 = strip_range(ctx, enum_ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind != ir.TyKind.Enum { return ConstFindVariantResult { ok: false, idx: -1, fields: Vec() }; }
  let fe: FindEnumResult = find_enum(ctx, ty_mod(t), ty_name(t));
  if !fe.found { return ConstFindVariantResult { ok: false, idx: -1, fields: Vec() }; }
  let mut i: i32 = 0;
  while i < fe.sig.vars.len() {
    let v: EnumVariantSig = fe.sig.vars.get(i);
    if v.name == vname { return ConstFindVariantResult { ok: true, idx: i, fields: v.fields }; }
    i = i + 1;
  }
  return ConstFindVariantResult { ok: false, idx: -1, fields: Vec() };
}

struct ConstResolveEnumCtorResult { ok: bool, err: String, enum_ty: i32, variant: String, vidx: i32, fields: Vec[i32] }

fn const_resolve_enum_ctor(ctx: Ctx, cur_mod: String, imps: Imports, parts: Vec[String], expected: i32) -> ConstResolveEnumCtorResult {
  if expected == -1 {
    return ConstResolveEnumCtorResult { ok: false, err: "const enum shorthand requires expected enum type", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }
  let eb: i32 = strip_range(ctx, expected);
  let et: ir.Ty = ir.ty_pool_get(ctx.pool, eb);
  if et.kind != ir.TyKind.Enum {
    return ConstResolveEnumCtorResult { ok: false, err: "const enum shorthand requires expected enum type", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }
  let want_mod: String = ty_mod(et);
  let want_name: String = ty_name(et);

  if parts.len() == 0 || parts.len() > 3 {
    return ConstResolveEnumCtorResult { ok: false, err: "bad enum ctor path in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }

  let mut enum_mod: String = want_mod;
  let mut enum_name: String = want_name;
  let mut vname: String = "";

  if parts.len() == 1 {
    vname = parts.get(0);
  } else if parts.len() == 2 {
    enum_mod = cur_mod;
    enum_name = parts.get(0);
    let nt: NamedTypeImport = find_named_type(imps.named_types, enum_name);
    if nt.local != "" {
      if nt.kind != named_type_kind_enum() {
        return ConstResolveEnumCtorResult { ok: false, err: "unknown enum in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
      }
      enum_mod = nt.mod_path;
      enum_name = nt.name;
    }
    vname = parts.get(1);
  } else {
    enum_mod = find_alias(imps.aliases, parts.get(0));
    if enum_mod == "" {
      return ConstResolveEnumCtorResult { ok: false, err: "unknown module qualifier", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
    }
    enum_name = parts.get(1);
    vname = parts.get(2);
  }

  let fe2: FindEnumResult = find_enum(ctx, enum_mod, enum_name);
  if !fe2.found {
    return ConstResolveEnumCtorResult { ok: false, err: "unknown enum in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }
  if enum_mod != want_mod || enum_name != want_name {
    return ConstResolveEnumCtorResult { ok: false, err: "const enum ctor type mismatch", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }

  let fv: ConstFindVariantResult = const_find_enum_variant(ctx, eb, vname);
  if !fv.ok {
    return ConstResolveEnumCtorResult { ok: false, err: "unknown enum variant in const expression", enum_ty: ctx.ty_bad, variant: "", vidx: -1, fields: Vec() };
  }
  return ConstResolveEnumCtorResult { ok: true, err: "", enum_ty: eb, variant: vname, vidx: fv.idx, fields: fv.fields };
}

fn const_match_int_pat(ctx: Ctx, scrut_ty: i32, scrut_iv: i64, text: String) -> ConstPatEvalResult {
  let base: i32 = strip_range(ctx, scrut_ty);
  if !is_int_like_ty(ctx, base) {
    return const_pat_err("const int pattern requires int scrutinee");
  }
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind == ir.TyKind.U64 || t.kind == ir.TyKind.USize {
    let pru: ParseU64DecResult = parse_u64_dec(text);
    if !pru.ok { return const_pat_err("const int pattern out of range"); }
    if pru.val == scrut_iv { return const_pat_match_no_bind(); }
    return const_pat_nomatch();
  }

  let pr: ParseI64DecResult = parse_i64_dec(text);
  if !pr.ok { return const_pat_err("const int pattern out of range"); }
  let v: i64 = pr.val;
  let ok_lit: bool = match t.kind {
    ir.TyKind.I8 => v >= -128 && v <= 127,
    ir.TyKind.U8 => v >= 0 && v <= 255,
    ir.TyKind.I16 => v >= -32768 && v <= 32767,
    ir.TyKind.U16 => v >= 0 && v <= 65535,
    ir.TyKind.I32 => v >= -2147483648 && v <= 2147483647,
    ir.TyKind.U32 => v >= 0 && v <= 4294967295,
    ir.TyKind.I64 => true,
    ir.TyKind.ISize => true,
    _ => false,
  };
  if !ok_lit { return const_pat_err("const int pattern out of range"); }
  if v == scrut_iv { return const_pat_match_no_bind(); }
  return const_pat_nomatch();
}

fn const_payload_field_eval(scrut: EvalConstExprResult, f: ConstEnumPayloadField) -> EvalConstExprResult {
  return EvalConstExprResult {
    ok: true,
    err: TcError.None,
    kind: f.kind,
    ty: f.ty,
    iv: f.iv,
    bv: f.bv,
    sv: f.sv,
    sigs: scrut.sigs,
    states: scrut.states,
  };
}

fn const_pat_matches(ctx: Ctx, scrut: EvalConstExprResult, pat: ast.Pat) -> ConstPatEvalResult {
  return match pat {
    ast.Pat.Wild(_sp) => const_pat_match_no_bind(),
    ast.Pat.Bind(_sp, n) => const_pat_match_bind(n, scrut),
    ast.Pat.Bool(_sp, b) => {
      if scrut.kind != const_kind_bool() {
        const_pat_err("const bool pattern requires bool scrutinee")
      } else {
        if scrut.bv == b { const_pat_match_no_bind() } else { const_pat_nomatch() }
      }
    },
    ast.Pat.Int(_sp, text) => {
      if scrut.kind != const_kind_int() {
        const_pat_err("const int pattern requires int scrutinee")
      } else {
        const_match_int_pat(ctx, scrut.ty, scrut.iv, text)
      }
    },
    ast.Pat.Str(_sp, text) => {
      if scrut.kind != const_kind_str() {
        const_pat_err("const string pattern requires String scrutinee")
      } else {
        if scrut.sv == text { const_pat_match_no_bind() } else { const_pat_nomatch() }
      }
    },
    ast.Pat.EnumVariant(_sp, _enum_parts, vname, args) => {
      if scrut.kind != const_kind_enum() {
        const_pat_err("const enum pattern requires enum scrutinee")
      } else {
        let vidx: i32 = const_find_enum_variant_idx(ctx, scrut.ty, vname);
        if vidx == -1 {
          const_pat_err("unknown enum variant in const pattern")
        } else if scrut.iv != (vidx as i64) {
          const_pat_nomatch()
        } else {
          let dec: ConstEnumPayloadDecode = const_enum_unpack(scrut.sv);
          if !dec.ok {
            const_pat_err("bad const enum payload encoding")
          } else if dec.variant != vname {
            const_pat_err("const enum payload variant mismatch")
          } else if args.len() != dec.fields.len() {
            const_pat_err("const enum pattern arity mismatch")
          } else {
            let mut bs: Vec[ConstLocal] = Vec();
            let mut i: i32 = 0;
            while i < args.len() {
              let pr: ConstPatEvalResult = const_pat_matches(ctx, const_payload_field_eval(scrut, dec.fields.get(i)), args.get(i));
              if !pr.ok { return pr; }
              if !pr.matched { return const_pat_nomatch(); }
              let mut bi: i32 = 0;
              while bi < pr.binds.len() {
                let b: ConstLocal = pr.binds.get(bi);
                if const_bind_name_exists(bs, b.name) {
                  return const_pat_err("duplicate bind in const pattern: ".concat(b.name));
                }
                bs.push(b);
                bi = bi + 1;
              }
              i = i + 1;
            }
            const_pat_match_with_binds(bs)
          }
        }
      }
    },
  };
}

struct ConstToPayloadFieldResult { ok: bool, err: String, f: ConstEnumPayloadField }

fn const_payload_field_from_eval(v: EvalConstExprResult) -> ConstToPayloadFieldResult {
  let is_ok_kind: bool =
    v.kind == const_kind_int() ||
    v.kind == const_kind_bool() ||
    v.kind == const_kind_str() ||
    v.kind == const_kind_float() ||
    v.kind == const_kind_enum();
  if !is_ok_kind {
    return ConstToPayloadFieldResult { ok: false, err: "const enum payload must be const value", f: ConstEnumPayloadField { kind: 0, ty: -1, iv: 0, bv: false, sv: "" } };
  }
  if v.kind == const_kind_enum() {
    let dec: ConstEnumPayloadDecode = const_enum_unpack(v.sv);
    if !dec.ok {
      return ConstToPayloadFieldResult { ok: false, err: "bad const enum payload encoding", f: ConstEnumPayloadField { kind: 0, ty: -1, iv: 0, bv: false, sv: "" } };
    }
  }
  return ConstToPayloadFieldResult {
    ok: true, err: "",
    f: ConstEnumPayloadField { kind: v.kind, ty: v.ty, iv: v.iv, bv: v.bv, sv: v.sv },
  };
}

// Evaluate in a specific module's expr pool (const init expr ids are module-local).
fn eval_const_expr_in_mod_locals(ctx: Ctx, w: World, items: Vec[ConstItem], sigs0: Vec[ConstSig], states0: Vec[i32], cur_mod: String, imps: Imports, exprs: ast.ExprPool, file: String, id: i32, expected: i32, locals: Vec[ConstLocal]) -> EvalConstExprResult {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);

  // literals
  if match n { ast.ExprNode.Int(_v) => true, _ => false } {
    let s: String = match n { ast.ExprNode.Int(x) => x, _ => "" };

    // When expected is present, constrain to that scalar type (range types require explicit `as`).
    if expected != -1 {
      let eb: i32 = strip_range(ctx, expected);
      if eb != expected { return EvalConstExprResult { ok: false, err: type_error(file, "const int requires expected scalar int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if !is_int_like_ty(ctx, eb) { return EvalConstExprResult { ok: false, err: type_error(file, "const int requires expected int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }

      let bt: ir.Ty = ir.ty_pool_get(ctx.pool, eb);
      if bt.kind == ir.TyKind.U64 || bt.kind == ir.TyKind.USize {
        let pru: ParseU64DecResult = parse_u64_dec(s);
        if !pru.ok { return EvalConstExprResult { ok: false, err: type_error(file, "integer literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: eb, iv: pru.val, bv: false, sv: "", sigs: sigs0, states: states0 };
      }

      let pr2: ParseI64DecResult = parse_i64_dec(s);
      if !pr2.ok { return EvalConstExprResult { ok: false, err: type_error(file, "integer literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      let v: i64 = pr2.val;
      if bt.kind == ir.TyKind.I8 && (v < -128 || v > 127) { return EvalConstExprResult { ok: false, err: type_error(file, "i8 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if bt.kind == ir.TyKind.U8 && (v < 0 || v > 255) { return EvalConstExprResult { ok: false, err: type_error(file, "u8 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if bt.kind == ir.TyKind.I16 && (v < -32768 || v > 32767) { return EvalConstExprResult { ok: false, err: type_error(file, "i16 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if bt.kind == ir.TyKind.U16 && (v < 0 || v > 65535) { return EvalConstExprResult { ok: false, err: type_error(file, "u16 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if bt.kind == ir.TyKind.I32 && (v < -2147483648 || v > 2147483647) { return EvalConstExprResult { ok: false, err: type_error(file, "i32 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if bt.kind == ir.TyKind.U32 && (v < 0 || v > 4294967295) { return EvalConstExprResult { ok: false, err: type_error(file, "u32 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if bt.kind == ir.TyKind.ISize { return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: eb, iv: v, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: eb, iv: v, bv: false, sv: "", sigs: sigs0, states: states0 };
    }

    // No expected type: default to i32 if it fits, else i64.
    let pr2: ParseI64DecResult = parse_i64_dec(s);
    if !pr2.ok { return EvalConstExprResult { ok: false, err: type_error(file, "integer literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let v2: i64 = pr2.val;
    if v2 >= -2147483648 && v2 <= 2147483647 {
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: ctx.ty_i32, iv: v2, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: ctx.ty_i64, iv: v2, bv: false, sv: "", sigs: sigs0, states: states0 };
  }
  if match n { ast.ExprNode.Float(_v) => true, _ => false } {
    let s: String = match n { ast.ExprNode.Float(x) => x, _ => "" };
    let suf: i32 = float_suffix_kind_text(s);
    let mut out_ty: i32 = if suf == 32 { ctx.ty_f32 } else { ctx.ty_f64 };
    if expected != -1 {
      let eb: i32 = strip_range(ctx, expected);
      if eb != expected { return EvalConstExprResult { ok: false, err: type_error(file, "const float requires expected scalar f32/f64"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if !is_float_scalar_ty(ctx, eb) { return EvalConstExprResult { ok: false, err: type_error(file, "const float requires expected f32/f64"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if (suf == 32 && eb != ctx.ty_f32) || (suf == 64 && eb != ctx.ty_f64) {
        return EvalConstExprResult { ok: false, err: type_error(file, "const float suffix conflicts with expected type"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      out_ty = eb;
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: out_ty, iv: 0, bv: false, sv: float_norm_text(s), sigs: sigs0, states: states0 };
  }
  if match n { ast.ExprNode.Bool(_v) => true, _ => false } {
    if expected != -1 && expected != ctx.ty_bool {
      return EvalConstExprResult { ok: false, err: type_error(file, "const bool requires expected bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let b: bool = match n { ast.ExprNode.Bool(x) => x, _ => false };
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: b, sv: "", sigs: sigs0, states: states0 };
  }
  if match n { ast.ExprNode.Str(_v) => true, _ => false } {
    if expected != -1 && expected != ctx.ty_string {
      return EvalConstExprResult { ok: false, err: type_error(file, "const string requires expected String"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let s: String = match n { ast.ExprNode.Str(x) => x, _ => "" };
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_str(), ty: ctx.ty_string, iv: 0, bv: false, sv: s, sigs: sigs0, states: states0 };
  }

  // enum variant shorthand: `.None` (unit) / `.Some(...)` (payload)
  // expected enum type is required.
  if match n { ast.ExprNode.DotIdent(_name) => true, _ => false } {
    let vname: String = match n { ast.ExprNode.DotIdent(x) => x, _ => "" };
    let mut parts0: Vec[String] = Vec();
    parts0.push(vname);
    let cr0: ConstResolveEnumCtorResult = const_resolve_enum_ctor(ctx, cur_mod, imps, parts0, expected);
    if !cr0.ok {
      return EvalConstExprResult { ok: false, err: type_error(file, cr0.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    if cr0.fields.len() != 0 {
      return EvalConstExprResult { ok: false, err: type_error(file, "const enum payload requires call syntax"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let packed0: String = const_enum_pack(cr0.variant, Vec());
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_enum(), ty: cr0.enum_ty, iv: cr0.vidx as i64, bv: false, sv: packed0, sigs: sigs0, states: states0 };
  }

  // enum ctor call in const: `.Some(x)` / `E.Some(x)` / `alias.E.Some(x)`.
  if match n { ast.ExprNode.Call(_c, _ta, _args) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(c, _ta, _args) => c, _ => -1 };
    let type_args: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_c, ta, _args) => ta, _ => Vec() };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _ta, as0) => as0, _ => Vec() };
    let cn: ast.ExprNode = ast.expr_pool_get(exprs, callee);
    let mut parts2: Vec[String] = Vec();
    let mut is_ctor: bool = false;
    if match cn { ast.ExprNode.DotIdent(_name) => true, _ => false } {
      let vname2: String = match cn { ast.ExprNode.DotIdent(x) => x, _ => "" };
      parts2.push(vname2);
      is_ctor = true;
    } else if match cn { ast.ExprNode.Member(_recv, _name) => true, _ => false } {
      let recv2: i32 = match cn { ast.ExprNode.Member(r2, _name2) => r2, _ => -1 };
      let name2: String = match cn { ast.ExprNode.Member(_r2, n2) => n2, _ => "" };
      let pr2: ExprPartsResult = expr_parts_member(exprs, recv2, name2);
      if pr2.ok {
        parts2 = pr2.parts;
        is_ctor = true;
      }
    }

    if is_ctor {
      if type_args.len() != 0 {
        return EvalConstExprResult { ok: false, err: type_error(file, "const enum ctor does not accept type args"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      let cr2: ConstResolveEnumCtorResult = const_resolve_enum_ctor(ctx, cur_mod, imps, parts2, expected);
      if !cr2.ok {
        return EvalConstExprResult { ok: false, err: type_error(file, cr2.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      if args.len() != cr2.fields.len() {
        return EvalConstExprResult { ok: false, err: type_error(file, "const enum payload arity mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }

      let mut sigs2: Vec[ConstSig] = sigs0;
      let mut states2: Vec[i32] = states0;
      let mut payload: Vec[ConstEnumPayloadField] = Vec();
      let mut ai: i32 = 0;
      while ai < args.len() {
        let want_ty: i32 = cr2.fields.get(ai);
        let ar2: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs2, states2, cur_mod, imps, exprs, file, args.get(ai), want_ty, locals);
        if !ar2.ok { return ar2; }
        sigs2 = ar2.sigs;
        states2 = ar2.states;

        let fr: ConstToPayloadFieldResult = const_payload_field_from_eval(ar2);
        if !fr.ok {
          return EvalConstExprResult { ok: false, err: type_error(file, fr.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs2, states: states2 };
        }
        payload.push(fr.f);
        ai = ai + 1;
      }

      let packed: String = const_enum_pack(cr2.variant, payload);
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_enum(), ty: cr2.enum_ty, iv: cr2.vidx as i64, bv: false, sv: packed, sigs: sigs2, states: states2 };
    }
  }

  // identifier: must resolve to a const
  if match n { ast.ExprNode.Ident(_x) => true, _ => false } {
    let name: String = match n { ast.ExprNode.Ident(x) => x, _ => "" };
    let li: i32 = const_find_local(locals, name);
    if li != -1 {
      let lv: ConstLocal = locals.get(li);
      if expected != -1 && !assignable_to(ctx, expected, lv.ty) {
        return EvalConstExprResult { ok: false, err: type_error(file, "const local type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: lv.kind, ty: lv.ty, iv: lv.iv, bv: lv.bv, sv: lv.sv, sigs: sigs0, states: states0 };
    }

    let ni: NamedConstImport = find_named_const(imps.named_consts, name);
    let want_mod: String = if ni.local != "" { ni.mod_path } else { cur_mod };
    let want_name: String = if ni.local != "" { ni.name } else { name };
    let idx: i32 = const_find_item(items, want_mod, want_name);
    if idx == -1 { return EvalConstExprResult { ok: false, err: type_error(file, "unknown const: ".concat(const_qname(want_mod, want_name))), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    // ensure referenced const is resolved
    let rr: ResolveConstResult = resolve_const(ctx, w, items, sigs0, states0, idx);
    if !rr.ok { return EvalConstExprResult { ok: false, err: rr.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr.sigs, states: rr.states }; }
    let cs: ConstSig = rr.sigs.get(idx);
    if want_mod != cur_mod && !cs.is_pub { return EvalConstExprResult { ok: false, err: type_error(file, "const is private: ".concat(const_qname(want_mod, want_name))), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr.sigs, states: rr.states }; }
    if expected != -1 && !assignable_to(ctx, expected, cs.ty) {
      return EvalConstExprResult { ok: false, err: type_error(file, "const type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr.sigs, states: rr.states };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: cs.kind, ty: cs.ty, iv: cs.iv, bv: cs.bv, sv: cs.sv, sigs: rr.sigs, states: rr.states };
  }

  // module-qualified const or enum unit value:
  // `alias.NAME` / `alias.mod.NAME` / `E.A` / `alias.E.A`
  if match n { ast.ExprNode.Member(_r, _name) => true, _ => false } {
    let recv: i32 = match n { ast.ExprNode.Member(r, _name) => r, _ => -1 };
    let mname: String = match n { ast.ExprNode.Member(_r, x) => x, _ => "" };
    let pr: ExprPartsResult = expr_parts_member(exprs, recv, mname);
    if !pr.ok { return EvalConstExprResult { ok: false, err: type_error(file, "unsupported const member path"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let parts: Vec[String] = pr.parts;
    if parts.len() < 2 { return EvalConstExprResult { ok: false, err: type_error(file, "unsupported const member path"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let base: String = find_alias(imps.aliases, parts.get(0));
    if base != "" {
      let extra: Vec[String] = slice_parts(parts, 1, parts.len() - 1);
      let want_mod: String = if extra.len() == 0 { base } else { join_mod_path(base, extra) };
      let want_name: String = parts.get(parts.len() - 1);
      let idx2: i32 = const_find_item(items, want_mod, want_name);
      if idx2 != -1 {
        let rr2: ResolveConstResult = resolve_const(ctx, w, items, sigs0, states0, idx2);
        if !rr2.ok { return EvalConstExprResult { ok: false, err: rr2.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states }; }
        let cs2: ConstSig = rr2.sigs.get(idx2);
        if want_mod != cur_mod && !cs2.is_pub { return EvalConstExprResult { ok: false, err: type_error(file, "const is private: ".concat(const_qname(want_mod, want_name))), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states }; }
        if expected != -1 && !assignable_to(ctx, expected, cs2.ty) {
          return EvalConstExprResult { ok: false, err: type_error(file, "const type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        return EvalConstExprResult { ok: true, err: TcError.None, kind: cs2.kind, ty: cs2.ty, iv: cs2.iv, bv: cs2.bv, sv: cs2.sv, sigs: rr2.sigs, states: rr2.states };
      }
    }

    // Fallback to enum unit value path when const lookup does not match.
    let cr3: ConstResolveEnumCtorResult = const_resolve_enum_ctor(ctx, cur_mod, imps, parts, expected);
    if !cr3.ok {
      return EvalConstExprResult { ok: false, err: type_error(file, cr3.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    if cr3.fields.len() != 0 {
      return EvalConstExprResult { ok: false, err: type_error(file, "const enum payload requires call syntax"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    let packed3: String = const_enum_pack(cr3.variant, Vec());
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_enum(), ty: cr3.enum_ty, iv: cr3.vidx as i64, bv: false, sv: packed3, sigs: sigs0, states: states0 };
  }

  // unary
  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let op: ast.UnaryOp = match n { ast.ExprNode.Unary(o, _a) => o, _ => ast.UnaryOp.Not };
    let a: i32 = match n { ast.ExprNode.Unary(_o, x) => x, _ => -1 };
    if match op { ast.UnaryOp.Not => true, _ => false } {
      let ar: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, ctx.ty_bool, locals);
      if !ar.ok { return ar; }
      if ar.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: type_error(file, "const ! expects bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states }; }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: !ar.bv, sv: "", sigs: ar.sigs, states: ar.states };
    }
    // neg
    let ar2: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, -1, locals);
    if !ar2.ok { return ar2; }
    if ar2.kind == const_kind_float() {
      let out_tyf: i32 = if expected != -1 { strip_range(ctx, expected) } else { strip_range(ctx, ar2.ty) };
      if !is_float_scalar_ty(ctx, out_tyf) { return EvalConstExprResult { ok: false, err: type_error(file, "const - expects float or signed int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states }; }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: out_tyf, iv: 0, bv: false, sv: float_neg_text(ar2.sv), sigs: ar2.sigs, states: ar2.states };
    }

    if ar2.kind != const_kind_int() { return EvalConstExprResult { ok: false, err: type_error(file, "const - expects float or signed int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states }; }
    let out_ty: i32 = if expected != -1 { strip_range(ctx, expected) } else { strip_range(ctx, ar2.ty) };
    let k: ir.TyKind = int_kind(ctx, out_ty);
    if !is_signed_int_kind(k) { return EvalConstExprResult { ok: false, err: type_error(file, "const - expects signed int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states }; }
    let wr: WrapResult = wrap_value_for_type(ctx, file, out_ty, -ar2.iv);
    if !wr.ok { return EvalConstExprResult { ok: false, err: wr.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states }; }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: out_ty, iv: wr.v, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states };
  }

  // cast: `expr as Type`
  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(x, _tn) => x, _ => -1 };
    let tn: ast.TypeName = match n { ast.ExprNode.As(_a2, t) => t, _ => ast.TypeName { parts: Vec(), args: Vec() } };
    let tr: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, Vec(), tn);
    let c2: Ctx = tr.ctx;
    if !tr.ok { return EvalConstExprResult { ok: false, err: type_error(file, "const expression: unknown cast type"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let to: i32 = tr.idx;
    let to_base: i32 = strip_range(c2, to);
    if is_float_scalar_ty(c2, to_base) {
      let an_f: ast.ExprNode = ast.expr_pool_get(exprs, a);
      let eval_expected_f: i32 = if match an_f { ast.ExprNode.Float(_s) => true, _ => false } { to_base } else { -1 };
      let ar_f: EvalConstExprResult = eval_const_expr_in_mod_locals(c2, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, eval_expected_f, locals);
      if !ar_f.ok { return ar_f; }
      if ar_f.kind == const_kind_float() && is_float_scalar_ty(c2, ar_f.ty) {
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: to_base, iv: 0, bv: false, sv: float_norm_text(ar_f.sv), sigs: ar_f.sigs, states: ar_f.states };
      }
      if ar_f.kind == const_kind_int() && is_int_like_ty(c2, ar_f.ty) {
        let from_base_i: i32 = strip_range(c2, ar_f.ty);
        let sv: String = const_int_to_float_text(c2, from_base_i, ar_f.iv);
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: to_base, iv: 0, bv: false, sv: sv, sigs: ar_f.sigs, states: ar_f.states };
      }
      return EvalConstExprResult { ok: false, err: type_error(file, "const expression: cast expects int/float"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar_f.sigs, states: ar_f.states };
    }

    let tk: ir.TyKind = int_kind(c2, to_base);
    if !is_int_scalar_kind(tk) { return EvalConstExprResult { ok: false, err: type_error(file, "const expression: cast target must be int/@range int or f32/f64"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }

    let an: ast.ExprNode = ast.expr_pool_get(exprs, a);
    let eval_expected: i32 = if match an { ast.ExprNode.Int(_s) => true, _ => false } && is_unsigned_int_kind(tk) { to_base } else { -1 };
    let ar: EvalConstExprResult = eval_const_expr_in_mod_locals(c2, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, eval_expected, locals);
    if !ar.ok { return ar; }
    let mut v: i64 = 0;
    if ar.kind == const_kind_int() {
      let from_base: i32 = strip_range(c2, ar.ty);
      let cr: CastConstResult = cast_const_int_checked(c2, file, from_base, to_base, ar.iv);
      if !cr.ok { return EvalConstExprResult { ok: false, err: cr.err, kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states }; }
      v = cr.v;
    } else if ar.kind == const_kind_float() && is_float_scalar_ty(c2, ar.ty) {
      let cfr: CastConstFloatToIntResult = cast_const_float_to_int_checked(c2, to_base, ar.sv);
      if !cfr.ok {
        return EvalConstExprResult { ok: false, err: type_error(file, cfr.err), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
      }
      v = cfr.v;
    } else {
      return EvalConstExprResult { ok: false, err: type_error(file, "const expression: cast expects int/float"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
    }

    if is_range_ty(c2, to) {
      let rt: ir.Ty = ir.ty_pool_get(c2.pool, to);
      if v < rt.lo || v > rt.hi {
        return EvalConstExprResult { ok: false, err: type_error(file, "const expression: range check failed"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
      }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: to, iv: v, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: to_base, iv: v, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
  }

  // if expr
  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } {
    let cnd: i32 = match n { ast.ExprNode.If(c, _t, _e) => c, _ => -1 };
    let thn: i32 = match n { ast.ExprNode.If(_c, t, _e) => t, _ => -1 };
    let els: i32 = match n { ast.ExprNode.If(_c, _t, e2) => e2, _ => -1 };
    let cr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, cnd, ctx.ty_bool, locals);
    if !cr.ok { return cr; }
    if cr.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: type_error(file, "const if cond must be bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: cr.sigs, states: cr.states }; }
    if cr.bv {
      return eval_const_expr_in_mod_locals(ctx, w, items, cr.sigs, cr.states, cur_mod, imps, exprs, file, thn, expected, locals);
    }
    return eval_const_expr_in_mod_locals(ctx, w, items, cr.sigs, cr.states, cur_mod, imps, exprs, file, els, expected, locals);
  }

  // match expr (const v0 subset: wildcard/bind/bool/int/string/enum patterns).
  if match n { ast.ExprNode.Match(_scrut, _arms) => true, _ => false } {
    let scrut: i32 = match n { ast.ExprNode.Match(s, _as) => s, _ => -1 };
    let arms: Vec[ast.MatchArm] = match n { ast.ExprNode.Match(_s, as0) => as0, _ => Vec() };
    if arms.len() == 0 {
      return EvalConstExprResult { ok: false, err: type_error(file, "const match requires at least one arm"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
    }

    let sr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, scrut, -1, locals);
    if !sr.ok { return sr; }

    let mut ai: i32 = 0;
    while ai < arms.len() {
      let arm: ast.MatchArm = arms.get(ai);
      let pr: ConstPatEvalResult = const_pat_matches(ctx, sr, arm.pat);
      if !pr.ok {
        return EvalConstExprResult { ok: false, err: type_error(file, pr.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
      }
      if pr.matched {
        let mut arm_locals: Vec[ConstLocal] = locals;
        let mut bi2: i32 = 0;
        while bi2 < pr.binds.len() {
          arm_locals.push(pr.binds.get(bi2));
          bi2 = bi2 + 1;
        }
        return eval_const_expr_in_mod_locals(ctx, w, items, sr.sigs, sr.states, cur_mod, imps, exprs, file, arm.expr, expected, arm_locals);
      }
      ai = ai + 1;
    }

    return EvalConstExprResult { ok: false, err: type_error(file, "const match has no matching arm"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sr.sigs, states: sr.states };
  }

  // binary
  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let op: ast.BinaryOp = match n { ast.ExprNode.Binary(o, _l, _r) => o, _ => ast.BinaryOp.Add };
    let l: i32 = match n { ast.ExprNode.Binary(_o, x, _r) => x, _ => -1 };
    let r: i32 = match n { ast.ExprNode.Binary(_o, _l, x) => x, _ => -1 };

    let is_logic: bool = match op { ast.BinaryOp.AndAnd => true, ast.BinaryOp.OrOr => true, _ => false };
    if is_logic {
      let lr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, l, ctx.ty_bool, locals);
      if !lr.ok { return lr; }
      if lr.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: type_error(file, "const &&/|| expects bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: lr.sigs, states: lr.states }; }
      if match op { ast.BinaryOp.AndAnd => true, _ => false } && !lr.bv {
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: false, sv: "", sigs: lr.sigs, states: lr.states };
      }
      if match op { ast.BinaryOp.OrOr => true, _ => false } && lr.bv {
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: true, sv: "", sigs: lr.sigs, states: lr.states };
      }
      let rr: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, lr.sigs, lr.states, cur_mod, imps, exprs, file, r, ctx.ty_bool, locals);
      if !rr.ok { return rr; }
      if rr.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: type_error(file, "const &&/|| expects bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr.sigs, states: rr.states }; }
      let out: bool = if match op { ast.BinaryOp.AndAnd => true, _ => false } { lr.bv && rr.bv } else { lr.bv || rr.bv };
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: out, sv: "", sigs: rr.sigs, states: rr.states };
    }

    let is_cmp: bool = match op { ast.BinaryOp.Lt => true, ast.BinaryOp.Le => true, ast.BinaryOp.Gt => true, ast.BinaryOp.Ge => true, _ => false };
    let is_eq: bool = match op { ast.BinaryOp.Eq => true, ast.BinaryOp.Ne => true, _ => false };
    let is_arith: bool = match op { ast.BinaryOp.Add => true, ast.BinaryOp.Sub => true, ast.BinaryOp.Mul => true, ast.BinaryOp.Div => true, ast.BinaryOp.Mod => true, _ => false };
    let is_bit: bool = match op { ast.BinaryOp.BitAnd => true, ast.BinaryOp.BitOr => true, ast.BinaryOp.BitXor => true, _ => false };
    let is_shift: bool = match op { ast.BinaryOp.Shl => true, ast.BinaryOp.Shr => true, _ => false };

    if is_arith || is_bit || is_shift || is_cmp {
      // For comparisons assigned to bool, infer operand type from lhs/rhs instead
      // of forcing expected=bool into numeric subexpressions.
      let is_cmp_bool_ctx: bool = is_cmp && expected == ctx.ty_bool;
      let lhs_expected: i32 = if is_cmp_bool_ctx { -1 } else { expected };
      let mut lr2: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, l, lhs_expected, locals);
      if !lr2.ok && is_cmp_bool_ctx {
        // Keep const-eval usable for literal-vs-literal int comparisons.
        lr2 = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, l, ctx.ty_i32, locals);
      }
      if !lr2.ok { return lr2; }

      let rhs_expected: i32 =
        if is_cmp_bool_ctx {
          strip_range(ctx, lr2.ty)
        } else {
          expected
        };
      let rr2: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, lr2.sigs, lr2.states, cur_mod, imps, exprs, file, r, rhs_expected, locals);
      if !rr2.ok { return rr2; }
      let out_ty: i32 = if is_cmp { strip_range(ctx, lr2.ty) } else if expected != -1 { strip_range(ctx, expected) } else { strip_range(ctx, lr2.ty) };
      if strip_range(ctx, lr2.ty) != out_ty || strip_range(ctx, rr2.ty) != out_ty {
        return EvalConstExprResult { ok: false, err: type_error(file, "const numeric op type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
      }

      if lr2.kind == const_kind_float() || rr2.kind == const_kind_float() {
        if lr2.kind != const_kind_float() || rr2.kind != const_kind_float() || !is_float_scalar_ty(ctx, out_ty) {
          return EvalConstExprResult { ok: false, err: type_error(file, "const float op expects f32/f64"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        let fr: ConstFloatBinaryEvalResult = const_float_binary_eval(op, lr2.sv, rr2.sv);
        if !fr.ok {
          return EvalConstExprResult { ok: false, err: type_error(file, fr.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        if fr.is_bool {
          return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: fr.out, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: out_ty, iv: 0, bv: false, sv: fr.text, sigs: rr2.sigs, states: rr2.states };
      }

      if lr2.kind != const_kind_int() || rr2.kind != const_kind_int() { return EvalConstExprResult { ok: false, err: type_error(file, "const int op expects ints"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states }; }
      let k: ir.TyKind = int_kind(ctx, out_ty);
      if !is_int_scalar_kind(k) { return EvalConstExprResult { ok: false, err: type_error(file, "const int op expects int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states }; }

      if is_cmp {
        let outb: bool =
          if is_signed_int_kind(k) {
            match op {
              ast.BinaryOp.Lt => lr2.iv < rr2.iv,
              ast.BinaryOp.Le => lr2.iv <= rr2.iv,
              ast.BinaryOp.Gt => lr2.iv > rr2.iv,
              _ => lr2.iv >= rr2.iv,
            }
          } else {
            match op {
              ast.BinaryOp.Lt => u64_lt_bits(lr2.iv, rr2.iv),
              ast.BinaryOp.Le => u64_le_bits(lr2.iv, rr2.iv),
              ast.BinaryOp.Gt => u64_lt_bits(rr2.iv, lr2.iv),
              _ => u64_le_bits(rr2.iv, lr2.iv),
            }
          };
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: outb, sv: "", sigs: rr2.sigs, states: rr2.states };
      }

      let is_div: bool = match op { ast.BinaryOp.Div => true, _ => false };
      let is_mod: bool = match op { ast.BinaryOp.Mod => true, _ => false };
      if (is_div || is_mod) && rr2.iv == 0 {
        return EvalConstExprResult { ok: false, err: type_error(file, "const division by zero"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
      }
      if (is_div || is_mod) && is_signed_int_kind(k) {
        let min: i64 =
          if k == ir.TyKind.I8 { -128 }
          else if k == ir.TyKind.I16 { -32768 }
          else if k == ir.TyKind.I32 { -2147483647 - 1 }
          else { -9223372036854775807 - 1 };
        if lr2.iv == min && rr2.iv == -1 {
          return EvalConstExprResult { ok: false, err: type_error(file, "const division overflow"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
      }
      if is_shift {
        let wbits: i64 = int_bits_of_kind(k);
        if rr2.iv < 0 || rr2.iv >= wbits {
          return EvalConstExprResult { ok: false, err: type_error(file, "const shift count out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
      }

      let mut raw: i64 = 0;
      if is_div {
        if is_signed_int_kind(k) { raw = lr2.iv / rr2.iv; }
        else { raw = u64_div_bits(lr2.iv, rr2.iv); }
      } else if is_mod {
        if is_signed_int_kind(k) { raw = lr2.iv % rr2.iv; }
        else { raw = u64_mod_bits(lr2.iv, rr2.iv); }
      } else {
        raw = match op {
          ast.BinaryOp.Add => lr2.iv + rr2.iv,
          ast.BinaryOp.Sub => lr2.iv - rr2.iv,
          ast.BinaryOp.Mul => lr2.iv * rr2.iv,
          ast.BinaryOp.BitAnd => lr2.iv & rr2.iv,
          ast.BinaryOp.BitOr => lr2.iv | rr2.iv,
          ast.BinaryOp.BitXor => lr2.iv ^ rr2.iv,
          ast.BinaryOp.Shl => lr2.iv << rr2.iv,
          _ => lr2.iv >> rr2.iv,
        };
      }
      let wr: WrapResult = wrap_value_for_type(ctx, file, out_ty, raw);
      if !wr.ok { return EvalConstExprResult { ok: false, err: wr.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states }; }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: out_ty, iv: wr.v, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
    }

    if is_eq {
      let lr3: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, l, -1, locals);
      if !lr3.ok { return lr3; }
      let rr3: EvalConstExprResult = eval_const_expr_in_mod_locals(ctx, w, items, lr3.sigs, lr3.states, cur_mod, imps, exprs, file, r, -1, locals);
      if !rr3.ok { return rr3; }

      let lb: i32 = strip_range(ctx, lr3.ty);
      let rb: i32 = strip_range(ctx, rr3.ty);
      if lb != rb { return EvalConstExprResult { ok: false, err: type_error(file, "const ==/!= type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states }; }

      let mut eq: bool = false;
      if is_int_like_ty(ctx, lb) {
        if lr3.kind != const_kind_int() || rr3.kind != const_kind_int() { return EvalConstExprResult { ok: false, err: type_error(file, "const ==/!= expects int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states }; }
        eq = lr3.iv == rr3.iv;
      } else if is_float_scalar_ty(ctx, lb) {
        if lr3.kind != const_kind_float() || rr3.kind != const_kind_float() { return EvalConstExprResult { ok: false, err: type_error(file, "const ==/!= expects float"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states }; }
        eq = float_norm_text(lr3.sv) == float_norm_text(rr3.sv);
      } else if lb == ctx.ty_bool {
        if lr3.kind != const_kind_bool() || rr3.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: type_error(file, "const ==/!= expects bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states }; }
        eq = lr3.bv == rr3.bv;
      } else if lb == ctx.ty_string {
        if lr3.kind != const_kind_str() || rr3.kind != const_kind_str() { return EvalConstExprResult { ok: false, err: type_error(file, "const ==/!= expects string"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states }; }
        eq = lr3.sv == rr3.sv;
      } else {
        return EvalConstExprResult { ok: false, err: type_error(file, "const ==/!= expects primitive"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states };
      }

      let ne: bool = match op { ast.BinaryOp.Ne => true, _ => false };
      let out: bool = if ne { !eq } else { eq };
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: out, sv: "", sigs: rr3.sigs, states: rr3.states };
    }

    return EvalConstExprResult { ok: false, err: type_error(file, "unsupported const binary op"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
  }

  return EvalConstExprResult { ok: false, err: type_error(file, "unsupported const expression"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
}

fn eval_const_expr_in_mod(ctx: Ctx, w: World, items: Vec[ConstItem], sigs0: Vec[ConstSig], states0: Vec[i32], cur_mod: String, imps: Imports, exprs: ast.ExprPool, file: String, id: i32, expected: i32) -> EvalConstExprResult {
  return eval_const_expr_in_mod_locals(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, id, expected, Vec());
}

fn slice_parts(xs: Vec[String], lo: i32, hi: i32) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = lo;
  while i < hi {
    out.push(xs.get(i));
    i = i + 1;
  }
  return out;
}

fn resolve_const(ctx: Ctx, w: World, items: Vec[ConstItem], sigs0: Vec[ConstSig], states0: Vec[i32], idx: i32) -> ResolveConstResult {
  let st: i32 = states0.get(idx); // 0 pending, 1 resolving, 2 done
  if st == 2 { return ResolveConstResult { ok: true, err: TcError.None, sigs: sigs0, states: states0 }; }
  if st == 1 {
    let it0: ConstItem = items.get(idx);
    return ResolveConstResult { ok: false, err: type_error(it0.decl.file, "const cycle: ".concat(const_qname(it0.mod_path, it0.decl.name))), sigs: sigs0, states: states0 };
  }

  let mut sigs: Vec[ConstSig] = sigs0;
  let mut states: Vec[i32] = const_set_i32_at(states0, idx, 1);
  let it: ConstItem = items.get(idx);

  // Resolve declared type (v0: must be primitive or `@range(..) <int>`).
  let fm: FindModResult = find_mod(w, it.mod_path);
  if !fm.found {
    return ResolveConstResult { ok: false, err: type_error(it.decl.file, "unknown module for const"), sigs: sigs, states: states };
  }
  let m: WorldModule = w.mods.get(fm.idx);
  let ir0: ImportsResult = build_imports(w, it.mod_path, m.prog.imports, it.decl.file);
  if !ir0.ok { return ResolveConstResult { ok: false, err: ir0.err, sigs: sigs, states: states }; }
  let imps: Imports = ir0.imps;

  let tr: ResolveTyResult = resolve_type(ctx, w, it.mod_path, imps, Vec(), it.decl.ty);
  if !tr.ok { return ResolveConstResult { ok: false, err: type_error(it.decl.file, "type resolve failed in const"), sigs: sigs, states: states }; }
  let ty: i32 = tr.idx;
  let ok_v0: bool =
    ty == ctx.ty_bool ||
    ty == ctx.ty_string ||
    ty == ctx.ty_f32 ||
    ty == ctx.ty_f64 ||
    is_enum_ty(ctx, ty) ||
    is_int_scalar_kind(int_kind(ctx, ty));
  if !ok_v0 { return ResolveConstResult { ok: false, err: type_error(it.decl.file, "const type must be primitive/enum in v0"), sigs: sigs, states: states }; }

  // Evaluate init expression.
  let ev: EvalConstExprResult = eval_const_expr_in_mod(ctx, w, items, sigs, states, it.mod_path, imps, m.prog.exprs, it.decl.file, it.decl.init, ty);
  if !ev.ok { return ResolveConstResult { ok: false, err: ev.err, sigs: ev.sigs, states: ev.states }; }
  sigs = ev.sigs;
  states = ev.states;

  let cs: ConstSig = ConstSig {
    mod_path: it.mod_path,
    name: it.decl.name,
    is_pub: it.decl.is_pub,
    ty: ty,
    kind: ev.kind,
    iv: ev.iv,
    bv: ev.bv,
    sv: ev.sv,
  };
  sigs = const_set_sig_at(sigs, idx, cs);
  states = const_set_i32_at(states, idx, 2);
  return ResolveConstResult { ok: true, err: TcError.None, sigs: sigs, states: states };
}

fn const_set_i32_at(xs0: Vec[i32], idx: i32, val: i32) -> Vec[i32] {
  let mut xs: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    xs.push(if i == idx { val } else { xs0.get(i) });
    i = i + 1;
  }
  return xs;
}

fn const_placeholder() -> ConstSig {
  return ConstSig { mod_path: "", name: "", is_pub: false, ty: -1, kind: 0, iv: 0, bv: false, sv: "" };
}

fn collect_consts(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;

  // Gather all const decls across modules.
  let mut items: Vec[ConstItem] = Vec();
  let mut seen: Vec[String] = Vec();
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ci: i32 = 0;
    while ci < m.prog.consts.len() {
      let cd: ast.ConstDecl = m.prog.consts.get(ci);
      if is_reserved_intrinsic_name(cd.name) {
        return TcCtxResult { ok: false, err: type_error(cd.file, "reserved name: ".concat(cd.name)), ctx: c };
      }
      let qn: String = const_qname(m.path, cd.name);
      if const_contains_str(seen, qn) {
        return TcCtxResult { ok: false, err: type_error(cd.file, "duplicate const: ".concat(cd.name)), ctx: c };
      }
      seen.push(qn);
      items.push(ConstItem { mod_path: m.path, decl: cd });
      ci = ci + 1;
    }
    mi = mi + 1;
  }

  // Pre-size sigs/states vectors.
  let mut sigs: Vec[ConstSig] = Vec();
  let mut states: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < items.len() {
    sigs.push(const_placeholder());
    states.push(0);
    i = i + 1;
  }

  // Resolve all consts (value + type).
  i = 0;
  while i < items.len() {
    let rr: ResolveConstResult = resolve_const(c, w, items, sigs, states, i);
    if !rr.ok { return TcCtxResult { ok: false, err: rr.err, ctx: c }; }
    sigs = rr.sigs;
    states = rr.states;
    i = i + 1;
  }

  c.consts = sigs;
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}
