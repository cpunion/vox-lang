import "ast" as ast
import "ir" as ir

struct ConstItem { mod_path: String, decl: ast.ConstDecl }

fn const_qname(mod_path: String, name: String) -> String { return mod_path.concat("::").concat(name); }

fn const_find_item(items: Vec[ConstItem], mod_path: String, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < items.len() {
    let it: ConstItem = items.get(i);
    if it.mod_path == mod_path && it.decl.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn const_set_sig_at(xs0: Vec[ConstSig], idx: i32, val: ConstSig) -> Vec[ConstSig] {
  let mut xs: Vec[ConstSig] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    xs.push(if i == idx { val } else { xs0.get(i) });
    i = i + 1;
  }
  return xs;
}

fn const_contains_str(xs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn join_mod_path(base: String, segs: Vec[String]) -> String {
  let mut out: String = base;
  let mut i: i32 = 0;
  while i < segs.len() {
    out = out.concat("/").concat(segs.get(i));
    i = i + 1;
  }
  return out;
}

struct EvalConstExprResult { ok: bool, err: TcError, kind: i32, ty: i32, iv: i64, bv: bool, sv: String, sigs: Vec[ConstSig], states: Vec[i32] }
struct ResolveConstResult { ok: bool, err: TcError, sigs: Vec[ConstSig], states: Vec[i32] }

fn is_int_scalar_kind(k: ir.TyKind) -> bool {
  return match k {
    ir.TyKind.I8 => true,
    ir.TyKind.U8 => true,
    ir.TyKind.I16 => true,
    ir.TyKind.U16 => true,
    ir.TyKind.I32 => true,
    ir.TyKind.U32 => true,
    ir.TyKind.I64 => true,
    ir.TyKind.U64 => true,
    ir.TyKind.ISize => true,
    ir.TyKind.USize => true,
    _ => false,
  };
}

fn is_signed_int_kind(k: ir.TyKind) -> bool {
  return match k { ir.TyKind.I8 => true, ir.TyKind.I16 => true, ir.TyKind.I32 => true, ir.TyKind.I64 => true, ir.TyKind.ISize => true, _ => false };
}

fn is_unsigned_int_kind(k: ir.TyKind) -> bool {
  return match k { ir.TyKind.U8 => true, ir.TyKind.U16 => true, ir.TyKind.U32 => true, ir.TyKind.U64 => true, ir.TyKind.USize => true, _ => false };
}

fn int_bits_of_kind(k: ir.TyKind) -> i64 {
  return match k {
    ir.TyKind.I8 => 8,
    ir.TyKind.U8 => 8,
    ir.TyKind.I16 => 16,
    ir.TyKind.U16 => 16,
    ir.TyKind.I32 => 32,
    ir.TyKind.U32 => 32,
    ir.TyKind.I64 => 64,
    ir.TyKind.U64 => 64,
    ir.TyKind.ISize => 64,
    ir.TyKind.USize => 64,
    _ => 0,
  };
}

fn int_kind(ctx: Ctx, ty: i32) -> ir.TyKind {
  let base: i32 = strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  return t.kind;
}

fn is_float_scalar_ty(ctx: Ctx, ty: i32) -> bool {
  let b: i32 = strip_range(ctx, ty);
  return b == ctx.ty_f32 || b == ctx.ty_f64;
}

fn is_digit_byte(b: i32) -> bool { return b >= 48 && b <= 57; }

struct ParseSignedI32Result { ok: bool, val: i32 }

fn zeros_text(n: i32) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < n {
    out = out.concat("0");
    i = i + 1;
  }
  return out;
}

pub fn float_suffix_kind_text(s: String) -> i32 {
  // 0 = none, 32 = f32, 64 = f64
  if s.len() < 3 { return 0; }
  if s.byte_at(s.len() - 3) != 102 { return 0; } // 'f'
  let b1: i32 = s.byte_at(s.len() - 2);
  let b2: i32 = s.byte_at(s.len() - 1);
  if b1 == 51 && b2 == 50 { return 32; } // f32
  if b1 == 54 && b2 == 52 { return 64; } // f64
  return 0;
}

pub fn float_strip_suffix_text(s: String) -> String {
  let k: i32 = float_suffix_kind_text(s);
  if k == 0 { return s; }
  return s.slice(0, s.len() - 3);
}

fn parse_signed_i32_dec(s: String) -> ParseSignedI32Result {
  if s.len() == 0 { return ParseSignedI32Result { ok: false, val: 0 }; }
  let mut i: i32 = 0;
  let mut neg: bool = false;
  if s.byte_at(0) == 45 { neg = true; i = 1; } else if s.byte_at(0) == 43 { i = 1; }
  if i >= s.len() { return ParseSignedI32Result { ok: false, val: 0 }; }
  let ds: String = s.slice(i, s.len());
  let pr: ParseI32DecResult = parse_i32_dec(ds);
  if !pr.ok { return ParseSignedI32Result { ok: false, val: 0 }; }
  if neg { return ParseSignedI32Result { ok: true, val: 0 - pr.val }; }
  return ParseSignedI32Result { ok: true, val: pr.val };
}

fn float_norm_text(s0: String) -> String {
  // Canonical form used for const float equality:
  // - optional leading '-'
  // - at least one digit before dot
  // - at least one digit after dot
  // - trim leading zeros in integer part and trailing zeros in fraction.
  // Also accepts exponent (`1e3`, `1.2e-3`) and suffix (`f32`/`f64`).
  let mut s: String = float_strip_suffix_text(s0);
  let mut neg: bool = false;
  if s.len() > 0 && s.byte_at(0) == 45 { // '-'
    neg = true;
    s = s.slice(1, s.len());
  }

  // Split exponent part if present.
  let mut exp_shift: i32 = 0;
  let mut epos: i32 = -1;
  let mut ei: i32 = 0;
  while ei < s.len() {
    let b: i32 = s.byte_at(ei);
    if b == 101 || b == 69 { // 'e' / 'E'
      epos = ei;
      ei = s.len();
    } else {
      ei = ei + 1;
    }
  }
  if epos != -1 {
    let expt: String = s.slice(epos + 1, s.len());
    let pr: ParseSignedI32Result = parse_signed_i32_dec(expt);
    if pr.ok {
      exp_shift = pr.val;
      s = s.slice(0, epos);
    }
  }

  let mut dot: i32 = -1;
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 46 { dot = i; }
    i = i + 1;
  }
  let mut intp: String = "";
  let mut frac: String = "";
  if dot == -1 { intp = s; } else { intp = s.slice(0, dot); frac = s.slice(dot + 1, s.len()); }
  if intp.len() == 0 { intp = "0"; }

  // Re-scale by exponent by moving decimal point.
  let mut digits: String = intp.concat(frac);
  if digits.len() == 0 { digits = "0"; }
  let shift: i32 = exp_shift - frac.len();
  if shift >= 0 {
    intp = digits.concat(zeros_text(shift));
    frac = "0";
  } else {
    let split: i32 = digits.len() + shift; // shift is negative
    if split <= 0 {
      intp = "0";
      frac = zeros_text(0 - split).concat(digits);
    } else {
      intp = digits.slice(0, split);
      frac = digits.slice(split, digits.len());
    }
  }
  if frac.len() == 0 { frac = "0"; }

  // trim int leading zeros
  let mut ii: i32 = 0;
  while ii < intp.len() && intp.byte_at(ii) == 48 { ii = ii + 1; }
  if ii >= intp.len() { intp = "0"; } else { intp = intp.slice(ii, intp.len()); }

  // trim frac trailing zeros
  let mut fj: i32 = frac.len() - 1;
  while fj >= 0 && frac.byte_at(fj) == 48 { fj = fj - 1; }
  if fj < 0 { frac = "0"; } else { frac = frac.slice(0, fj + 1); }

  let mut out: String = intp.concat(".").concat(frac);
  if out == "0.0" { return "0.0"; }
  if neg { out = "-".concat(out); }
  return out;
}

fn float_neg_text(s: String) -> String {
  let n: String = float_norm_text(s);
  if n == "0.0" { return n; }
  if n.len() > 0 && n.byte_at(0) == 45 { return n.slice(1, n.len()); }
  return "-".concat(n);
}

fn signed_min_of_kind(k: ir.TyKind) -> i64 {
  if k == ir.TyKind.I8 { return -128; }
  if k == ir.TyKind.I16 { return -32768; }
  if k == ir.TyKind.I32 { return -2147483647 - 1; }
  return -9223372036854775807 - 1;
}

fn signed_max_of_kind(k: ir.TyKind) -> i64 {
  if k == ir.TyKind.I8 { return 127; }
  if k == ir.TyKind.I16 { return 32767; }
  if k == ir.TyKind.I32 { return 2147483647; }
  return 9223372036854775807;
}

fn unsigned_max_bits_of_kind(k: ir.TyKind) -> i64 {
  if k == ir.TyKind.U8 { return 255; }
  if k == ir.TyKind.U16 { return 65535; }
  if k == ir.TyKind.U32 { return 4294967295; }
  // u64/usize max as full 64-bit ones.
  return -1;
}

fn u64_lt_bits(a: i64, b: i64) -> bool {
  let an: bool = a < 0;
  let bn: bool = b < 0;
  if an != bn {
    return !an && bn;
  }
  return a < b;
}

fn u64_le_bits(a: i64, b: i64) -> bool {
  return !u64_lt_bits(b, a);
}

fn u64_div_bits(a0: i64, b0: i64) -> i64 {
  // Bit-by-bit long division on u64 values represented as i64 bit patterns.
  let mut a: i64 = a0;
  let b: i64 = b0;
  let mut q: i64 = 0;
  let mut rem: i64 = 0;
  let mut i: i32 = 0;
  while i < 64 {
    let top1: bool = a < 0;
    rem = rem << 1;
    if top1 { rem = rem | 1; }
    a = a << 1;
    q = q << 1;
    if !u64_lt_bits(rem, b) {
      rem = rem - b;
      q = q | 1;
    }
    i = i + 1;
  }
  return q;
}

fn u64_mod_bits(a0: i64, b0: i64) -> i64 {
  let mut a: i64 = a0;
  let b: i64 = b0;
  let mut rem: i64 = 0;
  let mut i: i32 = 0;
  while i < 64 {
    let top1: bool = a < 0;
    rem = rem << 1;
    if top1 { rem = rem | 1; }
    a = a << 1;
    if !u64_lt_bits(rem, b) {
      rem = rem - b;
    }
    i = i + 1;
  }
  return rem;
}

fn wrap_signed_i8(v: i64) -> i64 {
  let m: i64 = 256;
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  if x >= 128 { x = x - m; }
  return x;
}

fn wrap_unsigned_u8(v: i64) -> i64 {
  let m: i64 = 256;
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  return x;
}

fn wrap_signed_i16(v: i64) -> i64 {
  let m: i64 = 65536;
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  if x >= 32768 { x = x - m; }
  return x;
}

fn wrap_unsigned_u16(v: i64) -> i64 {
  let m: i64 = 65536;
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  return x;
}

fn wrap_signed_i32(v: i64) -> i64 {
  let m: i64 = 4294967296; // 2^32
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  if x >= 2147483648 { x = x - m; } // 2^31
  return x;
}

fn wrap_unsigned_u32(v: i64) -> i64 {
  let m: i64 = 4294967296; // 2^32
  let mut x: i64 = v % m;
  if x < 0 { x = x + m; }
  return x;
}

struct WrapResult { ok: bool, err: TcError, v: i64 }

fn wrap_value_for_type(ctx: Ctx, file: String, ty: i32, v: i64) -> WrapResult {
  let k: ir.TyKind = int_kind(ctx, ty);
  if !is_int_scalar_kind(k) { return WrapResult { ok: false, err: type_error(file, "expected int type"), v: 0 }; }
  if k == ir.TyKind.I8 { return WrapResult { ok: true, err: TcError.None, v: wrap_signed_i8(v) }; }
  if k == ir.TyKind.U8 { return WrapResult { ok: true, err: TcError.None, v: wrap_unsigned_u8(v) }; }
  if k == ir.TyKind.I16 { return WrapResult { ok: true, err: TcError.None, v: wrap_signed_i16(v) }; }
  if k == ir.TyKind.U16 { return WrapResult { ok: true, err: TcError.None, v: wrap_unsigned_u16(v) }; }
  if k == ir.TyKind.I32 { return WrapResult { ok: true, err: TcError.None, v: wrap_signed_i32(v) }; }
  if k == ir.TyKind.U32 { return WrapResult { ok: true, err: TcError.None, v: wrap_unsigned_u32(v) }; }
  if k == ir.TyKind.I64 || k == ir.TyKind.ISize { return WrapResult { ok: true, err: TcError.None, v: v }; }
  if k == ir.TyKind.U64 || k == ir.TyKind.USize { return WrapResult { ok: true, err: TcError.None, v: v }; }
  return WrapResult { ok: false, err: type_error(file, "expected int type"), v: 0 };
}

struct CastConstResult { ok: bool, err: TcError, v: i64 }

fn cast_const_int_checked(ctx: Ctx, file: String, from_ty: i32, to_ty: i32, v: i64) -> CastConstResult {
  let fk: ir.TyKind = int_kind(ctx, from_ty);
  let tk: ir.TyKind = int_kind(ctx, to_ty);
  if !is_int_scalar_kind(fk) || !is_int_scalar_kind(tk) {
    return CastConstResult { ok: false, err: type_error(file, "const expression: int cast overflow"), v: 0 };
  }

  let msg: String = if (fk == ir.TyKind.I64 || fk == ir.TyKind.ISize) && tk == ir.TyKind.I32 { "const expression: i64 to i32 overflow" } else { "const expression: int cast overflow" };

  let wr_from: WrapResult = wrap_value_for_type(ctx, file, from_ty, v);
  if !wr_from.ok { return CastConstResult { ok: false, err: wr_from.err, v: 0 }; }
  let x: i64 = wr_from.v;

  if is_signed_int_kind(fk) {
    if is_signed_int_kind(tk) {
      let lo: i64 = signed_min_of_kind(tk);
      let hi: i64 = signed_max_of_kind(tk);
      if x < lo || x > hi { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
      let wr_to: WrapResult = wrap_value_for_type(ctx, file, to_ty, x);
      if !wr_to.ok { return CastConstResult { ok: false, err: wr_to.err, v: 0 }; }
      return CastConstResult { ok: true, err: TcError.None, v: wr_to.v };
    }
    if x < 0 { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
    let umax0: i64 = unsigned_max_bits_of_kind(tk);
    if u64_lt_bits(umax0, x) { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
    let wr_to0: WrapResult = wrap_value_for_type(ctx, file, to_ty, x);
    if !wr_to0.ok { return CastConstResult { ok: false, err: wr_to0.err, v: 0 }; }
    return CastConstResult { ok: true, err: TcError.None, v: wr_to0.v };
  }

  // from unsigned
  if is_signed_int_kind(tk) {
    let smax: i64 = signed_max_of_kind(tk);
    if u64_lt_bits(smax, x) { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
    let wr_to1: WrapResult = wrap_value_for_type(ctx, file, to_ty, x);
    if !wr_to1.ok { return CastConstResult { ok: false, err: wr_to1.err, v: 0 }; }
    return CastConstResult { ok: true, err: TcError.None, v: wr_to1.v };
  }
  let umax: i64 = unsigned_max_bits_of_kind(tk);
  if u64_lt_bits(umax, x) { return CastConstResult { ok: false, err: type_error(file, msg), v: 0 }; }
  let wr_to2: WrapResult = wrap_value_for_type(ctx, file, to_ty, x);
  if !wr_to2.ok { return CastConstResult { ok: false, err: wr_to2.err, v: 0 }; }
  return CastConstResult { ok: true, err: TcError.None, v: wr_to2.v };
}

// Evaluate in a specific module's expr pool (const init expr ids are module-local).
fn eval_const_expr_in_mod(ctx: Ctx, w: World, items: Vec[ConstItem], sigs0: Vec[ConstSig], states0: Vec[i32], cur_mod: String, imps: Imports, exprs: ast.ExprPool, file: String, id: i32, expected: i32) -> EvalConstExprResult {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);

  // literals
  if match n { ast.ExprNode.Int(_v) => true, _ => false } {
    let s: String = match n { ast.ExprNode.Int(x) => x, _ => "" };

    // When expected is present, constrain to that scalar type (range types require explicit `as`).
    if expected != -1 {
      let eb: i32 = strip_range(ctx, expected);
      if eb != expected { return EvalConstExprResult { ok: false, err: type_error(file, "const int requires expected scalar int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if !is_int_like_ty(ctx, eb) { return EvalConstExprResult { ok: false, err: type_error(file, "const int requires expected int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }

      let bt: ir.Ty = ir.ty_pool_get(ctx.pool, eb);
      if bt.kind == ir.TyKind.U64 || bt.kind == ir.TyKind.USize {
        let pru: ParseU64DecResult = parse_u64_dec(s);
        if !pru.ok { return EvalConstExprResult { ok: false, err: type_error(file, "integer literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: eb, iv: pru.val, bv: false, sv: "", sigs: sigs0, states: states0 };
      }

      let pr2: ParseI64DecResult = parse_i64_dec(s);
      if !pr2.ok { return EvalConstExprResult { ok: false, err: type_error(file, "integer literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      let v: i64 = pr2.val;
      if bt.kind == ir.TyKind.I8 && (v < -128 || v > 127) { return EvalConstExprResult { ok: false, err: type_error(file, "i8 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if bt.kind == ir.TyKind.U8 && (v < 0 || v > 255) { return EvalConstExprResult { ok: false, err: type_error(file, "u8 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if bt.kind == ir.TyKind.I16 && (v < -32768 || v > 32767) { return EvalConstExprResult { ok: false, err: type_error(file, "i16 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if bt.kind == ir.TyKind.U16 && (v < 0 || v > 65535) { return EvalConstExprResult { ok: false, err: type_error(file, "u16 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if bt.kind == ir.TyKind.I32 && (v < -2147483648 || v > 2147483647) { return EvalConstExprResult { ok: false, err: type_error(file, "i32 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if bt.kind == ir.TyKind.U32 && (v < 0 || v > 4294967295) { return EvalConstExprResult { ok: false, err: type_error(file, "u32 literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if bt.kind == ir.TyKind.ISize { return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: eb, iv: v, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: eb, iv: v, bv: false, sv: "", sigs: sigs0, states: states0 };
    }

    // No expected type: default to i32 if it fits, else i64.
    let pr2: ParseI64DecResult = parse_i64_dec(s);
    if !pr2.ok { return EvalConstExprResult { ok: false, err: type_error(file, "integer literal out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let v2: i64 = pr2.val;
    if v2 >= -2147483648 && v2 <= 2147483647 {
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: ctx.ty_i32, iv: v2, bv: false, sv: "", sigs: sigs0, states: states0 };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: ctx.ty_i64, iv: v2, bv: false, sv: "", sigs: sigs0, states: states0 };
  }
  if match n { ast.ExprNode.Float(_v) => true, _ => false } {
    let s: String = match n { ast.ExprNode.Float(x) => x, _ => "" };
    let suf: i32 = float_suffix_kind_text(s);
    let mut out_ty: i32 = if suf == 32 { ctx.ty_f32 } else { ctx.ty_f64 };
    if expected != -1 {
      let eb: i32 = strip_range(ctx, expected);
      if eb != expected { return EvalConstExprResult { ok: false, err: type_error(file, "const float requires expected scalar f32/f64"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if !is_float_scalar_ty(ctx, eb) { return EvalConstExprResult { ok: false, err: type_error(file, "const float requires expected f32/f64"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
      if (suf == 32 && eb != ctx.ty_f32) || (suf == 64 && eb != ctx.ty_f64) {
        return EvalConstExprResult { ok: false, err: type_error(file, "const float suffix conflicts with expected type"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
      }
      out_ty = eb;
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: out_ty, iv: 0, bv: false, sv: float_norm_text(s), sigs: sigs0, states: states0 };
  }
  if match n { ast.ExprNode.Bool(_v) => true, _ => false } {
    if expected != ctx.ty_bool { return EvalConstExprResult { ok: false, err: type_error(file, "const bool requires expected bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let b: bool = match n { ast.ExprNode.Bool(x) => x, _ => false };
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: b, sv: "", sigs: sigs0, states: states0 };
  }
  if match n { ast.ExprNode.Str(_v) => true, _ => false } {
    if expected != ctx.ty_string { return EvalConstExprResult { ok: false, err: type_error(file, "const string requires expected String"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let s: String = match n { ast.ExprNode.Str(x) => x, _ => "" };
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_str(), ty: ctx.ty_string, iv: 0, bv: false, sv: s, sigs: sigs0, states: states0 };
  }

  // identifier: must resolve to a const
  if match n { ast.ExprNode.Ident(_x) => true, _ => false } {
    let name: String = match n { ast.ExprNode.Ident(x) => x, _ => "" };
    let ni: NamedConstImport = find_named_const(imps.named_consts, name);
    let want_mod: String = if ni.local != "" { ni.mod_path } else { cur_mod };
    let want_name: String = if ni.local != "" { ni.name } else { name };
    let idx: i32 = const_find_item(items, want_mod, want_name);
    if idx == -1 { return EvalConstExprResult { ok: false, err: type_error(file, "unknown const: ".concat(const_qname(want_mod, want_name))), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    // ensure referenced const is resolved
    let rr: ResolveConstResult = resolve_const(ctx, w, items, sigs0, states0, idx);
    if !rr.ok { return EvalConstExprResult { ok: false, err: rr.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr.sigs, states: rr.states }; }
    let cs: ConstSig = rr.sigs.get(idx);
    if want_mod != cur_mod && !cs.is_pub { return EvalConstExprResult { ok: false, err: type_error(file, "const is private: ".concat(const_qname(want_mod, want_name))), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr.sigs, states: rr.states }; }
    if expected != -1 && !assignable_to(ctx, expected, cs.ty) {
      return EvalConstExprResult { ok: false, err: type_error(file, "const type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr.sigs, states: rr.states };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: cs.kind, ty: cs.ty, iv: cs.iv, bv: cs.bv, sv: cs.sv, sigs: rr.sigs, states: rr.states };
  }

  // module-qualified const: `alias.NAME` / `alias.mod.NAME`
  if match n { ast.ExprNode.Member(_r, _name) => true, _ => false } {
    let recv: i32 = match n { ast.ExprNode.Member(r, _name) => r, _ => -1 };
    let mname: String = match n { ast.ExprNode.Member(_r, x) => x, _ => "" };
    let pr: ExprPartsResult = expr_parts_member(exprs, recv, mname);
    if !pr.ok { return EvalConstExprResult { ok: false, err: type_error(file, "unsupported const member path"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let parts: Vec[String] = pr.parts;
    if parts.len() < 2 { return EvalConstExprResult { ok: false, err: type_error(file, "unsupported const member path"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let base: String = find_alias(imps.aliases, parts.get(0));
    if base == "" { return EvalConstExprResult { ok: false, err: type_error(file, "unknown module qualifier"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let extra: Vec[String] = slice_parts(parts, 1, parts.len() - 1);
    let want_mod: String = if extra.len() == 0 { base } else { join_mod_path(base, extra) };
    let want_name: String = parts.get(parts.len() - 1);
    let idx2: i32 = const_find_item(items, want_mod, want_name);
    if idx2 == -1 { return EvalConstExprResult { ok: false, err: type_error(file, "unknown const: ".concat(const_qname(want_mod, want_name))), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let rr2: ResolveConstResult = resolve_const(ctx, w, items, sigs0, states0, idx2);
    if !rr2.ok { return EvalConstExprResult { ok: false, err: rr2.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states }; }
    let cs2: ConstSig = rr2.sigs.get(idx2);
    if want_mod != cur_mod && !cs2.is_pub { return EvalConstExprResult { ok: false, err: type_error(file, "const is private: ".concat(const_qname(want_mod, want_name))), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states }; }
    if expected != -1 && !assignable_to(ctx, expected, cs2.ty) {
      return EvalConstExprResult { ok: false, err: type_error(file, "const type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: cs2.kind, ty: cs2.ty, iv: cs2.iv, bv: cs2.bv, sv: cs2.sv, sigs: rr2.sigs, states: rr2.states };
  }

  // unary
  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let op: ast.UnaryOp = match n { ast.ExprNode.Unary(o, _a) => o, _ => ast.UnaryOp.Not };
    let a: i32 = match n { ast.ExprNode.Unary(_o, x) => x, _ => -1 };
    if match op { ast.UnaryOp.Not => true, _ => false } {
      let ar: EvalConstExprResult = eval_const_expr_in_mod(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, ctx.ty_bool);
      if !ar.ok { return ar; }
      if ar.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: type_error(file, "const ! expects bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states }; }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: !ar.bv, sv: "", sigs: ar.sigs, states: ar.states };
    }
    // neg
    let ar2: EvalConstExprResult = eval_const_expr_in_mod(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, -1);
    if !ar2.ok { return ar2; }
    if ar2.kind == const_kind_float() {
      let out_tyf: i32 = if expected != -1 { strip_range(ctx, expected) } else { strip_range(ctx, ar2.ty) };
      if !is_float_scalar_ty(ctx, out_tyf) { return EvalConstExprResult { ok: false, err: type_error(file, "const - expects float or signed int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states }; }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: out_tyf, iv: 0, bv: false, sv: float_neg_text(ar2.sv), sigs: ar2.sigs, states: ar2.states };
    }

    if ar2.kind != const_kind_int() { return EvalConstExprResult { ok: false, err: type_error(file, "const - expects float or signed int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states }; }
    let out_ty: i32 = if expected != -1 { strip_range(ctx, expected) } else { strip_range(ctx, ar2.ty) };
    let k: ir.TyKind = int_kind(ctx, out_ty);
    if !is_signed_int_kind(k) { return EvalConstExprResult { ok: false, err: type_error(file, "const - expects signed int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states }; }
    let wr: WrapResult = wrap_value_for_type(ctx, file, out_ty, -ar2.iv);
    if !wr.ok { return EvalConstExprResult { ok: false, err: wr.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states }; }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: out_ty, iv: wr.v, bv: false, sv: "", sigs: ar2.sigs, states: ar2.states };
  }

  // cast: `expr as Type`
  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(x, _tn) => x, _ => -1 };
    let tn: ast.TypeName = match n { ast.ExprNode.As(_a2, t) => t, _ => ast.TypeName { parts: Vec(), args: Vec() } };
    let tr: ResolveTyResult = resolve_type(ctx, w, cur_mod, imps, Vec(), tn);
    let c2: Ctx = tr.ctx;
    if !tr.ok { return EvalConstExprResult { ok: false, err: type_error(file, "const expression: unknown cast type"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }
    let to: i32 = tr.idx;
    let to_base: i32 = strip_range(c2, to);
    if is_float_scalar_ty(c2, to_base) {
      let an_f: ast.ExprNode = ast.expr_pool_get(exprs, a);
      let eval_expected_f: i32 = if match an_f { ast.ExprNode.Float(_s) => true, _ => false } { to_base } else { -1 };
      let ar_f: EvalConstExprResult = eval_const_expr_in_mod(c2, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, eval_expected_f);
      if !ar_f.ok { return ar_f; }
      if ar_f.kind != const_kind_float() || !is_float_scalar_ty(c2, ar_f.ty) {
        return EvalConstExprResult { ok: false, err: type_error(file, "const expression: cast expects float"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar_f.sigs, states: ar_f.states };
      }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: to_base, iv: 0, bv: false, sv: float_norm_text(ar_f.sv), sigs: ar_f.sigs, states: ar_f.states };
    }

    let tk: ir.TyKind = int_kind(c2, to_base);
    if !is_int_scalar_kind(tk) { return EvalConstExprResult { ok: false, err: type_error(file, "const expression: cast target must be int/@range int or f32/f64"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 }; }

    let an: ast.ExprNode = ast.expr_pool_get(exprs, a);
    let eval_expected: i32 = if match an { ast.ExprNode.Int(_s) => true, _ => false } && is_unsigned_int_kind(tk) { to_base } else { -1 };
    let ar: EvalConstExprResult = eval_const_expr_in_mod(c2, w, items, sigs0, states0, cur_mod, imps, exprs, file, a, eval_expected);
    if !ar.ok { return ar; }
    if ar.kind != const_kind_int() { return EvalConstExprResult { ok: false, err: type_error(file, "const expression: cast expects int"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states }; }

    let from_base: i32 = strip_range(c2, ar.ty);
    let cr: CastConstResult = cast_const_int_checked(c2, file, from_base, to_base, ar.iv);
    if !cr.ok { return EvalConstExprResult { ok: false, err: cr.err, kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states }; }
    let v: i64 = cr.v;

    if is_range_ty(c2, to) {
      let rt: ir.Ty = ir.ty_pool_get(c2.pool, to);
      if v < rt.lo || v > rt.hi {
        return EvalConstExprResult { ok: false, err: type_error(file, "const expression: range check failed"), kind: 0, ty: c2.ty_bad, iv: 0, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
      }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: to, iv: v, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
    }
    return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: to_base, iv: v, bv: false, sv: "", sigs: ar.sigs, states: ar.states };
  }

  // if expr
  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } {
    let cnd: i32 = match n { ast.ExprNode.If(c, _t, _e) => c, _ => -1 };
    let thn: i32 = match n { ast.ExprNode.If(_c, t, _e) => t, _ => -1 };
    let els: i32 = match n { ast.ExprNode.If(_c, _t, e2) => e2, _ => -1 };
    let cr: EvalConstExprResult = eval_const_expr_in_mod(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, cnd, ctx.ty_bool);
    if !cr.ok { return cr; }
    if cr.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: type_error(file, "const if cond must be bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: cr.sigs, states: cr.states }; }
    if cr.bv {
      return eval_const_expr_in_mod(ctx, w, items, cr.sigs, cr.states, cur_mod, imps, exprs, file, thn, expected);
    }
    return eval_const_expr_in_mod(ctx, w, items, cr.sigs, cr.states, cur_mod, imps, exprs, file, els, expected);
  }

  // binary
  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let op: ast.BinaryOp = match n { ast.ExprNode.Binary(o, _l, _r) => o, _ => ast.BinaryOp.Add };
    let l: i32 = match n { ast.ExprNode.Binary(_o, x, _r) => x, _ => -1 };
    let r: i32 = match n { ast.ExprNode.Binary(_o, _l, x) => x, _ => -1 };

    let is_logic: bool = match op { ast.BinaryOp.AndAnd => true, ast.BinaryOp.OrOr => true, _ => false };
    if is_logic {
      let lr: EvalConstExprResult = eval_const_expr_in_mod(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, l, ctx.ty_bool);
      if !lr.ok { return lr; }
      if lr.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: type_error(file, "const &&/|| expects bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: lr.sigs, states: lr.states }; }
      if match op { ast.BinaryOp.AndAnd => true, _ => false } && !lr.bv {
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: false, sv: "", sigs: lr.sigs, states: lr.states };
      }
      if match op { ast.BinaryOp.OrOr => true, _ => false } && lr.bv {
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: true, sv: "", sigs: lr.sigs, states: lr.states };
      }
      let rr: EvalConstExprResult = eval_const_expr_in_mod(ctx, w, items, lr.sigs, lr.states, cur_mod, imps, exprs, file, r, ctx.ty_bool);
      if !rr.ok { return rr; }
      if rr.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: type_error(file, "const &&/|| expects bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr.sigs, states: rr.states }; }
      let out: bool = if match op { ast.BinaryOp.AndAnd => true, _ => false } { lr.bv && rr.bv } else { lr.bv || rr.bv };
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: out, sv: "", sigs: rr.sigs, states: rr.states };
    }

    let is_cmp: bool = match op { ast.BinaryOp.Lt => true, ast.BinaryOp.Le => true, ast.BinaryOp.Gt => true, ast.BinaryOp.Ge => true, _ => false };
    let is_eq: bool = match op { ast.BinaryOp.Eq => true, ast.BinaryOp.Ne => true, _ => false };
    let is_arith: bool = match op { ast.BinaryOp.Add => true, ast.BinaryOp.Sub => true, ast.BinaryOp.Mul => true, ast.BinaryOp.Div => true, ast.BinaryOp.Mod => true, _ => false };
    let is_bit: bool = match op { ast.BinaryOp.BitAnd => true, ast.BinaryOp.BitOr => true, ast.BinaryOp.BitXor => true, _ => false };
    let is_shift: bool = match op { ast.BinaryOp.Shl => true, ast.BinaryOp.Shr => true, _ => false };

    if is_arith || is_bit || is_shift || is_cmp {
      // For comparisons assigned to bool, infer operand type from lhs/rhs instead
      // of forcing expected=bool into numeric subexpressions.
      let is_cmp_bool_ctx: bool = is_cmp && expected == ctx.ty_bool;
      let lhs_expected: i32 = if is_cmp_bool_ctx { -1 } else { expected };
      let mut lr2: EvalConstExprResult = eval_const_expr_in_mod(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, l, lhs_expected);
      if !lr2.ok && is_cmp_bool_ctx {
        // Keep const-eval usable for literal-vs-literal int comparisons.
        lr2 = eval_const_expr_in_mod(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, l, ctx.ty_i32);
      }
      if !lr2.ok { return lr2; }

      let rhs_expected: i32 =
        if is_cmp_bool_ctx {
          strip_range(ctx, lr2.ty)
        } else {
          expected
        };
      let rr2: EvalConstExprResult = eval_const_expr_in_mod(ctx, w, items, lr2.sigs, lr2.states, cur_mod, imps, exprs, file, r, rhs_expected);
      if !rr2.ok { return rr2; }
      let out_ty: i32 = if is_cmp { strip_range(ctx, lr2.ty) } else if expected != -1 { strip_range(ctx, expected) } else { strip_range(ctx, lr2.ty) };
      if strip_range(ctx, lr2.ty) != out_ty || strip_range(ctx, rr2.ty) != out_ty {
        return EvalConstExprResult { ok: false, err: type_error(file, "const numeric op type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
      }

      if lr2.kind == const_kind_float() || rr2.kind == const_kind_float() {
        if lr2.kind != const_kind_float() || rr2.kind != const_kind_float() || !is_float_scalar_ty(ctx, out_ty) {
          return EvalConstExprResult { ok: false, err: type_error(file, "const float op expects f32/f64"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        let fr: ConstFloatBinaryEvalResult = const_float_binary_eval(op, lr2.sv, rr2.sv);
        if !fr.ok {
          return EvalConstExprResult { ok: false, err: type_error(file, fr.err), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        if fr.is_bool {
          return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: fr.out, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_float(), ty: out_ty, iv: 0, bv: false, sv: fr.text, sigs: rr2.sigs, states: rr2.states };
      }

      if lr2.kind != const_kind_int() || rr2.kind != const_kind_int() { return EvalConstExprResult { ok: false, err: type_error(file, "const int op expects ints"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states }; }
      let k: ir.TyKind = int_kind(ctx, out_ty);
      if !is_int_scalar_kind(k) { return EvalConstExprResult { ok: false, err: type_error(file, "const int op expects int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states }; }

      if is_cmp {
        let outb: bool =
          if is_signed_int_kind(k) {
            match op {
              ast.BinaryOp.Lt => lr2.iv < rr2.iv,
              ast.BinaryOp.Le => lr2.iv <= rr2.iv,
              ast.BinaryOp.Gt => lr2.iv > rr2.iv,
              _ => lr2.iv >= rr2.iv,
            }
          } else {
            match op {
              ast.BinaryOp.Lt => u64_lt_bits(lr2.iv, rr2.iv),
              ast.BinaryOp.Le => u64_le_bits(lr2.iv, rr2.iv),
              ast.BinaryOp.Gt => u64_lt_bits(rr2.iv, lr2.iv),
              _ => u64_le_bits(rr2.iv, lr2.iv),
            }
          };
        return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: outb, sv: "", sigs: rr2.sigs, states: rr2.states };
      }

      let is_div: bool = match op { ast.BinaryOp.Div => true, _ => false };
      let is_mod: bool = match op { ast.BinaryOp.Mod => true, _ => false };
      if (is_div || is_mod) && rr2.iv == 0 {
        return EvalConstExprResult { ok: false, err: type_error(file, "const division by zero"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
      }
      if (is_div || is_mod) && is_signed_int_kind(k) {
        let min: i64 =
          if k == ir.TyKind.I8 { -128 }
          else if k == ir.TyKind.I16 { -32768 }
          else if k == ir.TyKind.I32 { -2147483647 - 1 }
          else { -9223372036854775807 - 1 };
        if lr2.iv == min && rr2.iv == -1 {
          return EvalConstExprResult { ok: false, err: type_error(file, "const division overflow"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
      }
      if is_shift {
        let wbits: i64 = int_bits_of_kind(k);
        if rr2.iv < 0 || rr2.iv >= wbits {
          return EvalConstExprResult { ok: false, err: type_error(file, "const shift count out of range"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
        }
      }

      let mut raw: i64 = 0;
      if is_div {
        if is_signed_int_kind(k) { raw = lr2.iv / rr2.iv; }
        else { raw = u64_div_bits(lr2.iv, rr2.iv); }
      } else if is_mod {
        if is_signed_int_kind(k) { raw = lr2.iv % rr2.iv; }
        else { raw = u64_mod_bits(lr2.iv, rr2.iv); }
      } else {
        raw = match op {
          ast.BinaryOp.Add => lr2.iv + rr2.iv,
          ast.BinaryOp.Sub => lr2.iv - rr2.iv,
          ast.BinaryOp.Mul => lr2.iv * rr2.iv,
          ast.BinaryOp.BitAnd => lr2.iv & rr2.iv,
          ast.BinaryOp.BitOr => lr2.iv | rr2.iv,
          ast.BinaryOp.BitXor => lr2.iv ^ rr2.iv,
          ast.BinaryOp.Shl => lr2.iv << rr2.iv,
          _ => lr2.iv >> rr2.iv,
        };
      }
      let wr: WrapResult = wrap_value_for_type(ctx, file, out_ty, raw);
      if !wr.ok { return EvalConstExprResult { ok: false, err: wr.err, kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states }; }
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_int(), ty: out_ty, iv: wr.v, bv: false, sv: "", sigs: rr2.sigs, states: rr2.states };
    }

    if is_eq {
      let lr3: EvalConstExprResult = eval_const_expr_in_mod(ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, l, -1);
      if !lr3.ok { return lr3; }
      let rr3: EvalConstExprResult = eval_const_expr_in_mod(ctx, w, items, lr3.sigs, lr3.states, cur_mod, imps, exprs, file, r, -1);
      if !rr3.ok { return rr3; }

      let lb: i32 = strip_range(ctx, lr3.ty);
      let rb: i32 = strip_range(ctx, rr3.ty);
      if lb != rb { return EvalConstExprResult { ok: false, err: type_error(file, "const ==/!= type mismatch"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states }; }

      let mut eq: bool = false;
      if is_int_like_ty(ctx, lb) {
        if lr3.kind != const_kind_int() || rr3.kind != const_kind_int() { return EvalConstExprResult { ok: false, err: type_error(file, "const ==/!= expects int"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states }; }
        eq = lr3.iv == rr3.iv;
      } else if is_float_scalar_ty(ctx, lb) {
        if lr3.kind != const_kind_float() || rr3.kind != const_kind_float() { return EvalConstExprResult { ok: false, err: type_error(file, "const ==/!= expects float"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states }; }
        eq = float_norm_text(lr3.sv) == float_norm_text(rr3.sv);
      } else if lb == ctx.ty_bool {
        if lr3.kind != const_kind_bool() || rr3.kind != const_kind_bool() { return EvalConstExprResult { ok: false, err: type_error(file, "const ==/!= expects bool"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states }; }
        eq = lr3.bv == rr3.bv;
      } else if lb == ctx.ty_string {
        if lr3.kind != const_kind_str() || rr3.kind != const_kind_str() { return EvalConstExprResult { ok: false, err: type_error(file, "const ==/!= expects string"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states }; }
        eq = lr3.sv == rr3.sv;
      } else {
        return EvalConstExprResult { ok: false, err: type_error(file, "const ==/!= expects primitive"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: rr3.sigs, states: rr3.states };
      }

      let ne: bool = match op { ast.BinaryOp.Ne => true, _ => false };
      let out: bool = if ne { !eq } else { eq };
      return EvalConstExprResult { ok: true, err: TcError.None, kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: out, sv: "", sigs: rr3.sigs, states: rr3.states };
    }

    return EvalConstExprResult { ok: false, err: type_error(file, "unsupported const binary op"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
  }

  return EvalConstExprResult { ok: false, err: type_error(file, "unsupported const expression"), kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "", sigs: sigs0, states: states0 };
}

fn slice_parts(xs: Vec[String], lo: i32, hi: i32) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = lo;
  while i < hi {
    out.push(xs.get(i));
    i = i + 1;
  }
  return out;
}

fn resolve_const(ctx: Ctx, w: World, items: Vec[ConstItem], sigs0: Vec[ConstSig], states0: Vec[i32], idx: i32) -> ResolveConstResult {
  let st: i32 = states0.get(idx); // 0 pending, 1 resolving, 2 done
  if st == 2 { return ResolveConstResult { ok: true, err: TcError.None, sigs: sigs0, states: states0 }; }
  if st == 1 {
    let it0: ConstItem = items.get(idx);
    return ResolveConstResult { ok: false, err: type_error(it0.decl.file, "const cycle: ".concat(const_qname(it0.mod_path, it0.decl.name))), sigs: sigs0, states: states0 };
  }

  let mut sigs: Vec[ConstSig] = sigs0;
  let mut states: Vec[i32] = const_set_i32_at(states0, idx, 1);
  let it: ConstItem = items.get(idx);

  // Resolve declared type (v0: must be primitive or `@range(..) <int>`).
  let fm: FindModResult = find_mod(w, it.mod_path);
  if !fm.found {
    return ResolveConstResult { ok: false, err: type_error(it.decl.file, "unknown module for const"), sigs: sigs, states: states };
  }
  let m: WorldModule = w.mods.get(fm.idx);
  let ir0: ImportsResult = build_imports(w, it.mod_path, m.prog.imports, it.decl.file);
  if !ir0.ok { return ResolveConstResult { ok: false, err: ir0.err, sigs: sigs, states: states }; }
  let imps: Imports = ir0.imps;

  let tr: ResolveTyResult = resolve_type(ctx, w, it.mod_path, imps, Vec(), it.decl.ty);
  if !tr.ok { return ResolveConstResult { ok: false, err: type_error(it.decl.file, "type resolve failed in const"), sigs: sigs, states: states }; }
  let ty: i32 = tr.idx;
  let ok_v0: bool =
    ty == ctx.ty_bool ||
    ty == ctx.ty_string ||
    ty == ctx.ty_f32 ||
    ty == ctx.ty_f64 ||
    is_int_scalar_kind(int_kind(ctx, ty));
  if !ok_v0 { return ResolveConstResult { ok: false, err: type_error(it.decl.file, "const type must be primitive in v0"), sigs: sigs, states: states }; }

  // Evaluate init expression.
  let ev: EvalConstExprResult = eval_const_expr_in_mod(ctx, w, items, sigs, states, it.mod_path, imps, m.prog.exprs, it.decl.file, it.decl.init, ty);
  if !ev.ok { return ResolveConstResult { ok: false, err: ev.err, sigs: ev.sigs, states: ev.states }; }
  sigs = ev.sigs;
  states = ev.states;

  let cs: ConstSig = ConstSig {
    mod_path: it.mod_path,
    name: it.decl.name,
    is_pub: it.decl.is_pub,
    ty: ty,
    kind: ev.kind,
    iv: ev.iv,
    bv: ev.bv,
    sv: ev.sv,
  };
  sigs = const_set_sig_at(sigs, idx, cs);
  states = const_set_i32_at(states, idx, 2);
  return ResolveConstResult { ok: true, err: TcError.None, sigs: sigs, states: states };
}

fn const_set_i32_at(xs0: Vec[i32], idx: i32, val: i32) -> Vec[i32] {
  let mut xs: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    xs.push(if i == idx { val } else { xs0.get(i) });
    i = i + 1;
  }
  return xs;
}

fn const_placeholder() -> ConstSig {
  return ConstSig { mod_path: "", name: "", is_pub: false, ty: -1, kind: 0, iv: 0, bv: false, sv: "" };
}

fn collect_consts(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;

  // Gather all const decls across modules.
  let mut items: Vec[ConstItem] = Vec();
  let mut seen: Vec[String] = Vec();
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ci: i32 = 0;
    while ci < m.prog.consts.len() {
      let cd: ast.ConstDecl = m.prog.consts.get(ci);
      if is_reserved_intrinsic_name(cd.name) {
        return TcCtxResult { ok: false, err: type_error(cd.file, "reserved name: ".concat(cd.name)), ctx: c };
      }
      let qn: String = const_qname(m.path, cd.name);
      if const_contains_str(seen, qn) {
        return TcCtxResult { ok: false, err: type_error(cd.file, "duplicate const: ".concat(cd.name)), ctx: c };
      }
      seen.push(qn);
      items.push(ConstItem { mod_path: m.path, decl: cd });
      ci = ci + 1;
    }
    mi = mi + 1;
  }

  // Pre-size sigs/states vectors.
  let mut sigs: Vec[ConstSig] = Vec();
  let mut states: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < items.len() {
    sigs.push(const_placeholder());
    states.push(0);
    i = i + 1;
  }

  // Resolve all consts (value + type).
  i = 0;
  while i < items.len() {
    let rr: ResolveConstResult = resolve_const(c, w, items, sigs, states, i);
    if !rr.ok { return TcCtxResult { ok: false, err: rr.err, ctx: c }; }
    sigs = rr.sigs;
    states = rr.states;
    i = i + 1;
  }

  c.consts = sigs;
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}
