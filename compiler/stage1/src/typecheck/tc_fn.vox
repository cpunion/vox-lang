import "ast" as ast
import "ir" as ir

fn typecheck_fn(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, fnc: ast.FuncDecl) -> TcResult {
  let fr: FindFuncResult = find_func(ctx, mod_path, fnc.name);
  if !fr.found {
    return TcResult { ok: false, err: type_error(fnc.file, "missing fn sig") };
  }
  let sig: FuncSig = fr.sig;

  let mut l: Locals = locals_new();
  // params at depth 0
  let mut pi: i32 = 0;
  while pi < fnc.params.len() {
    let p: ast.Param = fnc.params.get(pi);
    l = locals_decl(l, p.name, sig.params.get(pi), false);
    pi = pi + 1;
  }

  let r: TcStmtResult = tc_block(ctx, w, mod_path, imps, exprs, l, sig.ret, fnc.body);
  if !r.ok {
    return TcResult { ok: false, err: r.err };
  }
  return TcResult { ok: true, err: TcError.None };
}

struct TcStmtResult { ok: bool, err: TcError, ctx: Ctx, locals: Locals }

fn tc_block(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, ret_ty: i32, b: ast.Block) -> TcStmtResult {
  let mut c: Ctx = ctx;
  let mut l: Locals = locals_enter(l0);
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let r: TcStmtResult = tc_stmt(c, w, mod_path, imps, exprs, l, ret_ty, b.stmts.get(i));
    if !r.ok { return r; }
    c = r.ctx;
    l = r.locals;
    i = i + 1;
  }
  l = locals_exit(l);
  return TcStmtResult { ok: true, err: TcError.None, ctx: c, locals: l0 };
}

fn tc_stmt(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, ret_ty: i32, st: ast.Stmt) -> TcStmtResult {
  return match st {
    ast.Stmt.Let(sp, mutable, name, has_ann, ann, init) => tc_stmt_let(ctx, w, mod_path, imps, exprs, l0, sp, mutable, name, has_ann, ann, init),
    ast.Stmt.Assign(sp, name, rhs) => tc_stmt_assign(ctx, w, mod_path, imps, exprs, l0, sp, name, rhs),
    ast.Stmt.AssignField(sp, recv, field, rhs) => tc_stmt_assign_field(ctx, w, mod_path, imps, exprs, l0, sp, recv, field, rhs),
    ast.Stmt.Expr(sp, eid) => tc_stmt_expr(ctx, w, mod_path, imps, exprs, l0, sp, eid),
    ast.Stmt.If(sp, cond, then_b, has_else, else_b) => tc_stmt_if(ctx, w, mod_path, imps, exprs, l0, ret_ty, sp, cond, then_b, has_else, else_b),
    ast.Stmt.While(sp, cond, body) => tc_stmt_while(ctx, w, mod_path, imps, exprs, l0, ret_ty, sp, cond, body),
    ast.Stmt.Break(_sp) => TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 },
    ast.Stmt.Continue(_sp) => TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 },
    ast.Stmt.Return(sp, has, eid) => tc_stmt_return(ctx, w, mod_path, imps, exprs, l0, ret_ty, sp, has, eid),
  };
}

fn tc_stmt_let(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, sp: ast.Span, mutable: bool, name: String, has_ann: bool, ann: ast.TypeName, init: i32) -> TcStmtResult {
  let mut c: Ctx = ctx;
  let mut expected: i32 = -1;
  if has_ann {
    let rr: ResolveTyResult = resolve_type(c, w, mod_path, imps, Vec(), ann);
    c = rr.ctx;
    if !rr.ok { return TcStmtResult { ok: false, err: type_error_at(sp, "bad let annotation"), ctx: c, locals: l0 }; }
    expected = rr.idx;
  }
  let er: ExprTyResult = tc_expr(c, w, mod_path, imps, exprs, l0, init, expected);
  if !er.ok { return TcStmtResult { ok: false, err: er.err, ctx: c, locals: l0 }; }
  let mut final_ty: i32 = er.ty;
  if has_ann {
    final_ty = expected;
    if !assignable_to(c, final_ty, er.ty) { return TcStmtResult { ok: false, err: type_error_at(ast.expr_pool_span(exprs, init), "let init type mismatch"), ctx: c, locals: l0 }; }
  }
  let l1: Locals = locals_decl(l0, name, final_ty, mutable);
  return TcStmtResult { ok: true, err: TcError.None, ctx: c, locals: l1 };
}

fn tc_stmt_assign(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, sp: ast.Span, name: String, rhs: i32) -> TcStmtResult {
  let vr: LookupVarResult = locals_lookup(l0, name);
  if !vr.found { return TcStmtResult { ok: false, err: type_error_at(sp, "unknown var"), ctx: ctx, locals: l0 }; }
  if !vr.mutable { return TcStmtResult { ok: false, err: type_error_at(sp, "assign to immutable var"), ctx: ctx, locals: l0 }; }
  let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, rhs, vr.ty);
  if !er.ok { return TcStmtResult { ok: false, err: er.err, ctx: ctx, locals: l0 }; }
  if !assignable_to(ctx, vr.ty, er.ty) { return TcStmtResult { ok: false, err: type_error_at(ast.expr_pool_span(exprs, rhs), "assign type mismatch"), ctx: ctx, locals: l0 }; }
  return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 };
}

fn tc_stmt_assign_field(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, sp: ast.Span, recv: String, field: String, rhs: i32) -> TcStmtResult {
  let vr: LookupVarResult = locals_lookup(l0, recv);
  if !vr.found { return TcStmtResult { ok: false, err: type_error_at(sp, "unknown var"), ctx: ctx, locals: l0 }; }
  if !vr.mutable { return TcStmtResult { ok: false, err: type_error_at(sp, "assign to immutable var"), ctx: ctx, locals: l0 }; }

  let rt: ir.Ty = ir.ty_pool_get(ctx.pool, vr.ty);
  if rt.kind != ir.TyKind.Struct { return TcStmtResult { ok: false, err: type_error_at(sp, "field assign recv must be struct"), ctx: ctx, locals: l0 }; }
  let fs: FindStructResult = find_struct(ctx, rt.mod_path, rt.name);
  if !fs.found { return TcStmtResult { ok: false, err: type_error_at(sp, "unknown struct type"), ctx: ctx, locals: l0 }; }
  // Visibility: crossing modules requires both the type and the field to be pub.
  if fs.sig.mod_path != mod_path && !fs.sig.is_pub { return TcStmtResult { ok: false, err: type_error_at(sp, "type is private"), ctx: ctx, locals: l0 }; }

  let mut found: bool = false;
  let mut fty: i32 = ctx.ty_bad;
  let mut fpub: bool = false;
  let mut i: i32 = 0;
  while i < fs.sig.fields.len() {
    let f: StructFieldSig = fs.sig.fields.get(i);
    if f.name == field {
      found = true;
      fty = f.ty;
      fpub = f.is_pub;
      break;
    }
    i = i + 1;
  }
  if !found { return TcStmtResult { ok: false, err: type_error_at(sp, "unknown field"), ctx: ctx, locals: l0 }; }
  if fs.sig.mod_path != mod_path && !fpub { return TcStmtResult { ok: false, err: type_error_at(sp, "field is private"), ctx: ctx, locals: l0 }; }

  let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, rhs, fty);
  if !er.ok { return TcStmtResult { ok: false, err: er.err, ctx: ctx, locals: l0 }; }
  if !assignable_to(ctx, fty, er.ty) { return TcStmtResult { ok: false, err: type_error_at(ast.expr_pool_span(exprs, rhs), "assign type mismatch"), ctx: ctx, locals: l0 }; }
  return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 };
}

fn tc_stmt_expr(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, _sp: ast.Span, eid: i32) -> TcStmtResult {
  let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, eid, -1);
  if !er.ok { return TcStmtResult { ok: false, err: er.err, ctx: ctx, locals: l0 }; }
  return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 };
}

fn tc_stmt_if(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, ret_ty: i32, _sp: ast.Span, cond: i32, then_b: ast.Block, has_else: bool, else_b: ast.Block) -> TcStmtResult {
  let cr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, cond, ctx.ty_bool);
  if !cr.ok { return TcStmtResult { ok: false, err: cr.err, ctx: ctx, locals: l0 }; }
  if cr.ty != ctx.ty_bool { return TcStmtResult { ok: false, err: type_error_at(ast.expr_pool_span(exprs, cond), "if cond must be bool"), ctx: ctx, locals: l0 }; }

  let r1: TcStmtResult = tc_block(ctx, w, mod_path, imps, exprs, locals_enter(l0), ret_ty, then_b);
  if !r1.ok { return r1; }
  if has_else {
    let r2: TcStmtResult = tc_block(ctx, w, mod_path, imps, exprs, locals_enter(l0), ret_ty, else_b);
    if !r2.ok { return r2; }
  }
  return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 };
}

fn tc_stmt_while(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, ret_ty: i32, _sp: ast.Span, cond: i32, body: ast.Block) -> TcStmtResult {
  let cr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, cond, ctx.ty_bool);
  if !cr.ok { return TcStmtResult { ok: false, err: cr.err, ctx: ctx, locals: l0 }; }
  if cr.ty != ctx.ty_bool { return TcStmtResult { ok: false, err: type_error_at(ast.expr_pool_span(exprs, cond), "while cond must be bool"), ctx: ctx, locals: l0 }; }
  let r1: TcStmtResult = tc_block(ctx, w, mod_path, imps, exprs, locals_enter(l0), ret_ty, body);
  if !r1.ok { return r1; }
  return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 };
}

fn tc_stmt_return(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, ret_ty: i32, sp: ast.Span, has: bool, eid: i32) -> TcStmtResult {
  if !has {
    if ret_ty != ctx.ty_unit { return TcStmtResult { ok: false, err: type_error_at(sp, "return type mismatch"), ctx: ctx, locals: l0 }; }
    return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 };
  }
  let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, eid, ret_ty);
  if !er.ok { return TcStmtResult { ok: false, err: er.err, ctx: ctx, locals: l0 }; }
  if !assignable_to(ctx, ret_ty, er.ty) { return TcStmtResult { ok: false, err: type_error_at(ast.expr_pool_span(exprs, eid), "return type mismatch"), ctx: ctx, locals: l0 }; }
  return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 };
}
