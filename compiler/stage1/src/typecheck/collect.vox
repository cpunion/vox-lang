import "ast" as ast

struct TcCtxResult {
  ok: bool,
  err: TcError,
  ctx: Ctx,
}

struct CollectConstWhereResult {
  ok: bool,
  err: TcError,
  bounds: Vec[ConstWhereBoundSig],
}

struct AliasItem { mod_path: String, decl: ast.TypeAliasDecl }

fn alias_qname(mod_path: String, name: String) -> String {
  return mod_path.concat("::").concat(name);
}

fn contains_str_local(vs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < vs.len() {
    if vs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn contains_i32(vs: Vec[i32], x: i32) -> bool {
  let mut i: i32 = 0;
  while i < vs.len() {
    if vs.get(i) == x { return true; }
    i = i + 1;
  }
  return false;
}

fn find_alias_item(items: Vec[AliasItem], mod_path: String, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < items.len() {
    let it: AliasItem = items.get(i);
    if it.mod_path == mod_path && it.decl.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn has_resolved_alias(ctx: Ctx, mod_path: String, name: String) -> bool {
  let mut i: i32 = 0;
  while i < ctx.type_aliases.len() {
    let a: TypeAliasSig = ctx.type_aliases.get(i);
    if a.mod_path == mod_path && a.name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn set_i32_at(xs0: Vec[i32], idx: i32, val: i32) -> Vec[i32] {
  let mut xs: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    xs.push(if i == idx { val } else { xs0.get(i) });
    i = i + 1;
  }
  return xs;
}

fn collect_alias_deps(items: Vec[AliasItem], cur_mod: String, imps: Imports, tn: ast.TypeName) -> Vec[i32] {
  let mut deps: Vec[i32] = Vec();

  // Visit the current node (only when not generic).
  if tn.args.len() == 0 {
    if tn.parts.len() == 1 {
      let mut mod_path: String = cur_mod;
      let mut name: String = tn.parts.get(0);
      let ni: NamedTypeImport = find_named_type(imps.named_types, name);
      if ni.local != "" {
        mod_path = ni.mod_path;
        name = ni.name;
      }
      let ai: i32 = find_alias_item(items, mod_path, name);
      if ai != -1 && !contains_i32(deps, ai) { deps.push(ai); }
    } else if tn.parts.len() == 2 {
      let mp: String = find_alias(imps.aliases, tn.parts.get(0));
      if mp != "" {
        let ai: i32 = find_alias_item(items, mp, tn.parts.get(1));
        if ai != -1 && !contains_i32(deps, ai) { deps.push(ai); }
      }
    }
  }

  // Recurse into generic args.
  let mut i: i32 = 0;
  while i < tn.args.len() {
    let ds: Vec[i32] = collect_alias_deps(items, cur_mod, imps, tn.args.get(i));
    let mut j: i32 = 0;
    while j < ds.len() {
      let d: i32 = ds.get(j);
      if !contains_i32(deps, d) { deps.push(d); }
      j = j + 1;
    }
    i = i + 1;
  }

  return deps;
}

struct ResolveAliasResult { ok: bool, err: TcError, ctx: Ctx, states: Vec[i32] }

fn resolve_alias(ctx0: Ctx, w: World, items: Vec[AliasItem], states0: Vec[i32], idx: i32) -> ResolveAliasResult {
  let st: i32 = states0.get(idx); // 0 pending, 1 resolving, 2 done
  if st == 2 { return ResolveAliasResult { ok: true, err: TcError.None, ctx: ctx0, states: states0 }; }
  if st == 1 {
    let it0: AliasItem = items.get(idx);
    return ResolveAliasResult { ok: false, err: type_error(it0.decl.file, "type alias cycle: ".concat(alias_qname(it0.mod_path, it0.decl.name))), ctx: ctx0, states: states0 };
  }

  let mut c: Ctx = ctx0;
  let mut states: Vec[i32] = set_i32_at(states0, idx, 1);
  let it: AliasItem = items.get(idx);

  let fm: FindModResult = find_mod(w, it.mod_path);
  if !fm.found {
    return ResolveAliasResult { ok: false, err: type_error(it.decl.file, "unknown module for type alias"), ctx: c, states: states };
  }
  let m: WorldModule = w.mods.get(fm.idx);
  let ir: ImportsResult = build_imports(w, it.mod_path, m.prog.imports, it.decl.file);
  if !ir.ok { return ResolveAliasResult { ok: false, err: ir.err, ctx: c, states: states }; }
  let imps: Imports = ir.imps;

  // Resolve dependencies (other type aliases referenced from the RHS).
  let deps: Vec[i32] = collect_alias_deps(items, it.mod_path, imps, it.decl.ty);
  let mut di: i32 = 0;
  while di < deps.len() {
    let dep_idx: i32 = deps.get(di);
    if dep_idx != idx {
      let rr: ResolveAliasResult = resolve_alias(c, w, items, states, dep_idx);
      if !rr.ok { return rr; }
      c = rr.ctx;
      states = rr.states;
    }
    di = di + 1;
  }

  // Resolve the alias RHS type.
  let tr: ResolveTyResult = resolve_type(c, w, it.mod_path, imps, Vec(), it.decl.ty);
  c = tr.ctx;
  if !tr.ok {
    return ResolveAliasResult { ok: false, err: type_error(it.decl.file, "type resolve failed in type alias"), ctx: c, states: states };
  }

  // Cache the resolved alias for later use sites.
  if !has_resolved_alias(c, it.mod_path, it.decl.name) {
    c.type_aliases.push(TypeAliasSig { mod_path: it.mod_path, name: it.decl.name, vis: it.decl.vis, is_pub: it.decl.is_pub, ty: tr.idx });
  }

  states = set_i32_at(states, idx, 2);
  return ResolveAliasResult { ok: true, err: TcError.None, ctx: c, states: states };
}

fn collect_type_aliases(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;

  // Gather all type alias decls across modules (multi-file modules are already merged).
  let mut items: Vec[AliasItem] = Vec();
  let mut seen: Vec[String] = Vec();
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ti: i32 = 0;
    while ti < m.prog.types.len() {
      let td: ast.TypeAliasDecl = m.prog.types.get(ti);
      if is_reserved_intrinsic_name(td.name) {
        return TcCtxResult { ok: false, err: type_error(td.file, "reserved name: ".concat(td.name)), ctx: c };
      }
      let qn: String = alias_qname(m.path, td.name);
      if contains_str_local(seen, qn) {
        return TcCtxResult { ok: false, err: type_error(td.file, "duplicate type alias: ".concat(td.name)), ctx: c };
      }
      seen.push(qn);
      items.push(AliasItem { mod_path: m.path, decl: td });
      ti = ti + 1;
    }
    mi = mi + 1;
  }

  // Resolve with recursion + cycle detection.
  let mut states: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < items.len() { states.push(0); i = i + 1; }

  i = 0;
  while i < items.len() {
    let rr: ResolveAliasResult = resolve_alias(c, w, items, states, i);
    if !rr.ok { return TcCtxResult { ok: false, err: rr.err, ctx: rr.ctx }; }
    c = rr.ctx;
    states = rr.states;
    i = i + 1;
  }

  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn collect_structs(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut si: i32 = 0;
    while si < m.prog.structs.len() {
      let sd: ast.StructDecl = m.prog.structs.get(si);
      if is_reserved_intrinsic_name(sd.name) {
        return TcCtxResult { ok: false, err: type_error(sd.file, "reserved name: ".concat(sd.name)), ctx: c };
      }
      // Generic nominal declarations are instantiated on-demand in resolve_type.
      if sd.type_params.len() != 0 {
        si = si + 1;
        continue;
      }
      let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, sd.file);
      if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
      let imps: Imports = ir.imps;
      let mut fields: Vec[StructFieldSig] = Vec();
      let mut fi: i32 = 0;
      while fi < sd.fields.len() {
        let fd: ast.FieldDecl = sd.fields.get(fi);
        let rr: ResolveTyResult = resolve_type(c, w, m.path, imps, Vec(), fd.ty);
        c = rr.ctx;
        if !rr.ok {
          return TcCtxResult { ok: false, err: type_error(sd.file, "type resolve failed in struct field"), ctx: c };
        }
        fields.push(StructFieldSig { name: fd.name, ty: rr.idx, vis: fd.vis, is_pub: fd.is_pub });
        fi = fi + 1;
      }
      c.structs.push(StructSig { mod_path: m.path, name: sd.name, base_name: sd.name, vis: sd.vis, is_pub: sd.is_pub, fields: fields });
      // Pre-intern nominal struct type so later passes (e.g. const collection)
      // can reference a stable ty index without relying on resolve_type side effects.
      let mut self_parts: Vec[String] = Vec();
      self_parts.push(sd.name);
      let self_ty: ast.TypeName = ast.TypeName { parts: self_parts, args: Vec() };
      let self_r: ResolveTyResult = resolve_type(c, w, m.path, imps, Vec(), self_ty);
      c = self_r.ctx;
      if !self_r.ok {
        return TcCtxResult { ok: false, err: type_error(sd.file, "type resolve failed for struct self type"), ctx: c };
      }
      si = si + 1;
    }
    mi = mi + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn collect_enums(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ei: i32 = 0;
    while ei < m.prog.enums.len() {
      let ed: ast.EnumDecl = m.prog.enums.get(ei);
      if is_reserved_intrinsic_name(ed.name) {
        return TcCtxResult { ok: false, err: type_error(ed.file, "reserved name: ".concat(ed.name)), ctx: c };
      }
      // Generic nominal declarations are instantiated on-demand in resolve_type.
      if ed.type_params.len() != 0 {
        ei = ei + 1;
        continue;
      }
      let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, ed.file);
      if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
      let imps: Imports = ir.imps;
      let mut vars: Vec[EnumVariantSig] = Vec();
      let mut vi: i32 = 0;
      while vi < ed.variants.len() {
        let vd: ast.EnumVariantDecl = ed.variants.get(vi);
        let mut ftys: Vec[i32] = Vec();
        let mut fi: i32 = 0;
        while fi < vd.fields.len() {
          let tr: ResolveTyResult = resolve_type(c, w, m.path, imps, Vec(), vd.fields.get(fi));
          c = tr.ctx;
          if !tr.ok {
            return TcCtxResult { ok: false, err: type_error(ed.file, "type resolve failed in enum variant"), ctx: c };
          }
          ftys.push(tr.idx);
          fi = fi + 1;
        }
        vars.push(EnumVariantSig { name: vd.name, fields: ftys });
        vi = vi + 1;
      }
      c.enums.push(EnumSig { mod_path: m.path, name: ed.name, base_name: ed.name, vis: ed.vis, is_pub: ed.is_pub, vars: vars });
      // Pre-intern nominal enum type so later passes (e.g. const collection)
      // can reference a stable ty index without relying on resolve_type side effects.
      let mut self_parts: Vec[String] = Vec();
      self_parts.push(ed.name);
      let self_ty: ast.TypeName = ast.TypeName { parts: self_parts, args: Vec() };
      let self_r: ResolveTyResult = resolve_type(c, w, m.path, imps, Vec(), self_ty);
      c = self_r.ctx;
      if !self_r.ok {
        return TcCtxResult { ok: false, err: type_error(ed.file, "type resolve failed for enum self type"), ctx: c };
      }
      ei = ei + 1;
    }
    mi = mi + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

struct TypeWalkResult {
  ok: bool,
  err: TcError,
  ctx: Ctx,
}

fn type_walk_ok(c: Ctx) -> TypeWalkResult { return TypeWalkResult { ok: true, err: TcError.None, ctx: c }; }
fn type_walk_err(c: Ctx, e: TcError) -> TypeWalkResult { return TypeWalkResult { ok: false, err: e, ctx: c }; }

// Typed-path marker pre-resolution:
// parser encodes `TypePath[T]` (before `.member` or `{ ... }`) as `Call(path, [T], [])`.
// We resolve it here to ensure typecheck/irgen can rely on already-interned nominal types.
fn maybe_resolve_typed_path_marker(ctx: Ctx, w: World, mod_path: String, imps: Imports, type_params: Vec[String], exprs: ast.ExprPool, id: i32) -> Ctx {
  let mut c: Ctx = ctx;
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);
  if !match n { ast.ExprNode.Call(_callee, _targs, _args) => true, _ => false } { return c; }

  let callee: i32 = match n { ast.ExprNode.Call(x, _ts, _as) => x, _ => -1 };
  let targs: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_x, ts, _as) => ts, _ => Vec() };
  let args: Vec[i32] = match n { ast.ExprNode.Call(_x, _ts, as0) => as0, _ => Vec() };
  if args.len() != 0 || targs.len() == 0 { return c; }
  // `Call(path, [@const...], [])` is not a typed-path marker.
  let mut ti0: i32 = 0;
  while ti0 < targs.len() {
    if is_const_generic_arg_tn(targs.get(ti0)) { return c; }
    ti0 = ti0 + 1;
  }

  let pr: ExprPartsResult = expr_parts(exprs, callee);
  if !pr.ok { return c; }
  if pr.parts.len() != 1 && pr.parts.len() != 2 { return c; }

  let tn: ast.TypeName = ast.TypeName { parts: pr.parts, args: targs };
  let tr: ResolveTyResult = resolve_type(c, w, mod_path, imps, type_params, tn);
  // Best-effort pre-warm only; real type errors are reported in main typecheck pass.
  if tr.ok { c = tr.ctx; }
  return c;
}

fn walk_expr_type_names(ctx: Ctx, w: World, mod_path: String, imps: Imports, type_params: Vec[String], exprs: ast.ExprPool, id: i32, owner_file: String) -> TypeWalkResult {
  let mut c: Ctx = ctx;
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);

  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let tn: ast.TypeName = match n { ast.ExprNode.As(_a, t) => t, _ => ast.TypeName { parts: Vec(), args: Vec() } };
    let tr: ResolveTyResult = resolve_type(c, w, mod_path, imps, type_params, tn);
    c = tr.ctx;
    if !tr.ok { return type_walk_err(c, type_error(owner_file, "type resolve failed in expression type annotation")); }
  }
  if match n { ast.ExprNode.Call(_callee, _targs, _args) => true, _ => false } {
    let targs: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_c, ts, _a) => ts, _ => Vec() };
    let mut ti: i32 = 0;
    while ti < targs.len() {
      let ta: ast.TypeName = targs.get(ti);
      if !is_const_generic_arg_tn(ta) {
        let tr: ResolveTyResult = resolve_type(c, w, mod_path, imps, type_params, ta);
        c = tr.ctx;
        if !tr.ok { return type_walk_err(c, type_error(owner_file, "type resolve failed in call type arg")); }
      }
      ti = ti + 1;
    }
  }
  if match n { ast.ExprNode.Member(_recv, _name) => true, _ => false } {
    let recv: i32 = match n { ast.ExprNode.Member(r, _n) => r, _ => -1 };
    c = maybe_resolve_typed_path_marker(c, w, mod_path, imps, type_params, exprs, recv);
  }
  if match n { ast.ExprNode.StructLit(_tyex, _fields) => true, _ => false } {
    let tyex: i32 = match n { ast.ExprNode.StructLit(t, _fs) => t, _ => -1 };
    c = maybe_resolve_typed_path_marker(c, w, mod_path, imps, type_params, exprs, tyex);
  }

  let wr: TypeWalkResult = match n {
    ast.ExprNode.Int(_v) => type_walk_ok(c),
    ast.ExprNode.Float(_v) => type_walk_ok(c),
    ast.ExprNode.Bool(_v) => type_walk_ok(c),
    ast.ExprNode.Ident(_s) => type_walk_ok(c),
    ast.ExprNode.Str(_s) => type_walk_ok(c),
    ast.ExprNode.DotIdent(_s) => type_walk_ok(c),
    ast.ExprNode.Block(b) => walk_expr_block_type_names(c, w, mod_path, imps, type_params, exprs, b, owner_file),
    ast.ExprNode.If(c0, t0, e0) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, c0, owner_file);
      if !r0.ok { r0 } else {
        let r1: TypeWalkResult = walk_expr_type_names(r0.ctx, w, mod_path, imps, type_params, exprs, t0, owner_file);
        if !r1.ok { r1 } else { walk_expr_type_names(r1.ctx, w, mod_path, imps, type_params, exprs, e0, owner_file) }
      }
    },
    ast.ExprNode.Unary(_op, a) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, a, owner_file),
    ast.ExprNode.As(a, _tn) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, a, owner_file),
    ast.ExprNode.Binary(_op, l, r) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, l, owner_file);
      if !r0.ok { r0 } else { walk_expr_type_names(r0.ctx, w, mod_path, imps, type_params, exprs, r, owner_file) }
    },
    ast.ExprNode.Member(recv, _name) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, recv, owner_file),
    ast.ExprNode.TryBlock(bid) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, bid, owner_file),
    ast.ExprNode.Try(a) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, a, owner_file),
    ast.ExprNode.Call(callee, _targs, args) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, callee, owner_file);
      if !r0.ok { r0 } else {
        let mut c1: Ctx = r0.ctx;
        let mut ai: i32 = 0;
        let mut ok1: bool = true;
        while ok1 && ai < args.len() {
          let ri: TypeWalkResult = walk_expr_type_names(c1, w, mod_path, imps, type_params, exprs, args.get(ai), owner_file);
          if !ri.ok { ok1 = false; c1 = ri.ctx; } else { c1 = ri.ctx; ai = ai + 1; }
        }
        if ok1 { type_walk_ok(c1) } else { type_walk_err(c1, type_error(owner_file, "type resolve failed in call arg expression")) }
      }
    },
    ast.ExprNode.StructLit(tyex, fields) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, tyex, owner_file);
      if !r0.ok { r0 } else {
        let mut c1: Ctx = r0.ctx;
        let mut fi: i32 = 0;
        let mut ok1: bool = true;
        while ok1 && fi < fields.len() {
          let rf: TypeWalkResult = walk_expr_type_names(c1, w, mod_path, imps, type_params, exprs, fields.get(fi).expr, owner_file);
          if !rf.ok { ok1 = false; c1 = rf.ctx; } else { c1 = rf.ctx; fi = fi + 1; }
        }
        if ok1 { type_walk_ok(c1) } else { type_walk_err(c1, type_error(owner_file, "type resolve failed in struct literal field expression")) }
      }
    },
    ast.ExprNode.Match(scrut, arms) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, scrut, owner_file);
      if !r0.ok { r0 } else {
        let mut c1: Ctx = r0.ctx;
        let mut ai: i32 = 0;
        let mut ok1: bool = true;
        while ok1 && ai < arms.len() {
          let ra: TypeWalkResult = walk_expr_type_names(c1, w, mod_path, imps, type_params, exprs, arms.get(ai).expr, owner_file);
          if !ra.ok { ok1 = false; c1 = ra.ctx; } else { c1 = ra.ctx; ai = ai + 1; }
        }
        if ok1 { type_walk_ok(c1) } else { type_walk_err(c1, type_error(owner_file, "type resolve failed in match arm expression")) }
      }
    },
  };
  return wr;
}

fn walk_stmt_type_names(ctx: Ctx, w: World, mod_path: String, imps: Imports, type_params: Vec[String], exprs: ast.ExprPool, st: ast.Stmt, owner_file: String) -> TypeWalkResult {
  let mut c: Ctx = ctx;
  return match st {
    ast.Stmt.Let(_sp, _mut, _name, has_ann, ann, init) => {
      if has_ann {
        let tr: ResolveTyResult = resolve_type(c, w, mod_path, imps, type_params, ann);
        c = tr.ctx;
        if !tr.ok { return type_walk_err(c, type_error(owner_file, "type resolve failed in let annotation")); }
      }
      walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, init, owner_file)
    },
    ast.Stmt.Assign(_sp, _name, ex) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, ex, owner_file),
    ast.Stmt.AssignField(_sp, _recv, _field, ex) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, ex, owner_file),
    ast.Stmt.ExprStmt(_sp, ex) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, ex, owner_file),
    ast.Stmt.IfStmt(_sp, cond, then_b, has_else, else_b) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, cond, owner_file);
      if !r0.ok { r0 } else {
        let r1: TypeWalkResult = walk_block_type_names(r0.ctx, w, mod_path, imps, type_params, exprs, then_b, owner_file);
        if !r1.ok { r1 } else if has_else { walk_block_type_names(r1.ctx, w, mod_path, imps, type_params, exprs, else_b, owner_file) } else { r1 }
      }
    },
    ast.Stmt.WhileStmt(_sp, cond, body) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, cond, owner_file);
      if !r0.ok { r0 } else { walk_block_type_names(r0.ctx, w, mod_path, imps, type_params, exprs, body, owner_file) }
    },
    ast.Stmt.Break(_sp) => type_walk_ok(c),
    ast.Stmt.Continue(_sp) => type_walk_ok(c),
    ast.Stmt.ReturnStmt(_sp, has_ex, ex) => if has_ex { walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, ex, owner_file) } else { type_walk_ok(c) },
  };
}

fn walk_expr_block_type_names(ctx: Ctx, w: World, mod_path: String, imps: Imports, type_params: Vec[String], exprs: ast.ExprPool, b: ast.ExprBlock, owner_file: String) -> TypeWalkResult {
  let mut c: Ctx = ctx;
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let wr: TypeWalkResult = walk_stmt_type_names(c, w, mod_path, imps, type_params, exprs, b.stmts.get(i), owner_file);
    if !wr.ok { return wr; }
    c = wr.ctx;
    i = i + 1;
  }
  if b.has_tail {
    return walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, b.tail, owner_file);
  }
  return type_walk_ok(c);
}

fn walk_block_type_names(ctx: Ctx, w: World, mod_path: String, imps: Imports, type_params: Vec[String], exprs: ast.ExprPool, b: ast.Block, owner_file: String) -> TypeWalkResult {
  let mut c: Ctx = ctx;
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let wr: TypeWalkResult = walk_stmt_type_names(c, w, mod_path, imps, type_params, exprs, b.stmts.get(i), owner_file);
    if !wr.ok { return wr; }
    c = wr.ctx;
    i = i + 1;
  }
  return type_walk_ok(c);
}

fn collect_body_type_names(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);

    // Non-generic function bodies.
    let mut fi: i32 = 0;
    while fi < m.prog.funcs.len() {
      let fd: ast.FuncDecl = m.prog.funcs.get(fi);
      if fd.type_params.len() == 0 && fd.const_params.len() == 0 {
        let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, fd.file);
        if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
        let wr: TypeWalkResult = walk_block_type_names(c, w, m.path, ir.imps, fd.type_params, m.prog.exprs, fd.body, fd.file);
        if !wr.ok { return TcCtxResult { ok: false, err: wr.err, ctx: wr.ctx }; }
        c = wr.ctx;
      }
      fi = fi + 1;
    }

    // Non-generic impl method bodies.
    let mut ii: i32 = 0;
    while ii < m.prog.impls.len() {
      let id: ast.ImplDecl = m.prog.impls.get(ii);
      if id.type_params.len() == 0 {
        let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, id.file);
        if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
        let mut mdi: i32 = 0;
        while mdi < id.methods.len() {
          let md: ast.FuncDecl = id.methods.get(mdi);
          if md.type_params.len() == 0 && md.const_params.len() == 0 {
            let wr: TypeWalkResult = walk_block_type_names(c, w, m.path, ir.imps, md.type_params, m.prog.exprs, md.body, md.file);
            if !wr.ok { return TcCtxResult { ok: false, err: wr.err, ctx: wr.ctx }; }
            c = wr.ctx;
          }
          mdi = mdi + 1;
        }
      }
      ii = ii + 1;
    }

    mi = mi + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn has_bound_sig(bs: Vec[TypeParamBoundSig], tp: String, trait_mod: String, trait_name: String) -> bool {
  let mut i: i32 = 0;
  while i < bs.len() {
    let b: TypeParamBoundSig = bs.get(i);
    if b.type_param == tp && b.trait_mod_path == trait_mod && b.trait_name == trait_name { return true; }
    i = i + 1;
  }
  return false;
}

fn find_const_param_sig(cps: Vec[ConstParamSig], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < cps.len() {
    if cps.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn const_where_op_supported(op: ast.BinaryOp) -> bool {
  return
    match op {
      ast.BinaryOp.Eq => true,
      ast.BinaryOp.Ne => true,
      ast.BinaryOp.Lt => true,
      ast.BinaryOp.Le => true,
      ast.BinaryOp.Gt => true,
      ast.BinaryOp.Ge => true,
      _ => false,
    };
}

fn has_const_where_sig(bs: Vec[ConstWhereBoundSig], name: String, op: ast.BinaryOp, rhs_is_param: bool, rhs_param: String, rhs_iv: i64) -> bool {
  let mut i: i32 = 0;
  while i < bs.len() {
    let b: ConstWhereBoundSig = bs.get(i);
    let rhs_ok: bool =
      if b.rhs_is_param != rhs_is_param {
        false
      } else if rhs_is_param {
        b.rhs_param == rhs_param
      } else {
        b.rhs_iv == rhs_iv
      };
    if b.name == name && rhs_ok {
      if match b.op { ast.BinaryOp.Eq => true, _ => false } && match op { ast.BinaryOp.Eq => true, _ => false } { return true; }
      if match b.op { ast.BinaryOp.Ne => true, _ => false } && match op { ast.BinaryOp.Ne => true, _ => false } { return true; }
      if match b.op { ast.BinaryOp.Lt => true, _ => false } && match op { ast.BinaryOp.Lt => true, _ => false } { return true; }
      if match b.op { ast.BinaryOp.Le => true, _ => false } && match op { ast.BinaryOp.Le => true, _ => false } { return true; }
      if match b.op { ast.BinaryOp.Gt => true, _ => false } && match op { ast.BinaryOp.Gt => true, _ => false } { return true; }
      if match b.op { ast.BinaryOp.Ge => true, _ => false } && match op { ast.BinaryOp.Ge => true, _ => false } { return true; }
    }
    i = i + 1;
  }
  return false;
}

fn collect_const_where_bounds(file: String, cps: Vec[ConstParamSig], ds: Vec[ast.ConstWhereDecl]) -> CollectConstWhereResult {
  let mut out: Vec[ConstWhereBoundSig] = Vec();
  let mut i: i32 = 0;
  while i < ds.len() {
    let d: ast.ConstWhereDecl = ds.get(i);
    if !const_where_op_supported(d.op) {
      return CollectConstWhereResult { ok: false, err: type_error(file, "unsupported comptime where operator"), bounds: out };
    }
    if find_const_param_sig(cps, d.name) == -1 {
      return CollectConstWhereResult { ok: false, err: type_error(file, "unknown const param in comptime where: ".concat(d.name)), bounds: out };
    }
    if d.rhs_is_param {
      if find_const_param_sig(cps, d.rhs_param) == -1 {
        return CollectConstWhereResult { ok: false, err: type_error(file, "unknown const param in comptime where rhs: ".concat(d.rhs_param)), bounds: out };
      }
      out.push(ConstWhereBoundSig {
        name: d.name,
        op: d.op,
        rhs_is_param: true,
        rhs_param: d.rhs_param,
        rhs_iv: 0,
        rhs_text: d.rhs_text,
      });
    } else {
      let pr: ParseI64DecResult = parse_i64_dec(d.rhs_text);
      if !pr.ok {
        return CollectConstWhereResult { ok: false, err: type_error(file, "comptime where rhs out of range: ".concat(d.rhs_text)), bounds: out };
      }
      out.push(ConstWhereBoundSig {
        name: d.name,
        op: d.op,
        rhs_is_param: false,
        rhs_param: "",
        rhs_iv: pr.val,
        rhs_text: d.rhs_text,
      });
    }
    i = i + 1;
  }

  // Validate defaults eagerly: if a const param has default, it must satisfy all
  // comptime where constraints at declaration time.
  let mut defaults: Vec[ConstSub] = Vec();
  i = 0;
  while i < cps.len() {
    let cp: ConstParamSig = cps.get(i);
    if cp.has_default {
      defaults.push(ConstSub { name: cp.name, ty: cp.ty, iv: cp.default_iv, text: cp.default_text });
    }
    i = i + 1;
  }
  let mut wi: i32 = 0;
  while wi < out.len() {
    let wb: ConstWhereBoundSig = out.get(wi);
    let mut cfi: i32 = 0;
    while cfi < cps.len() {
      let cp2: ConstParamSig = cps.get(cfi);
      if cp2.name == wb.name && cp2.has_default {
        // Eagerly validate only when every value used by the bound has defaults.
        let mut can_check: bool = true;
        if wb.rhs_is_param {
          let mut has_rhs_default: bool = false;
          let mut di: i32 = 0;
          while di < defaults.len() {
            if defaults.get(di).name == wb.rhs_param { has_rhs_default = true; }
            di = di + 1;
          }
          can_check = has_rhs_default;
        }
        if can_check {
          let chk: ConstWhereCheckResult = check_const_where_bounds(vec1_const_where(wb), defaults);
          if !chk.ok {
            return CollectConstWhereResult { ok: false, err: type_error(file, "const param default violates comptime where: ".concat(wb.name)), bounds: out };
          }
        }
      }
      cfi = cfi + 1;
    }
    wi = wi + 1;
  }
  return CollectConstWhereResult { ok: true, err: TcError.None, bounds: out };
}

fn vec1_const_where(x: ConstWhereBoundSig) -> Vec[ConstWhereBoundSig] {
  let mut v: Vec[ConstWhereBoundSig] = Vec();
  v.push(x);
  return v;
}

fn collect_funcs(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;

  // Builtins (stage1): keep minimal and stable.
  // Higher-level helpers should live in stdlib Vox sources.
  c.funcs.push(FuncSym { mod_path: "", name: "panic", sig: FuncSig { params: vec1(c.ty_string), ret: c.ty_unit, vis: ast.vis_pub(), is_pub: true, type_params: Vec(), const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "print", sig: FuncSig { params: vec1(c.ty_string), ret: c.ty_unit, vis: ast.vis_pub(), is_pub: true, type_params: Vec(), const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  // Type reflection intrinsics (Stage1 subset): parsed as `@name(Type)`.
  let mut tp_reflect: Vec[String] = Vec();
  tp_reflect.push("T");
  c.funcs.push(FuncSym { mod_path: "", name: "@size_of", sig: FuncSig { params: Vec(), ret: c.ty_usize, vis: ast.vis_pub(), is_pub: true, type_params: tp_reflect, const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  let mut tp_reflect2: Vec[String] = Vec();
  tp_reflect2.push("T");
  c.funcs.push(FuncSym { mod_path: "", name: "@align_of", sig: FuncSig { params: Vec(), ret: c.ty_usize, vis: ast.vis_pub(), is_pub: true, type_params: tp_reflect2, const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  let mut tp_reflect3: Vec[String] = Vec();
  tp_reflect3.push("T");
  c.funcs.push(FuncSym { mod_path: "", name: "@type_name", sig: FuncSig { params: Vec(), ret: c.ty_string, vis: ast.vis_pub(), is_pub: true, type_params: tp_reflect3, const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  let mut tp_reflect4: Vec[String] = Vec();
  tp_reflect4.push("T");
  c.funcs.push(FuncSym { mod_path: "", name: "@field_count", sig: FuncSig { params: Vec(), ret: c.ty_usize, vis: ast.vis_pub(), is_pub: true, type_params: tp_reflect4, const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  let mut tp_reflect4b: Vec[String] = Vec();
  tp_reflect4b.push("T");
  let mut cp_reflect_name: Vec[ConstParamSig] = Vec();
  cp_reflect_name.push(ConstParamSig { name: "I", ty: c.ty_usize, has_default: false, default_iv: 0, default_text: "" });
  c.funcs.push(FuncSym { mod_path: "", name: "@field_name", sig: FuncSig { params: Vec(), ret: c.ty_string, vis: ast.vis_pub(), is_pub: true, type_params: tp_reflect4b, const_params: cp_reflect_name, type_param_bounds: Vec(), const_where_bounds: Vec() } });
  let mut tp_reflect5: Vec[String] = Vec();
  tp_reflect5.push("T");
  c.funcs.push(FuncSym { mod_path: "", name: "@is_integer", sig: FuncSig { params: Vec(), ret: c.ty_bool, vis: ast.vis_pub(), is_pub: true, type_params: tp_reflect5, const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  let mut tp_reflect6: Vec[String] = Vec();
  tp_reflect6.push("T");
  c.funcs.push(FuncSym { mod_path: "", name: "@is_float", sig: FuncSig { params: Vec(), ret: c.ty_bool, vis: ast.vis_pub(), is_pub: true, type_params: tp_reflect6, const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  let mut tp_reflect7: Vec[String] = Vec();
  tp_reflect7.push("T");
  c.funcs.push(FuncSym { mod_path: "", name: "@is_struct", sig: FuncSig { params: Vec(), ret: c.ty_bool, vis: ast.vis_pub(), is_pub: true, type_params: tp_reflect7, const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  let mut tp_reflect8: Vec[String] = Vec();
  tp_reflect8.push("T");
  c.funcs.push(FuncSym { mod_path: "", name: "@is_enum", sig: FuncSig { params: Vec(), ret: c.ty_bool, vis: ast.vis_pub(), is_pub: true, type_params: tp_reflect8, const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  // Tooling/stdlib support builtins (stage1): used by std/fs and std/process.
  // Keep these low-level and prefer std wrappers.
  let v1: ResolveTyResult = intern_vec(c, c.ty_string);
  c = v1.ctx;
  let vec_string: i32 = v1.idx;
  c.funcs.push(FuncSym { mod_path: "", name: "__args", sig: FuncSig { params: Vec(), ret: vec_string, vis: ast.vis_pub(), is_pub: true, type_params: Vec(), const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__exe_path", sig: FuncSig { params: Vec(), ret: c.ty_string, vis: ast.vis_pub(), is_pub: true, type_params: Vec(), const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__read_file", sig: FuncSig { params: vec1(c.ty_string), ret: c.ty_string, vis: ast.vis_pub(), is_pub: true, type_params: Vec(), const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__write_file", sig: FuncSig { params: vec2(c.ty_string, c.ty_string), ret: c.ty_unit, vis: ast.vis_pub(), is_pub: true, type_params: Vec(), const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__exec", sig: FuncSig { params: vec1(c.ty_string), ret: c.ty_i32, vis: ast.vis_pub(), is_pub: true, type_params: Vec(), const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__walk_vox_files", sig: FuncSig { params: vec1(c.ty_string), ret: vec_string, vis: ast.vis_pub(), is_pub: true, type_params: Vec(), const_params: Vec(), type_param_bounds: Vec(), const_where_bounds: Vec() } });

  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut fi: i32 = 0;
    while fi < m.prog.funcs.len() {
      let fd: ast.FuncDecl = m.prog.funcs.get(fi);
      if is_reserved_intrinsic_name(fd.name) {
        return TcCtxResult { ok: false, err: type_error(fd.file, "reserved name: ".concat(fd.name)), ctx: c };
      }
      let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, fd.file);
      if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
      let imps: Imports = ir.imps;
      let mut cps: Vec[ConstParamSig] = Vec();
      let mut cpi: i32 = 0;
      while cpi < fd.const_params.len() {
        let cp: ast.ConstParamDecl = fd.const_params.get(cpi);
        if contains_str_local(fd.type_params, cp.name) {
          return TcCtxResult { ok: false, err: type_error(fd.file, "const param duplicates type param: ".concat(cp.name)), ctx: c };
        }
        let mut dup: bool = false;
        let mut cj: i32 = 0;
        while cj < cps.len() {
          if cps.get(cj).name == cp.name { dup = true; }
          cj = cj + 1;
        }
        if dup {
          return TcCtxResult { ok: false, err: type_error(fd.file, "duplicate const param: ".concat(cp.name)), ctx: c };
        }
        let cpr: ResolveTyResult = resolve_type(c, w, m.path, imps, fd.type_params, cp.ty);
        c = cpr.ctx;
        if !cpr.ok {
          return TcCtxResult { ok: false, err: type_error(fd.file, "type resolve failed in const param"), ctx: c };
        }
        if !is_int_like_ty(c, cpr.idx) {
          return TcCtxResult { ok: false, err: type_error(fd.file, "const param type must be integer"), ctx: c };
        }
        let mut has_default: bool = false;
        let mut default_iv: i64 = 0;
        let mut default_text: String = "";
        if cp.has_default {
          let mut dparts: Vec[String] = Vec();
          dparts.push("@const");
          dparts.push(cp.default_text);
          let dpr: ParseConstGenericArgResult = parse_const_generic_arg(c, ast.TypeName { parts: dparts, args: Vec() }, cpr.idx);
          if !dpr.ok {
            return TcCtxResult { ok: false, err: type_error(fd.file, "const param default out of range"), ctx: c };
          }
          has_default = true;
          default_iv = dpr.iv;
          default_text = dpr.text;
        }
        cps.push(ConstParamSig { name: cp.name, ty: cpr.idx, has_default: has_default, default_iv: default_iv, default_text: default_text });
        cpi = cpi + 1;
      }
      // Resolve signature types (skip bodies for generic fns; still collect signature).
      let mut ps: Vec[i32] = Vec();
      let mut pi: i32 = 0;
      while pi < fd.params.len() {
        let pr: ast.Param = fd.params.get(pi);
        let tr: ResolveTyResult = resolve_type(c, w, m.path, imps, fd.type_params, pr.ty);
        c = tr.ctx;
        if !tr.ok {
          return TcCtxResult { ok: false, err: type_error(fd.file, "type resolve failed in fn param"), ctx: c };
        }
        ps.push(tr.idx);
        pi = pi + 1;
      }
      let rr: ResolveTyResult = resolve_type(c, w, m.path, imps, fd.type_params, fd.ret);
      c = rr.ctx;
      if !rr.ok {
        return TcCtxResult { ok: false, err: type_error(fd.file, "type resolve failed in fn ret"), ctx: c };
      }

      let mut tbs: Vec[TypeParamBoundSig] = Vec();
      let mut bi: i32 = 0;
      while bi < fd.type_param_bounds.len() {
        let bdecl: ast.TypeParamBoundsDecl = fd.type_param_bounds.get(bi);
        if !contains_str_local(fd.type_params, bdecl.name) {
          return TcCtxResult { ok: false, err: type_error(fd.file, "unknown type param in bound: ".concat(bdecl.name)), ctx: c };
        }
        let mut bj: i32 = 0;
        while bj < bdecl.bounds.len() {
          let rtr: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, bdecl.bounds.get(bj));
          if !rtr.ok {
            return TcCtxResult { ok: false, err: type_error(fd.file, "bad trait bound"), ctx: c };
          }
          let tf: FindTraitResult = find_trait(c, rtr.mod_path, rtr.name);
          if !tf.found {
            return TcCtxResult { ok: false, err: type_error(fd.file, "unknown trait in bound"), ctx: c };
          }
          if !vis_allows(tf.sig.vis, rtr.mod_path, m.path) {
            return TcCtxResult { ok: false, err: type_error(fd.file, "trait bound refers to private trait"), ctx: c };
          }
          if !has_bound_sig(tbs, bdecl.name, rtr.mod_path, rtr.name) {
            tbs.push(TypeParamBoundSig { type_param: bdecl.name, trait_mod_path: rtr.mod_path, trait_name: rtr.name });
          }
          bj = bj + 1;
        }
        bi = bi + 1;
      }

      let mut pj: i32 = 0;
      while pj < fd.params.len() {
        let pr0: ast.Param = fd.params.get(pj);
        let perr0: String = projection_bound_issue(c, fd.type_params, tbs, pr0.ty);
        if perr0 != "" { return TcCtxResult { ok: false, err: type_error(fd.file, perr0), ctx: c }; }
        pj = pj + 1;
      }
      let perr1: String = projection_bound_issue(c, fd.type_params, tbs, fd.ret);
      if perr1 != "" { return TcCtxResult { ok: false, err: type_error(fd.file, perr1), ctx: c }; }

      let cwr: CollectConstWhereResult = collect_const_where_bounds(fd.file, cps, fd.const_where_bounds);
      if !cwr.ok { return TcCtxResult { ok: false, err: cwr.err, ctx: c }; }

      let sig: FuncSig = FuncSig { params: ps, ret: rr.idx, vis: fd.vis, is_pub: fd.is_pub, type_params: fd.type_params, const_params: cps, type_param_bounds: tbs, const_where_bounds: cwr.bounds };
      c.funcs.push(FuncSym { mod_path: m.path, name: fd.name, sig: sig });
      fi = fi + 1;
    }
    mi = mi + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn vec1(x: i32) -> Vec[i32] { let mut v: Vec[i32] = Vec(); v.push(x); return v; }
fn vec2(a: i32, b: i32) -> Vec[i32] { let mut v: Vec[i32] = Vec(); v.push(a); v.push(b); return v; }
