import "ast" as ast

struct TcCtxResult {
  ok: bool,
  err: TcError,
  ctx: Ctx,
}

fn collect_structs(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut si: i32 = 0;
    while si < m.prog.structs.len() {
      let sd: ast.StructDecl = m.prog.structs.get(si);
      if is_reserved_intrinsic_name(sd.name) {
        return TcCtxResult { ok: false, err: TcError.Msg("reserved name: ".concat(sd.name)), ctx: c };
      }
      let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, sd.file);
      if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
      let imps: Imports = ir.imps;
      let mut fields: Vec[StructFieldSig] = Vec();
      let mut fi: i32 = 0;
      while fi < sd.fields.len() {
        let fd: ast.FieldDecl = sd.fields.get(fi);
        let rr: ResolveTyResult = resolve_type(c, w, m.path, imps, Vec(), fd.ty);
        c = rr.ctx;
        if !rr.ok {
          return TcCtxResult { ok: false, err: TcError.Msg("type resolve failed in struct field"), ctx: c };
        }
        fields.push(StructFieldSig { name: fd.name, ty: rr.idx, is_pub: fd.is_pub });
        fi = fi + 1;
      }
      c.structs.push(StructSig { mod_path: m.path, name: sd.name, is_pub: sd.is_pub, fields: fields });
      si = si + 1;
    }
    mi = mi + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn collect_enums(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ei: i32 = 0;
    while ei < m.prog.enums.len() {
      let ed: ast.EnumDecl = m.prog.enums.get(ei);
      if is_reserved_intrinsic_name(ed.name) {
        return TcCtxResult { ok: false, err: TcError.Msg("reserved name: ".concat(ed.name)), ctx: c };
      }
      let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, ed.file);
      if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
      let imps: Imports = ir.imps;
      let mut vars: Vec[EnumVariantSig] = Vec();
      let mut vi: i32 = 0;
      while vi < ed.variants.len() {
        let vd: ast.EnumVariantDecl = ed.variants.get(vi);
        let mut ftys: Vec[i32] = Vec();
        let mut fi: i32 = 0;
        while fi < vd.fields.len() {
          let tr: ResolveTyResult = resolve_type(c, w, m.path, imps, Vec(), vd.fields.get(fi));
          c = tr.ctx;
          if !tr.ok {
            return TcCtxResult { ok: false, err: TcError.Msg("type resolve failed in enum variant"), ctx: c };
          }
          ftys.push(tr.idx);
          fi = fi + 1;
        }
        vars.push(EnumVariantSig { name: vd.name, fields: ftys });
        vi = vi + 1;
      }
      c.enums.push(EnumSig { mod_path: m.path, name: ed.name, is_pub: ed.is_pub, vars: vars });
      ei = ei + 1;
    }
    mi = mi + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn collect_funcs(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;

  // Builtins (stage1): keep minimal and stable.
  // Higher-level helpers should live in stdlib Vox sources.
  c.funcs.push(FuncSym { mod_path: "", name: "panic", sig: FuncSig { params: vec1(c.ty_string), ret: c.ty_unit, is_pub: true, type_params: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "print", sig: FuncSig { params: vec1(c.ty_string), ret: c.ty_unit, is_pub: true, type_params: Vec() } });
  // Tooling/stdlib support builtins (stage1): used by std/fs and std/process.
  // Keep these low-level and prefer std wrappers.
  let v1: ResolveTyResult = intern_vec(c, c.ty_string);
  c = v1.ctx;
  let vec_string: i32 = v1.idx;
  c.funcs.push(FuncSym { mod_path: "", name: "__args", sig: FuncSig { params: Vec(), ret: vec_string, is_pub: true, type_params: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__exe_path", sig: FuncSig { params: Vec(), ret: c.ty_string, is_pub: true, type_params: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__read_file", sig: FuncSig { params: vec1(c.ty_string), ret: c.ty_string, is_pub: true, type_params: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__write_file", sig: FuncSig { params: vec2(c.ty_string, c.ty_string), ret: c.ty_unit, is_pub: true, type_params: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__exec", sig: FuncSig { params: vec1(c.ty_string), ret: c.ty_i32, is_pub: true, type_params: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__walk_vox_files", sig: FuncSig { params: vec1(c.ty_string), ret: vec_string, is_pub: true, type_params: Vec() } });

  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut fi: i32 = 0;
    while fi < m.prog.funcs.len() {
      let fd: ast.FuncDecl = m.prog.funcs.get(fi);
      if is_reserved_intrinsic_name(fd.name) {
        return TcCtxResult { ok: false, err: TcError.Msg("reserved name: ".concat(fd.name)), ctx: c };
      }
      let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, fd.file);
      if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
      let imps: Imports = ir.imps;
      // Resolve signature types (skip bodies for generic fns; still collect signature).
      let mut ps: Vec[i32] = Vec();
      let mut pi: i32 = 0;
      while pi < fd.params.len() {
        let pr: ast.Param = fd.params.get(pi);
        let tr: ResolveTyResult = resolve_type(c, w, m.path, imps, fd.type_params, pr.ty);
        c = tr.ctx;
        if !tr.ok {
          return TcCtxResult { ok: false, err: TcError.Msg("type resolve failed in fn param"), ctx: c };
        }
        ps.push(tr.idx);
        pi = pi + 1;
      }
      let rr: ResolveTyResult = resolve_type(c, w, m.path, imps, fd.type_params, fd.ret);
      c = rr.ctx;
      if !rr.ok {
        return TcCtxResult { ok: false, err: TcError.Msg("type resolve failed in fn ret"), ctx: c };
      }
      let sig: FuncSig = FuncSig { params: ps, ret: rr.idx, is_pub: fd.is_pub, type_params: fd.type_params };
      c.funcs.push(FuncSym { mod_path: m.path, name: fd.name, sig: sig });
      fi = fi + 1;
    }
    mi = mi + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn vec1(x: i32) -> Vec[i32] { let mut v: Vec[i32] = Vec(); v.push(x); return v; }
fn vec2(a: i32, b: i32) -> Vec[i32] { let mut v: Vec[i32] = Vec(); v.push(a); v.push(b); return v; }
