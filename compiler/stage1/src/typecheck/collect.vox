import "ast" as ast

struct TcCtxResult {
  ok: bool,
  err: TcError,
  ctx: Ctx,
}

struct AliasItem { mod_path: String, decl: ast.TypeAliasDecl }

fn alias_qname(mod_path: String, name: String) -> String {
  return mod_path.concat("::").concat(name);
}

fn contains_str_local(vs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < vs.len() {
    if vs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn contains_i32(vs: Vec[i32], x: i32) -> bool {
  let mut i: i32 = 0;
  while i < vs.len() {
    if vs.get(i) == x { return true; }
    i = i + 1;
  }
  return false;
}

fn find_alias_item(items: Vec[AliasItem], mod_path: String, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < items.len() {
    let it: AliasItem = items.get(i);
    if it.mod_path == mod_path && it.decl.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn has_resolved_alias(ctx: Ctx, mod_path: String, name: String) -> bool {
  let mut i: i32 = 0;
  while i < ctx.type_aliases.len() {
    let a: TypeAliasSig = ctx.type_aliases.get(i);
    if a.mod_path == mod_path && a.name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn set_i32_at(xs0: Vec[i32], idx: i32, val: i32) -> Vec[i32] {
  let mut xs: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    xs.push(if i == idx { val } else { xs0.get(i) });
    i = i + 1;
  }
  return xs;
}

fn collect_alias_deps(items: Vec[AliasItem], cur_mod: String, imps: Imports, tn: ast.TypeName) -> Vec[i32] {
  let mut deps: Vec[i32] = Vec();

  // Visit the current node (only when not generic).
  if tn.args.len() == 0 {
    if tn.parts.len() == 1 {
      let mut mod_path: String = cur_mod;
      let mut name: String = tn.parts.get(0);
      let ni: NamedTypeImport = find_named_type(imps.named_types, name);
      if ni.local != "" {
        mod_path = ni.mod_path;
        name = ni.name;
      }
      let ai: i32 = find_alias_item(items, mod_path, name);
      if ai != -1 && !contains_i32(deps, ai) { deps.push(ai); }
    } else if tn.parts.len() == 2 {
      let mp: String = find_alias(imps.aliases, tn.parts.get(0));
      if mp != "" {
        let ai: i32 = find_alias_item(items, mp, tn.parts.get(1));
        if ai != -1 && !contains_i32(deps, ai) { deps.push(ai); }
      }
    }
  }

  // Recurse into generic args.
  let mut i: i32 = 0;
  while i < tn.args.len() {
    let ds: Vec[i32] = collect_alias_deps(items, cur_mod, imps, tn.args.get(i));
    let mut j: i32 = 0;
    while j < ds.len() {
      let d: i32 = ds.get(j);
      if !contains_i32(deps, d) { deps.push(d); }
      j = j + 1;
    }
    i = i + 1;
  }

  return deps;
}

struct ResolveAliasResult { ok: bool, err: TcError, ctx: Ctx, states: Vec[i32] }

fn resolve_alias(ctx0: Ctx, w: World, items: Vec[AliasItem], states0: Vec[i32], idx: i32) -> ResolveAliasResult {
  let st: i32 = states0.get(idx); // 0 pending, 1 resolving, 2 done
  if st == 2 { return ResolveAliasResult { ok: true, err: TcError.None, ctx: ctx0, states: states0 }; }
  if st == 1 {
    let it0: AliasItem = items.get(idx);
    return ResolveAliasResult { ok: false, err: type_error(it0.decl.file, "type alias cycle: ".concat(alias_qname(it0.mod_path, it0.decl.name))), ctx: ctx0, states: states0 };
  }

  let mut c: Ctx = ctx0;
  let mut states: Vec[i32] = set_i32_at(states0, idx, 1);
  let it: AliasItem = items.get(idx);

  let fm: FindModResult = find_mod(w, it.mod_path);
  if !fm.found {
    return ResolveAliasResult { ok: false, err: type_error(it.decl.file, "unknown module for type alias"), ctx: c, states: states };
  }
  let m: WorldModule = w.mods.get(fm.idx);
  let ir: ImportsResult = build_imports(w, it.mod_path, m.prog.imports, it.decl.file);
  if !ir.ok { return ResolveAliasResult { ok: false, err: ir.err, ctx: c, states: states }; }
  let imps: Imports = ir.imps;

  // Resolve dependencies (other type aliases referenced from the RHS).
  let deps: Vec[i32] = collect_alias_deps(items, it.mod_path, imps, it.decl.ty);
  let mut di: i32 = 0;
  while di < deps.len() {
    let dep_idx: i32 = deps.get(di);
    if dep_idx != idx {
      let rr: ResolveAliasResult = resolve_alias(c, w, items, states, dep_idx);
      if !rr.ok { return rr; }
      c = rr.ctx;
      states = rr.states;
    }
    di = di + 1;
  }

  // Resolve the alias RHS type.
  let tr: ResolveTyResult = resolve_type(c, w, it.mod_path, imps, Vec(), it.decl.ty);
  c = tr.ctx;
  if !tr.ok {
    return ResolveAliasResult { ok: false, err: type_error(it.decl.file, "type resolve failed in type alias"), ctx: c, states: states };
  }

  // Cache the resolved alias for later use sites.
  if !has_resolved_alias(c, it.mod_path, it.decl.name) {
    c.type_aliases.push(TypeAliasSig { mod_path: it.mod_path, name: it.decl.name, is_pub: it.decl.is_pub, ty: tr.idx });
  }

  states = set_i32_at(states, idx, 2);
  return ResolveAliasResult { ok: true, err: TcError.None, ctx: c, states: states };
}

fn collect_type_aliases(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;

  // Gather all type alias decls across modules (multi-file modules are already merged).
  let mut items: Vec[AliasItem] = Vec();
  let mut seen: Vec[String] = Vec();
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ti: i32 = 0;
    while ti < m.prog.types.len() {
      let td: ast.TypeAliasDecl = m.prog.types.get(ti);
      if is_reserved_intrinsic_name(td.name) {
        return TcCtxResult { ok: false, err: type_error(td.file, "reserved name: ".concat(td.name)), ctx: c };
      }
      let qn: String = alias_qname(m.path, td.name);
      if contains_str_local(seen, qn) {
        return TcCtxResult { ok: false, err: type_error(td.file, "duplicate type alias: ".concat(td.name)), ctx: c };
      }
      seen.push(qn);
      items.push(AliasItem { mod_path: m.path, decl: td });
      ti = ti + 1;
    }
    mi = mi + 1;
  }

  // Resolve with recursion + cycle detection.
  let mut states: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < items.len() { states.push(0); i = i + 1; }

  i = 0;
  while i < items.len() {
    let rr: ResolveAliasResult = resolve_alias(c, w, items, states, i);
    if !rr.ok { return TcCtxResult { ok: false, err: rr.err, ctx: rr.ctx }; }
    c = rr.ctx;
    states = rr.states;
    i = i + 1;
  }

  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn collect_structs(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut si: i32 = 0;
    while si < m.prog.structs.len() {
      let sd: ast.StructDecl = m.prog.structs.get(si);
      if is_reserved_intrinsic_name(sd.name) {
        return TcCtxResult { ok: false, err: type_error(sd.file, "reserved name: ".concat(sd.name)), ctx: c };
      }
      // Generic nominal declarations are instantiated on-demand in resolve_type.
      if sd.type_params.len() != 0 {
        si = si + 1;
        continue;
      }
      let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, sd.file);
      if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
      let imps: Imports = ir.imps;
      let mut fields: Vec[StructFieldSig] = Vec();
      let mut fi: i32 = 0;
      while fi < sd.fields.len() {
        let fd: ast.FieldDecl = sd.fields.get(fi);
        let rr: ResolveTyResult = resolve_type(c, w, m.path, imps, Vec(), fd.ty);
        c = rr.ctx;
        if !rr.ok {
          return TcCtxResult { ok: false, err: type_error(sd.file, "type resolve failed in struct field"), ctx: c };
        }
        fields.push(StructFieldSig { name: fd.name, ty: rr.idx, is_pub: fd.is_pub });
        fi = fi + 1;
      }
      c.structs.push(StructSig { mod_path: m.path, name: sd.name, base_name: sd.name, is_pub: sd.is_pub, fields: fields });
      // Pre-intern nominal struct type so later passes (e.g. const collection)
      // can reference a stable ty index without relying on resolve_type side effects.
      let mut self_parts: Vec[String] = Vec();
      self_parts.push(sd.name);
      let self_ty: ast.TypeName = ast.TypeName { parts: self_parts, args: Vec() };
      let self_r: ResolveTyResult = resolve_type(c, w, m.path, imps, Vec(), self_ty);
      c = self_r.ctx;
      if !self_r.ok {
        return TcCtxResult { ok: false, err: type_error(sd.file, "type resolve failed for struct self type"), ctx: c };
      }
      si = si + 1;
    }
    mi = mi + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn collect_enums(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ei: i32 = 0;
    while ei < m.prog.enums.len() {
      let ed: ast.EnumDecl = m.prog.enums.get(ei);
      if is_reserved_intrinsic_name(ed.name) {
        return TcCtxResult { ok: false, err: type_error(ed.file, "reserved name: ".concat(ed.name)), ctx: c };
      }
      // Generic nominal declarations are instantiated on-demand in resolve_type.
      if ed.type_params.len() != 0 {
        ei = ei + 1;
        continue;
      }
      let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, ed.file);
      if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
      let imps: Imports = ir.imps;
      let mut vars: Vec[EnumVariantSig] = Vec();
      let mut vi: i32 = 0;
      while vi < ed.variants.len() {
        let vd: ast.EnumVariantDecl = ed.variants.get(vi);
        let mut ftys: Vec[i32] = Vec();
        let mut fi: i32 = 0;
        while fi < vd.fields.len() {
          let tr: ResolveTyResult = resolve_type(c, w, m.path, imps, Vec(), vd.fields.get(fi));
          c = tr.ctx;
          if !tr.ok {
            return TcCtxResult { ok: false, err: type_error(ed.file, "type resolve failed in enum variant"), ctx: c };
          }
          ftys.push(tr.idx);
          fi = fi + 1;
        }
        vars.push(EnumVariantSig { name: vd.name, fields: ftys });
        vi = vi + 1;
      }
      c.enums.push(EnumSig { mod_path: m.path, name: ed.name, base_name: ed.name, is_pub: ed.is_pub, vars: vars });
      // Pre-intern nominal enum type so later passes (e.g. const collection)
      // can reference a stable ty index without relying on resolve_type side effects.
      let mut self_parts: Vec[String] = Vec();
      self_parts.push(ed.name);
      let self_ty: ast.TypeName = ast.TypeName { parts: self_parts, args: Vec() };
      let self_r: ResolveTyResult = resolve_type(c, w, m.path, imps, Vec(), self_ty);
      c = self_r.ctx;
      if !self_r.ok {
        return TcCtxResult { ok: false, err: type_error(ed.file, "type resolve failed for enum self type"), ctx: c };
      }
      ei = ei + 1;
    }
    mi = mi + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

struct TypeWalkResult {
  ok: bool,
  err: TcError,
  ctx: Ctx,
}

fn type_walk_ok(c: Ctx) -> TypeWalkResult { return TypeWalkResult { ok: true, err: TcError.None, ctx: c }; }
fn type_walk_err(c: Ctx, e: TcError) -> TypeWalkResult { return TypeWalkResult { ok: false, err: e, ctx: c }; }

// Typed-path marker pre-resolution:
// parser encodes `TypePath[T]` (before `.member` or `{ ... }`) as `Call(path, [T], [])`.
// We resolve it here to ensure typecheck/irgen can rely on already-interned nominal types.
fn maybe_resolve_typed_path_marker(ctx: Ctx, w: World, mod_path: String, imps: Imports, type_params: Vec[String], exprs: ast.ExprPool, id: i32) -> Ctx {
  let mut c: Ctx = ctx;
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);
  if !match n { ast.ExprNode.Call(_callee, _targs, _args) => true, _ => false } { return c; }

  let callee: i32 = match n { ast.ExprNode.Call(x, _ts, _as) => x, _ => -1 };
  let targs: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_x, ts, _as) => ts, _ => Vec() };
  let args: Vec[i32] = match n { ast.ExprNode.Call(_x, _ts, as0) => as0, _ => Vec() };
  if args.len() != 0 || targs.len() == 0 { return c; }

  let pr: ExprPartsResult = expr_parts(exprs, callee);
  if !pr.ok { return c; }
  if pr.parts.len() != 1 && pr.parts.len() != 2 { return c; }

  let tn: ast.TypeName = ast.TypeName { parts: pr.parts, args: targs };
  let tr: ResolveTyResult = resolve_type(c, w, mod_path, imps, type_params, tn);
  // Best-effort pre-warm only; real type errors are reported in main typecheck pass.
  if tr.ok { c = tr.ctx; }
  return c;
}

fn walk_expr_type_names(ctx: Ctx, w: World, mod_path: String, imps: Imports, type_params: Vec[String], exprs: ast.ExprPool, id: i32, owner_file: String) -> TypeWalkResult {
  let mut c: Ctx = ctx;
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);

  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let tn: ast.TypeName = match n { ast.ExprNode.As(_a, t) => t, _ => ast.TypeName { parts: Vec(), args: Vec() } };
    let tr: ResolveTyResult = resolve_type(c, w, mod_path, imps, type_params, tn);
    c = tr.ctx;
    if !tr.ok { return type_walk_err(c, type_error(owner_file, "type resolve failed in expression type annotation")); }
  }
  if match n { ast.ExprNode.Call(_callee, _targs, _args) => true, _ => false } {
    let targs: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_c, ts, _a) => ts, _ => Vec() };
    let mut ti: i32 = 0;
    while ti < targs.len() {
      let tr: ResolveTyResult = resolve_type(c, w, mod_path, imps, type_params, targs.get(ti));
      c = tr.ctx;
      if !tr.ok { return type_walk_err(c, type_error(owner_file, "type resolve failed in call type arg")); }
      ti = ti + 1;
    }
  }
  if match n { ast.ExprNode.Member(_recv, _name) => true, _ => false } {
    let recv: i32 = match n { ast.ExprNode.Member(r, _n) => r, _ => -1 };
    c = maybe_resolve_typed_path_marker(c, w, mod_path, imps, type_params, exprs, recv);
  }
  if match n { ast.ExprNode.StructLit(_tyex, _fields) => true, _ => false } {
    let tyex: i32 = match n { ast.ExprNode.StructLit(t, _fs) => t, _ => -1 };
    c = maybe_resolve_typed_path_marker(c, w, mod_path, imps, type_params, exprs, tyex);
  }

  let wr: TypeWalkResult = match n {
    ast.ExprNode.Int(_v) => type_walk_ok(c),
    ast.ExprNode.Float(_v) => type_walk_ok(c),
    ast.ExprNode.Bool(_v) => type_walk_ok(c),
    ast.ExprNode.Ident(_s) => type_walk_ok(c),
    ast.ExprNode.Str(_s) => type_walk_ok(c),
    ast.ExprNode.DotIdent(_s) => type_walk_ok(c),
    ast.ExprNode.Block(b) => walk_expr_block_type_names(c, w, mod_path, imps, type_params, exprs, b, owner_file),
    ast.ExprNode.If(c0, t0, e0) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, c0, owner_file);
      if !r0.ok { r0 } else {
        let r1: TypeWalkResult = walk_expr_type_names(r0.ctx, w, mod_path, imps, type_params, exprs, t0, owner_file);
        if !r1.ok { r1 } else { walk_expr_type_names(r1.ctx, w, mod_path, imps, type_params, exprs, e0, owner_file) }
      }
    },
    ast.ExprNode.Unary(_op, a) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, a, owner_file),
    ast.ExprNode.As(a, _tn) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, a, owner_file),
    ast.ExprNode.Binary(_op, l, r) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, l, owner_file);
      if !r0.ok { r0 } else { walk_expr_type_names(r0.ctx, w, mod_path, imps, type_params, exprs, r, owner_file) }
    },
    ast.ExprNode.Member(recv, _name) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, recv, owner_file),
    ast.ExprNode.Call(callee, _targs, args) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, callee, owner_file);
      if !r0.ok { r0 } else {
        let mut c1: Ctx = r0.ctx;
        let mut ai: i32 = 0;
        let mut ok1: bool = true;
        while ok1 && ai < args.len() {
          let ri: TypeWalkResult = walk_expr_type_names(c1, w, mod_path, imps, type_params, exprs, args.get(ai), owner_file);
          if !ri.ok { ok1 = false; c1 = ri.ctx; } else { c1 = ri.ctx; ai = ai + 1; }
        }
        if ok1 { type_walk_ok(c1) } else { type_walk_err(c1, type_error(owner_file, "type resolve failed in call arg expression")) }
      }
    },
    ast.ExprNode.StructLit(tyex, fields) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, tyex, owner_file);
      if !r0.ok { r0 } else {
        let mut c1: Ctx = r0.ctx;
        let mut fi: i32 = 0;
        let mut ok1: bool = true;
        while ok1 && fi < fields.len() {
          let rf: TypeWalkResult = walk_expr_type_names(c1, w, mod_path, imps, type_params, exprs, fields.get(fi).expr, owner_file);
          if !rf.ok { ok1 = false; c1 = rf.ctx; } else { c1 = rf.ctx; fi = fi + 1; }
        }
        if ok1 { type_walk_ok(c1) } else { type_walk_err(c1, type_error(owner_file, "type resolve failed in struct literal field expression")) }
      }
    },
    ast.ExprNode.Match(scrut, arms) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, scrut, owner_file);
      if !r0.ok { r0 } else {
        let mut c1: Ctx = r0.ctx;
        let mut ai: i32 = 0;
        let mut ok1: bool = true;
        while ok1 && ai < arms.len() {
          let ra: TypeWalkResult = walk_expr_type_names(c1, w, mod_path, imps, type_params, exprs, arms.get(ai).expr, owner_file);
          if !ra.ok { ok1 = false; c1 = ra.ctx; } else { c1 = ra.ctx; ai = ai + 1; }
        }
        if ok1 { type_walk_ok(c1) } else { type_walk_err(c1, type_error(owner_file, "type resolve failed in match arm expression")) }
      }
    },
  };
  return wr;
}

fn walk_stmt_type_names(ctx: Ctx, w: World, mod_path: String, imps: Imports, type_params: Vec[String], exprs: ast.ExprPool, st: ast.Stmt, owner_file: String) -> TypeWalkResult {
  let mut c: Ctx = ctx;
  return match st {
    ast.Stmt.Let(_sp, _mut, _name, has_ann, ann, init) => {
      if has_ann {
        let tr: ResolveTyResult = resolve_type(c, w, mod_path, imps, type_params, ann);
        c = tr.ctx;
        if !tr.ok { return type_walk_err(c, type_error(owner_file, "type resolve failed in let annotation")); }
      }
      walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, init, owner_file)
    },
    ast.Stmt.Assign(_sp, _name, ex) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, ex, owner_file),
    ast.Stmt.AssignField(_sp, _recv, _field, ex) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, ex, owner_file),
    ast.Stmt.Expr(_sp, ex) => walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, ex, owner_file),
    ast.Stmt.If(_sp, cond, then_b, has_else, else_b) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, cond, owner_file);
      if !r0.ok { r0 } else {
        let r1: TypeWalkResult = walk_block_type_names(r0.ctx, w, mod_path, imps, type_params, exprs, then_b, owner_file);
        if !r1.ok { r1 } else if has_else { walk_block_type_names(r1.ctx, w, mod_path, imps, type_params, exprs, else_b, owner_file) } else { r1 }
      }
    },
    ast.Stmt.While(_sp, cond, body) => {
      let r0: TypeWalkResult = walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, cond, owner_file);
      if !r0.ok { r0 } else { walk_block_type_names(r0.ctx, w, mod_path, imps, type_params, exprs, body, owner_file) }
    },
    ast.Stmt.Break(_sp) => type_walk_ok(c),
    ast.Stmt.Continue(_sp) => type_walk_ok(c),
    ast.Stmt.Return(_sp, has_ex, ex) => if has_ex { walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, ex, owner_file) } else { type_walk_ok(c) },
  };
}

fn walk_expr_block_type_names(ctx: Ctx, w: World, mod_path: String, imps: Imports, type_params: Vec[String], exprs: ast.ExprPool, b: ast.ExprBlock, owner_file: String) -> TypeWalkResult {
  let mut c: Ctx = ctx;
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let wr: TypeWalkResult = walk_stmt_type_names(c, w, mod_path, imps, type_params, exprs, b.stmts.get(i), owner_file);
    if !wr.ok { return wr; }
    c = wr.ctx;
    i = i + 1;
  }
  if b.has_tail {
    return walk_expr_type_names(c, w, mod_path, imps, type_params, exprs, b.tail, owner_file);
  }
  return type_walk_ok(c);
}

fn walk_block_type_names(ctx: Ctx, w: World, mod_path: String, imps: Imports, type_params: Vec[String], exprs: ast.ExprPool, b: ast.Block, owner_file: String) -> TypeWalkResult {
  let mut c: Ctx = ctx;
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let wr: TypeWalkResult = walk_stmt_type_names(c, w, mod_path, imps, type_params, exprs, b.stmts.get(i), owner_file);
    if !wr.ok { return wr; }
    c = wr.ctx;
    i = i + 1;
  }
  return type_walk_ok(c);
}

fn collect_body_type_names(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);

    // Non-generic function bodies.
    let mut fi: i32 = 0;
    while fi < m.prog.funcs.len() {
      let fd: ast.FuncDecl = m.prog.funcs.get(fi);
      if fd.type_params.len() == 0 {
        let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, fd.file);
        if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
        let wr: TypeWalkResult = walk_block_type_names(c, w, m.path, ir.imps, fd.type_params, m.prog.exprs, fd.body, fd.file);
        if !wr.ok { return TcCtxResult { ok: false, err: wr.err, ctx: wr.ctx }; }
        c = wr.ctx;
      }
      fi = fi + 1;
    }

    // Non-generic impl method bodies.
    let mut ii: i32 = 0;
    while ii < m.prog.impls.len() {
      let id: ast.ImplDecl = m.prog.impls.get(ii);
      if id.type_params.len() == 0 {
        let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, id.file);
        if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
        let mut mdi: i32 = 0;
        while mdi < id.methods.len() {
          let md: ast.FuncDecl = id.methods.get(mdi);
          if md.type_params.len() == 0 {
            let wr: TypeWalkResult = walk_block_type_names(c, w, m.path, ir.imps, md.type_params, m.prog.exprs, md.body, md.file);
            if !wr.ok { return TcCtxResult { ok: false, err: wr.err, ctx: wr.ctx }; }
            c = wr.ctx;
          }
          mdi = mdi + 1;
        }
      }
      ii = ii + 1;
    }

    mi = mi + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn has_bound_sig(bs: Vec[TypeParamBoundSig], tp: String, trait_mod: String, trait_name: String) -> bool {
  let mut i: i32 = 0;
  while i < bs.len() {
    let b: TypeParamBoundSig = bs.get(i);
    if b.type_param == tp && b.trait_mod_path == trait_mod && b.trait_name == trait_name { return true; }
    i = i + 1;
  }
  return false;
}

fn collect_funcs(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;

  // Builtins (stage1): keep minimal and stable.
  // Higher-level helpers should live in stdlib Vox sources.
  c.funcs.push(FuncSym { mod_path: "", name: "panic", sig: FuncSig { params: vec1(c.ty_string), ret: c.ty_unit, is_pub: true, type_params: Vec(), type_param_bounds: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "print", sig: FuncSig { params: vec1(c.ty_string), ret: c.ty_unit, is_pub: true, type_params: Vec(), type_param_bounds: Vec() } });
  // Tooling/stdlib support builtins (stage1): used by std/fs and std/process.
  // Keep these low-level and prefer std wrappers.
  let v1: ResolveTyResult = intern_vec(c, c.ty_string);
  c = v1.ctx;
  let vec_string: i32 = v1.idx;
  c.funcs.push(FuncSym { mod_path: "", name: "__args", sig: FuncSig { params: Vec(), ret: vec_string, is_pub: true, type_params: Vec(), type_param_bounds: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__exe_path", sig: FuncSig { params: Vec(), ret: c.ty_string, is_pub: true, type_params: Vec(), type_param_bounds: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__read_file", sig: FuncSig { params: vec1(c.ty_string), ret: c.ty_string, is_pub: true, type_params: Vec(), type_param_bounds: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__write_file", sig: FuncSig { params: vec2(c.ty_string, c.ty_string), ret: c.ty_unit, is_pub: true, type_params: Vec(), type_param_bounds: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__exec", sig: FuncSig { params: vec1(c.ty_string), ret: c.ty_i32, is_pub: true, type_params: Vec(), type_param_bounds: Vec() } });
  c.funcs.push(FuncSym { mod_path: "", name: "__walk_vox_files", sig: FuncSig { params: vec1(c.ty_string), ret: vec_string, is_pub: true, type_params: Vec(), type_param_bounds: Vec() } });

  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut fi: i32 = 0;
    while fi < m.prog.funcs.len() {
      let fd: ast.FuncDecl = m.prog.funcs.get(fi);
      if is_reserved_intrinsic_name(fd.name) {
        return TcCtxResult { ok: false, err: type_error(fd.file, "reserved name: ".concat(fd.name)), ctx: c };
      }
      let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, fd.file);
      if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
      let imps: Imports = ir.imps;
      // Resolve signature types (skip bodies for generic fns; still collect signature).
      let mut ps: Vec[i32] = Vec();
      let mut pi: i32 = 0;
      while pi < fd.params.len() {
        let pr: ast.Param = fd.params.get(pi);
        let tr: ResolveTyResult = resolve_type(c, w, m.path, imps, fd.type_params, pr.ty);
        c = tr.ctx;
        if !tr.ok {
          return TcCtxResult { ok: false, err: type_error(fd.file, "type resolve failed in fn param"), ctx: c };
        }
        ps.push(tr.idx);
        pi = pi + 1;
      }
      let rr: ResolveTyResult = resolve_type(c, w, m.path, imps, fd.type_params, fd.ret);
      c = rr.ctx;
      if !rr.ok {
        return TcCtxResult { ok: false, err: type_error(fd.file, "type resolve failed in fn ret"), ctx: c };
      }

      let mut tbs: Vec[TypeParamBoundSig] = Vec();
      let mut bi: i32 = 0;
      while bi < fd.type_param_bounds.len() {
        let bdecl: ast.TypeParamBoundsDecl = fd.type_param_bounds.get(bi);
        if !contains_str_local(fd.type_params, bdecl.name) {
          return TcCtxResult { ok: false, err: type_error(fd.file, "unknown type param in bound: ".concat(bdecl.name)), ctx: c };
        }
        let mut bj: i32 = 0;
        while bj < bdecl.bounds.len() {
          let rtr: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, bdecl.bounds.get(bj));
          if !rtr.ok {
            return TcCtxResult { ok: false, err: type_error(fd.file, "bad trait bound"), ctx: c };
          }
          let tf: FindTraitResult = find_trait(c, rtr.mod_path, rtr.name);
          if !tf.found {
            return TcCtxResult { ok: false, err: type_error(fd.file, "unknown trait in bound"), ctx: c };
          }
          if rtr.mod_path != m.path && !tf.sig.is_pub {
            return TcCtxResult { ok: false, err: type_error(fd.file, "trait bound refers to private trait"), ctx: c };
          }
          if !has_bound_sig(tbs, bdecl.name, rtr.mod_path, rtr.name) {
            tbs.push(TypeParamBoundSig { type_param: bdecl.name, trait_mod_path: rtr.mod_path, trait_name: rtr.name });
          }
          bj = bj + 1;
        }
        bi = bi + 1;
      }

      let mut pj: i32 = 0;
      while pj < fd.params.len() {
        let pr0: ast.Param = fd.params.get(pj);
        let perr0: String = projection_bound_issue(c, fd.type_params, tbs, pr0.ty);
        if perr0 != "" { return TcCtxResult { ok: false, err: type_error(fd.file, perr0), ctx: c }; }
        pj = pj + 1;
      }
      let perr1: String = projection_bound_issue(c, fd.type_params, tbs, fd.ret);
      if perr1 != "" { return TcCtxResult { ok: false, err: type_error(fd.file, perr1), ctx: c }; }

      let sig: FuncSig = FuncSig { params: ps, ret: rr.idx, is_pub: fd.is_pub, type_params: fd.type_params, type_param_bounds: tbs };
      c.funcs.push(FuncSym { mod_path: m.path, name: fd.name, sig: sig });
      fi = fi + 1;
    }
    mi = mi + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn vec1(x: i32) -> Vec[i32] { let mut v: Vec[i32] = Vec(); v.push(x); return v; }
fn vec2(a: i32, b: i32) -> Vec[i32] { let mut v: Vec[i32] = Vec(); v.push(a); v.push(b); return v; }
