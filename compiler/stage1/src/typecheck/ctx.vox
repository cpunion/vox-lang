import "ast" as ast
import "ir" as ir

pub struct Ctx {
  pub pool: ir.TyPool,
  pub ty_bad: i32,
  pub ty_unit: i32,
  pub ty_bool: i32,
  pub ty_i8: i32,
  pub ty_u8: i32,
  pub ty_i16: i32,
  pub ty_u16: i32,
  pub ty_i32: i32,
  pub ty_u32: i32,
  pub ty_i64: i32,
  pub ty_u64: i32,
  pub ty_isize: i32,
  pub ty_usize: i32,
  pub ty_string: i32,

  pub funcs: Vec[FuncSym],
  pub structs: Vec[StructSig],
  pub enums: Vec[EnumSig],
  pub type_aliases: Vec[TypeAliasSig],
  pub consts: Vec[ConstSig],
}

pub struct TypeAliasSig {
  pub mod_path: String,
  pub name: String,
  pub is_pub: bool,
  pub ty: i32,
}

// Const values are restricted to primitives in v0.
pub struct ConstSig {
  pub mod_path: String,
  pub name: String,
  pub is_pub: bool,
  pub ty: i32,
  pub kind: i32, // 1=int, 2=bool, 3=str
  // Int values are stored as i64 in stage1 v0. Unsigned ints are represented
  // as non-negative values (v0 limitation: literals/casts don't produce > i64::MAX).
  pub iv: i64,
  pub bv: bool,
  pub sv: String,
}

struct InternResult { ctx: Ctx, idx: i32 }

fn ty_eq(a: ir.Ty, b: ir.Ty) -> bool {
  return match a.kind {
    ir.TyKind.Bad => match b.kind { ir.TyKind.Bad => true, _ => false },
    ir.TyKind.Unit => match b.kind { ir.TyKind.Unit => true, _ => false },
    ir.TyKind.Bool => match b.kind { ir.TyKind.Bool => true, _ => false },
    ir.TyKind.I8 => match b.kind { ir.TyKind.I8 => true, _ => false },
    ir.TyKind.U8 => match b.kind { ir.TyKind.U8 => true, _ => false },
    ir.TyKind.I16 => match b.kind { ir.TyKind.I16 => true, _ => false },
    ir.TyKind.U16 => match b.kind { ir.TyKind.U16 => true, _ => false },
    ir.TyKind.I32 => match b.kind { ir.TyKind.I32 => true, _ => false },
    ir.TyKind.U32 => match b.kind { ir.TyKind.U32 => true, _ => false },
    ir.TyKind.I64 => match b.kind { ir.TyKind.I64 => true, _ => false },
    ir.TyKind.U64 => match b.kind { ir.TyKind.U64 => true, _ => false },
    ir.TyKind.ISize => match b.kind { ir.TyKind.ISize => true, _ => false },
    ir.TyKind.USize => match b.kind { ir.TyKind.USize => true, _ => false },
    ir.TyKind.String => match b.kind { ir.TyKind.String => true, _ => false },
    ir.TyKind.Param => match b.kind { ir.TyKind.Param => a.name == b.name, _ => false },
    ir.TyKind.Struct => match b.kind { ir.TyKind.Struct => a.mod_path == b.mod_path && a.name == b.name, _ => false },
    ir.TyKind.Enum => match b.kind { ir.TyKind.Enum => a.mod_path == b.mod_path && a.name == b.name, _ => false },
    ir.TyKind.Vec => match b.kind { ir.TyKind.Vec => a.elem == b.elem, _ => false },
    ir.TyKind.Range => match b.kind { ir.TyKind.Range => a.elem == b.elem && a.lo == b.lo && a.hi == b.hi, _ => false },
  };
}

fn intern_ty(ctx: Ctx, t: ir.Ty) -> InternResult {
  let mut q: Ctx = ctx;
  let mut pool: ir.TyPool = q.pool;
  let tys: Vec[ir.Ty] = pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    if ty_eq(tys.get(i), t) {
      return InternResult { ctx: q, idx: i };
    }
    i = i + 1;
  }
  let r: ir.AddTyResult = ir.ty_pool_add(pool, t);
  q.pool = r.pool;
  return InternResult { ctx: q, idx: r.idx };
}

pub fn new_ctx() -> Ctx {
  let mut c: Ctx = Ctx {
    pool: ir.ty_pool(),
    ty_bad: -1, ty_unit: -1, ty_bool: -1,
    ty_i8: -1, ty_u8: -1, ty_i16: -1, ty_u16: -1, ty_i32: -1, ty_u32: -1, ty_i64: -1, ty_u64: -1, ty_isize: -1, ty_usize: -1,
    ty_string: -1,
    funcs: Vec(), structs: Vec(), enums: Vec(), type_aliases: Vec(), consts: Vec(),
  };
  let r0: InternResult = intern_ty(c, ir.ty_bad()); c = r0.ctx; c.ty_bad = r0.idx;
  let r1: InternResult = intern_ty(c, ir.ty_unit()); c = r1.ctx; c.ty_unit = r1.idx;
  let r2: InternResult = intern_ty(c, ir.ty_bool()); c = r2.ctx; c.ty_bool = r2.idx;
  let r3: InternResult = intern_ty(c, ir.ty_i8()); c = r3.ctx; c.ty_i8 = r3.idx;
  let r4: InternResult = intern_ty(c, ir.ty_u8()); c = r4.ctx; c.ty_u8 = r4.idx;
  let r4b: InternResult = intern_ty(c, ir.ty_i16()); c = r4b.ctx; c.ty_i16 = r4b.idx;
  let r4c: InternResult = intern_ty(c, ir.ty_u16()); c = r4c.ctx; c.ty_u16 = r4c.idx;
  let r5: InternResult = intern_ty(c, ir.ty_i32()); c = r5.ctx; c.ty_i32 = r5.idx;
  let r6: InternResult = intern_ty(c, ir.ty_u32()); c = r6.ctx; c.ty_u32 = r6.idx;
  let r7: InternResult = intern_ty(c, ir.ty_i64()); c = r7.ctx; c.ty_i64 = r7.idx;
  let r8: InternResult = intern_ty(c, ir.ty_u64()); c = r8.ctx; c.ty_u64 = r8.idx;
  let r8b: InternResult = intern_ty(c, ir.ty_isize()); c = r8b.ctx; c.ty_isize = r8b.idx;
  let r9: InternResult = intern_ty(c, ir.ty_usize()); c = r9.ctx; c.ty_usize = r9.idx;
  let r10: InternResult = intern_ty(c, ir.ty_string()); c = r10.ctx; c.ty_string = r10.idx;

  // Ensure common `Vec[T]` instantiations exist even when not explicitly mentioned
  // in type annotations, so generic inference can return `Vec[i32]` etc.
  let rv0: InternResult = intern_ty(c, ir.ty_vec(c.ty_unit)); c = rv0.ctx;
  let rv1: InternResult = intern_ty(c, ir.ty_vec(c.ty_bool)); c = rv1.ctx;
  let _rv_i8: InternResult = intern_ty(c, ir.ty_vec(c.ty_i8)); c = _rv_i8.ctx;
  let _rv_u8: InternResult = intern_ty(c, ir.ty_vec(c.ty_u8)); c = _rv_u8.ctx;
  let _rv_i16: InternResult = intern_ty(c, ir.ty_vec(c.ty_i16)); c = _rv_i16.ctx;
  let _rv_u16: InternResult = intern_ty(c, ir.ty_vec(c.ty_u16)); c = _rv_u16.ctx;
  let rv2: InternResult = intern_ty(c, ir.ty_vec(c.ty_i32)); c = rv2.ctx;
  let rv3: InternResult = intern_ty(c, ir.ty_vec(c.ty_i64)); c = rv3.ctx;
  let _rv_u32: InternResult = intern_ty(c, ir.ty_vec(c.ty_u32)); c = _rv_u32.ctx;
  let _rv_u64: InternResult = intern_ty(c, ir.ty_vec(c.ty_u64)); c = _rv_u64.ctx;
  let _rv_isize: InternResult = intern_ty(c, ir.ty_vec(c.ty_isize)); c = _rv_isize.ctx;
  let _rv_usize: InternResult = intern_ty(c, ir.ty_vec(c.ty_usize)); c = _rv_usize.ctx;
  let rv4: InternResult = intern_ty(c, ir.ty_vec(c.ty_string)); c = rv4.ctx;

  return c;
}

fn typename_is0(tn: ast.TypeName, s: String) -> bool {
  return tn.parts.len() == 1 && tn.parts.get(0) == s && tn.args.len() == 0;
}

pub struct ResolveTyResult { pub ctx: Ctx, pub ok: bool, pub idx: i32 }

fn find_type_alias(type_aliases: Vec[TypeAliasSig], mod_path: String, name: String) -> TypeAliasSig {
  let mut i: i32 = 0;
  while i < type_aliases.len() {
    let a: TypeAliasSig = type_aliases.get(i);
    if a.mod_path == mod_path && a.name == name { return a; }
    i = i + 1;
  }
  return TypeAliasSig { mod_path: "", name: "", is_pub: false, ty: -1 };
}

pub fn intern_vec(ctx: Ctx, elem: i32) -> ResolveTyResult {
  let mut c: Ctx = ctx;
  let r: InternResult = intern_ty(c, ir.ty_vec(elem));
  c = r.ctx;
  return ResolveTyResult { ctx: c, ok: true, idx: r.idx };
}

pub fn resolve_type(ctx: Ctx, w: World, cur_mod: String, imps: Imports, type_params: Vec[String], tn: ast.TypeName) -> ResolveTyResult {
  let mut c: Ctx = ctx;
  // type param (generic function): `T`
  if tn.parts.len() == 1 && tn.args.len() == 0 {
    let name0: String = tn.parts.get(0);
    let mut i0: i32 = 0;
    while i0 < type_params.len() {
      if type_params.get(i0) == name0 {
        let ir0: InternResult = intern_ty(c, ir.ty_param(name0));
        c = ir0.ctx;
        return ResolveTyResult { ctx: c, ok: true, idx: ir0.idx };
      }
      i0 = i0 + 1;
    }
  }
  // primitives / unit
  if typename_is0(tn, "()") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_unit }; }
  if typename_is0(tn, "bool") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_bool }; }
  if typename_is0(tn, "i8") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_i8 }; }
  if typename_is0(tn, "u8") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_u8 }; }
  if typename_is0(tn, "i16") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_i16 }; }
  if typename_is0(tn, "u16") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_u16 }; }
  if typename_is0(tn, "i32") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_i32 }; }
  if typename_is0(tn, "u32") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_u32 }; }
  if typename_is0(tn, "i64") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_i64 }; }
  if typename_is0(tn, "u64") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_u64 }; }
  if typename_is0(tn, "isize") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_isize }; }
  if typename_is0(tn, "usize") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_usize }; }
  if typename_is0(tn, "String") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_string }; }

  // @range(lo..=hi) Base
  if tn.parts.len() == 3 && tn.parts.get(0) == "@range" && tn.args.len() == 1 {
    let pr_lo: ParseI64DecResult = parse_i64_dec(tn.parts.get(1));
    if !pr_lo.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    let pr_hi: ParseI64DecResult = parse_i64_dec(tn.parts.get(2));
    if !pr_hi.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    let lo: i64 = pr_lo.val;
    let hi: i64 = pr_hi.val;
    if lo > hi { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    let br: ResolveTyResult = resolve_type(c, w, cur_mod, imps, type_params, tn.args.get(0));
    c = br.ctx;
    if !br.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    let bt: ir.Ty = ir.ty_pool_get(c.pool, br.idx);
    let is_int: bool = match bt.kind {
      ir.TyKind.I8 => true,
      ir.TyKind.U8 => true,
      ir.TyKind.I16 => true,
      ir.TyKind.U16 => true,
      ir.TyKind.I32 => true,
      ir.TyKind.U32 => true,
      ir.TyKind.I64 => true,
      ir.TyKind.U64 => true,
      ir.TyKind.ISize => true,
      ir.TyKind.USize => true,
      _ => false,
    };
    if !is_int { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    // Bounds must fit the base type. (v0 simplification: u64/usize bounds are limited to i64 range.)
    if bt.kind == ir.TyKind.I8 && (lo < -128 || hi > 127) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if bt.kind == ir.TyKind.U8 && (lo < 0 || hi > 255) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if bt.kind == ir.TyKind.I16 && (lo < -32768 || hi > 32767) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if bt.kind == ir.TyKind.U16 && (lo < 0 || hi > 65535) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if bt.kind == ir.TyKind.I32 && (lo < -2147483648 || hi > 2147483647) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if bt.kind == ir.TyKind.U32 && (lo < 0 || hi > 4294967295) { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    if (bt.kind == ir.TyKind.U64 || bt.kind == ir.TyKind.USize) && lo < 0 { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }

    let ir0: InternResult = intern_ty(c, ir.ty_range(br.idx, lo, hi));
    c = ir0.ctx;
    return ResolveTyResult { ctx: c, ok: true, idx: ir0.idx };
  }

  // Vec[T]
  if tn.parts.len() == 1 && tn.parts.get(0) == "Vec" && tn.args.len() == 1 {
    let r0: ResolveTyResult = resolve_type(c, w, cur_mod, imps, type_params, tn.args.get(0));
    c = r0.ctx;
    if !r0.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    let ir0: InternResult = intern_ty(c, ir.ty_vec(r0.idx));
    c = ir0.ctx;
    // Also pre-intern one more level: `Vec[Vec[T]]`.
    let _ir1: InternResult = intern_ty(c, ir.ty_vec(ir0.idx));
    c = _ir1.ctx;
    return ResolveTyResult { ctx: c, ok: true, idx: ir0.idx };
  }

  // nominal types: local or imported module alias
  let mut mod_path: String = cur_mod;
  let mut name: String = "";
  if tn.parts.len() == 1 {
    name = tn.parts.get(0);
    let ni: NamedTypeImport = find_named_type(imps.named_types, name);
    if ni.local != "" {
      mod_path = ni.mod_path;
      name = ni.name;
    }
  } else if tn.parts.len() == 2 {
    let mp: String = find_alias(imps.aliases, tn.parts.get(0));
    if mp == "" {
      return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
    }
    mod_path = mp;
    name = tn.parts.get(1);
  } else {
    return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
  }
  if tn.args.len() != 0 {
    // stage1 typecheck v0: no generic nominal types yet
    return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
  }

  // Type aliases (type-only).
  let ta: TypeAliasSig = find_type_alias(c.type_aliases, mod_path, name);
  if ta.name != "" {
    if mod_path != cur_mod && !ta.is_pub { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    return ResolveTyResult { ctx: c, ok: true, idx: ta.ty };
  }

  // Search struct then enum decl in the target module.
  let fm: FindModResult = find_mod(w, mod_path);
  if !fm.found {
    return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
  }
  let m: WorldModule = w.mods.get(fm.idx);
  // struct
  let mut i: i32 = 0;
    while i < m.prog.structs.len() {
      let sd: ast.StructDecl = m.prog.structs.get(i);
      if sd.name == name {
        if mod_path != cur_mod && !sd.is_pub { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
        let ir1: InternResult = intern_ty(c, ir.ty_struct(mod_path, name));
        c = ir1.ctx;
        // Pre-intern `Vec[Struct]` and `Vec[Vec[Struct]]` so generics can build collections.
        let iv0: InternResult = intern_ty(c, ir.ty_vec(ir1.idx)); c = iv0.ctx;
        let iv1: InternResult = intern_ty(c, ir.ty_vec(iv0.idx)); c = iv1.ctx;
        return ResolveTyResult { ctx: c, ok: true, idx: ir1.idx };
      }
      i = i + 1;
    }
  // enum
  i = 0;
    while i < m.prog.enums.len() {
      let ed: ast.EnumDecl = m.prog.enums.get(i);
      if ed.name == name {
        if mod_path != cur_mod && !ed.is_pub { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
        let ir2: InternResult = intern_ty(c, ir.ty_enum(mod_path, name));
        c = ir2.ctx;
        // Pre-intern `Vec[Enum]` and `Vec[Vec[Enum]]`.
        let iv0: InternResult = intern_ty(c, ir.ty_vec(ir2.idx)); c = iv0.ctx;
        let iv1: InternResult = intern_ty(c, ir.ty_vec(iv0.idx)); c = iv1.ctx;
        return ResolveTyResult { ctx: c, ok: true, idx: ir2.idx };
      }
      i = i + 1;
    }
  return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
}

pub fn is_vec_ty(ctx: Ctx, ty_idx: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  return match t.kind { ir.TyKind.Vec => true, _ => false };
}

pub fn vec_elem(ctx: Ctx, ty_idx: i32) -> i32 {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  return t.elem;
}

pub fn is_struct_ty(ctx: Ctx, ty_idx: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  return match t.kind { ir.TyKind.Struct => true, _ => false };
}

pub fn is_enum_ty(ctx: Ctx, ty_idx: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  return match t.kind { ir.TyKind.Enum => true, _ => false };
}

pub fn ty_name(t: ir.Ty) -> String { return t.name; }
pub fn ty_mod(t: ir.Ty) -> String { return t.mod_path; }

pub fn const_kind_int() -> i32 { return 1; }
pub fn const_kind_bool() -> i32 { return 2; }
pub fn const_kind_str() -> i32 { return 3; }

pub fn find_const(ctx: Ctx, mod_path: String, name: String) -> ConstSig {
  let mut i: i32 = 0;
  while i < ctx.consts.len() {
    let c: ConstSig = ctx.consts.get(i);
    if c.mod_path == mod_path && c.name == name { return c; }
    i = i + 1;
  }
  return ConstSig { mod_path: "", name: "", is_pub: false, ty: -1, kind: 0, iv: 0, bv: false, sv: "" };
}
