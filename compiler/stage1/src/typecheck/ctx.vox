import "ast" as ast
import "ir" as ir

pub struct Ctx {
  pub pool: ir.TyPool,
  pub ty_bad: i32,
  pub ty_unit: i32,
  pub ty_bool: i32,
  pub ty_i32: i32,
  pub ty_i64: i32,
  pub ty_string: i32,

  pub funcs: Vec[FuncSym],
  pub structs: Vec[StructSig],
  pub enums: Vec[EnumSig],
  pub type_aliases: Vec[TypeAliasSig],
}

pub struct TypeAliasSig {
  pub mod_path: String,
  pub name: String,
  pub is_pub: bool,
  pub ty: i32,
}

struct InternResult { ctx: Ctx, idx: i32 }

fn ty_eq(a: ir.Ty, b: ir.Ty) -> bool {
  return match a.kind {
    ir.TyKind.Bad => match b.kind { ir.TyKind.Bad => true, _ => false },
    ir.TyKind.Unit => match b.kind { ir.TyKind.Unit => true, _ => false },
    ir.TyKind.Bool => match b.kind { ir.TyKind.Bool => true, _ => false },
    ir.TyKind.I32 => match b.kind { ir.TyKind.I32 => true, _ => false },
    ir.TyKind.I64 => match b.kind { ir.TyKind.I64 => true, _ => false },
    ir.TyKind.String => match b.kind { ir.TyKind.String => true, _ => false },
    ir.TyKind.Param => match b.kind { ir.TyKind.Param => a.name == b.name, _ => false },
    ir.TyKind.Struct => match b.kind { ir.TyKind.Struct => a.mod_path == b.mod_path && a.name == b.name, _ => false },
    ir.TyKind.Enum => match b.kind { ir.TyKind.Enum => a.mod_path == b.mod_path && a.name == b.name, _ => false },
    ir.TyKind.Vec => match b.kind { ir.TyKind.Vec => a.elem == b.elem, _ => false },
    _ => false,
  };
}

fn intern_ty(ctx: Ctx, t: ir.Ty) -> InternResult {
  let mut q: Ctx = ctx;
  let mut pool: ir.TyPool = q.pool;
  let tys: Vec[ir.Ty] = pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    if ty_eq(tys.get(i), t) {
      return InternResult { ctx: q, idx: i };
    }
    i = i + 1;
  }
  let r: ir.AddTyResult = ir.ty_pool_add(pool, t);
  q.pool = r.pool;
  return InternResult { ctx: q, idx: r.idx };
}

pub fn new_ctx() -> Ctx {
  let mut c: Ctx = Ctx {
    pool: ir.ty_pool(),
    ty_bad: -1, ty_unit: -1, ty_bool: -1, ty_i32: -1, ty_i64: -1, ty_string: -1,
    funcs: Vec(), structs: Vec(), enums: Vec(), type_aliases: Vec(),
  };
  let r0: InternResult = intern_ty(c, ir.ty_bad()); c = r0.ctx; c.ty_bad = r0.idx;
  let r1: InternResult = intern_ty(c, ir.ty_unit()); c = r1.ctx; c.ty_unit = r1.idx;
  let r2: InternResult = intern_ty(c, ir.ty_bool()); c = r2.ctx; c.ty_bool = r2.idx;
  let r3: InternResult = intern_ty(c, ir.ty_i32()); c = r3.ctx; c.ty_i32 = r3.idx;
  let r4: InternResult = intern_ty(c, ir.ty_i64()); c = r4.ctx; c.ty_i64 = r4.idx;
  let r5: InternResult = intern_ty(c, ir.ty_string()); c = r5.ctx; c.ty_string = r5.idx;

  // Ensure common `Vec[T]` instantiations exist even when not explicitly mentioned
  // in type annotations, so generic inference can return `Vec[i32]` etc.
  let rv0: InternResult = intern_ty(c, ir.ty_vec(c.ty_unit)); c = rv0.ctx;
  let rv1: InternResult = intern_ty(c, ir.ty_vec(c.ty_bool)); c = rv1.ctx;
  let rv2: InternResult = intern_ty(c, ir.ty_vec(c.ty_i32)); c = rv2.ctx;
  let rv3: InternResult = intern_ty(c, ir.ty_vec(c.ty_i64)); c = rv3.ctx;
  let rv4: InternResult = intern_ty(c, ir.ty_vec(c.ty_string)); c = rv4.ctx;

  return c;
}

fn typename_is0(tn: ast.TypeName, s: String) -> bool {
  return tn.parts.len() == 1 && tn.parts.get(0) == s && tn.args.len() == 0;
}

pub struct ResolveTyResult { pub ctx: Ctx, pub ok: bool, pub idx: i32 }

fn find_type_alias(type_aliases: Vec[TypeAliasSig], mod_path: String, name: String) -> TypeAliasSig {
  let mut i: i32 = 0;
  while i < type_aliases.len() {
    let a: TypeAliasSig = type_aliases.get(i);
    if a.mod_path == mod_path && a.name == name { return a; }
    i = i + 1;
  }
  return TypeAliasSig { mod_path: "", name: "", is_pub: false, ty: -1 };
}

pub fn intern_vec(ctx: Ctx, elem: i32) -> ResolveTyResult {
  let mut c: Ctx = ctx;
  let r: InternResult = intern_ty(c, ir.ty_vec(elem));
  c = r.ctx;
  return ResolveTyResult { ctx: c, ok: true, idx: r.idx };
}

pub fn resolve_type(ctx: Ctx, w: World, cur_mod: String, imps: Imports, type_params: Vec[String], tn: ast.TypeName) -> ResolveTyResult {
  let mut c: Ctx = ctx;
  // type param (generic function): `T`
  if tn.parts.len() == 1 && tn.args.len() == 0 {
    let name0: String = tn.parts.get(0);
    let mut i0: i32 = 0;
    while i0 < type_params.len() {
      if type_params.get(i0) == name0 {
        let ir0: InternResult = intern_ty(c, ir.ty_param(name0));
        c = ir0.ctx;
        return ResolveTyResult { ctx: c, ok: true, idx: ir0.idx };
      }
      i0 = i0 + 1;
    }
  }
  // primitives / unit
  if typename_is0(tn, "()") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_unit }; }
  if typename_is0(tn, "bool") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_bool }; }
  if typename_is0(tn, "i32") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_i32 }; }
  if typename_is0(tn, "i64") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_i64 }; }
  if typename_is0(tn, "String") { return ResolveTyResult { ctx: c, ok: true, idx: c.ty_string }; }

  // Vec[T]
  if tn.parts.len() == 1 && tn.parts.get(0) == "Vec" && tn.args.len() == 1 {
    let r0: ResolveTyResult = resolve_type(c, w, cur_mod, imps, type_params, tn.args.get(0));
    c = r0.ctx;
    if !r0.ok { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    let ir0: InternResult = intern_ty(c, ir.ty_vec(r0.idx));
    c = ir0.ctx;
    // Also pre-intern one more level: `Vec[Vec[T]]`.
    let _ir1: InternResult = intern_ty(c, ir.ty_vec(ir0.idx));
    c = _ir1.ctx;
    return ResolveTyResult { ctx: c, ok: true, idx: ir0.idx };
  }

  // nominal types: local or imported module alias
  let mut mod_path: String = cur_mod;
  let mut name: String = "";
  if tn.parts.len() == 1 {
    name = tn.parts.get(0);
    let ni: NamedTypeImport = find_named_type(imps.named_types, name);
    if ni.local != "" {
      mod_path = ni.mod_path;
      name = ni.name;
    }
  } else if tn.parts.len() == 2 {
    let mp: String = find_alias(imps.aliases, tn.parts.get(0));
    if mp == "" {
      return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
    }
    mod_path = mp;
    name = tn.parts.get(1);
  } else {
    return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
  }
  if tn.args.len() != 0 {
    // stage1 typecheck v0: no generic nominal types yet
    return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
  }

  // Type aliases (type-only).
  let ta: TypeAliasSig = find_type_alias(c.type_aliases, mod_path, name);
  if ta.name != "" {
    if mod_path != cur_mod && !ta.is_pub { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
    return ResolveTyResult { ctx: c, ok: true, idx: ta.ty };
  }

  // Search struct then enum decl in the target module.
  let fm: FindModResult = find_mod(w, mod_path);
  if !fm.found {
    return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
  }
  let m: WorldModule = w.mods.get(fm.idx);
  // struct
  let mut i: i32 = 0;
    while i < m.prog.structs.len() {
      let sd: ast.StructDecl = m.prog.structs.get(i);
      if sd.name == name {
        if mod_path != cur_mod && !sd.is_pub { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
        let ir1: InternResult = intern_ty(c, ir.ty_struct(mod_path, name));
        c = ir1.ctx;
        // Pre-intern `Vec[Struct]` and `Vec[Vec[Struct]]` so generics can build collections.
        let iv0: InternResult = intern_ty(c, ir.ty_vec(ir1.idx)); c = iv0.ctx;
        let iv1: InternResult = intern_ty(c, ir.ty_vec(iv0.idx)); c = iv1.ctx;
        return ResolveTyResult { ctx: c, ok: true, idx: ir1.idx };
      }
      i = i + 1;
    }
  // enum
  i = 0;
    while i < m.prog.enums.len() {
      let ed: ast.EnumDecl = m.prog.enums.get(i);
      if ed.name == name {
        if mod_path != cur_mod && !ed.is_pub { return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad }; }
        let ir2: InternResult = intern_ty(c, ir.ty_enum(mod_path, name));
        c = ir2.ctx;
        // Pre-intern `Vec[Enum]` and `Vec[Vec[Enum]]`.
        let iv0: InternResult = intern_ty(c, ir.ty_vec(ir2.idx)); c = iv0.ctx;
        let iv1: InternResult = intern_ty(c, ir.ty_vec(iv0.idx)); c = iv1.ctx;
        return ResolveTyResult { ctx: c, ok: true, idx: ir2.idx };
      }
      i = i + 1;
    }
  return ResolveTyResult { ctx: c, ok: false, idx: c.ty_bad };
}

pub fn is_vec_ty(ctx: Ctx, ty_idx: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  return match t.kind { ir.TyKind.Vec => true, _ => false };
}

pub fn vec_elem(ctx: Ctx, ty_idx: i32) -> i32 {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  return t.elem;
}

pub fn is_struct_ty(ctx: Ctx, ty_idx: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  return match t.kind { ir.TyKind.Struct => true, _ => false };
}

pub fn is_enum_ty(ctx: Ctx, ty_idx: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  return match t.kind { ir.TyKind.Enum => true, _ => false };
}

pub fn ty_name(t: ir.Ty) -> String { return t.name; }
pub fn ty_mod(t: ir.Ty) -> String { return t.mod_path; }
