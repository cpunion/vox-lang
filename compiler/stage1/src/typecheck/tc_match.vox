import "ast" as ast
import "ir" as ir

fn tc_expr_match(ctx: Ctx, w: World, mod_path: String, aliases: Vec[ImportAlias], exprs: ast.ExprPool, l0: Locals, scrut: i32, arms: Vec[ast.MatchArm], expected: i32) -> ExprTyResult {
  let sr: ExprTyResult = tc_expr(ctx, w, mod_path, aliases, exprs, l0, scrut, -1);
  if !sr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }

  // v0: match on enums/ints/strings only (enough for stage1 tests).
  let scrut_t: ir.Ty = ir.ty_pool_get(ctx.pool, sr.ty);
  let is_enum: bool = match scrut_t.kind { ir.TyKind.Enum => true, _ => false };
  let is_i32: bool = sr.ty == ctx.ty_i32;
  let is_str: bool = sr.ty == ctx.ty_string;
  if !is_enum && !is_i32 && !is_str { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }

  if arms.len() == 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }

  let mut out_ty: i32 = expected;
  let mut ai: i32 = 0;
  while ai < arms.len() {
    let arm: ast.MatchArm = arms.get(ai);
    let lr: Locals = locals_enter(l0);
    let pr: PatLocalsResult = tc_pat(ctx, mod_path, aliases, sr.ty, scrut_t, arm.pat, lr);
    if !pr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }

    let want: i32 = out_ty;
    let er: ExprTyResult = tc_expr(ctx, w, mod_path, aliases, exprs, pr.locals, arm.expr, want);
    if !er.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }

    if out_ty == -1 {
      out_ty = er.ty;
    } else {
      if er.ty != out_ty { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
    }

    ai = ai + 1;
  }

  if out_ty == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
  if expected != -1 && expected != out_ty { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
  return ExprTyResult { ok: true, ty: out_ty };
}

struct PatLocalsResult { ok: bool, locals: Locals }

fn tc_pat(ctx: Ctx, mod_path: String, aliases: Vec[ImportAlias], scrut_ty: i32, scrut_t: ir.Ty, pat: ast.Pat, l0: Locals) -> PatLocalsResult {
  return match pat {
    ast.Pat.Wild => PatLocalsResult { ok: true, locals: l0 },
    ast.Pat.Bind(name) => PatLocalsResult { ok: true, locals: locals_decl(l0, name, scrut_ty, false) },
    ast.Pat.Int(_) => if scrut_ty == ctx.ty_i32 { PatLocalsResult { ok: true, locals: l0 } } else { PatLocalsResult { ok: false, locals: l0 } },
    ast.Pat.Str(_) => if scrut_ty == ctx.ty_string { PatLocalsResult { ok: true, locals: l0 } } else { PatLocalsResult { ok: false, locals: l0 } },
    ast.Pat.EnumVariant(enum_parts, var_name, binders) => tc_pat_enum(ctx, mod_path, aliases, scrut_t, enum_parts, var_name, binders, l0),
  };
}

fn tc_pat_enum(ctx: Ctx, mod_path: String, aliases: Vec[ImportAlias], scrut_t: ir.Ty, enum_parts: Vec[String], var_name: String, binders: Vec[String], l0: Locals) -> PatLocalsResult {
  let is_enum: bool = match scrut_t.kind { ir.TyKind.Enum => true, _ => false };
  if !is_enum { return PatLocalsResult { ok: false, locals: l0 }; }

  // Shorthand: `.Variant(...)` uses the scrutinee enum type.
  if enum_parts.len() == 0 {
    let enum_mod0: String = ty_mod(scrut_t);
    let enum_name0: String = ty_name(scrut_t);
    let fe0: FindEnumResult = find_enum(ctx, enum_mod0, enum_name0);
    if !fe0.found { return PatLocalsResult { ok: false, locals: l0 }; }
    let es0: EnumSig = fe0.sig;
    if enum_mod0 != mod_path && !es0.is_pub { return PatLocalsResult { ok: false, locals: l0 }; }
    let mut vi0: i32 = 0;
    while vi0 < es0.vars.len() {
      let v0: EnumVariantSig = es0.vars.get(vi0);
      if v0.name == var_name {
        if v0.fields.len() != binders.len() { return PatLocalsResult { ok: false, locals: l0 }; }
        let mut l: Locals = l0;
        let mut bi: i32 = 0;
        while bi < binders.len() {
          l = locals_decl(l, binders.get(bi), v0.fields.get(bi), false);
          bi = bi + 1;
        }
        return PatLocalsResult { ok: true, locals: l };
      }
      vi0 = vi0 + 1;
    }
    return PatLocalsResult { ok: false, locals: l0 };
  }

  if enum_parts.len() != 1 && enum_parts.len() != 2 { return PatLocalsResult { ok: false, locals: l0 }; }
  let enum_mod: String = if enum_parts.len() == 1 { mod_path } else { find_alias(aliases, enum_parts.get(0)) };
  if enum_mod == "" { return PatLocalsResult { ok: false, locals: l0 }; }
  let enum_name: String = if enum_parts.len() == 1 { enum_parts.get(0) } else { enum_parts.get(1) };

  // Pattern enum must match scrutinee enum type.
  if ty_mod(scrut_t) != enum_mod || ty_name(scrut_t) != enum_name { return PatLocalsResult { ok: false, locals: l0 }; }

  let fe: FindEnumResult = find_enum(ctx, enum_mod, enum_name);
  if !fe.found { return PatLocalsResult { ok: false, locals: l0 }; }
  let es: EnumSig = fe.sig;
  if enum_mod != mod_path && !es.is_pub { return PatLocalsResult { ok: false, locals: l0 }; }

  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != binders.len() { return PatLocalsResult { ok: false, locals: l0 }; }
      let mut l: Locals = l0;
      let mut bi: i32 = 0;
      while bi < binders.len() {
        l = locals_decl(l, binders.get(bi), v.fields.get(bi), false);
        bi = bi + 1;
      }
      return PatLocalsResult { ok: true, locals: l };
    }
    vi = vi + 1;
  }

  return PatLocalsResult { ok: false, locals: l0 };
}
