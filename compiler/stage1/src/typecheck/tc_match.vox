import "ast" as ast
import "ir" as ir

fn tc_expr_match(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, scrut: i32, arms: Vec[ast.MatchArm], expected: i32) -> ExprTyResult {
  let sr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, scrut, -1);
  if !sr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  // v0: match on enums/ints/strings/bools.
  let scrut_base: i32 = strip_range(ctx, sr.ty);
  let scrut_t: ir.Ty = ir.ty_pool_get(ctx.pool, scrut_base);
  let is_enum: bool = match scrut_t.kind { ir.TyKind.Enum => true, _ => false };
  let is_int: bool = is_int_like_ty(ctx, scrut_base);
  let is_str: bool = scrut_base == ctx.ty_string;
  let is_bool: bool = scrut_base == ctx.ty_bool;
  if !is_enum && !is_int && !is_str && !is_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  if arms.len() == 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  // Enum metadata for exhaustiveness checks and enum variant patterns.
  let mut es: EnumSig = EnumSig { mod_path: "", name: "", base_name: "", is_pub: false, vars: Vec() };
  if is_enum {
    let et: ir.Ty = ir.ty_pool_get(ctx.pool, scrut_base);
    let fe: FindEnumResult = find_enum(ctx, ty_mod(et), ty_name(et));
    if !fe.found {
      let sp: ast.Span = ast.expr_pool_span(exprs, scrut);
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "unknown enum in match") };
    }
    es = fe.sig;
  }

  // Exhaustiveness approximation (Stage0/Stage1 v0):
  // - Any top-level wildcard/bind arm makes the match exhaustive.
  // - Otherwise:
  //   - enum scrutinee:
  //     - unit variant is covered if it appears in at least one arm.
  //     - single-payload variant is covered if the union of its payload patterns covers the field type
  //       (recursively, but only through enums; ints/strings require a wildcard/bind).
  //     - multi-payload variant requires a catch-all arm for that variant (all payload patterns are wild/bind).
  //   - non-enum scrutinee: require a wildcard/bind arm.
  let mut has_wild: bool = false;

  let mut out_ty: i32 = expected;
  let mut ai: i32 = 0;
  while ai < arms.len() {
    let arm: ast.MatchArm = arms.get(ai);
    let lr: Locals = locals_enter(l0);
    let pr: PatLocalsResult = tc_pat(ctx, mod_path, imps, sr.ty, scrut_t, arm.pat, lr);
    if !pr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

    // Unreachable arm detection (Stage0/Stage1 v0):
    // - Any arm after a `_` / bind arm is unreachable.
    // - Enum: if previous arms already cover the entire match, later arms are unreachable.
    // - Enum: if previous arms already cover the payload space of a specific variant, later arms for that variant are unreachable.
    // - Int/String/Bool: duplicate literal arms are unreachable.
    if arms_has_wild_or_bind(arms, ai) {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(pat_span(arm.pat), "unreachable match arm") };
    }
    if is_enum {
      if enum_covered_by_arms(ctx, es, arms, ai) {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(pat_span(arm.pat), "unreachable match arm") };
      }
      if match arm.pat { ast.Pat.EnumVariant(_sp, _ep, _vn, _args) => true, _ => false } {
        let vn: String = match arm.pat { ast.Pat.EnumVariant(_sp, _ep, vname, _args) => vname, _ => "" };
        let vidx: i32 = enum_variant_index(es, vn);
        if vidx >= 0 && enum_variant_covered_by_arms(ctx, es, vidx, arms, ai) {
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(pat_span(arm.pat), "unreachable match arm") };
        }
      }
    } else if is_int {
      if match arm.pat { ast.Pat.Int(_sp, _t) => true, _ => false } {
        let lit: String = match arm.pat { ast.Pat.Int(_sp, t) => t, _ => "" };
        if arms_has_int_lit(arms, ai, lit) {
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(pat_span(arm.pat), "unreachable match arm") };
        }
      }
    } else if is_str {
      if match arm.pat { ast.Pat.Str(_sp, _t) => true, _ => false } {
        let lit: String = match arm.pat { ast.Pat.Str(_sp, t) => t, _ => "" };
        if arms_has_str_lit(arms, ai, lit) {
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(pat_span(arm.pat), "unreachable match arm") };
        }
      }
    } else if is_bool {
      if match arm.pat { ast.Pat.Bool(_sp, _b) => true, _ => false } {
        let lit: bool = match arm.pat { ast.Pat.Bool(_sp, b) => b, _ => false };
        if arms_has_bool_lit(arms, ai, lit) {
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(pat_span(arm.pat), "unreachable match arm") };
        }
      }
    }

    if match arm.pat { ast.Pat.Wild(_sp) => true, ast.Pat.Bind(_sp, _n) => true, _ => false } { has_wild = true; }

    let want: i32 = out_ty;
    let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, pr.locals, arm.expr, want);
    if !er.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

    if out_ty == -1 {
      out_ty = er.ty;
    } else {
      if er.ty != out_ty {
        let ob: i32 = strip_range(ctx, out_ty);
        let eb: i32 = strip_range(ctx, er.ty);
        if ob == eb && is_int_like_ty(ctx, ob) {
          out_ty = ob; // unify to base
        } else {
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
        }
      }
    }

    ai = ai + 1;
  }

  // Exhaustiveness errors.
  if is_enum {
    if !has_wild {
      let mut vi: i32 = 0;
      while vi < es.vars.len() {
        let v: EnumVariantSig = es.vars.get(vi);
        let mut any_pat: bool = false;
        let mut arg_pats: Vec[ast.Pat] = Vec();
        let mut has_catch_all: bool = false;

        // Collect patterns for this variant from arms.
        let mut ai2: i32 = 0;
        while ai2 < arms.len() {
          let ap: ast.Pat = arms.get(ai2).pat;
          if match ap { ast.Pat.EnumVariant(_sp, _ep, name, _args) => name == v.name, _ => false } {
            let args: Vec[ast.Pat] = match ap { ast.Pat.EnumVariant(_sp, _ep, _n, a) => a, _ => Vec() };
            if args.len() == v.fields.len() {
              any_pat = true;
              if v.fields.len() == 1 {
                arg_pats.push(args.get(0));
              } else if v.fields.len() > 1 {
                // catch-all: all args are wild/bind
                let mut full: bool = true;
                let mut pi: i32 = 0;
                while pi < args.len() {
                  if !is_wild_or_bind(args.get(pi)) { full = false; }
                  pi = pi + 1;
                }
                if full { has_catch_all = true; }
              }
            }
          }
          ai2 = ai2 + 1;
        }

        let mut covered: bool = false;
        if v.fields.len() == 0 {
          covered = any_pat;
        } else if v.fields.len() == 1 {
          if arg_pats.len() != 0 { covered = pats_cover_all(ctx, v.fields.get(0), arg_pats); }
        } else {
          covered = has_catch_all;
        }

        if !covered {
          let sp: ast.Span = ast.expr_pool_span(exprs, scrut);
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "non-exhaustive match, missing coverage for variant: ".concat(v.name)) };
        }
        vi = vi + 1;
      }
    }
  } else if is_bool {
    if !has_wild && (!arms_has_bool_lit(arms, arms.len(), true) || !arms_has_bool_lit(arms, arms.len(), false)) {
      let sp: ast.Span = ast.expr_pool_span(exprs, scrut);
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "non-exhaustive match, missing coverage for bool") };
    }
  } else {
    if !has_wild {
      let sp: ast.Span = ast.expr_pool_span(exprs, scrut);
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "non-exhaustive match, missing wildcard arm `_`") };
    }
  }

  if out_ty == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if expected != -1 && !assignable_to(ctx, expected, out_ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
}

fn pat_span(p: ast.Pat) -> ast.Span {
  return match p {
    ast.Pat.Wild(sp) => sp,
    ast.Pat.Bind(sp, _n) => sp,
    ast.Pat.Bool(sp, _b) => sp,
    ast.Pat.Int(sp, _t) => sp,
    ast.Pat.Str(sp, _t) => sp,
    ast.Pat.EnumVariant(sp, _ep, _vn, _args) => sp,
  };
}

fn is_wild_or_bind(p: ast.Pat) -> bool {
  return match p { ast.Pat.Wild(_sp) => true, ast.Pat.Bind(_sp, _n) => true, _ => false };
}

fn arms_has_wild_or_bind(arms: Vec[ast.MatchArm], upto: i32) -> bool {
  let mut i: i32 = 0;
  while i < upto {
    let p: ast.Pat = arms.get(i).pat;
    if is_wild_or_bind(p) { return true; }
    i = i + 1;
  }
  return false;
}

fn arms_has_int_lit(arms: Vec[ast.MatchArm], upto: i32, lit: String) -> bool {
  let mut i: i32 = 0;
  while i < upto {
    let p: ast.Pat = arms.get(i).pat;
    if match p { ast.Pat.Int(_sp, t) => t == lit, _ => false } { return true; }
    i = i + 1;
  }
  return false;
}

fn arms_has_str_lit(arms: Vec[ast.MatchArm], upto: i32, lit: String) -> bool {
  let mut i: i32 = 0;
  while i < upto {
    let p: ast.Pat = arms.get(i).pat;
    if match p { ast.Pat.Str(_sp, t) => t == lit, _ => false } { return true; }
    i = i + 1;
  }
  return false;
}

fn arms_has_bool_lit(arms: Vec[ast.MatchArm], upto: i32, lit: bool) -> bool {
  let mut i: i32 = 0;
  while i < upto {
    let p: ast.Pat = arms.get(i).pat;
    if match p { ast.Pat.Bool(_sp, b) => b == lit, _ => false } { return true; }
    i = i + 1;
  }
  return false;
}

fn enum_variant_index(es: EnumSig, vname: String) -> i32 {
  let mut i: i32 = 0;
  while i < es.vars.len() {
    if es.vars.get(i).name == vname { return i; }
    i = i + 1;
  }
  return -1;
}

fn enum_variant_covered_by_arms(ctx: Ctx, es: EnumSig, vidx: i32, arms: Vec[ast.MatchArm], upto: i32) -> bool {
  let v: EnumVariantSig = es.vars.get(vidx);
  if v.fields.len() == 0 {
    // unit: appears once covers it
    let mut i: i32 = 0;
    while i < upto {
      let p: ast.Pat = arms.get(i).pat;
      if match p { ast.Pat.EnumVariant(_sp, _ep, n, args) => n == v.name && args.len() == 0, _ => false } { return true; }
      i = i + 1;
    }
    return false;
  }
  if v.fields.len() == 1 {
    // gather payload patterns for this variant
    let mut ps: Vec[ast.Pat] = Vec();
    let mut i: i32 = 0;
    while i < upto {
      let p: ast.Pat = arms.get(i).pat;
      if match p { ast.Pat.EnumVariant(_sp, _ep, n, args) => n == v.name && args.len() == 1, _ => false } {
        let args: Vec[ast.Pat] = match p { ast.Pat.EnumVariant(_sp, _ep, _n, a) => a, _ => Vec() };
        ps.push(args.get(0));
      }
      i = i + 1;
    }
    if ps.len() == 0 { return false; }
    return pats_cover_all(ctx, v.fields.get(0), ps);
  }
  // multi payload: require a catch-all for the variant
  let mut i: i32 = 0;
  while i < upto {
    let p: ast.Pat = arms.get(i).pat;
    if match p { ast.Pat.EnumVariant(_sp, _ep, n, args) => n == v.name && args.len() == v.fields.len(), _ => false } {
      let args: Vec[ast.Pat] = match p { ast.Pat.EnumVariant(_sp, _ep, _n, a) => a, _ => Vec() };
      let mut full: bool = true;
      let mut j: i32 = 0;
      while j < args.len() {
        if !is_wild_or_bind(args.get(j)) { full = false; }
        j = j + 1;
      }
      if full { return true; }
    }
    i = i + 1;
  }
  return false;
}

fn enum_covered_by_arms(ctx: Ctx, es: EnumSig, arms: Vec[ast.MatchArm], upto: i32) -> bool {
  let mut i: i32 = 0;
  while i < es.vars.len() {
    if !enum_variant_covered_by_arms(ctx, es, i, arms, upto) { return false; }
    i = i + 1;
  }
  return true;
}

fn pats_cover_all(ctx: Ctx, ty: i32, pats: Vec[ast.Pat]) -> bool {
  // Any wildcard/bind covers all.
  let mut i: i32 = 0;
  while i < pats.len() {
    if is_wild_or_bind(pats.get(i)) { return true; }
    i = i + 1;
  }

  let base: i32 = strip_range(ctx, ty);
  if base == ctx.ty_bool {
    let mut has_t: bool = false;
    let mut has_f: bool = false;
    let mut j: i32 = 0;
    while j < pats.len() {
      let p0: ast.Pat = pats.get(j);
      if match p0 { ast.Pat.Bool(_sp, b) => b, _ => false } { has_t = true; }
      if match p0 { ast.Pat.Bool(_sp, b) => !b, _ => false } { has_f = true; }
      j = j + 1;
    }
    return has_t && has_f;
  }
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind != ir.TyKind.Enum { return false; }
  let fe: FindEnumResult = find_enum(ctx, ty_mod(t), ty_name(t));
  if !fe.found { return false; }
  let es: EnumSig = fe.sig;

  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    // Collect patterns for this variant.
    let mut var_pats: Vec[ast.Pat] = Vec();
    let mut pi: i32 = 0;
    while pi < pats.len() {
      let p: ast.Pat = pats.get(pi);
      if match p { ast.Pat.EnumVariant(_sp, _ep, n, _args) => n == v.name, _ => false } { var_pats.push(p); }
      pi = pi + 1;
    }

    if v.fields.len() == 0 {
      // unit variant: must appear with correct arity (0)
      let mut ok: bool = false;
      let mut j: i32 = 0;
      while j < var_pats.len() {
        let args: Vec[ast.Pat] = match var_pats.get(j) { ast.Pat.EnumVariant(_sp, _ep, _n, a) => a, _ => Vec() };
        if args.len() == 0 { ok = true; }
        j = j + 1;
      }
      if !ok { return false; }
    } else if v.fields.len() == 1 {
      let mut arg_pats: Vec[ast.Pat] = Vec();
      let mut j: i32 = 0;
      while j < var_pats.len() {
        let args: Vec[ast.Pat] = match var_pats.get(j) { ast.Pat.EnumVariant(_sp, _ep, _n, a) => a, _ => Vec() };
        if args.len() == 1 { arg_pats.push(args.get(0)); }
        j = j + 1;
      }
      if arg_pats.len() == 0 { return false; }
      if !pats_cover_all(ctx, v.fields.get(0), arg_pats) { return false; }
    } else {
      // multi-payload: require a catch-all pattern for the variant
      let mut ok: bool = false;
      let mut j: i32 = 0;
      while j < var_pats.len() {
        let args: Vec[ast.Pat] = match var_pats.get(j) { ast.Pat.EnumVariant(_sp, _ep, _n, a) => a, _ => Vec() };
        if args.len() == v.fields.len() {
          let mut full: bool = true;
          let mut k: i32 = 0;
          while k < args.len() {
            if !is_wild_or_bind(args.get(k)) { full = false; }
            k = k + 1;
          }
          if full { ok = true; }
        }
        j = j + 1;
      }
      if !ok { return false; }
    }

    vi = vi + 1;
  }
  return true;
}

struct PatLocalsResult { ok: bool, locals: Locals }

fn tc_pat(ctx: Ctx, mod_path: String, imps: Imports, scrut_ty: i32, scrut_t: ir.Ty, pat: ast.Pat, l0: Locals) -> PatLocalsResult {
  return match pat {
    ast.Pat.Wild(_sp) => PatLocalsResult { ok: true, locals: l0 },
    ast.Pat.Bind(_sp, name) => PatLocalsResult { ok: true, locals: locals_decl(l0, name, scrut_ty, false) },
    ast.Pat.Bool(_sp, _b) => if strip_range(ctx, scrut_ty) == ctx.ty_bool { PatLocalsResult { ok: true, locals: l0 } } else { PatLocalsResult { ok: false, locals: l0 } },
    ast.Pat.Int(_sp, text) => {
      if !is_int_like_ty(ctx, scrut_ty) {
        PatLocalsResult { ok: false, locals: l0 }
      } else {
        let is_u64_like: bool = match scrut_t.kind { ir.TyKind.U64 => true, ir.TyKind.USize => true, _ => false };
        if is_u64_like {
          let pru: ParseU64DecResult = parse_u64_dec(text);
          if !pru.ok { PatLocalsResult { ok: false, locals: l0 } }
          else { PatLocalsResult { ok: true, locals: l0 } }
        } else {
          let pr: ParseI64DecResult = parse_i64_dec(text);
          if !pr.ok {
            PatLocalsResult { ok: false, locals: l0 }
          } else {
            let v: i64 = pr.val;
            let ok_lit: bool = match scrut_t.kind {
              ir.TyKind.I8 => v >= -128 && v <= 127,
              ir.TyKind.U8 => v >= 0 && v <= 255,
              ir.TyKind.I16 => v >= -32768 && v <= 32767,
              ir.TyKind.U16 => v >= 0 && v <= 65535,
              ir.TyKind.I32 => v >= -2147483648 && v <= 2147483647,
              ir.TyKind.U32 => v >= 0 && v <= 4294967295,
              ir.TyKind.I64 => true,
              ir.TyKind.ISize => true,
              _ => false,
            };
            if !ok_lit { PatLocalsResult { ok: false, locals: l0 } }
            else { PatLocalsResult { ok: true, locals: l0 } }
          }
        }
      }
    },
    ast.Pat.Str(_sp, _) => if strip_range(ctx, scrut_ty) == ctx.ty_string { PatLocalsResult { ok: true, locals: l0 } } else { PatLocalsResult { ok: false, locals: l0 } },
    ast.Pat.EnumVariant(_sp, enum_parts, var_name, args) => tc_pat_enum(ctx, mod_path, imps, scrut_t, enum_parts, var_name, args, l0),
  };
}

fn tc_pat_enum(ctx: Ctx, mod_path: String, imps: Imports, scrut_t: ir.Ty, enum_parts: Vec[String], var_name: String, args: Vec[ast.Pat], l0: Locals) -> PatLocalsResult {
  let is_enum: bool = match scrut_t.kind { ir.TyKind.Enum => true, _ => false };
  if !is_enum { return PatLocalsResult { ok: false, locals: l0 }; }
  let scrut_mod: String = ty_mod(scrut_t);
  let scrut_name: String = ty_name(scrut_t);
  let fse: FindEnumResult = find_enum(ctx, scrut_mod, scrut_name);
  if !fse.found { return PatLocalsResult { ok: false, locals: l0 }; }
  let ses: EnumSig = fse.sig;

  // Shorthand: `.Variant(...)` uses the scrutinee enum type.
  if enum_parts.len() == 0 {
    if scrut_mod != mod_path && !ses.is_pub { return PatLocalsResult { ok: false, locals: l0 }; }
    let mut vi0: i32 = 0;
    while vi0 < ses.vars.len() {
      let v0: EnumVariantSig = ses.vars.get(vi0);
      if v0.name == var_name {
        if v0.fields.len() != args.len() { return PatLocalsResult { ok: false, locals: l0 }; }
        let mut l: Locals = l0;
        let mut bi: i32 = 0;
        while bi < args.len() && bi < v0.fields.len() {
          let fty: i32 = v0.fields.get(bi);
          let fbase: i32 = strip_range(ctx, fty);
          let ft: ir.Ty = ir.ty_pool_get(ctx.pool, fbase);
          let pr: PatLocalsResult = tc_pat(ctx, mod_path, imps, fty, ft, args.get(bi), l);
          if !pr.ok { return PatLocalsResult { ok: false, locals: l0 }; }
          l = pr.locals;
          bi = bi + 1;
        }
        return PatLocalsResult { ok: true, locals: l };
      }
      vi0 = vi0 + 1;
    }
    return PatLocalsResult { ok: false, locals: l0 };
  }

  if enum_parts.len() != 1 && enum_parts.len() != 2 { return PatLocalsResult { ok: false, locals: l0 }; }
  let mut enum_mod: String = "";
  let mut enum_name: String = "";
  if enum_parts.len() == 1 {
    enum_mod = mod_path;
    enum_name = enum_parts.get(0);
    let nt: NamedTypeImport = find_named_type(imps.named_types, enum_name);
    if nt.local != "" {
      if nt.kind != named_type_kind_enum() { return PatLocalsResult { ok: false, locals: l0 }; }
      enum_mod = nt.mod_path;
      enum_name = nt.name;
    }
  } else {
    enum_mod = find_alias(imps.aliases, enum_parts.get(0));
    if enum_mod == "" { return PatLocalsResult { ok: false, locals: l0 }; }
    enum_name = enum_parts.get(1);
  }

  // Pattern enum must match scrutinee enum type.
  if scrut_mod != enum_mod { return PatLocalsResult { ok: false, locals: l0 }; }
  if enum_name != scrut_name && enum_name != ses.base_name { return PatLocalsResult { ok: false, locals: l0 }; }
  if enum_mod != mod_path && !ses.is_pub { return PatLocalsResult { ok: false, locals: l0 }; }

  let mut vi: i32 = 0;
  while vi < ses.vars.len() {
    let v: EnumVariantSig = ses.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != args.len() { return PatLocalsResult { ok: false, locals: l0 }; }
      let mut l: Locals = l0;
      let mut bi: i32 = 0;
      while bi < args.len() && bi < v.fields.len() {
        let fty: i32 = v.fields.get(bi);
        let fbase: i32 = strip_range(ctx, fty);
        let ft: ir.Ty = ir.ty_pool_get(ctx.pool, fbase);
        let pr: PatLocalsResult = tc_pat(ctx, mod_path, imps, fty, ft, args.get(bi), l);
        if !pr.ok { return PatLocalsResult { ok: false, locals: l0 }; }
        l = pr.locals;
        bi = bi + 1;
      }
      return PatLocalsResult { ok: true, locals: l };
    }
    vi = vi + 1;
  }

  return PatLocalsResult { ok: false, locals: l0 };
}
