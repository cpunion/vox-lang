import "ast" as ast
import "ir" as ir

fn tc_expr_match(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, scrut: i32, arms: Vec[ast.MatchArm], expected: i32) -> ExprTyResult {
  let sr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, scrut, -1);
  if !sr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  // v0: match on enums/ints/strings only (enough for stage1 tests).
  let scrut_base: i32 = strip_range(ctx, sr.ty);
  let scrut_t: ir.Ty = ir.ty_pool_get(ctx.pool, scrut_base);
  let is_enum: bool = match scrut_t.kind { ir.TyKind.Enum => true, _ => false };
  let is_int: bool = is_int_like_ty(ctx, scrut_base);
  let is_str: bool = scrut_base == ctx.ty_string;
  if !is_enum && !is_int && !is_str { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  if arms.len() == 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  // Enum metadata for exhaustiveness checks and enum variant patterns.
  let mut es: EnumSig = EnumSig { mod_path: "", name: "", is_pub: false, vars: Vec() };
  if is_enum {
    let et: ir.Ty = ir.ty_pool_get(ctx.pool, scrut_base);
    let fe: FindEnumResult = find_enum(ctx, ty_mod(et), ty_name(et));
    if !fe.found {
      let sp: ast.Span = ast.expr_pool_span(exprs, scrut);
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "unknown enum in match") };
    }
    es = fe.sig;
  }

  // Stage0/Stage1 v0 exhaustiveness approximation:
  // - Any top-level wildcard/bind arm makes the match exhaustive.
  // - Otherwise:
  //   - enum scrutinee: require a catch-all arm per variant (payload args are all wild/bind).
  //   - non-enum scrutinee: require a wildcard/bind arm.
  let mut has_wild: bool = false;
  let mut seen_full: Vec[bool] = Vec();
  if is_enum {
    let mut i: i32 = 0;
    while i < es.vars.len() { seen_full.push(false); i = i + 1; }
  }

  let mut out_ty: i32 = expected;
  let mut ai: i32 = 0;
  while ai < arms.len() {
    let arm: ast.MatchArm = arms.get(ai);
    let lr: Locals = locals_enter(l0);
    let pr: PatLocalsResult = tc_pat(ctx, mod_path, imps, sr.ty, scrut_t, arm.pat, lr);
    if !pr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

    // Track exhaustiveness coverage (after tc_pat validates the pattern).
    if match arm.pat { ast.Pat.Wild(_sp) => true, ast.Pat.Bind(_sp, _n) => true, _ => false } {
      has_wild = true;
    } else {
      if is_enum {
        if match arm.pat { ast.Pat.EnumVariant(_sp, _ep, _vn, _args) => true, _ => false } {
          let vn: String = match arm.pat { ast.Pat.EnumVariant(_sp, _ep, vname, _args) => vname, _ => "" };
          let args: Vec[ast.Pat] = match arm.pat { ast.Pat.EnumVariant(_sp, _ep, _vname, a) => a, _ => Vec() };
          let mut full: bool = true;
          let mut pi: i32 = 0;
          while pi < args.len() {
            let ap: ast.Pat = args.get(pi);
            if !match ap { ast.Pat.Wild(_s) => true, ast.Pat.Bind(_s, _n) => true, _ => false } { full = false; }
            pi = pi + 1;
          }
          if full {
            // Find the variant index and mark it.
            let mut vi: i32 = 0;
            while vi < es.vars.len() {
              if es.vars.get(vi).name == vn {
                // Update bool vec element.
                let mut newv: Vec[bool] = Vec();
                let mut j: i32 = 0;
                while j < seen_full.len() {
                  if j == vi { newv.push(true); } else { newv.push(seen_full.get(j)); }
                  j = j + 1;
                }
                seen_full = newv;
              }
              vi = vi + 1;
            }
          }
        }
      }
    }

    let want: i32 = out_ty;
    let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, pr.locals, arm.expr, want);
    if !er.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

    if out_ty == -1 {
      out_ty = er.ty;
    } else {
      if er.ty != out_ty {
        let ob: i32 = strip_range(ctx, out_ty);
        let eb: i32 = strip_range(ctx, er.ty);
        if ob == eb && is_int_like_ty(ctx, ob) {
          out_ty = ob; // unify to base
        } else {
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
        }
      }
    }

    ai = ai + 1;
  }

  // Exhaustiveness errors.
  if is_enum {
    if !has_wild {
      let mut vi: i32 = 0;
      while vi < es.vars.len() {
        if !seen_full.get(vi) {
          let sp: ast.Span = ast.expr_pool_span(exprs, scrut);
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "non-exhaustive match, missing catch-all arm for variant: ".concat(es.vars.get(vi).name)) };
        }
        vi = vi + 1;
      }
    }
  } else {
    if !has_wild {
      let sp: ast.Span = ast.expr_pool_span(exprs, scrut);
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "non-exhaustive match, missing wildcard arm `_`") };
    }
  }

  if out_ty == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if expected != -1 && !assignable_to(ctx, expected, out_ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
}

struct PatLocalsResult { ok: bool, locals: Locals }

fn tc_pat(ctx: Ctx, mod_path: String, imps: Imports, scrut_ty: i32, scrut_t: ir.Ty, pat: ast.Pat, l0: Locals) -> PatLocalsResult {
  return match pat {
    ast.Pat.Wild(_sp) => PatLocalsResult { ok: true, locals: l0 },
    ast.Pat.Bind(_sp, name) => PatLocalsResult { ok: true, locals: locals_decl(l0, name, scrut_ty, false) },
    ast.Pat.Int(_sp, text) => {
      if !is_int_like_ty(ctx, scrut_ty) {
        PatLocalsResult { ok: false, locals: l0 }
      } else {
        let pr: ParseI64DecResult = parse_i64_dec(text);
        if !pr.ok {
          PatLocalsResult { ok: false, locals: l0 }
        } else {
          let v: i64 = pr.val;
          let ok_lit: bool = match scrut_t.kind {
            ir.TyKind.I8 => v >= -128 && v <= 127,
            ir.TyKind.U8 => v >= 0 && v <= 255,
            ir.TyKind.I32 => v >= -2147483648 && v <= 2147483647,
            ir.TyKind.U32 => v >= 0 && v <= 4294967295,
            ir.TyKind.I64 => true,
            // Stage1 v0: pattern literals are parsed as i64 decimals; allow non-negative values for u64/usize too.
            ir.TyKind.U64 => v >= 0,
            ir.TyKind.USize => v >= 0,
            _ => false,
          };
          if !ok_lit { PatLocalsResult { ok: false, locals: l0 } }
          else { PatLocalsResult { ok: true, locals: l0 } }
        }
      }
    },
    ast.Pat.Str(_sp, _) => if strip_range(ctx, scrut_ty) == ctx.ty_string { PatLocalsResult { ok: true, locals: l0 } } else { PatLocalsResult { ok: false, locals: l0 } },
    ast.Pat.EnumVariant(_sp, enum_parts, var_name, args) => tc_pat_enum(ctx, mod_path, imps, scrut_t, enum_parts, var_name, args, l0),
  };
}

fn tc_pat_enum(ctx: Ctx, mod_path: String, imps: Imports, scrut_t: ir.Ty, enum_parts: Vec[String], var_name: String, args: Vec[ast.Pat], l0: Locals) -> PatLocalsResult {
  let is_enum: bool = match scrut_t.kind { ir.TyKind.Enum => true, _ => false };
  if !is_enum { return PatLocalsResult { ok: false, locals: l0 }; }

  // Shorthand: `.Variant(...)` uses the scrutinee enum type.
  if enum_parts.len() == 0 {
    let enum_mod0: String = ty_mod(scrut_t);
    let enum_name0: String = ty_name(scrut_t);
    let fe0: FindEnumResult = find_enum(ctx, enum_mod0, enum_name0);
    if !fe0.found { return PatLocalsResult { ok: false, locals: l0 }; }
    let es0: EnumSig = fe0.sig;
    if enum_mod0 != mod_path && !es0.is_pub { return PatLocalsResult { ok: false, locals: l0 }; }
    let mut vi0: i32 = 0;
    while vi0 < es0.vars.len() {
      let v0: EnumVariantSig = es0.vars.get(vi0);
      if v0.name == var_name {
        if v0.fields.len() != args.len() { return PatLocalsResult { ok: false, locals: l0 }; }
        let mut l: Locals = l0;
        let mut bi: i32 = 0;
        while bi < args.len() && bi < v0.fields.len() {
          let fty: i32 = v0.fields.get(bi);
          let fbase: i32 = strip_range(ctx, fty);
          let ft: ir.Ty = ir.ty_pool_get(ctx.pool, fbase);
          let pr: PatLocalsResult = tc_pat(ctx, mod_path, imps, fty, ft, args.get(bi), l);
          if !pr.ok { return PatLocalsResult { ok: false, locals: l0 }; }
          l = pr.locals;
          bi = bi + 1;
        }
        return PatLocalsResult { ok: true, locals: l };
      }
      vi0 = vi0 + 1;
    }
    return PatLocalsResult { ok: false, locals: l0 };
  }

  if enum_parts.len() != 1 && enum_parts.len() != 2 { return PatLocalsResult { ok: false, locals: l0 }; }
  let mut enum_mod: String = "";
  let mut enum_name: String = "";
  if enum_parts.len() == 1 {
    enum_mod = mod_path;
    enum_name = enum_parts.get(0);
    let nt: NamedTypeImport = find_named_type(imps.named_types, enum_name);
    if nt.local != "" {
      if nt.kind != named_type_kind_enum() { return PatLocalsResult { ok: false, locals: l0 }; }
      enum_mod = nt.mod_path;
      enum_name = nt.name;
    }
  } else {
    enum_mod = find_alias(imps.aliases, enum_parts.get(0));
    if enum_mod == "" { return PatLocalsResult { ok: false, locals: l0 }; }
    enum_name = enum_parts.get(1);
  }

  // Pattern enum must match scrutinee enum type.
  if ty_mod(scrut_t) != enum_mod || ty_name(scrut_t) != enum_name { return PatLocalsResult { ok: false, locals: l0 }; }

  let fe: FindEnumResult = find_enum(ctx, enum_mod, enum_name);
  if !fe.found { return PatLocalsResult { ok: false, locals: l0 }; }
  let es: EnumSig = fe.sig;
  if enum_mod != mod_path && !es.is_pub { return PatLocalsResult { ok: false, locals: l0 }; }

  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != args.len() { return PatLocalsResult { ok: false, locals: l0 }; }
      let mut l: Locals = l0;
      let mut bi: i32 = 0;
      while bi < args.len() && bi < v.fields.len() {
        let fty: i32 = v.fields.get(bi);
        let fbase: i32 = strip_range(ctx, fty);
        let ft: ir.Ty = ir.ty_pool_get(ctx.pool, fbase);
        let pr: PatLocalsResult = tc_pat(ctx, mod_path, imps, fty, ft, args.get(bi), l);
        if !pr.ok { return PatLocalsResult { ok: false, locals: l0 }; }
        l = pr.locals;
        bi = bi + 1;
      }
      return PatLocalsResult { ok: true, locals: l };
    }
    vi = vi + 1;
  }

  return PatLocalsResult { ok: false, locals: l0 };
}
