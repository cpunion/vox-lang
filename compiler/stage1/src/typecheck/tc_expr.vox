import "ast" as ast
import "ir" as ir

// Stage1 typecheck (v0): minimal expression typing used by tc_fn.vox.
// This module intentionally stays small; we will expand it with TDD when typecheck
// becomes part of Stage1's critical path.

pub struct ExprTyResult { pub ok: bool, pub ty: i32, pub err: TcError }

pub fn tc_expr(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, id: i32, expected: i32) -> ExprTyResult {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);

  let r: ExprTyResult = match n {
    ast.ExprNode.Int(text) => tc_expr_int(ctx, ast.expr_pool_span(exprs, id), text, expected),
    ast.ExprNode.Str(_) => tc_expr_str(ctx, expected),
    ast.ExprNode.Bool(_) => tc_expr_bool(ctx, expected),
    ast.ExprNode.Ident(name) => tc_expr_ident(ctx, mod_path, imps, l0, name, expected),
    ast.ExprNode.DotIdent(name) => tc_expr_dot_ident(ctx, mod_path, name, expected),
    ast.ExprNode.Block(b) => tc_expr_block(ctx, w, mod_path, imps, exprs, l0, b, expected),

    ast.ExprNode.If(c, t, e) => tc_expr_if(ctx, w, mod_path, imps, exprs, l0, c, t, e, expected),
    ast.ExprNode.Unary(op, a) => tc_expr_unary(ctx, w, mod_path, imps, exprs, l0, op, a, expected),
    ast.ExprNode.As(a, tn) => tc_expr_as(ctx, w, mod_path, imps, exprs, l0, a, tn, expected),
    ast.ExprNode.Binary(op, l, r) => tc_expr_binary(ctx, w, mod_path, imps, exprs, l0, op, l, r, expected),

    ast.ExprNode.Member(recv, name) => tc_expr_member(ctx, w, mod_path, imps, exprs, l0, recv, name, expected),
    ast.ExprNode.Call(callee, type_args, args) => tc_expr_call(ctx, w, mod_path, imps, exprs, l0, ast.expr_pool_span(exprs, id), callee, type_args, args, expected),
    ast.ExprNode.StructLit(ty_expr, fields) => tc_expr_struct_lit(ctx, w, mod_path, imps, exprs, l0, ty_expr, fields, expected),
    ast.ExprNode.Match(scrut, arms) => tc_expr_match(ctx, w, mod_path, imps, exprs, l0, scrut, arms, expected),
  };

  if r.ok { return r; }
  if r.err != TcError.None { return r; }
  // If a helper didn't attach a reason, fall back to a generic error at the expr span.
  let sp: ast.Span = ast.expr_pool_span(exprs, id);
  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "typecheck failed") };
}

fn tc_expr_as(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, a: i32, tn: ast.TypeName, expected: i32) -> ExprTyResult {
  let ar: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, a, -1);
  if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  let tr: ResolveTyResult = resolve_type(ctx, w, mod_path, imps, Vec(), tn);
  let c2: Ctx = tr.ctx;
  if !tr.ok { return ExprTyResult { ok: false, ty: c2.ty_bad, err: TcError.None }; }

  let from_ty: i32 = ar.ty;
  let to_ty: i32 = tr.idx;
  let ok_from: bool = from_ty == c2.ty_i32 || from_ty == c2.ty_i64;
  let ok_to: bool = to_ty == c2.ty_i32 || to_ty == c2.ty_i64;
  if !ok_from || !ok_to { return ExprTyResult { ok: false, ty: c2.ty_bad, err: TcError.None }; }

  let ok_cast: bool = from_ty == to_ty || (from_ty == c2.ty_i32 && to_ty == c2.ty_i64) || (from_ty == c2.ty_i64 && to_ty == c2.ty_i32);
  if !ok_cast { return ExprTyResult { ok: false, ty: c2.ty_bad, err: TcError.None }; }

  if expected != -1 && expected != to_ty { return ExprTyResult { ok: false, ty: c2.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: to_ty, err: TcError.None };
}

fn tc_expr_block(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, b: ast.ExprBlock, expected: i32) -> ExprTyResult {
  // Expression block: `{ stmt*; tailExpr }`. Tail is optional (missing => unit).
  //
  // v0 restriction (stage0 parity): terminators are not allowed in expression blocks.
  let mut c: Ctx = ctx;
  let mut l: Locals = locals_enter(l0);

  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let st: ast.Stmt = b.stmts.get(i);
    let is_term: bool = match st { ast.Stmt.Return(_, _, _) => true, ast.Stmt.Break(_) => true, ast.Stmt.Continue(_) => true, _ => false };
    if is_term { return ExprTyResult { ok: false, ty: c.ty_bad, err: TcError.None }; }

    let r: TcStmtResult = tc_stmt(c, w, mod_path, imps, exprs, l, c.ty_unit, st);
    if !r.ok { return ExprTyResult { ok: false, ty: c.ty_bad, err: TcError.None }; }
    c = r.ctx;
    l = r.locals;
    i = i + 1;
  }

  if !b.has_tail {
    if expected != -1 && expected != c.ty_unit { return ExprTyResult { ok: false, ty: c.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: c.ty_unit, err: TcError.None };
  }

  let er: ExprTyResult = tc_expr(c, w, mod_path, imps, exprs, l, b.tail, expected);
  if !er.ok { return ExprTyResult { ok: false, ty: c.ty_bad, err: TcError.None }; }
  let out_ty: i32 = if expected != -1 { expected } else { er.ty };
  if expected != -1 && er.ty != expected { return ExprTyResult { ok: false, ty: c.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
}

fn tc_expr_dot_ident(ctx: Ctx, mod_path: String, name: String, expected: i32) -> ExprTyResult {
  // `.Variant` needs an expected enum type.
  if expected == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let et: ir.Ty = ir.ty_pool_get(ctx.pool, expected);
  if et.kind != ir.TyKind.Enum { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let fe: FindEnumResult = find_enum(ctx, ty_mod(et), ty_name(et));
  if !fe.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let es: EnumSig = fe.sig;
  // Unit variant only.
  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    if v.name == name {
      if v.fields.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      return ExprTyResult { ok: true, ty: expected, err: TcError.None };
    }
    vi = vi + 1;
  }
  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}

fn tc_expr_int(ctx: Ctx, sp: ast.Span, text: String, expected: i32) -> ExprTyResult {
  // Infer integer literal type:
  // - if expected is i32/i64, constrain to that type with range check
  // - otherwise, pick i32 if it fits, else i64 if it fits.
  if expected == ctx.ty_i32 {
    let pr: ParseI32DecResult = parse_i32_dec(text);
    if !pr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "i32 literal out of range") }; }
    return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None };
  }
  if expected == ctx.ty_i64 {
    let pr2: ParseI64DecResult = parse_i64_dec(text);
    if !pr2.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "i64 literal out of range") }; }
    return ExprTyResult { ok: true, ty: ctx.ty_i64, err: TcError.None };
  }
  if expected != -1 {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "integer literal requires expected i32 or i64") };
  }

  let pr3: ParseI32DecResult = parse_i32_dec(text);
  if pr3.ok { return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None }; }
  let pr4: ParseI64DecResult = parse_i64_dec(text);
  if pr4.ok { return ExprTyResult { ok: true, ty: ctx.ty_i64, err: TcError.None }; }
  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "integer literal out of range") };
}

fn tc_expr_str(ctx: Ctx, expected: i32) -> ExprTyResult {
  if expected != -1 && expected != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
}

fn tc_expr_bool(ctx: Ctx, expected: i32) -> ExprTyResult {
  if expected != -1 && expected != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: ctx.ty_bool, err: TcError.None };
}

fn tc_expr_ident(ctx: Ctx, mod_path: String, imps: Imports, l0: Locals, name: String, expected: i32) -> ExprTyResult {
  let vr: LookupVarResult = locals_lookup(l0, name);
  if vr.found {
    if expected != -1 && vr.ty != expected { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: vr.ty, err: TcError.None };
  }

  // Const reference.
  let ni: NamedConstImport = find_named_const(imps.named_consts, name);
  let want_mod: String = if ni.local != "" { ni.mod_path } else { mod_path };
  let want_name: String = if ni.local != "" { ni.name } else { name };
  let cs: ConstSig = find_const(ctx, want_mod, want_name);
  if cs.name == "" { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if want_mod != mod_path && !cs.is_pub { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if expected != -1 && cs.ty != expected { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: cs.ty, err: TcError.None };
}

fn tc_expr_unary(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, op: ast.UnaryOp, a: i32, expected: i32) -> ExprTyResult {
  let ar: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, a, -1);
  if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let is_not: bool = match op { ast.UnaryOp.Not => true, _ => false };
  if is_not {
    if expected != -1 && expected != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_bool, err: TcError.None };
  }
  if expected != -1 && expected != ar.ty { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: ar.ty, err: TcError.None };
}

fn is_int_ty(ctx: Ctx, ty: i32) -> bool { return ty == ctx.ty_i32 || ty == ctx.ty_i64; }

fn enum_unit_tag_in_enum(ctx: Ctx, enum_ty: i32, var_name: String) -> i32 {
  let et: ir.Ty = ir.ty_pool_get(ctx.pool, enum_ty);
  if et.kind != ir.TyKind.Enum { return -1; }
  let fe: FindEnumResult = find_enum(ctx, ty_mod(et), ty_name(et));
  if !fe.found { return -1; }
  let es: EnumSig = fe.sig;
  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != 0 { return -1; }
      return vi;
    }
    vi = vi + 1;
  }
  return -1;
}

fn is_enum_unit_value(ctx: Ctx, mod_path: String, imps: Imports, exprs: ast.ExprPool, id: i32, enum_ty: i32) -> bool {
  if !is_enum_ty(ctx, enum_ty) { return false; }
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);
  if match n { ast.ExprNode.DotIdent(_x) => true, _ => false } {
    let name: String = match n { ast.ExprNode.DotIdent(s) => s, _ => "" };
    return enum_unit_tag_in_enum(ctx, enum_ty, name) != -1;
  }
  if match n { ast.ExprNode.Call(_c, _targs, _args) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(c, _targs, _args) => c, _ => -1 };
    let targs: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_c, ta, _args) => ta, _ => Vec() };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _ta, a) => a, _ => Vec() };
    if targs.len() == 0 && args.len() == 0 { return is_enum_unit_value(ctx, mod_path, imps, exprs, callee, enum_ty); }
    return false;
  }
  if !match n { ast.ExprNode.Member(_recv, _name) => true, _ => false } { return false; }

  // Only treat path-like member chains as enum unit values (e.g. `E.None` / `alias.E.None`).
  let recv: i32 = match n { ast.ExprNode.Member(r, _name) => r, _ => -1 };
  let name: String = match n { ast.ExprNode.Member(_r, s) => s, _ => "" };
  let pr: ExprPartsResult = expr_parts(exprs, recv);
  if !pr.ok { return false; }
  let mut parts: Vec[String] = pr.parts;
  parts.push(name);
  if parts.len() != 2 && parts.len() != 3 { return false; }

  // Ensure it resolves to the same enum type (avoid accidentally accepting field access that happens to share a name).
  let want_et: ir.Ty = ir.ty_pool_get(ctx.pool, enum_ty);
  let want_mod: String = ty_mod(want_et);
  let want_name: String = ty_name(want_et);

  let mut enum_mod: String = "";
  let mut enum_name: String = "";
  if parts.len() == 2 {
    enum_mod = mod_path;
    enum_name = parts.get(0);
    let ni: NamedTypeImport = find_named_type(imps.named_types, enum_name);
    if ni.local != "" {
      if ni.kind != named_type_kind_enum() { return false; }
      enum_mod = ni.mod_path;
      enum_name = ni.name;
    }
  } else {
    enum_mod = find_alias(imps.aliases, parts.get(0));
    if enum_mod == "" { return false; }
    enum_name = parts.get(1);
  }
  if enum_mod != want_mod || enum_name != want_name { return false; }

  let var_name: String = if parts.len() == 2 { parts.get(1) } else { parts.get(2) };
  return enum_unit_tag_in_enum(ctx, enum_ty, var_name) != -1;
}

fn tc_expr_binary(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, op: ast.BinaryOp, l: i32, r: i32, expected: i32) -> ExprTyResult {
  // bool results
  let is_cmp: bool = match op { ast.BinaryOp.Lt => true, ast.BinaryOp.Le => true, ast.BinaryOp.Gt => true, ast.BinaryOp.Ge => true, _ => false };
  let is_eq: bool = match op { ast.BinaryOp.Eq => true, ast.BinaryOp.Ne => true, _ => false };
  let is_logic: bool = match op { ast.BinaryOp.AndAnd => true, ast.BinaryOp.OrOr => true, _ => false };

  // Use the result expected type as a hint for operand typing when it is an int type.
  // This matters for cases like `0 - some_i64` where `0` would otherwise default to i32.
  let mut want_int: i32 = -1;
  if expected != -1 {
    let et: ir.Ty = ir.ty_pool_get(ctx.pool, expected);
    let is_int: bool = match et.kind { ir.TyKind.I32 => true, ir.TyKind.I64 => true, _ => false };
    if is_int { want_int = expected; }
  }
  let l_expected: i32 = if is_logic { ctx.ty_bool } else { want_int };
  let r_expected0: i32 = if is_logic { ctx.ty_bool } else { want_int };

  let mut lr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, l, l_expected);
  if !lr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let mut rr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, r, r_expected0);
  if !rr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  // If one side is an `i64` and the other is an int literal that defaulted to `i32`,
  // re-typecheck the literal with an `i64` expected type.
  if (is_cmp || is_eq || !is_logic) && lr.ty != rr.ty {
    let l_is_lit: bool = match ast.expr_pool_get(exprs, l) { ast.ExprNode.Int(_s) => true, _ => false };
    let r_is_lit: bool = match ast.expr_pool_get(exprs, r) { ast.ExprNode.Int(_s) => true, _ => false };

    if l_is_lit && rr.ty == ctx.ty_i64 {
      lr = tc_expr(ctx, w, mod_path, imps, exprs, l0, l, ctx.ty_i64);
    } else if r_is_lit && lr.ty == ctx.ty_i64 {
      rr = tc_expr(ctx, w, mod_path, imps, exprs, l0, r, ctx.ty_i64);
    }
    if !lr.ok || !rr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  }

  if is_logic {
    if lr.ty != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_bool, err: TcError.None };
  }

  if is_cmp {
    if !is_int_ty(ctx, lr.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if rr.ty != lr.ty { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_bool, err: TcError.None };
  }

  if is_eq {
    if rr.ty != lr.ty { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    // v0: primitive equality only (keep Stage1 aligned with Stage0 subset).
    let ok_prim: bool = lr.ty == ctx.ty_bool || lr.ty == ctx.ty_i32 || lr.ty == ctx.ty_i64 || lr.ty == ctx.ty_string;
    if !ok_prim {
      // Stage0 parity: enum equality is only allowed against unit variant values (lowers to tag compare).
      if is_enum_ty(ctx, lr.ty) {
        let ok_unit: bool = is_enum_unit_value(ctx, mod_path, imps, exprs, l, lr.ty) || is_enum_unit_value(ctx, mod_path, imps, exprs, r, lr.ty);
        if !ok_unit { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      } else {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
      }
    }
    if expected != -1 && expected != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_bool, err: TcError.None };
  }

  // arithmetic
  if !is_int_ty(ctx, lr.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if rr.ty != lr.ty { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if expected != -1 && expected != lr.ty { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: lr.ty, err: TcError.None };
}

fn tc_expr_if(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, c: i32, t: i32, e: i32, expected: i32) -> ExprTyResult {
  let cr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, c, ctx.ty_bool);
  if !cr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if cr.ty != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  let want: i32 = expected;
  let tr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, t, want);
  if !tr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, e, want);
  if !er.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  let out_ty: i32 = if expected != -1 { expected } else { tr.ty };
  if expected == -1 && tr.ty != er.ty { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
}
