import "ast" as ast
import "ir" as ir

// Stage1 typecheck (v0): minimal expression typing used by tc_fn.vox.
// This module intentionally stays small; we will expand it with TDD when typecheck
// becomes part of Stage1's critical path.

struct ExprTyResult { ok: bool, ty: i32 }

fn tc_expr(ctx: Ctx, w: World, mod_path: String, aliases: Vec[ImportAlias], exprs: ast.ExprPool, l0: Locals, id: i32, expected: i32) -> ExprTyResult {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);

  // If the caller already knows what type it expects, accept it eagerly.
  // This keeps Stage1's early typecheck usable even before we implement full inference.
  if expected != -1 {
    // Still do a shallow check for obvious mismatches on literals and known locals.
    return match n {
      ast.ExprNode.Int(_) => ExprTyResult { ok: true, ty: expected },
      ast.ExprNode.Str(_) => ExprTyResult { ok: true, ty: expected },
      ast.ExprNode.Bool(_) => ExprTyResult { ok: true, ty: expected },
      ast.ExprNode.Ident(name) => tc_expr_ident_expected(ctx, l0, name, expected),
      _ => ExprTyResult { ok: true, ty: expected },
    };
  }

  return match n {
    ast.ExprNode.Int(_) => ExprTyResult { ok: true, ty: ctx.ty_i32 },
    ast.ExprNode.Str(_) => ExprTyResult { ok: true, ty: ctx.ty_string },
    ast.ExprNode.Bool(_) => ExprTyResult { ok: true, ty: ctx.ty_bool },
    ast.ExprNode.Ident(name) => tc_expr_ident(ctx, l0, name),

    // v0: conservatively assume unary/binary yield primitive results.
    ast.ExprNode.Unary(op, a) => tc_expr_unary(ctx, w, mod_path, aliases, exprs, l0, op, a),
    ast.ExprNode.Binary(_, l, r) => tc_expr_binary(ctx, w, mod_path, aliases, exprs, l0, l, r),

    // Calls/members/struct literals/match: implemented later (keep build green for now).
    ast.ExprNode.Member(recv, name) => tc_expr_member_stub(ctx, w, mod_path, aliases, exprs, l0, recv, name),
    ast.ExprNode.Call(_, _) => ExprTyResult { ok: true, ty: ctx.ty_bad },
    ast.ExprNode.StructLit(_, _) => ExprTyResult { ok: true, ty: ctx.ty_bad },
    ast.ExprNode.Match(_, _) => ExprTyResult { ok: true, ty: ctx.ty_bad },
  };
}

fn tc_expr_ident_expected(ctx: Ctx, l0: Locals, name: String, expected: i32) -> ExprTyResult {
  let vr: LookupVarResult = locals_lookup(l0, name);
  if vr.found && vr.ty != expected { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
  return ExprTyResult { ok: true, ty: expected };
}

fn tc_expr_ident(ctx: Ctx, l0: Locals, name: String) -> ExprTyResult {
  let vr: LookupVarResult = locals_lookup(l0, name);
  if vr.found { return ExprTyResult { ok: true, ty: vr.ty }; }
  return ExprTyResult { ok: false, ty: ctx.ty_bad };
}

fn tc_expr_unary(ctx: Ctx, w: World, mod_path: String, aliases: Vec[ImportAlias], exprs: ast.ExprPool, l0: Locals, op: ast.UnaryOp, a: i32) -> ExprTyResult {
  let ar: ExprTyResult = tc_expr(ctx, w, mod_path, aliases, exprs, l0, a, -1);
  if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
  let is_not: bool = match op { ast.UnaryOp.Not => true, _ => false };
  if is_not { return ExprTyResult { ok: true, ty: ctx.ty_bool }; }
  return ExprTyResult { ok: true, ty: ar.ty };
}

fn tc_expr_binary(ctx: Ctx, w: World, mod_path: String, aliases: Vec[ImportAlias], exprs: ast.ExprPool, l0: Locals, l: i32, r: i32) -> ExprTyResult {
  let lr: ExprTyResult = tc_expr(ctx, w, mod_path, aliases, exprs, l0, l, -1);
  if !lr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
  let rr: ExprTyResult = tc_expr(ctx, w, mod_path, aliases, exprs, l0, r, lr.ty);
  if !rr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad }; }
  return ExprTyResult { ok: true, ty: lr.ty };
}

fn tc_expr_member_stub(ctx: Ctx, w: World, mod_path: String, aliases: Vec[ImportAlias], exprs: ast.ExprPool, l0: Locals, recv: i32, name: String) -> ExprTyResult {
  let _r: ExprTyResult = tc_expr(ctx, w, mod_path, aliases, exprs, l0, recv, -1);
  let _n: String = name;
  return ExprTyResult { ok: true, ty: ctx.ty_bad };
}
