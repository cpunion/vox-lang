import "ast" as ast
import "ir" as ir

fn struct_path_matches_expected(ctx: Ctx, path_mod: String, path_name: String, expected: i32) -> bool {
  if expected == -1 { return false; }
  let eb: i32 = strip_range(ctx, expected);
  if !is_struct_ty(ctx, eb) { return false; }

  let et: ir.Ty = ir.ty_pool_get(ctx.pool, eb);
  if path_mod != ty_mod(et) { return false; }

  let fs: FindStructResult = find_struct(ctx, ty_mod(et), ty_name(et));
  if !fs.found { return false; }
  return path_name == fs.sig.base_name || path_name == fs.sig.name;
}

fn tc_expr_struct_lit(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, ty_expr: i32, fields: Vec[ast.StructLitField], expected: i32) -> ExprTyResult {
  let mut struct_ty: i32 = -1;
  let mut struct_mod: String = "";
  let mut struct_name: String = "";
  let mut has_named_path: bool = false;

  let pr: ExprTypePathResult = expr_type_path(exprs, ty_expr);
  if pr.ok {
    has_named_path = true;
    let ps: Vec[String] = pr.parts;
    if ps.len() != 1 && ps.len() != 2 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

    if ps.len() == 1 {
      struct_mod = mod_path;
      struct_name = ps.get(0);
      let nt: NamedTypeImport = find_named_type(imps.named_types, struct_name);
      if nt.local != "" {
        if nt.kind != named_type_kind_struct() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        struct_mod = nt.mod_path;
        struct_name = nt.name;
      }
    } else {
      struct_mod = find_alias(imps.aliases, ps.get(0));
      if struct_mod == "" { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      struct_name = ps.get(1);
    }

    if pr.targs.len() != 0 {
      let tn: ast.TypeName = ast.TypeName { parts: ps, args: pr.targs };
      let tr: ResolveTyResult = resolve_type(ctx, w, mod_path, imps, l0.type_params, tn);
      if !tr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      if tr.idx < 0 || tr.idx >= ctx.pool.tys.len() { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      if !is_struct_ty(ctx, tr.idx) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      struct_ty = tr.idx;
      let t0: ir.Ty = ir.ty_pool_get(ctx.pool, tr.idx);
      struct_mod = ty_mod(t0);
      struct_name = ty_name(t0);
    } else {
      struct_ty = find_struct_ty_idx(ctx, struct_mod, struct_name);
      if struct_ty == -1 && struct_path_matches_expected(ctx, struct_mod, struct_name, expected) {
        let eb: i32 = strip_range(ctx, expected);
        struct_ty = eb;
        let et: ir.Ty = ir.ty_pool_get(ctx.pool, eb);
        struct_mod = ty_mod(et);
        struct_name = ty_name(et);
      }
    }
  }

  if struct_ty == -1 {
    if !has_named_path && expected != -1 && is_struct_ty(ctx, strip_range(ctx, expected)) {
      let eb: i32 = strip_range(ctx, expected);
      struct_ty = eb;
      let t: ir.Ty = ir.ty_pool_get(ctx.pool, eb);
      struct_mod = ty_mod(t);
      struct_name = ty_name(t);
    } else {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
    }
  }

  // Validate the struct exists and is visible.
  let fs: FindStructResult = find_struct(ctx, struct_mod, struct_name);
  if !fs.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let sig: StructSig = fs.sig;
  if !vis_allows(sig.vis, struct_mod, mod_path) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  // v0: require all fields are provided exactly once, and no extra fields.
  if fields.len() != sig.fields.len() {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
  }

  let mut i: i32 = 0;
  while i < fields.len() {
    let f: ast.StructLitField = fields.get(i);

    // Find field declaration.
    let mut found: bool = false;
    let mut want: i32 = ctx.ty_bad;
    let mut fvis: i32 = ast.vis_private();
    let mut fi: i32 = 0;
    while fi < sig.fields.len() {
      let sf: StructFieldSig = sig.fields.get(fi);
      if sf.name == f.name {
        found = true;
        want = sf.ty;
        fvis = sf.vis;
      }
      fi = fi + 1;
    }
    if !found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if !vis_allows(fvis, struct_mod, mod_path) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

    let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, f.expr, want);
    if !er.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if !assignable_to(ctx, want, er.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

    i = i + 1;
  }

  if expected != -1 && expected != struct_ty { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: struct_ty, err: TcError.None };
}
