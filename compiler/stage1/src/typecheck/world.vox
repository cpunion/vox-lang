import "ast" as ast

struct FindModResult { found: bool, idx: i32 }

fn find_mod(w: World, path: String) -> FindModResult {
  let ms: Vec[WorldModule] = w.mods;
  let mut i: i32 = 0;
  while i < ms.len() {
    if ms.get(i).path == path {
      return FindModResult { found: true, idx: i };
    }
    i = i + 1;
  }
  return FindModResult { found: false, idx: -1 };
}

pub struct ImportAlias {
  pub alias: String,
  pub path: String,
}

pub struct ImportAliasesResult {
  pub ok: bool,
  pub err: TcError,
  pub aliases: Vec[ImportAlias],
}

fn ok_aliases(xs: Vec[ImportAlias]) -> ImportAliasesResult {
  return ImportAliasesResult { ok: true, err: TcError.None, aliases: xs };
}

fn err_aliases(msg: String) -> ImportAliasesResult {
  return ImportAliasesResult { ok: false, err: TcError.Msg(msg), aliases: Vec() };
}

fn last_path_seg(path: String) -> String {
  let n: i32 = path.len();
  let mut i: i32 = n - 1;
  while i >= 0 {
    if path.byte_at(i) == 47 { // '/'
      return path.slice(i + 1, n);
    }
    i = i - 1;
  }
  return path;
}

fn contains_str(vs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < vs.len() {
    if vs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

pub fn build_import_aliases(imps: Vec[ast.ImportDecl], file: String) -> ImportAliasesResult {
  let mut out: Vec[ImportAlias] = Vec();
  let mut seen: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < imps.len() {
    let imp: ast.ImportDecl = imps.get(i);
    if imp.file != file { i = i + 1; continue; }
    let alias: String = if imp.alias == "" { last_path_seg(imp.path) } else { imp.alias };
    if contains_str(seen, alias) {
      return err_aliases("duplicate import alias: ".concat(alias));
    }
    seen.push(alias);
    out.push(ImportAlias { alias: alias, path: imp.path });
    i = i + 1;
  }
  return ok_aliases(out);
}

pub fn find_alias(aliases: Vec[ImportAlias], name: String) -> String {
  let mut i: i32 = 0;
  while i < aliases.len() {
    let a: ImportAlias = aliases.get(i);
    if a.alias == name { return a.path; }
    i = i + 1;
  }
  return "";
}
