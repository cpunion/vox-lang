import "ast" as ast

pub enum TcError {
  None,
  Msg(String),
}

pub struct TcResult {
  pub ok: bool,
  pub err: TcError,
}

pub struct WorldModule {
  pub path: String,
  pub prog: ast.Program,
}

pub struct World {
  pub mods: Vec[WorldModule],
}

pub fn world() -> World { return World { mods: Vec() }; }

pub fn world_add(w: World, path: String, prog: ast.Program) -> World {
  let mut q: World = w;
  q.mods.push(WorldModule { path: path, prog: prog });
  return q;
}

pub fn typecheck_world(w: World) -> TcResult {
  let br: BuildCtxResult = build_ctx(w);
  if !br.ok { return TcResult { ok: false, err: br.err }; }
  let c: Ctx = br.ctx;

  // Typecheck bodies for non-generic functions.
  let mut mi2: i32 = 0;
  while mi2 < w.mods.len() {
    let m2: WorldModule = w.mods.get(mi2);
    let mut fi2: i32 = 0;
    while fi2 < m2.prog.funcs.len() {
      let fd: ast.FuncDecl = m2.prog.funcs.get(fi2);
      if fd.type_params.len() != 0 {
        fi2 = fi2 + 1;
        continue;
      }
      let ar: ImportAliasesResult = build_import_aliases(m2.prog.imports, fd.file);
      if !ar.ok { return TcResult { ok: false, err: ar.err }; }
      let aliases: Vec[ImportAlias] = ar.aliases;
      let fr: TcResult = typecheck_fn(c, w, m2.path, aliases, m2.prog.exprs, fd);
      if !fr.ok { return fr; }
      fi2 = fi2 + 1;
    }
    mi2 = mi2 + 1;
  }

  return TcResult { ok: true, err: TcError.None };
}

pub struct BuildCtxResult {
  pub ok: bool,
  pub err: TcError,
  pub ctx: Ctx,
}

pub fn build_ctx(w: World) -> BuildCtxResult {
  // Validate that all imported modules exist.
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let imps: Vec[ast.ImportDecl] = m.prog.imports;
    let mut ii: i32 = 0;
    while ii < imps.len() {
      let imp: ast.ImportDecl = imps.get(ii);
      let fm: FindModResult = find_mod(w, imp.path);
      if !fm.found {
        return BuildCtxResult { ok: false, err: TcError.Msg("unknown local module import"), ctx: new_ctx() };
      }
      ii = ii + 1;
    }
    mi = mi + 1;
  }

  let mut c: Ctx = new_ctx();
  let r1: TcCtxResult = collect_structs(c, w);
  if !r1.ok { return BuildCtxResult { ok: false, err: r1.err, ctx: r1.ctx }; }
  c = r1.ctx;
  let r2: TcCtxResult = collect_enums(c, w);
  if !r2.ok { return BuildCtxResult { ok: false, err: r2.err, ctx: r2.ctx }; }
  c = r2.ctx;
  let r3: TcCtxResult = collect_funcs(c, w);
  if !r3.ok { return BuildCtxResult { ok: false, err: r3.err, ctx: r3.ctx }; }
  c = r3.ctx;
  return BuildCtxResult { ok: true, err: TcError.None, ctx: c };
}
