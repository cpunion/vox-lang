import "ast" as ast

pub enum TcError {
  None,
  Msg(String),
}

pub fn tc_error_to_string(e: TcError) -> String {
  return match e {
    TcError.None => "none",
    TcError.Msg(s) => s,
  };
}

// Minimal diagnostics formatting (v0): when span is unknown, fall back to 1:1.
// See docs/18-diagnostics.md.
pub fn diag1(file: String, msg: String) -> String {
  return file.concat(":1:1: ").concat(msg);
}

pub fn diag_span(sp: ast.Span, msg: String) -> String {
  if sp.file == "" { return diag1("", msg); }
  return sp.file.concat(":").concat(sp.line.to_string()).concat(":").concat(sp.col.to_string()).concat(": ").concat(msg);
}

fn type_error(file: String, msg: String) -> TcError {
  return TcError.Msg(diag1(file, "type error: ".concat(msg)));
}

fn import_error(file: String, msg: String) -> TcError {
  return TcError.Msg(diag1(file, "import error: ".concat(msg)));
}

pub fn irgen_error(file: String, msg: String) -> String {
  return diag1(file, "irgen error: ".concat(msg));
}

pub fn irgen_error_at(sp: ast.Span, msg: String) -> String {
  return diag_span(sp, "irgen error: ".concat(msg));
}

pub struct TcResult {
  pub ok: bool,
  pub err: TcError,
}

pub struct WorldModule {
  pub path: String,
  pub prog: ast.Program,
}

pub struct World {
  pub mods: Vec[WorldModule],
}

pub fn world() -> World { return World { mods: Vec() }; }

pub fn world_add(w: World, path: String, prog: ast.Program) -> World {
  let mut q: World = w;
  q.mods.push(WorldModule { path: path, prog: prog });
  return q;
}

pub fn typecheck_world(w: World) -> TcResult {
  let br: BuildCtxResult = build_ctx(w);
  if !br.ok { return TcResult { ok: false, err: br.err }; }
  let c: Ctx = br.ctx;

  // Typecheck bodies for non-generic functions.
  let mut mi2: i32 = 0;
  while mi2 < w.mods.len() {
    let m2: WorldModule = w.mods.get(mi2);
    let mut fi2: i32 = 0;
    while fi2 < m2.prog.funcs.len() {
      let fd: ast.FuncDecl = m2.prog.funcs.get(fi2);
      if fd.type_params.len() != 0 {
        fi2 = fi2 + 1;
        continue;
      }
      let ir: ImportsResult = build_imports(w, m2.path, m2.prog.imports, fd.file);
      if !ir.ok { return TcResult { ok: false, err: ir.err }; }
      let imps: Imports = ir.imps;
      let fr: TcResult = typecheck_fn(c, w, m2.path, imps, m2.prog.exprs, fd);
      if !fr.ok { return fr; }
      fi2 = fi2 + 1;
    }
    mi2 = mi2 + 1;
  }

  return TcResult { ok: true, err: TcError.None };
}

pub struct BuildCtxResult {
  pub ok: bool,
  pub err: TcError,
  pub ctx: Ctx,
}

pub fn build_ctx(w: World) -> BuildCtxResult {
  // Validate that all imported modules exist.
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let imps: Vec[ast.ImportDecl] = m.prog.imports;
    let mut ii: i32 = 0;
    while ii < imps.len() {
      let imp: ast.ImportDecl = imps.get(ii);
      let rr: ResolveImportResult = resolve_import_path(w, imp.file, imp.path);
      if !rr.ok { return BuildCtxResult { ok: false, err: rr.err, ctx: new_ctx() }; }
      let fm: FindModResult = find_mod(w, rr.path);
      if !fm.found {
        return BuildCtxResult { ok: false, err: import_error(imp.file, "unknown module import: ".concat(imp.path)), ctx: new_ctx() };
      }
      ii = ii + 1;
    }
    mi = mi + 1;
  }

  let mut c: Ctx = new_ctx();
  let r0: TcCtxResult = collect_type_aliases(c, w);
  if !r0.ok { return BuildCtxResult { ok: false, err: r0.err, ctx: r0.ctx }; }
  c = r0.ctx;
  let r00: TcCtxResult = collect_consts(c, w);
  if !r00.ok { return BuildCtxResult { ok: false, err: r00.err, ctx: r00.ctx }; }
  c = r00.ctx;
  let r1: TcCtxResult = collect_structs(c, w);
  if !r1.ok { return BuildCtxResult { ok: false, err: r1.err, ctx: r1.ctx }; }
  c = r1.ctx;
  let r2: TcCtxResult = collect_enums(c, w);
  if !r2.ok { return BuildCtxResult { ok: false, err: r2.err, ctx: r2.ctx }; }
  c = r2.ctx;
  let r3: TcCtxResult = collect_funcs(c, w);
  if !r3.ok { return BuildCtxResult { ok: false, err: r3.err, ctx: r3.ctx }; }
  c = r3.ctx;
  return BuildCtxResult { ok: true, err: TcError.None, ctx: c };
}
