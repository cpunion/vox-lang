// Decimal integer literal parsing helpers for stage1 toolchain.
//
// Note: lexer guarantees the token text is digits only, but these helpers are
// defensive and also perform range checks.

pub struct ParseI32DecResult { pub ok: bool, pub val: i32 }
pub struct ParseI64DecResult { pub ok: bool, pub val: i64 }

pub fn parse_i32_dec(s: String) -> ParseI32DecResult {
  if s.len() == 0 { return ParseI32DecResult { ok: false, val: 0 }; }
  let max: i32 = 2147483647;
  let mut n: i32 = 0;
  let mut i: i32 = 0;
  while i < s.len() {
    let b: i32 = s.byte_at(i);
    if b < 48 || b > 57 { return ParseI32DecResult { ok: false, val: 0 }; }
    let d: i32 = b - 48;
    // overflow check: n*10 + d <= max
    if n > (max - d) / 10 { return ParseI32DecResult { ok: false, val: 0 }; }
    n = n * 10 + d;
    i = i + 1;
  }
  return ParseI32DecResult { ok: true, val: n };
}

pub fn parse_i64_dec(s: String) -> ParseI64DecResult {
  if s.len() == 0 { return ParseI64DecResult { ok: false, val: 0 }; }
  let max: i64 = 9223372036854775807;
  let mut neg: bool = false;
  let mut n: i64 = 0;
  let mut i: i32 = 0;
  if s.byte_at(0) == 45 { // '-'
    neg = true;
    i = 1;
    if s.len() == 1 { return ParseI64DecResult { ok: false, val: 0 }; }
  }
  while i < s.len() {
    let b: i32 = s.byte_at(i);
    if b < 48 || b > 57 { return ParseI64DecResult { ok: false, val: 0 }; }
    // Avoid implicit casts and avoid `match` on i32 (stage0 interp only supports enum match).
    let mut d: i64 = 0;
    if b == 48 { d = 0; }
    else if b == 49 { d = 1; }
    else if b == 50 { d = 2; }
    else if b == 51 { d = 3; }
    else if b == 52 { d = 4; }
    else if b == 53 { d = 5; }
    else if b == 54 { d = 6; }
    else if b == 55 { d = 7; }
    else if b == 56 { d = 8; }
    else { d = 9; }
    // overflow check: n*10 + d <= max
    if n > (max - d) / 10 { return ParseI64DecResult { ok: false, val: 0 }; }
    n = n * 10 + d;
    i = i + 1;
  }
  if neg { return ParseI64DecResult { ok: true, val: -n }; }
  return ParseI64DecResult { ok: true, val: n };
}
