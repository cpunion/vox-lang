import "std/testing" as t
import "parse" as p
import "typecheck" as tc

fn add_mod2(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn test_typecheck_allows_generic_fn_sig() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", "fn id[T](x: T) -> T { return x; }\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(r.ok);
}

fn test_typecheck_generic_call_infers_vec_return() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", "fn mk[T](x: T) -> Vec[T] { return Vec(); }\nfn main() -> i32 { let v = mk(1); return v.len(); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(r.ok);
}

fn test_typecheck_generic_trait_bound_satisfied() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }\nfn main() -> i32 { return if same(1, 1) { 1 } else { 0 }; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(r.ok);
}

fn test_typecheck_generic_trait_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }\nfn main() -> i32 { return if same(\"a\", \"b\") { 1 } else { 0 }; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.len() > 0);
}

fn test_typecheck_generic_where_trait_bound_satisfied() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn same[T](a: T, b: T) -> bool where T: Eq { return Eq.eq(a, b); }\nfn main() -> i32 { return if same(1, 1) { 1 } else { 0 }; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(r.ok);
}

fn test_typecheck_generic_where_trait_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn same[T](a: T, b: T) -> bool where T: Eq { return Eq.eq(a, b); }\nfn main() -> i32 { return if same(\"a\", \"b\") { 1 } else { 0 }; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!r.ok);
}
