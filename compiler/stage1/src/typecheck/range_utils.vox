import "ir" as ir

// Range types are refined integer types: `@range(lo..=hi) Base`.
// Stage1 v0 rule: a range is assignable to its base (widening only).

pub fn is_range_ty(ctx: Ctx, ty: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty);
  return t.kind == ir.TyKind.Range;
}

pub fn strip_range(ctx: Ctx, ty: i32) -> i32 {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty);
  if t.kind == ir.TyKind.Range { return t.elem; }
  return ty;
}

pub fn assignable_to(ctx: Ctx, want: i32, got: i32) -> bool {
  if want == got { return true; }
  let gt: ir.Ty = ir.ty_pool_get(ctx.pool, got);
  if gt.kind == ir.TyKind.Range && gt.elem == want { return true; }
  return false;
}

pub fn is_int_like_ty(ctx: Ctx, ty: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty);
  let is_int_scalar: bool = match t.kind {
    ir.TyKind.I8 => true,
    ir.TyKind.U8 => true,
    ir.TyKind.I16 => true,
    ir.TyKind.U16 => true,
    ir.TyKind.I32 => true,
    ir.TyKind.U32 => true,
    ir.TyKind.I64 => true,
    ir.TyKind.U64 => true,
    ir.TyKind.ISize => true,
    ir.TyKind.USize => true,
    _ => false,
  };
  if is_int_scalar { return true; }
  if t.kind != ir.TyKind.Range { return false; }
  let bt: ir.Ty = ir.ty_pool_get(ctx.pool, t.elem);
  return match bt.kind {
    ir.TyKind.I8 => true,
    ir.TyKind.U8 => true,
    ir.TyKind.I16 => true,
    ir.TyKind.U16 => true,
    ir.TyKind.I32 => true,
    ir.TyKind.U32 => true,
    ir.TyKind.I64 => true,
    ir.TyKind.U64 => true,
    ir.TyKind.ISize => true,
    ir.TyKind.USize => true,
    _ => false,
  };
}

pub fn is_i32_like(ctx: Ctx, ty: i32) -> bool { return strip_range(ctx, ty) == ctx.ty_i32; }
pub fn is_i64_like(ctx: Ctx, ty: i32) -> bool { return strip_range(ctx, ty) == ctx.ty_i64; }
