import "std/testing" as t
import "parse" as p
import "typecheck" as tc

fn parse_prog(src: String) -> p.ParseResult { return p.parse_text(src); }

fn add_mod(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = parse_prog(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn ok(r: tc.TcResult) -> bool { return r.ok; }

fn test_typecheck_prelude_fallback() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub fn assert(cond: bool) -> () { return; }");
  w = add_mod(w, "main", "fn main() -> i32 { assert(true); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_import_alias_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub fn assert(cond: bool) -> () { return; }");
  w = add_mod(w, "std/testing", "import \"std/prelude\" as prelude\npub fn assert(cond: bool) -> () { prelude.assert(cond); return; }");
  w = add_mod(w, "main", "import \"std/testing\" as t\nfn main() -> i32 { t.assert(true); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_ifexpr_and_field_push() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct S { items: Vec[i32] }\nfn main() -> i32 {\n  let mut s: S = S { items: Vec() };\n  let x: i32 = if true { 40 } else { 0 };\n  s.items.push(x);\n  s.items.push(2);\n  return s.items.get(0) + s.items.get(1) + s.items.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_enum_ctor_and_match() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let x: E = E.A(1);\n  let y: i32 = match x { E.A(v) => v, E.None => 0, };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_enum_unit_equality_allows_if_condition() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let x: E = E.A(1);\n  if x == E.None { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_builtins_panic_print() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> () { print(\"hi\"); panic(\"bye\"); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_rejects_unknown_fn() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> i32 { nope(); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_rejects_vec_ctor_without_expected_ty() -> () {
  let mut w: tc.World = tc.world();
  // `Vec()` requires an expected `Vec[T]` type (e.g. from an annotation or struct field).
  w = add_mod(w, "main", "fn main() -> i32 { let v = Vec(); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}
