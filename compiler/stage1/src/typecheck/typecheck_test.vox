import "std/testing" as t
import "parse" as p
import "typecheck" as tc

fn parse_prog(src: String) -> p.ParseResult { return p.parse_text(src); }

fn add_mod(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = parse_prog(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn ok(r: tc.TcResult) -> bool { return r.ok; }

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn test_typecheck_prelude_fallback() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub fn assert(cond: bool) -> () { return; }");
  w = add_mod(w, "main", "fn main() -> i32 { assert(true); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_import_alias_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub fn assert(cond: bool) -> () { return; }");
  w = add_mod(w, "std/testing", "import \"std/prelude\" as prelude\npub fn assert(cond: bool) -> () { prelude.assert(cond); return; }");
  w = add_mod(w, "main", "import \"std/testing\" as t\nfn main() -> i32 { t.assert(true); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_ifexpr_and_field_push() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct S { items: Vec[i32] }\nfn main() -> i32 {\n  let mut s: S = S { items: Vec() };\n  let x: i32 = if true { 40 } else { 0 };\n  s.items.push(x);\n  s.items.push(2);\n  return s.items.get(0) + s.items.get(1) + s.items.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_cmp_u32_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: u32 = 1;\n  if x < 2 { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_i64_arith_coerces_int_lit_to_context() -> () {
  let mut w: tc.World = tc.world();
  // Regression: `0 - y` should typecheck under i64 context (self-hosting relies on this).
  let src: String = "fn main() -> i32 {\n  let y: i64 = 1;\n  let x: i64 = 0 - y;\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_i64_arith_coerces_int_lit_to_context_struct_field() -> () {
  let mut w: tc.World = tc.world();
  // Also cover the common `0 - s.iv` form.
  let src: String = "struct S { iv: i64 }\nfn main() -> i32 {\n  let s: S = S { iv: 1 };\n  let x: i64 = 0 - s.iv;\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_enum_ctor_and_match() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let x: E = E.A(1);\n  let y: i32 = match x { E.A(v) => v, E.None => 0, };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_u32_patterns_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u32) -> i32 {\n  let y: i32 = match x { 0 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_u8_patterns_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u8) -> i32 {\n  let y: i32 = match x { 0 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_i8_pat_literal_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i8) -> i32 {\n  let y: i32 = match x { 200 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_u8_pat_literal_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u8) -> i32 {\n  let y: i32 = match x { 300 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_negative_int_pattern_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  let y: i32 = match x { -1 => 0, _ => 1 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_negative_int_pattern_rejected_for_u8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u8) -> i32 {\n  let y: i32 = match x { -1 => 0, _ => 1 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_nested_variant_patterns_requires_variant_catchall() -> () {
  // Missing coverage for Ok(O.None).
  let mut w: tc.World = tc.world();
  let src: String = "enum O { Some(i32), None }\nenum R { Ok(O), Err(i32) }\nfn main(x: R) -> i32 {\n  return match x {\n    R.Ok(O.Some(v)) => v,\n    R.Err(_) => -1,\n  };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_nested_variant_patterns_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum O { Some(i32), None }\nenum R { Ok(O), Err(i32) }\nfn main(x: R) -> i32 {\n  return match x {\n    R.Ok(O.Some(v)) => v,\n    R.Ok(O.None) => 0,\n    R.Err(_) => -1,\n  };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_int_requires_wildcard() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  let y: i32 = match x { 0 => 1, 1 => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_rejects_unreachable_after_wildcard() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  let y: i32 = match x { _ => 0, 1 => 1 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_rejects_unreachable_after_enum_variant_fully_covered() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum O { Some(i32), None }\nenum R { Ok(O), Err(i32) }\nfn main(x: R) -> i32 {\n  return match x {\n    R.Ok(O.Some(v)) => v,\n    R.Ok(O.None) => 0,\n    R.Ok(_o) => 0,\n    R.Err(_) => -1,\n  };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_enum_unit_equality_allows_if_condition() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let x: E = E.A(1);\n  if x == E.None { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_builtins_panic_print() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> () { print(\"hi\"); panic(\"bye\"); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_rejects_unknown_fn() -> () {
  let mut w: tc.World = tc.world();
  // Put the error at a stable location: line 2, col 1.
  w = add_mod(w, "main", "fn main() -> i32 {\nnope();\nreturn 0;\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.slice(0, "src/main.vox:2:1:".len()) == "src/main.vox:2:1:");
  // We want a specific reason, not just "bad expr".
  t.assert(contains(msg, "unknown fn"));
  t.assert(contains(msg, "nope"));
}

fn test_typecheck_error_has_file_line_col_prefix() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> i32 {\nnope();\nreturn 0;\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.slice(0, "src/main.vox:2:1:".len()) == "src/main.vox:2:1:");
}

fn test_typecheck_rejects_vec_ctor_without_expected_ty() -> () {
  let mut w: tc.World = tc.world();
  // `Vec()` requires an expected `Vec[T]` type (e.g. from an annotation or struct field).
  w = add_mod(w, "main", "fn main() -> i32 {\nVec();\nreturn 0;\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec()"));
  t.assert(contains(msg, "expected"));
}

fn test_typecheck_wrong_number_of_args_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn f(x: i32) -> i32 { return x; }\nfn main() -> i32 {\n  return f(1, 2);\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "wrong number of args"));
  t.assert(contains(msg, "expected 1"));
  t.assert(contains(msg, "got 2"));
}

fn test_typecheck_type_alias_resolves() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type I = i32\ntype V = Vec[I]\nfn main() -> i32 {\n  let x: I = 1;\n  let mut v: V = Vec();\n  v.push(x);\n  return v.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_union_type_decl_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Value = I32: i32 | Str: String\nfn main() -> i32 {\n  let x: Value = .I32(1);\n  return match x { .I32(v) => v, .Str(_s) => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_decl_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = 1 + 2 * 3\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_named_import_const_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "pub const N: i32 = 7");
  w = add_mod(w, "main", "import { N } from \"dep\"\nfn main() -> i32 { return N; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = 1 as i32\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_cast_overflow_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = 3000000000 as i32\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "i64 to i32 overflow"));
}

fn test_typecheck_range_widening_allows_range_to_base() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i32\nfn main() -> i32 {\n  let x: Tiny = 1 as Tiny;\n  let y: i32 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_i8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i8\nfn main() -> i8 {\n  let x: Tiny = 1 as Tiny;\n  let y: i8 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_u32() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u32\nfn main() -> u32 {\n  let x: Tiny = 1 as Tiny;\n  let y: u32 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_u8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u8\nfn main() -> u8 {\n  let x: Tiny = 1 as Tiny;\n  let y: u8 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_u64() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u64\nfn main() -> u64 {\n  let x: Tiny = 1 as Tiny;\n  let y: u64 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_usize() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) usize\nfn main() -> usize {\n  let x: Tiny = 1 as Tiny;\n  let y: usize = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_requires_explicit_cast_from_base() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i32\nfn main() -> i32 { let x: Tiny = 1; return x as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "integer literal requires expected scalar int"));
}

fn test_typecheck_range_requires_explicit_cast_from_base_i8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i8\nfn main() -> i8 { let x: Tiny = 1; return x as i8; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "integer literal requires expected scalar int"));
}

fn test_typecheck_range_requires_explicit_cast_from_base_u8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u8\nfn main() -> u8 { let x: Tiny = 1; return x as u8; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "integer literal requires expected scalar int"));
}

fn test_typecheck_const_range_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i32\nconst N: Tiny = 2 as Tiny\nfn main() -> i32 { return N as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_range_cast_smoke_u32() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u32\nconst N: Tiny = 2 as Tiny\nfn main() -> u32 { return N as u32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_range_cast_smoke_usize() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) usize\nconst N: Tiny = 2 as Tiny\nfn main() -> usize { return N as usize; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_range_cast_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i32\nconst N: Tiny = 5 as Tiny\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "range check failed"));
}

fn test_typecheck_const_range_cast_rejected_i8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i8\nconst N: Tiny = 5 as Tiny\nfn main() -> i8 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "range check failed"));
}

fn test_typecheck_const_range_cast_rejected_u8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u8\nconst N: Tiny = 5 as Tiny\nfn main() -> u8 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "range check failed"));
}
