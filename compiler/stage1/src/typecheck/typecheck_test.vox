import "std/testing" as t
import "parse" as p
import "typecheck" as tc

fn parse_prog(src: String) -> p.ParseResult { return p.parse_text(src); }

fn add_mod(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = parse_prog(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn ok(r: tc.TcResult) -> bool { return r.ok; }

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn test_typecheck_prelude_fallback() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub fn assert(cond: bool) -> () { return; }");
  w = add_mod(w, "main", "fn main() -> i32 { assert(true); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_prelude_trait_static_call_fallback() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }");
  w = add_mod(w, "main", "fn main() -> i32 { if Eq.eq(1, 1) { return 1; } return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_impl_uses_prelude_trait_without_import() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Show { fn show(x: Self) -> String; }");
  w = add_mod(w, "main", "struct I { v: i32 }\nimpl Show for I { fn show(x: I) -> String { return \"ok\"; } }\nfn main() -> i32 { let s: String = Show.show(I { v: 1 }); return s.len(); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_impl_uses_prelude_trait_default_method_without_import() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "fn tag() -> String { return \"pre\"; }\npub trait Show { fn show(x: Self) -> String { return tag(); } }");
  w = add_mod(w, "main", "struct I { v: i32 }\nimpl Show for I {}\nfn main() -> i32 { let s: String = I { v: 1 }.show(); return s.len(); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_import_alias_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub fn assert(cond: bool) -> () { return; }");
  w = add_mod(w, "std/testing", "import \"std/prelude\" as prelude\npub fn assert(cond: bool) -> () { prelude.assert(cond); return; }");
  w = add_mod(w, "main", "import \"std/testing\" as t\nfn main() -> i32 { t.assert(true); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_testing_assert_ne_wrapper_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\npub fn assert_ne[T: Eq](a: T, b: T) -> () { if a == b { panic(\"assertion failed\"); } }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }");
  w = add_mod(w, "std/testing", "import \"std/prelude\" as prelude\npub fn assert_ne[T: prelude.Eq](a: T, b: T) -> () { prelude.assert_ne(a, b); }");
  w = add_mod(w, "main", "import \"std/testing\" as t\nfn main() -> i32 { t.assert_ne(1, 2); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_testing_assert_lt_wrapper_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Ord { fn lt(a: Self, b: Self) -> bool; }\npub fn assert_lt[T: Ord](a: T, b: T) -> () { if a < b { return; } panic(\"assertion failed\"); }\nimpl Ord for i32 { fn lt(a: i32, b: i32) -> bool { return a < b; } }");
  w = add_mod(w, "std/testing", "import \"std/prelude\" as prelude\npub fn assert_lt[T: prelude.Ord](a: T, b: T) -> () { prelude.assert_lt(a, b); }");
  w = add_mod(w, "main", "import \"std/testing\" as t\nfn main() -> i32 { t.assert_lt(1, 2); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_io_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/io", "pub fn out(msg: String) -> () { print(msg); }\npub fn out_ln(msg: String) -> () { print(msg); print(\"\\n\"); }\npub fn fail(msg: String) -> () { panic(msg); }");
  w = add_mod(w, "main", "import \"std/io\" as io\nfn main() -> i32 { io.out(\"x\"); io.out_ln(\"y\"); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_sync_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/sync", "pub struct MutexI32 { value: i32 }\npub fn mutex_i32(v: i32) -> MutexI32 { return MutexI32 { value: v }; }\npub fn mutex_i32_into_inner(m: MutexI32) -> i32 { return m.value; }\npub struct AtomicI32 { value: i32 }\npub fn atomic_i32(v: i32) -> AtomicI32 { return AtomicI32 { value: v }; }\npub fn atomic_i32_load(a: AtomicI32) -> i32 { return a.value; }\npub fn atomic_i32_store(a: AtomicI32, v: i32) -> AtomicI32 { let mut out: AtomicI32 = a; out.value = v; return out; }\npub fn atomic_i32_fetch_add(a: AtomicI32, delta: i32) -> AtomicI32 { let mut out: AtomicI32 = a; out.value = out.value + delta; return out; }");
  w = add_mod(w, "main", "import \"std/sync\" as s\nfn main() -> i32 { let m: s.MutexI32 = s.mutex_i32(7); let x: i32 = s.mutex_i32_into_inner(m); let mut a: s.AtomicI32 = s.atomic_i32(1); a = s.atomic_i32_fetch_add(a, 2); a = s.atomic_i32_store(a, 4); return x + s.atomic_i32_load(a); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_ifexpr_and_field_push() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct S { items: Vec[i32] }\nfn main() -> i32 {\n  let mut s: S = S { items: Vec() };\n  let x: i32 = if true { 40 } else { 0 };\n  s.items.push(x);\n  s.items.push(2);\n  return s.items.get(0) + s.items.get(1) + s.items.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_nested_field_assign_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct I { x: i32 }\nstruct O { i: I }\nfn main() -> i32 {\n  let mut o: O = O { i: I { x: 1 } };\n  o.i.x = 2;\n  o.i.x += 3;\n  return o.i.x;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_cmp_u32_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: u32 = 1;\n  if x < 2 { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_float_arith_compare_and_to_string_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: f64 = 1.25;\n  let y: f64 = x + 2.75;\n  let s: String = y.to_string();\n  if y > 3.0 && s.len() > 0 { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_float_mod_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: f64 = 5.5 % 2.0;\n  if x > 1.0 { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_string_ordered_compare_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  if \"ab\" < \"ac\" { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_string_to_string_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let s: String = \"vox\";\n  let t2: String = s.to_string();\n  return t2.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_float_cast_f64_to_f32_and_back_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: f64 = 1.5;\n  let y: f32 = x as f32;\n  let z: f64 = y as f64;\n  if z >= 1.0 { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_int_float_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: i32 = 7;\n  let y: f64 = x as f64;\n  let z: i32 = y as i32;\n  return z;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_float_scientific_and_suffix_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let a: f64 = 1e3;\n  let b: f32 = 2.5e-2f32;\n  let c: f64 = b as f64;\n  if a > c { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_float_suffix_conflict_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: f64 = 1.0f32;\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_i16_u16_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let a: i16 = -5;\n  let b: u16 = 7;\n  let x: i32 = (a as i32) + (b as i32);\n  return x;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_isize_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let a: isize = -5;\n  let x: i64 = a as i64;\n  return x as i32;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_bitwise_shift_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let a: i32 = 6 & 3;\n  let b: i32 = 1 << 4;\n  let c: i32 = b >> 2;\n  return (a | c) ^ 1;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_bitwise_bool_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let a: bool = true;\n  let b: bool = false;\n  let x: bool = a & b;\n  if x { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_unary_not_int_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: i32 = !1;\n  return x;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_unary_not_float_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: f64 = !1.0;\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_unary_plus_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: i32 = +1;\n  let y: f64 = +1.5;\n  if y > 1.0 { return x; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_compound_assign_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct S { x: i32 }\nfn main() -> i32 {\n  let mut x: i32 = 32;\n  x += 10;\n  x -= 2;\n  x *= 3;\n  x /= 5;\n  x %= 7;\n  x <<= 4;\n  x >>= 3;\n  x &= 3;\n  x |= 8;\n  x ^= 15;\n  let mut s: S = S { x: 32 };\n  s.x += 10;\n  s.x -= 2;\n  s.x *= 3;\n  s.x /= 5;\n  s.x %= 7;\n  s.x <<= 4;\n  s.x >>= 3;\n  s.x &= 3;\n  s.x |= 8;\n  s.x ^= 15;\n  return x + s.x;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_i64_arith_coerces_int_lit_to_context() -> () {
  let mut w: tc.World = tc.world();
  // Regression: `0 - y` should typecheck under i64 context (self-hosting relies on this).
  let src: String = "fn main() -> i32 {\n  let y: i64 = 1;\n  let x: i64 = 0 - y;\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_i64_arith_coerces_int_lit_to_context_struct_field() -> () {
  let mut w: tc.World = tc.world();
  // Also cover the common `0 - s.iv` form.
  let src: String = "struct S { iv: i64 }\nfn main() -> i32 {\n  let s: S = S { iv: 1 };\n  let x: i64 = 0 - s.iv;\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_enum_ctor_and_match() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let x: E = E.A(1);\n  let y: i32 = match x { E.A(v) => v, E.None => 0, };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_struct_instantiation_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Pair[T] { a: T, b: T }\nfn main() -> i32 {\n  let p: Pair[i32] = Pair { a: 1, b: 2 };\n  return p.a + p.b;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_enum_instantiation_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum Option[T] { Some(T), None }\nfn main() -> i32 {\n  let x: Option[i32] = Option.Some(7);\n  return match x { Option.Some(v) => v, Option.None => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_typed_path_struct_lit_without_expected_type() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Pair[T] { a: T, b: T }\nfn main() -> i32 {\n  let p = Pair[i32] { a: 1, b: 2 };\n  return p.a + p.b;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_typed_path_enum_ctor_and_unit_variant_without_expected_type() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum Option[T] { Some(T), None }\nfn main() -> i32 {\n  let a = Option[i32].Some(7);\n  let b = Option[i32].None;\n  let x: i32 = match a { Option.Some(v) => v, Option.None => 0 };\n  let y: i32 = match b { Option.Some(v) => v, Option.None => 1 };\n  return x + y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_nominal_requires_type_args() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Pair[T] { a: T, b: T }\nfn main() -> i32 {\n  let p: Pair = Pair { a: 1, b: 2 };\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_u32_patterns_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u32) -> i32 {\n  let y: i32 = match x { 0 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_u8_patterns_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u8) -> i32 {\n  let y: i32 = match x { 0 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_u64_max_pattern_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u64) -> i32 {\n  let y: i32 = match x { 18446744073709551615 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_i8_pat_literal_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i8) -> i32 {\n  let y: i32 = match x { 200 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_u8_pat_literal_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u8) -> i32 {\n  let y: i32 = match x { 300 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_negative_int_pattern_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  let y: i32 = match x { -1 => 0, _ => 1 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_negative_int_pattern_rejected_for_u8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u8) -> i32 {\n  let y: i32 = match x { -1 => 0, _ => 1 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_nested_variant_patterns_requires_variant_catchall() -> () {
  // Missing coverage for Ok(O.None).
  let mut w: tc.World = tc.world();
  let src: String = "enum O { Some(i32), None }\nenum R { Ok(O), Err(i32) }\nfn main(x: R) -> i32 {\n  return match x {\n    R.Ok(O.Some(v)) => v,\n    R.Err(_) => -1,\n  };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_nested_variant_patterns_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum O { Some(i32), None }\nenum R { Ok(O), Err(i32) }\nfn main(x: R) -> i32 {\n  return match x {\n    R.Ok(O.Some(v)) => v,\n    R.Ok(O.None) => 0,\n    R.Err(_) => -1,\n  };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_int_requires_wildcard() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  let y: i32 = match x { 0 => 1, 1 => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_bool_patterns_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: bool) -> i32 {\n  return match x { true => 1, false => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_bool_non_exhaustive_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: bool) -> i32 {\n  return match x { true => 1 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_rejects_unreachable_after_wildcard() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  let y: i32 = match x { _ => 0, 1 => 1 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_rejects_unreachable_after_enum_variant_fully_covered() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum O { Some(i32), None }\nenum R { Ok(O), Err(i32) }\nfn main(x: R) -> i32 {\n  return match x {\n    R.Ok(O.Some(v)) => v,\n    R.Ok(O.None) => 0,\n    R.Ok(_o) => 0,\n    R.Err(_) => -1,\n  };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_enum_unit_equality_allows_if_condition() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let x: E = E.A(1);\n  if x == E.None { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_enum_payload_equality_allows_if_condition() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let a: E = E.A(1);\n  let b: E = E.A(1);\n  if a == b { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_enum_payload_equality_rejects_non_eq_field() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(Vec[i32]), None }\nfn main() -> i32 {\n  let mut x: Vec[i32] = Vec();\n  let mut y: Vec[i32] = Vec();\n  let a: E = E.A(x);\n  let b: E = E.A(y);\n  return if a == b { 1 } else { 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_struct_equality_allows_if_condition() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct S { a: i32, b: String }\nfn main() -> i32 {\n  let x: S = S { a: 1, b: \"v\" };\n  let y: S = S { a: 1, b: \"v\" };\n  return if x == y { 1 } else { 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_struct_equality_rejects_non_eq_field() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct S { v: Vec[i32] }\nfn main() -> i32 {\n  let mut x: Vec[i32] = Vec();\n  let mut y: Vec[i32] = Vec();\n  let a: S = S { v: x };\n  let b: S = S { v: y };\n  return if a == b { 1 } else { 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_builtins_panic_print() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> () { print(\"hi\"); panic(\"bye\"); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_reflect_intrinsics_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type R = @range(0..=7) i32\nstruct S { a: i32, b: i64 }\nenum E { A(i32), B }\nconst SZ: usize = @size_of(S)\nconst AL: usize = @align_of(S)\nconst FC_S: usize = @field_count(S)\nconst FC_E: usize = @field_count(E)\nconst FN0: String = @field_name(S, 0)\nconst VN1: String = @field_name(E, 1)\nconst FT1: String = @field_type(S, 1)\nconst ET0: String = @field_type(E, 0)\nconst ET1: String = @field_type(E, 1)\nconst FTY1: TypeId = @field_type_id(S, 1)\nconst ETY0: TypeId = @field_type_id(E, 0)\nconst ETY1: TypeId = @field_type_id(E, 1)\nconst TY_S: TypeId = @type(S)\nconst TY_I32: TypeId = @type(i32)\nconst TY_I64: TypeId = @type(i64)\nconst TN: String = @type_name(S)\nconst EQTY: bool = @same_type(i32, i32)\nconst NETY: bool = @same_type(i32, i64)\nconst A0: bool = @assignable_to(R, i32)\nconst A1: bool = @assignable_to(i32, R)\nconst A2: bool = @assignable_to(i32, i32)\nconst C0: bool = @castable_to(i32, f64)\nconst C1: bool = @castable_to(String, i32)\nconst E2E0: bool = @eq_comparable_with(S, S)\nconst E2E1: bool = @eq_comparable_with(Vec[i32], Vec[i32])\nconst O2O0: bool = @ordered_with(String, String)\nconst O2O1: bool = @ordered_with(S, S)\nconst I0: bool = @is_integer(i32)\nconst I1: bool = @is_integer(S)\nconst SI: bool = @is_signed_int(i64)\nconst SU: bool = @is_unsigned_int(u64)\nconst F0: bool = @is_float(f64)\nconst B0: bool = @is_bool(bool)\nconst S0: bool = @is_string(String)\nconst ST: bool = @is_struct(S)\nconst EN: bool = @is_enum(E)\nconst V0: bool = @is_vec(Vec[i32])\nconst R0: bool = @is_range(R)\nconst EQC0: bool = @is_eq_comparable(S)\nconst EQC1: bool = @is_eq_comparable(Vec[i32])\nconst ORD0: bool = @is_ordered(String)\nconst ORD1: bool = @is_ordered(S)\nconst U0: bool = @is_unit(())\nconst U1: bool = @is_unit(i32)\nconst N0: bool = @is_numeric(i32)\nconst N1: bool = @is_numeric(String)\nfn main() -> i32 { return if SZ >= AL && FC_S == 2 && FC_E == 2 && FN0 == \"a\" && VN1 == \"B\" && FT1 == \"i64\" && ET0 == \"i32\" && ET1 == \"()\" && FTY1 == TY_I64 && ETY0 == TY_I32 && ETY1 == @type(()) && TY_S == @type(S) && TY_I32 != TY_I64 && EQTY && !NETY && A0 && !A1 && A2 && C0 && !C1 && E2E0 && !E2E1 && O2O0 && !O2O1 && I0 && !I1 && SI && SU && F0 && B0 && S0 && ST && EN && V0 && R0 && EQC0 && !EQC1 && ORD0 && !ORD1 && U0 && !U1 && N0 && !N1 && TN.len() > 0 { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_reflect_layout_intrinsics_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const Z0: bool = @is_zero_sized(())\nconst Z1: bool = @is_zero_sized(i32)\nconst L0: bool = @same_layout(i32, u32)\nconst L1: bool = @same_layout(i32, i64)\nconst B0: bool = @bitcastable(i32, u32)\nconst B1: bool = @bitcastable(i32, i64)\nfn main() -> i32 { return if Z0 && !Z1 && L0 && !L1 && B0 && !B1 { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_reflect_intrinsic_unknown_type_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> usize { return @size_of(UnknownType); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_reflect_intrinsic_field_count_non_nominal_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const N: usize = @field_count(i32)\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_reflect_intrinsic_field_name_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct S { a: i32 }\nconst N: String = @field_name(S, 1)\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_reflect_intrinsic_field_type_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct S { a: i32 }\nconst N: String = @field_type(S, 1)\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_reflect_intrinsic_field_type_id_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct S { a: i32 }\nconst N: TypeId = @field_type_id(S, 1)\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_reflect_intrinsic_field_type_id_multi_payload_enum_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "enum E { A(i32, i64) }\nconst N: TypeId = @field_type_id(E, 0)\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_rejects_unknown_fn() -> () {
  let mut w: tc.World = tc.world();
  // Put the error at a stable location: line 2, col 1.
  w = add_mod(w, "main", "fn main() -> i32 {\nnope();\nreturn 0;\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.slice(0, "src/main.vox:2:1:".len()) == "src/main.vox:2:1:");
  // We want a specific reason, not just "bad expr".
  t.assert(contains(msg, "unknown fn"));
  t.assert(contains(msg, "nope"));
}

fn test_typecheck_error_has_file_line_col_prefix() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> i32 {\nnope();\nreturn 0;\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.slice(0, "src/main.vox:2:1:".len()) == "src/main.vox:2:1:");
}

fn test_typecheck_rejects_vec_ctor_without_expected_ty() -> () {
  let mut w: tc.World = tc.world();
  // `Vec()` requires an expected `Vec[T]` type (e.g. from an annotation or struct field).
  w = add_mod(w, "main", "fn main() -> i32 {\nVec();\nreturn 0;\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec()"));
  t.assert(contains(msg, "expected"));
}

fn test_typecheck_wrong_number_of_args_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn f(x: i32) -> i32 { return x; }\nfn main() -> i32 {\n  return f(1, 2);\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "wrong number of args"));
  t.assert(contains(msg, "expected 1"));
  t.assert(contains(msg, "got 2"));
}

fn test_typecheck_type_alias_resolves() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type I = i32\ntype V = Vec[I]\nfn main() -> i32 {\n  let x: I = 1;\n  let mut v: V = Vec();\n  v.push(x);\n  return v.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_union_type_decl_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Value = I32: i32 | Str: String\nfn main() -> i32 {\n  let x: Value = .I32(1);\n  return match x { .I32(v) => v, .Str(_s) => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_union_ctor_qualified_path_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Value = I32: i32 | Str: String\nfn main() -> i32 {\n  let x: Value = Value.I32(7);\n  return match x { .I32(v) => v, .Str(_s) => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_union_match_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Value = I32: i32 | Str: String\nconst X: Value = Value.I32(7)\nconst N: i32 = match X { .I32(v) => v, .Str(_s) => 0 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_decl_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = 1 + 2 * 3\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn add2(x: i32) -> i32 { return x + 2; }\nconst N: i32 = add2(5)\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_named_import_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "pub fn plus(a: i32, b: i32) -> i32 { return a + b; }");
  let src: String = "import { plus } from \"dep\"\nconst N: i32 = plus(3, 4)\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_generic_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn id[T](x: T) -> T { return x; }\nconst N: i32 = id(7)\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_const_generic_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nconst M: i32 = addn[3](4)\nfn main() -> i32 { return M; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_generic_trait_bound_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn id[T: Eq](x: T) -> T { return x; }\nconst N: i32 = id(7)\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_generic_trait_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn id[T: Eq](x: T) -> T { return x; }\nconst S: String = id(\"x\")\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  t.assert(!ok(r));
}

fn test_typecheck_const_fn_call_generic_type_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn id[T](x: T) -> T { return x; }\nconst N: i32 = id[String](7)\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  t.assert(!ok(r));
}

fn test_typecheck_const_unary_not_int_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = !0\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_block_expr_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let a: i32 = 2; let b: i32 = a + 3; b * 2 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_shadowing_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let x: i32 = 1; let x: i32 = 2; x }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_if_stmt_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let x: i32 = 1; if true { let y: i32 = 2; } else { let z: i32 = 3; }; x + 4 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_block_let_mut_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let mut a: i32 = 1; a = 2; a }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_assign_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let mut x: i32 = 1; x = 2; x }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_assign_immutable_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let x: i32 = 1; x = 2; x }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const assign target is immutable"));
}

fn test_typecheck_const_block_assign_field_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct P { x: i32 }\nconst N: i32 = { let mut p: P = P { x: 1 }; p.x = 7; p.x }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_struct_member_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct P { x: i32, y: i32 }\nconst P0: P = P { x: 3, y: 4 }\nconst N: i32 = P0.x + P0.y\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_typed_path_generic_struct_lit_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Pair[T] { a: T, b: T }\nconst P0: Pair[i32] = Pair[i32] { a: 3, b: 4 }\nconst N: i32 = P0.a + P0.b\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_branch_assign_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let mut x: i32 = 1; if true { x = 3; } else { x = 4; }; x }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_while_break_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { while true { break; } 7 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_break_outside_while_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { break; 1 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const break outside while"));
}

fn test_typecheck_const_block_continue_outside_while_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { continue; 1 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const continue outside while"));
}

fn test_typecheck_const_block_return_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { return 7; 1 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_float_decl_and_ops_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: f64 = 1.5\nconst B: f64 = A\nconst C: bool = B == 1.5\nfn main() -> i32 { return if C { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_float_unary_and_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: f64 = -1.5\nconst B: f32 = A as f32\nconst C: f64 = B as f64\nconst D: bool = C == -1.5\nfn main() -> i32 { return if D { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_float_arith_and_cmp_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: f64 = 3.0 + 2.0\nconst B: f64 = A * 4.0\nconst C: f64 = B / 2.0\nconst D: f64 = C - 3.0\nconst LT: bool = D < 8.0\nconst LE: bool = D <= 7.0\nconst GT: bool = D > 6.0\nconst GE: bool = D >= 7.0\nfn main() -> i32 { return if LT && LE && GT && GE { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_float_scientific_and_suffix_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: f64 = 1e3\nconst B: f32 = 2.5e-2f32\nconst C: f64 = B as f64\nconst D: bool = A > C\nfn main() -> i32 { return if D { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_float_div_by_zero_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: f64 = 1.0 / 0.0\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const division by zero"));
}

fn test_typecheck_const_logic_short_circuit_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: bool = false && (1 / 0 == 0)\nconst B: bool = true || (1 / 0 == 0)\nfn main() -> i32 { return if A || B { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_logic_evaluates_rhs_when_needed() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: bool = true && (1 / 0 == 0)\nfn main() -> i32 { return if A { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const division by zero"));
}

fn test_typecheck_const_match_int_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = match 2 { 1 => 10, 2 => 20, _ => 0 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_match_string_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const B: bool = match \"a\" { \"a\" => true, _ => false }\nfn main() -> i32 { return if B { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_match_bool_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = match true { true => 1, false => 0 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_match_no_matching_arm_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = match 1 { 2 => 3 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const match has no matching arm"));
}

fn test_typecheck_const_match_bind_pattern_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = match 1 { x => x + 1 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_enum_unit_match_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A, B }\nconst X: E = .A\nconst N: i32 = match X { .A => 1, .B => 0 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_enum_payload_match_bind_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), B }\nconst X: E = .A(7)\nconst N: i32 = match X { .A(v) => v + 1, .B => 0 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_enum_payload_multiple_binds_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32, i32) }\nconst X: E = .A(1, 2)\nconst N: i32 = match X { .A(a, b) => a + b }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_enum_payload_duplicate_bind_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32, i32) }\nconst X: E = .A(1, 2)\nconst N: i32 = match X { .A(a, a) => a }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "duplicate bind"));
}

fn test_typecheck_const_enum_ctor_qualified_path_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), B }\nconst X: E = E.A(7)\nconst Y: E = E.B\nconst N: i32 = match X { .A(v) => v, .B => 0 }\nfn main() -> i32 { return if Y == E.B { N } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_enum_ctor_alias_path_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "pub enum E { A(i32), B }");
  let src: String = "import \"dep\" as dep\nconst X: dep.E = dep.E.A(7)\nconst Y: dep.E = dep.E.B\nconst N: i32 = match X { .A(v) => v, .B => 0 }\nfn main() -> i32 { return if Y == dep.E.B { N } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_typed_path_generic_enum_ctor_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum Option[T] { Some(T), None }\nconst A: Option[i32] = Option[i32].Some(7)\nconst B: Option[i32] = Option[i32].None\nfn main() -> i32 { let _a: Option[i32] = A; let _b: Option[i32] = B; return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_int_float_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: f64 = 1 as f64\nconst B: i32 = 1.75 as i32\nconst C: i32 = -1.75 as i32\nconst D: u32 = 9.9 as u32\nfn main() -> i32 { return A as i32 + B + C + D as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_float_to_int_overflow_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: u32 = (-1.0) as u32\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "int cast overflow"));
}

fn test_typecheck_const_i8_wrapping_add_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: i8 = 120\nconst B: i8 = A + A\nfn main() -> i32 { return B as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_u64_max_literal_expected_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> u64 { let x: u64 = 18446744073709551615; return x; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_expr_cast_u64_max_literal_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> u64 { let x: u64 = 18446744073709551615 as u64; return x; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_u64_max_literal_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: u64 = 18446744073709551615\nfn main() -> u64 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_u64_max_add_wrap_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: u64 = 18446744073709551615\nconst B: u64 = A + 1\nfn main() -> u64 { return B; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_named_import_const_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "pub const N: i32 = 7");
  w = add_mod(w, "main", "import { N } from \"dep\"\nfn main() -> i32 { return N; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = 1 as i32\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_cast_overflow_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = 3000000000 as i32\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "i64 to i32 overflow"));
}

fn test_typecheck_const_u64_to_i64_cast_overflow_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: u64 = 18446744073709551615\nconst B: i64 = A as i64\nfn main() -> i64 { return B; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const expression: int cast overflow"));
}

fn test_typecheck_const_division_overflow_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i8 = (-128) / (-1)\nfn main() -> i32 { return N as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const division overflow"));
}

fn test_typecheck_const_shift_count_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = 1 << 32\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const shift count out of range"));
}

fn test_typecheck_const_eq_type_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const B: bool = (1 as i8) == (1 as i16)\nfn main() -> i32 { return if B { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const ==/!= type mismatch"));
}

fn test_typecheck_const_struct_equality_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct S { a: i32, b: String }\nconst X: S = S { a: 1, b: \"x\" }\nconst Y: S = S { a: 1, b: \"x\" }\nconst B: bool = X == Y\nfn main() -> i32 { return if B { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_enum_payload_equality_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32, String), None }\nconst X: E = E.A(7, \"x\")\nconst Y: E = E.A(7, \"x\")\nconst B: bool = X == Y\nfn main() -> i32 { return if B { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i32\nfn main() -> i32 {\n  let x: Tiny = 1 as Tiny;\n  let y: i32 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_i8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i8\nfn main() -> i8 {\n  let x: Tiny = 1 as Tiny;\n  let y: i8 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_u32() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u32\nfn main() -> u32 {\n  let x: Tiny = 1 as Tiny;\n  let y: u32 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_u8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u8\nfn main() -> u8 {\n  let x: Tiny = 1 as Tiny;\n  let y: u8 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_u64() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u64\nfn main() -> u64 {\n  let x: Tiny = 1 as Tiny;\n  let y: u64 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_usize() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) usize\nfn main() -> usize {\n  let x: Tiny = 1 as Tiny;\n  let y: usize = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_requires_explicit_cast_from_base() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i32\nfn main() -> i32 { let x: Tiny = 1; return x as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "integer literal requires expected scalar int"));
}

fn test_typecheck_range_requires_explicit_cast_from_base_i8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i8\nfn main() -> i8 { let x: Tiny = 1; return x as i8; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "integer literal requires expected scalar int"));
}

fn test_typecheck_range_requires_explicit_cast_from_base_u8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u8\nfn main() -> u8 { let x: Tiny = 1; return x as u8; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "integer literal requires expected scalar int"));
}

fn test_typecheck_const_range_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i32\nconst N: Tiny = 2 as Tiny\nfn main() -> i32 { return N as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_range_cast_smoke_u32() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u32\nconst N: Tiny = 2 as Tiny\nfn main() -> u32 { return N as u32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_range_cast_smoke_usize() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) usize\nconst N: Tiny = 2 as Tiny\nfn main() -> usize { return N as usize; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_range_cast_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i32\nconst N: Tiny = 5 as Tiny\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "range check failed"));
}

fn test_typecheck_const_range_cast_rejected_i8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i8\nconst N: Tiny = 5 as Tiny\nfn main() -> i8 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "range check failed"));
}

fn test_typecheck_const_range_cast_rejected_u8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u8\nconst N: Tiny = 5 as Tiny\nfn main() -> u8 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "range check failed"));
}

fn test_typecheck_trait_static_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "pub trait Show {\n  fn show(x: Self) -> String;\n}\nstruct I { v: i32 }\nimpl Show for I {\n  fn show(x: I) -> String { return \"ok\"; }\n}\nfn main() -> i32 {\n  let x: I = I { v: 1 };\n  let s: String = Show.show(x);\n  return s.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_static_call_through_alias_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "pub trait Show { fn show(x: Self) -> String; }");
  let main_src: String = "import \"dep\" as d\nstruct I { v: i32 }\nimpl d.Show for I {\n  fn show(x: I) -> String { return \"ok\"; }\n}\nfn main() -> i32 {\n  let x: I = I { v: 1 };\n  let s: String = d.Show.show(x);\n  return s.len();\n}";
  w = add_mod(w, "main", main_src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_impl_local_trait_for_foreign_type_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Tag { fn tag(x: Self) -> i32; }\nimpl Tag for i32 { fn tag(x: i32) -> i32 { return x; } }\nfn main() -> i32 { return Tag.tag(7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_impl_foreign_trait_for_foreign_type_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "pub trait Show { fn show(x: Self) -> String; }");
  let src: String = "import \"dep\" as d\nimpl d.Show for i32 { fn show(x: i32) -> String { return \"x\"; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "orphan impl is not allowed"));
}

fn test_typecheck_trait_method_sugar_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I {\n  fn show(x: I) -> String { return \"ok\"; }\n}\nfn main() -> i32 {\n  let x: I = I { v: 1 };\n  let s: String = x.show();\n  return s.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_impl_trait_static_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String; }\nimpl[T] Show for Vec[T] {\n  fn show(x: Vec[T]) -> String { return x.len().to_string(); }\n}\nfn main() -> i32 {\n  let mut v: Vec[i32] = Vec();\n  v.push(7);\n  let s: String = Show.show(v);\n  return s.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_impl_trait_method_sugar_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String; }\nimpl[T] Show for Vec[T] {\n  fn show(x: Vec[T]) -> String { return x.len().to_string(); }\n}\nfn main() -> i32 {\n  let mut v: Vec[i32] = Vec();\n  v.push(7);\n  let s: String = v.show();\n  return s.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_impl_bound_rejected_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Mark { fn mark(x: Self) -> bool; }\ntrait Show { fn show(x: Self) -> String; }\nimpl[T: Mark] Show for Vec[T] {\n  fn show(x: Vec[T]) -> String { return x.len().to_string(); }\n}\nfn main() -> i32 {\n  let mut v: Vec[i32] = Vec();\n  v.push(7);\n  let s: String = Show.show(v);\n  return s.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "does not satisfy trait bound"));
  t.assert(contains(msg, "Mark"));
}

fn test_typecheck_trait_default_method_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String { return \"ok\"; } }\nstruct I { v: i32 }\nimpl Show for I {}\nfn main() -> i32 { let x: I = I { v: 1 }; let s: String = x.show(); return s.len(); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_default_method_external_trait_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "fn dep_tag() -> String { return \"dep\"; }\npub trait Show { fn show(x: Self) -> String { return dep_tag(); } }");
  w = add_mod(w, "main", "import \"dep\" as d\nstruct I { v: i32 }\nimpl d.Show for I {}\nfn main() -> i32 { let x: I = I { v: 1 }; let s: String = x.show(); return s.len(); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_generic_method_static_and_member_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }");
  let src: String = "trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Wrap for I { fn wrap[T: Eq](x: I, v: T) -> T { return v; } }\nfn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = Wrap.wrap[i32](x, 7); let b: i32 = I { v: 2 }.wrap[i32](9); return a + b; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_const_generic_method_static_and_member_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }\nstruct I { v: i32 }\nimpl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }\nfn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = AddN.addn[3](x, 4); let b: i32 = I { v: 2 }.addn[5](6); return a + b; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_const_generic_method_default_const_arg_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddN { fn addn[const N: i32 = 3](x: Self, v: i32) -> i32; }\nstruct I { v: i32 }\nimpl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }\nfn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = AddN.addn(x, 4); let b: i32 = I { v: 2 }.addn(6); return a + b; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_const_generic_method_comptime_where_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }\nstruct I { v: i32 }\nimpl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N > 0 { return v + N; } }\nfn main() -> i32 { let x: I = I { v: 1 }; return AddN.addn[3](x, 4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_const_generic_method_comptime_where_rhs_param_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddNM { fn addnm[const N: i32, const M: i32](x: Self, v: i32) -> i32 where comptime N < M; }\nstruct I { v: i32 }\nimpl AddNM for I { fn addnm[const N: i32, const M: i32](x: I, v: i32) -> i32 where comptime N < M { return v + N; } }\nfn main() -> i32 { let x: I = I { v: 1 }; return AddNM.addnm[3, 5](x, 4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_const_generic_method_comptime_where_impl_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }\nstruct I { v: i32 }\nimpl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N >= 0 { return v + N; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "comptime where"));
}

fn test_typecheck_trait_const_generic_method_comptime_where_rhs_param_impl_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddNM { fn addnm[const N: i32, const M: i32](x: Self, v: i32) -> i32 where comptime N < M; }\nstruct I { v: i32 }\nimpl AddNM for I { fn addnm[const N: i32, const M: i32](x: I, v: i32) -> i32 where comptime N <= M { return v + N; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "comptime where"));
}

fn test_typecheck_trait_const_generic_method_default_violates_comptime_where_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddN { fn addn[const N: i32 = 0](x: Self, v: i32) -> i32 where comptime N > 0; }\nstruct I { v: i32 }\nimpl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N > 0 { return v + N; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "default violates comptime where"));
}

fn test_typecheck_trait_const_generic_method_default_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddN { fn addn[const N: i32 = 3](x: Self, v: i32) -> i32; }\nstruct I { v: i32 }\nimpl AddN for I { fn addn[const N: i32 = 4](x: I, v: i32) -> i32 { return v + N; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "default mismatch"));
}

fn test_typecheck_trait_const_generic_method_impl_name_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }\nstruct I { v: i32 }\nimpl AddN for I { fn addn[const M: i32](x: I, v: i32) -> i32 { return v + M; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl method const param name mismatch"));
}

fn test_typecheck_trait_generic_method_impl_type_param_rename_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }");
  let src: String = "trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }\nfn main() -> i32 { let x: I = I { v: 1 }; return Wrap.wrap[i32](x, 7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_generic_method_impl_type_param_rename_assoc_projection_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Pass { type Item; fn pass[T: Pass](x: Self, v: T.Item) -> T.Item; }\nstruct I { v: i32 }\nimpl Pass for I { type Item = i32; fn pass[U: Pass](x: I, v: U.Item) -> U.Item { return v; } }\nfn main() -> i32 { let x: I = I { v: 1 }; return Pass.pass[I](x, 7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_generic_method_impl_type_param_rename_assoc_projection_nested_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Pass { type Item; fn dup[T: Pass](x: Self, v: T.Item) -> Vec[T.Item]; }\nstruct I { v: i32 }\nimpl Pass for I { type Item = i32; fn dup[U: Pass](x: I, v: U.Item) -> Vec[U.Item] { return Vec(); } }\nfn main() -> i32 { let x: I = I { v: 1 }; let ys: Vec[i32] = Pass.dup[I](x, 7); return ys.len(); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_impl_method_bound_mismatch_reports_missing_bound() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\npub trait Show { fn show(x: Self) -> String; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nimpl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }");
  let src: String = "trait Wrap { fn wrap[T: Eq + Show](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl method missing type bound"));
  t.assert(contains(msg, "Show"));
}

fn test_typecheck_trait_generic_default_method_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }");
  let src: String = "trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T { return v; } }\nstruct I { v: i32 }\nimpl Wrap for I {}\nfn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = Wrap.wrap[i32](x, 7); let b: i32 = I { v: 2 }.wrap[i32](9); return a + b; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_fn_body_checked_without_instantiation() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn bad[T](x: T) -> T { let y: i32 = x; return x; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_const_generic_fn_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn[3](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_default_const_arg_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn(4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_default_const_arg_can_override() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn[9](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_comptime_where_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0, comptime N <= 8 { return x + N; }\nfn main() -> i32 { return addn[3](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_comptime_where_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0, comptime N <= 8 { return x + N; }\nfn main() -> i32 { return addn[0](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "constraint failed"));
}

fn test_typecheck_const_generic_fn_comptime_where_rhs_param_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addnm[const N: i32, const M: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return addnm[3, 5](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_comptime_where_rhs_param_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addnm[const N: i32, const M: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return addnm[5, 3](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "constraint failed"));
}

fn test_typecheck_const_generic_fn_comptime_where_rhs_unknown_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addnm[const N: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "unknown const param in comptime where rhs"));
}

fn test_typecheck_const_generic_fn_default_violates_comptime_where_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32 = 0](x: i32) -> i32 where comptime N > 0 { return x + N; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "default violates comptime where"));
}

fn test_typecheck_const_generic_fn_infers_type_params_with_const_args() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn idn[T, const N: i32](x: T) -> T { return x; }\nfn main() -> i32 { return idn[3](7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_infers_type_params_with_default_const_arg() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn idn[T, const N: i32 = 3](x: T) -> T { return x; }\nfn main() -> i32 { return idn(7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_missing_const_arg_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn(4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_const_generic_fn_const_arg_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn f[const N: u8](x: i32) -> i32 { return x; }\nfn main() -> i32 { return f[300](1); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_generic_impl_method_body_checked_without_instantiation() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Boxed { fn id[T](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Boxed for I { fn id[T](x: I, v: T) -> T { let y: i32 = v; return v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_generic_default_method_body_checked_without_instantiation() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Boxed { fn id[T](x: Self, v: T) -> T { let y: i32 = v; return v; } }\nstruct I { v: i32 }\nimpl Boxed for I {}\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_generic_bound_trait_static_call_in_body_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_eq_operator_with_eq_bound_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn same[T: Eq](a: T, b: T) -> bool { return a == b; }\nfn main() -> i32 { return if same(1, 1) { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_eq_operator_without_eq_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn same[T](a: T, b: T) -> bool { return a == b; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_generic_cmp_operator_with_ord_bound_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Ord { fn lt(a: Self, b: Self) -> bool; }\nimpl Ord for i32 { fn lt(a: i32, b: i32) -> bool { return a < b; } }\nfn less[T: Ord](a: T, b: T) -> bool { return a < b; }\nfn main() -> i32 { return if less(1, 2) { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_cmp_operator_without_ord_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn less[T](a: T, b: T) -> bool { return a < b; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_generic_bound_trait_method_sugar_in_body_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String; }\nimpl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }\nfn f[T: Show](x: T) -> String { return x.show(); }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_bound_trait_method_sugar_generic_method_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\ntrait Wrap { fn wrap[U: Eq](x: Self, v: U) -> U; }\nstruct I { v: i32 }\nimpl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }\nfn f[T: Wrap](x: T) -> i32 { return x.wrap[i32](7); }\nfn main() -> i32 { let x: I = I { v: 1 }; return f(x); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_bound_trait_method_sugar_supertrait_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String; }\ntrait Wrap: Show { fn id(x: Self) -> Self; }\nstruct I { v: i32 }\nimpl Show for I { fn show(x: I) -> String { return \"ok\"; } }\nimpl Wrap for I { fn id(x: I) -> I { return x; } }\nfn f[T: Wrap](x: T) -> String { return x.show(); }\nfn main() -> i32 { let x: I = I { v: 1 }; let s: String = f(x); return s.len(); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_bound_trait_method_sugar_missing_bound_method_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn f[T: Eq](x: T) -> String { return x.show(); }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "trait method not in bounds"));
  t.assert(contains(msg, "Eq"));
}

fn test_typecheck_generic_bound_trait_method_sugar_ambiguous_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait A { fn show(x: Self) -> String; }\ntrait B { fn show(x: Self) -> String; }\nstruct I { v: i32 }\nimpl A for I { fn show(x: I) -> String { return \"a\"; } }\nimpl B for I { fn show(x: I) -> String { return \"b\"; } }\nfn f[T: A + B](x: T) -> String { return x.show(); }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "ambiguous trait method call"));
  t.assert(contains(msg, "A.show"));
  t.assert(contains(msg, "B.show"));
}

fn test_typecheck_supertrait_forward_decl_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait B: A { fn b(x: Self) -> i32; }\ntrait A { fn a(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl A for I { fn a(x: I) -> i32 { return 1; } }\nimpl B for I { fn b(x: I) -> i32 { return 2; } }\nfn main() -> i32 { let x: I = I { v: 1 }; return B.b(x) + A.a(x); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_supertrait_impl_requires_parent_impl() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait A { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl B for I { fn b(x: I) -> i32 { return 2; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "requires supertrait A"));
}

fn test_typecheck_supertrait_cycle_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait A: B { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "supertrait cycle"));
}

fn test_typecheck_supertrait_impl_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait A { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl A for I { fn a(x: I) -> i32 { return 1; } }\nimpl B for I { fn b(x: I) -> i32 { return 2; } }\nfn main() -> i32 { let x: I = I { v: 1 }; return B.b(x) + A.a(x); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_assoc_type_impl_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { let x: I = I { v: 1 }; return Iter.next(x); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_assoc_type_projection_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; fn next(x: Self) -> Self.Item; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> Self.Item { return x.v; } }\nfn id[T: Iter](x: T) -> T.Item { return x.next(); }\nfn main() -> i32 { let x: I = I { v: 1 }; let y: i32 = id[I](x); return y; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_assoc_type_projection_infer_local_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; fn next(x: Self) -> Self.Item; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> Self.Item { return x.v; } }\nfn id[T: Iter](x: T) -> T.Item { return x.next(); }\nfn main() -> i32 { let x: I = I { v: 1 }; let y = id[I](x); return y; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_assoc_type_unknown_in_method_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; fn next(x: Self) -> Self.Missing; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "unknown associated type in trait method"));
  t.assert(contains(msg, "Missing"));
}

fn test_typecheck_trait_assoc_type_projection_unknown_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait A { fn a(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl A for I { fn a(x: I) -> i32 { return x.v; } }\nfn bad[T: A](x: T) -> T.Item { return 0; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "unknown associated type projection"));
  t.assert(contains(msg, "T.Item"));
}

fn test_typecheck_trait_assoc_type_projection_ambiguous_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait A { type Item; fn a(x: Self) -> i32; }\ntrait B { type Item; fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl A for I { type Item = i32; fn a(x: I) -> i32 { return x.v; } }\nimpl B for I { type Item = i32; fn b(x: I) -> i32 { return x.v; } }\nfn bad[T: A + B](x: T) -> T.Item { return x.a(); }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "ambiguous associated type projection"));
  t.assert(contains(msg, "T.Item"));
}

fn test_typecheck_trait_assoc_type_impl_missing_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl missing associated type"));
  t.assert(contains(msg, "Item"));
}

fn test_typecheck_trait_assoc_type_impl_extra_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl associated type not in trait"));
  t.assert(contains(msg, "Item"));
}

fn test_typecheck_trait_assoc_type_duplicate_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "duplicate trait associated type"));
  t.assert(contains(msg, "Item"));
}

fn test_typecheck_impl_assoc_type_duplicate_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; type Item = i64; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "duplicate impl associated type"));
  t.assert(contains(msg, "Item"));
}

fn test_typecheck_trait_method_name_conflicts_assoc_type_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; fn Item(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn Item(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "trait method conflicts with associated type"));
  t.assert(contains(msg, "Item"));
}

fn test_typecheck_trait_method_sugar_ambiguous_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait A { fn show(x: Self) -> String; }\ntrait B { fn show(x: Self) -> String; }\nstruct I { v: i32 }\nimpl A for I { fn show(x: I) -> String { return \"a\"; } }\nimpl B for I { fn show(x: I) -> String { return \"b\"; } }\nfn main() -> i32 { let x: I = I { v: 1 }; let _s: String = x.show(); return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "ambiguous trait method call"));
  t.assert(contains(msg, "A.show"));
  t.assert(contains(msg, "B.show"));
}

fn test_typecheck_trait_call_missing_impl_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "pub trait Show { fn show(x: Self) -> String; }\nstruct I { v: i32 }\nfn main() -> i32 {\n  let x: I = I { v: 1 };\n  let _s: String = Show.show(x);\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "no impl for trait call"));
  t.assert(contains(msg, "available impls"));
}

fn test_typecheck_trait_call_unknown_method_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "pub trait Show { fn show(x: Self) -> String; fn debug(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I { fn show(x: I) -> String { return \"ok\"; } fn debug(x: I) -> String { return \"dbg\"; } }\nfn main() -> i32 { let x: I = I { v: 1 }; let _s: String = Show.missing(x); return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "unknown trait method"));
  t.assert(contains(msg, "available methods"));
  t.assert(contains(msg, "show"));
  t.assert(contains(msg, "debug"));
}

fn test_typecheck_impl_method_sig_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddOne { fn add_one(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl AddOne for I {\n  fn add_one(x: i32) -> i32 { return x + 1; }\n}\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl method param type mismatch"));
}

fn test_typecheck_impl_missing_required_method_reports_candidates() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String; fn debug(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I { fn show(x: I) -> String { return \"ok\"; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl missing trait method"));
  t.assert(contains(msg, "required methods"));
  t.assert(contains(msg, "show"));
  t.assert(contains(msg, "debug"));
}

fn test_typecheck_impl_extra_method_reports_candidates() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I { fn show(x: I) -> String { return \"ok\"; } fn debug(x: I) -> String { return \"dbg\"; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl method not in trait"));
  t.assert(contains(msg, "available methods"));
  t.assert(contains(msg, "show"));
}
