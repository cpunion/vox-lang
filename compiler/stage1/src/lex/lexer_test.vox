import "std/testing" as t
import "lex" as l

fn is_none(e: l.LexError) -> bool {
  return match e {
    l.LexError.None => true,
    _ => false,
  };
}

fn test_lex_smoke_keywords_and_punct() -> () {
  let r: l.LexResult = l.lex_text("fn main() -> i32 { return 0; }");
  t.assert(is_none(r.err));

  let toks: Vec[l.Token] = r.tokens;
  t.assert(toks.len() > 0);

  // fn
  t.assert(match toks.get(0).kind { l.TokenKind.KwFn => true, _ => false });
  // main
  t.assert(match toks.get(1).kind { l.TokenKind.Ident => true, _ => false });
  // (
  t.assert(match toks.get(2).kind { l.TokenKind.LParen => true, _ => false });
  // )
  t.assert(match toks.get(3).kind { l.TokenKind.RParen => true, _ => false });
  // ->
  t.assert(match toks.get(4).kind { l.TokenKind.Arrow => true, _ => false });
  // i32
  t.assert(match toks.get(5).kind { l.TokenKind.Ident => true, _ => false });
  // {
  t.assert(match toks.get(6).kind { l.TokenKind.LBrace => true, _ => false });
  // return
  t.assert(match toks.get(7).kind { l.TokenKind.KwReturn => true, _ => false });
  // 0
  t.assert(match toks.get(8).kind { l.TokenKind.Int => true, _ => false });
  // ;
  t.assert(match toks.get(9).kind { l.TokenKind.Semicolon => true, _ => false });
  // }
  t.assert(match toks.get(10).kind { l.TokenKind.RBrace => true, _ => false });
  // eof
  t.assert(match toks.get(11).kind { l.TokenKind.Eof => true, _ => false });
}

fn test_lex_skips_line_comment() -> () {
  let r: l.LexResult = l.lex_text("fn main() -> i32 { // hi\n return 0; }");
  t.assert(is_none(r.err));
  let toks: Vec[l.Token] = r.tokens;
  // Ensure we still see `return` after the comment.
  let mut saw_return: bool = false;
  let mut i: i32 = 0;
  while i < toks.len() {
    if match toks.get(i).kind { l.TokenKind.KwReturn => true, _ => false } {
      saw_return = true;
      break;
    }
    i = i + 1;
  }
  t.assert(saw_return);
}

fn test_lex_unterminated_string_is_error() -> () {
  let r: l.LexResult = l.lex_text("\"abc");
  t.assert(match r.err { l.LexError.UnterminatedString(_) => true, _ => false });
}

fn test_lex_unexpected_char_is_error() -> () {
  let r: l.LexResult = l.lex_text("@");
  t.assert(match r.err { l.LexError.UnexpectedChar(_) => true, _ => false });
}

