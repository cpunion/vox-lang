// LexError is a minimal error channel for stage1 lexer.
pub enum LexError {
  None,
  UnexpectedChar(i32),     // byte offset
  UnterminatedString(i32), // byte offset of opening quote
}

pub struct LexResult {
  pub tokens: Vec[Token],
  pub err: LexError,
}

fn is_space(b: i32) -> bool {
  return b == 32 || b == 9 || b == 10 || b == 13; // ' ' '\t' '\n' '\r'
}

fn is_alpha(b: i32) -> bool {
  return (b >= 65 && b <= 90) || (b >= 97 && b <= 122) || b == 95; // A-Z a-z _
}

fn is_digit(b: i32) -> bool {
  return b >= 48 && b <= 57; // 0-9
}

fn is_alnum(b: i32) -> bool {
  return is_alpha(b) || is_digit(b);
}

fn kw_kind(text: String, start: i32, end: i32) -> TokenKind {
  // Keyword detection without substring support: compare by length + bytes.
  let n: i32 = end - start;

  // 2
  if n == 2 {
    let b0: i32 = text.byte_at(start + 0);
    let b1: i32 = text.byte_at(start + 1);
    if b0 == 102 && b1 == 110 { return TokenKind.KwFn; } // fn
    if b0 == 105 && b1 == 102 { return TokenKind.KwIf; } // if
    if b0 == 97 && b1 == 115 { return TokenKind.KwAs; }  // as
    return TokenKind.Ident;
  }

  // 3
  if n == 3 {
    let b0: i32 = text.byte_at(start + 0);
    let b1: i32 = text.byte_at(start + 1);
    let b2: i32 = text.byte_at(start + 2);
    if b0 == 108 && b1 == 101 && b2 == 116 { return TokenKind.KwLet; } // let
    if b0 == 109 && b1 == 117 && b2 == 116 { return TokenKind.KwMut; } // mut
    if b0 == 112 && b1 == 117 && b2 == 98 { return TokenKind.KwPub; }  // pub
    return TokenKind.Ident;
  }

  // 4
  if n == 4 {
    let b0: i32 = text.byte_at(start + 0);
    let b1: i32 = text.byte_at(start + 1);
    let b2: i32 = text.byte_at(start + 2);
    let b3: i32 = text.byte_at(start + 3);
    if b0 == 101 && b1 == 108 && b2 == 115 && b3 == 101 { return TokenKind.KwElse; } // else
    if b0 == 101 && b1 == 110 && b2 == 117 && b3 == 109 { return TokenKind.KwEnum; } // enum
    if b0 == 102 && b1 == 114 && b2 == 111 && b3 == 109 { return TokenKind.KwFrom; } // from
    if b0 == 116 && b1 == 114 && b2 == 117 && b3 == 101 { return TokenKind.KwTrue; } // true
    return TokenKind.Ident;
  }

  // 5
  if n == 5 {
    let b0: i32 = text.byte_at(start + 0);
    let b1: i32 = text.byte_at(start + 1);
    let b2: i32 = text.byte_at(start + 2);
    let b3: i32 = text.byte_at(start + 3);
    let b4: i32 = text.byte_at(start + 4);
    if b0 == 119 && b1 == 104 && b2 == 105 && b3 == 108 && b4 == 101 { return TokenKind.KwWhile; } // while
    if b0 == 109 && b1 == 97 && b2 == 116 && b3 == 99 && b4 == 104 { return TokenKind.KwMatch; }  // match
    if b0 == 98 && b1 == 114 && b2 == 101 && b3 == 97 && b4 == 107 { return TokenKind.KwBreak; }  // break
    if b0 == 102 && b1 == 97 && b2 == 108 && b3 == 115 && b4 == 101 { return TokenKind.KwFalse; } // false
    return TokenKind.Ident;
  }

  // 6
  if n == 6 {
    let b0: i32 = text.byte_at(start + 0);
    let b1: i32 = text.byte_at(start + 1);
    let b2: i32 = text.byte_at(start + 2);
    let b3: i32 = text.byte_at(start + 3);
    let b4: i32 = text.byte_at(start + 4);
    let b5: i32 = text.byte_at(start + 5);
    if b0 == 114 && b1 == 101 && b2 == 116 && b3 == 117 && b4 == 114 && b5 == 110 { return TokenKind.KwReturn; } // return
    if b0 == 115 && b1 == 116 && b2 == 114 && b3 == 117 && b4 == 99 && b5 == 116 { return TokenKind.KwStruct; } // struct
    if b0 == 105 && b1 == 109 && b2 == 112 && b3 == 111 && b4 == 114 && b5 == 116 { return TokenKind.KwImport; } // import
    return TokenKind.Ident;
  }

  // 8
  if n == 8 {
    let b0: i32 = text.byte_at(start + 0);
    let b1: i32 = text.byte_at(start + 1);
    let b2: i32 = text.byte_at(start + 2);
    let b3: i32 = text.byte_at(start + 3);
    let b4: i32 = text.byte_at(start + 4);
    let b5: i32 = text.byte_at(start + 5);
    let b6: i32 = text.byte_at(start + 6);
    let b7: i32 = text.byte_at(start + 7);
    if b0 == 99 && b1 == 111 && b2 == 110 && b3 == 116 && b4 == 105 && b5 == 110 && b6 == 117 && b7 == 101 {
      return TokenKind.KwContinue; // continue
    }
    return TokenKind.Ident;
  }

  return TokenKind.Ident;
}

pub fn lex_text(text: String) -> LexResult {
  let mut i: i32 = 0;
  let n: i32 = text.len();
  let mut toks: Vec[Token] = Vec();

  while i < n {
    let b: i32 = text.byte_at(i);

    // whitespace
    if is_space(b) {
      i = i + 1;
      continue;
    }

    // line comment: //
    if b == 47 {
      if (i + 1) < n {
        if text.byte_at(i + 1) == 47 {
          i = i + 2;
          while i < n {
            if text.byte_at(i) == 10 {
              break;
            }
            i = i + 1;
          }
          continue;
        }
      }
    }

    // identifier / keyword
    if is_alpha(b) {
      let start: i32 = i;
      i = i + 1;
      while i < n {
        if !is_alnum(text.byte_at(i)) {
          break;
        }
        i = i + 1;
      }
      let k: TokenKind = kw_kind(text, start, i);
      toks.push(Token { kind: k, start: start, end: i });
      continue;
    }

    // int literal
    if is_digit(b) {
      let start: i32 = i;
      i = i + 1;
      while i < n {
        if !is_digit(text.byte_at(i)) {
          break;
        }
        i = i + 1;
      }
      toks.push(Token { kind: TokenKind.Int, start: start, end: i });
      continue;
    }

    // string literal (no escape processing yet; just skip over escapes)
    if b == 34 { // '"'
      let start: i32 = i;
      i = i + 1;
      let mut closed: bool = false;
      while i < n {
        let c: i32 = text.byte_at(i);
        if c == 34 { // closing '"'
          i = i + 1;
          toks.push(Token { kind: TokenKind.Str, start: start, end: i });
          closed = true;
          break;
        }
        if c == 92 { // '\\' escape, skip next char if present
          i = i + 1;
          if i < n { i = i + 1; }
          continue;
        }
        i = i + 1;
      }
      if !closed {
        return LexResult { tokens: toks, err: LexError.UnterminatedString(start) };
      }
      continue;
    }

    // punctuators / operators (maximal munch)
    let start: i32 = i;

    // 2-char ops
    if (i + 1) < n {
      let b1: i32 = text.byte_at(i + 1);
      // ->
      if b == 45 && b1 == 62 {
        i = i + 2;
        toks.push(Token { kind: TokenKind.Arrow, start: start, end: i });
        continue;
      }
      // =>
      if b == 61 && b1 == 62 {
        i = i + 2;
        toks.push(Token { kind: TokenKind.FatArrow, start: start, end: i });
        continue;
      }
      // ==
      if b == 61 && b1 == 61 {
        i = i + 2;
        toks.push(Token { kind: TokenKind.EqEq, start: start, end: i });
        continue;
      }
      // !=
      if b == 33 && b1 == 61 {
        i = i + 2;
        toks.push(Token { kind: TokenKind.Ne, start: start, end: i });
        continue;
      }
      // <=
      if b == 60 && b1 == 61 {
        i = i + 2;
        toks.push(Token { kind: TokenKind.Le, start: start, end: i });
        continue;
      }
      // >=
      if b == 62 && b1 == 61 {
        i = i + 2;
        toks.push(Token { kind: TokenKind.Ge, start: start, end: i });
        continue;
      }
      // &&
      if b == 38 && b1 == 38 {
        i = i + 2;
        toks.push(Token { kind: TokenKind.AndAnd, start: start, end: i });
        continue;
      }
      // ||
      if b == 124 && b1 == 124 {
        i = i + 2;
        toks.push(Token { kind: TokenKind.OrOr, start: start, end: i });
        continue;
      }
    }

    // 1-char tokens
    if b == 40 { i = i + 1; toks.push(Token { kind: TokenKind.LParen, start: start, end: i }); continue; }   // (
    if b == 41 { i = i + 1; toks.push(Token { kind: TokenKind.RParen, start: start, end: i }); continue; }   // )
    if b == 123 { i = i + 1; toks.push(Token { kind: TokenKind.LBrace, start: start, end: i }); continue; }  // {
    if b == 125 { i = i + 1; toks.push(Token { kind: TokenKind.RBrace, start: start, end: i }); continue; }  // }
    if b == 91 { i = i + 1; toks.push(Token { kind: TokenKind.LBracket, start: start, end: i }); continue; } // [
    if b == 93 { i = i + 1; toks.push(Token { kind: TokenKind.RBracket, start: start, end: i }); continue; } // ]
    if b == 44 { i = i + 1; toks.push(Token { kind: TokenKind.Comma, start: start, end: i }); continue; }    // ,
    if b == 59 { i = i + 1; toks.push(Token { kind: TokenKind.Semicolon, start: start, end: i }); continue; } // ;
    if b == 46 { i = i + 1; toks.push(Token { kind: TokenKind.Dot, start: start, end: i }); continue; }      // .
    if b == 58 { i = i + 1; toks.push(Token { kind: TokenKind.Colon, start: start, end: i }); continue; }    // :

    if b == 61 { i = i + 1; toks.push(Token { kind: TokenKind.Eq, start: start, end: i }); continue; }      // =
    if b == 60 { i = i + 1; toks.push(Token { kind: TokenKind.Lt, start: start, end: i }); continue; }      // <
    if b == 62 { i = i + 1; toks.push(Token { kind: TokenKind.Gt, start: start, end: i }); continue; }      // >
    if b == 33 { i = i + 1; toks.push(Token { kind: TokenKind.Not, start: start, end: i }); continue; }     // !

    if b == 43 { i = i + 1; toks.push(Token { kind: TokenKind.Plus, start: start, end: i }); continue; }    // +
    if b == 45 { i = i + 1; toks.push(Token { kind: TokenKind.Minus, start: start, end: i }); continue; }   // -
    if b == 42 { i = i + 1; toks.push(Token { kind: TokenKind.Star, start: start, end: i }); continue; }    // *
    if b == 47 { i = i + 1; toks.push(Token { kind: TokenKind.Slash, start: start, end: i }); continue; }   // /
    if b == 37 { i = i + 1; toks.push(Token { kind: TokenKind.Percent, start: start, end: i }); continue; } // %

    return LexResult { tokens: toks, err: LexError.UnexpectedChar(i) };
  }

  toks.push(Token { kind: TokenKind.Eof, start: n, end: n });
  return LexResult { tokens: toks, err: LexError.None };
}
