// Stage1 lexer token model.

pub enum TokenKind {
  // Special
  Eof,

  // Identifiers and literals
  Ident,
  Int,
  Str,

  // Keywords (subset; extend as stage1 grows)
  KwFn,
  KwLet,
  KwMut,
  KwReturn,
  KwIf,
  KwElse,
  KwWhile,
  KwBreak,
  KwContinue,
  KwMatch,
  KwStruct,
  KwEnum,
  KwImport,
  KwAs,
  KwFrom,
  KwPub,

  // Punctuators/operators
  LParen,
  RParen,
  LBrace,
  RBrace,
  LBracket,
  RBracket,
  Comma,
  Semicolon,
  Dot,
  Colon,

  Eq,
  EqEq,
  Ne,
  Lt,
  Le,
  Gt,
  Ge,

  Plus,
  Minus,
  Star,
  Slash,
  Percent,

  AndAnd,
  OrOr,
  Not,

  Arrow,    // ->
  FatArrow, // =>
}

pub struct Token {
  pub kind: TokenKind,
  // Byte offsets in the original source string: [start, end)
  pub start: i32,
  pub end: i32,
}

// token_kind_tag maps TokenKind to a stable i32 so stage0 (which doesn't support enum equality)
// can implement TokenKind comparisons via integer equality.
pub fn token_kind_tag(k: TokenKind) -> i32 {
  return match k {
    TokenKind.Eof => 0,
    TokenKind.Ident => 1,
    TokenKind.Int => 2,
    TokenKind.Str => 3,

    TokenKind.KwFn => 10,
    TokenKind.KwLet => 11,
    TokenKind.KwMut => 12,
    TokenKind.KwReturn => 13,
    TokenKind.KwIf => 14,
    TokenKind.KwElse => 15,
    TokenKind.KwWhile => 16,
    TokenKind.KwBreak => 17,
    TokenKind.KwContinue => 18,
    TokenKind.KwMatch => 19,
    TokenKind.KwStruct => 20,
    TokenKind.KwEnum => 21,
    TokenKind.KwImport => 22,
    TokenKind.KwAs => 23,
    TokenKind.KwFrom => 24,
    TokenKind.KwPub => 25,

    TokenKind.LParen => 30,
    TokenKind.RParen => 31,
    TokenKind.LBrace => 32,
    TokenKind.RBrace => 33,
    TokenKind.LBracket => 34,
    TokenKind.RBracket => 35,
    TokenKind.Comma => 36,
    TokenKind.Semicolon => 37,
    TokenKind.Dot => 38,
    TokenKind.Colon => 39,

    TokenKind.Eq => 40,
    TokenKind.EqEq => 41,
    TokenKind.Ne => 42,
    TokenKind.Lt => 43,
    TokenKind.Le => 44,
    TokenKind.Gt => 45,
    TokenKind.Ge => 46,

    TokenKind.Plus => 50,
    TokenKind.Minus => 51,
    TokenKind.Star => 52,
    TokenKind.Slash => 53,
    TokenKind.Percent => 54,

    TokenKind.AndAnd => 60,
    TokenKind.OrOr => 61,
    TokenKind.Not => 62,

    TokenKind.Arrow => 70,
    TokenKind.FatArrow => 71,
  };
}

pub fn token_kind_eq(a: TokenKind, b: TokenKind) -> bool {
  return token_kind_tag(a) == token_kind_tag(b);
}
