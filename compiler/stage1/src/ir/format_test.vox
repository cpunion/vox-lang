import "std/testing" as t
import "ir" as ir

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn test_ir_format_smoke() -> () {
  let mut pool: ir.TyPool = ir.ty_pool();
  let r: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_i32());
  pool = r.pool;

  let p: ir.Program = ir.program(pool);
  let s: String = ir.format_program(p);
  // Only check the header; the rest is intentionally elided in v0 format.
  t.assert(s.len() >= 5);
}

fn test_ir_format_range_check_instr() -> () {
  let mut pool: ir.TyPool = ir.ty_pool();
  let r: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_i32());
  pool = r.pool;
  let ty_i32: i32 = r.idx;

  let mut p: ir.Program = ir.program(pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.RangeCheck(ty_i32, ir.v_int(1), 0, 3));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(true, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  let f: ir.Func = ir.Func { name: "main", params: Vec(), ret: ty_i32, blocks: blocks };
  p.funcs.push(f);

  let s: String = ir.format_program(p);
  t.assert(contains(s, "range_check i32 0 3 1"));
}
