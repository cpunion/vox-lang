import "std/testing" as t
import "ir" as ir

struct TestPool {
  pool: ir.TyPool,
  ty_unit: i32,
  ty_bool: i32,
  ty_i32: i32,
  ty_f64: i32,
}

fn mk_pool() -> TestPool {
  let mut pool: ir.TyPool = ir.ty_pool();

  let a0: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_unit());
  pool = a0.pool;
  let ty_unit: i32 = a0.idx;

  let a1: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_bool());
  pool = a1.pool;
  let ty_bool: i32 = a1.idx;

  let a2: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_i32());
  pool = a2.pool;
  let ty_i32: i32 = a2.idx;

  let a3: ir.AddTyResult = ir.ty_pool_add(pool, ir.ty_f64());
  pool = a3.pool;
  let ty_f64: i32 = a3.idx;

  return TestPool {
    pool: pool,
    ty_unit: ty_unit,
    ty_bool: ty_bool,
    ty_i32: ty_i32,
    ty_f64: ty_f64,
  };
}

fn has_substr(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn test_ir_verify_valid_cast_and_cfg_smoke() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.IntCast(0, tp.ty_i32, tp.ty_i32, ir.v_int(1)));
  instrs.push(ir.Instr.IntCastChecked(1, tp.ty_i32, tp.ty_f64, ir.v_float("1.5")));
  instrs.push(ir.Instr.FloatCast(2, tp.ty_f64, tp.ty_i32, ir.v_int(3)));
  instrs.push(ir.Instr.RangeCheck(tp.ty_i32, ir.v_int(2), 0, 3));

  let b0: ir.Block = ir.Block {
    name: "entry",
    instrs: instrs,
    has_term: true,
    term: ir.Term.CondBr(ir.v_bool(true), "ok", "ko"),
  };
  let b1: ir.Block = ir.Block {
    name: "ok",
    instrs: Vec(),
    has_term: true,
    term: ir.Term.Ret(false, ir.v_int(0)),
  };
  let b2: ir.Block = ir.Block {
    name: "ko",
    instrs: Vec(),
    has_term: true,
    term: ir.Term.Panic(ir.v_str("bad")),
  };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b0);
  blocks.push(b1);
  blocks.push(b2);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert_with(vr.ok, vr.err);
}

fn test_ir_verify_rejects_int_cast_from_float() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.IntCast(0, tp.ty_i32, tp.ty_f64, ir.v_float("1.0")));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "int_cast"));
}

fn test_ir_verify_rejects_int_cast_checked_non_int_dst() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.IntCastChecked(0, tp.ty_f64, tp.ty_i32, ir.v_int(1)));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "dst must be int"));
}

fn test_ir_verify_rejects_range_check_non_int_ty() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut instrs: Vec[ir.Instr] = Vec();
  instrs.push(ir.Instr.RangeCheck(tp.ty_f64, ir.v_float("1.0"), 0, 3));
  let b: ir.Block = ir.Block { name: "entry", instrs: instrs, has_term: true, term: ir.Term.Ret(false, ir.v_int(0)) };

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(b);
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "range_check must use int type"));
}

fn test_ir_verify_rejects_unknown_branch_target() -> () {
  let tp: TestPool = mk_pool();
  let mut p: ir.Program = ir.program(tp.pool);

  let mut blocks: Vec[ir.Block] = Vec();
  blocks.push(ir.Block {
    name: "entry",
    instrs: Vec(),
    has_term: true,
    term: ir.Term.Br("missing"),
  });
  p.funcs.push(ir.Func { name: "main", params: Vec(), ret: tp.ty_unit, blocks: blocks });

  let vr: ir.VerifyResult = ir.verify_program(p);
  t.assert(!vr.ok);
  t.assert(has_substr(vr.err, "unknown branch target"));
}
