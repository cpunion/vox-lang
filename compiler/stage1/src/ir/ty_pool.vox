// Stage1 IR definitions (initial skeleton).
//
// Design note:
// Stage0 (host compiler) currently has no references/pointers in the language core,
// so we model recursive structures using small indices into arenas.

pub enum TyKind { Bad, Unit, Bool, I32, I64, String, Struct, Enum, Vec }

pub struct Ty {
  pub kind: TyKind,
  // For nominal types: module path + type name. Otherwise empty.
  pub mod_path: String,
  pub name: String,
  // For Vec: element type index in TyPool, otherwise -1.
  pub elem: i32,
}

pub struct TyPool {
  pub tys: Vec[Ty],
}

pub struct AddTyResult {
  pub pool: TyPool,
  pub idx: i32,
}

pub fn ty_pool() -> TyPool {
  return TyPool { tys: Vec() };
}

pub fn ty_bad() -> Ty { return Ty { kind: TyKind.Bad, mod_path: "", name: "", elem: -1 }; }
pub fn ty_unit() -> Ty { return Ty { kind: TyKind.Unit, mod_path: "", name: "", elem: -1 }; }
pub fn ty_bool() -> Ty { return Ty { kind: TyKind.Bool, mod_path: "", name: "", elem: -1 }; }
pub fn ty_i32() -> Ty { return Ty { kind: TyKind.I32, mod_path: "", name: "", elem: -1 }; }
pub fn ty_i64() -> Ty { return Ty { kind: TyKind.I64, mod_path: "", name: "", elem: -1 }; }
pub fn ty_string() -> Ty { return Ty { kind: TyKind.String, mod_path: "", name: "", elem: -1 }; }

pub fn ty_struct(mod_path: String, name: String) -> Ty { return Ty { kind: TyKind.Struct, mod_path: mod_path, name: name, elem: -1 }; }
pub fn ty_enum(mod_path: String, name: String) -> Ty { return Ty { kind: TyKind.Enum, mod_path: mod_path, name: name, elem: -1 }; }
pub fn ty_vec(elem: i32) -> Ty { return Ty { kind: TyKind.Vec, mod_path: "", name: "", elem: elem }; }

pub fn ty_pool_add(pool: TyPool, ty: Ty) -> AddTyResult {
  let mut p: TyPool = pool;
  let mut v: Vec[Ty] = p.tys;
  v.push(ty);
  let idx: i32 = v.len() - 1;
  p.tys = v;
  return AddTyResult { pool: p, idx: idx };
}

pub fn ty_pool_get(pool: TyPool, idx: i32) -> Ty {
  let v: Vec[Ty] = pool.tys;
  return v.get(idx);
}
