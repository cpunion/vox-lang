import "std/testing" as t
import "parse" as p
import "ast" as ast

fn ok(e: p.ParseError) -> bool {
  return match e {
    p.ParseError.None => true,
    _ => false,
  };
}

fn test_parse_single_fn_return_int() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> i32 { return 0; }");
  t.assert(ok(r.err));

  let prog: ast.Program = r.prog;
  let imports: Vec[ast.ImportDecl] = prog.imports;
  t.assert_eq(imports.len(), 0);
  t.assert_eq(prog.structs.len(), 0);
  t.assert_eq(prog.enums.len(), 0);
  let funcs: Vec[ast.FuncDecl] = prog.funcs;
  t.assert_eq(funcs.len(), 1);
  let exprs: ast.ExprPool = prog.exprs;

  let f: ast.FuncDecl = funcs.get(0);
  t.assert_eq(f.name, "main");
  let params: Vec[ast.Param] = f.params;
  t.assert_eq(params.len(), 0);
  t.assert_eq(f.ret.name, "i32");
  let stmts: Vec[ast.Stmt] = f.body.stmts;
  t.assert_eq(stmts.len(), 1);

  let st: ast.Stmt = stmts.get(0);
  let is_ret0: bool = match st {
    ast.Stmt.Return(has, id) => has && match ast.expr_pool_get(exprs, id) {
      ast.ExprNode.Int(v) => v == 0,
      _ => false,
    },
    _ => false,
  };
  t.assert(is_ret0);
}

fn test_parse_import_as_alias() -> () {
  let r: p.ParseResult = p.parse_text("import \"dep\" as d\nfn main() -> i32 { return 0; }");
  t.assert(ok(r.err));

  let prog: ast.Program = r.prog;
  let imports: Vec[ast.ImportDecl] = prog.imports;
  t.assert_eq(imports.len(), 1);
  let imp: ast.ImportDecl = imports.get(0);
  t.assert_eq(imp.path, "dep");
  t.assert_eq(imp.alias, "d");

  let funcs: Vec[ast.FuncDecl] = prog.funcs;
  t.assert_eq(funcs.len(), 1);
  t.assert_eq(funcs.get(0).name, "main");
}

fn test_parse_struct_decl_and_pub_fields() -> () {
  let src: String = "pub struct S { pub x: i32, y: i32 }\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  t.assert_eq(r.prog.structs.len(), 1);
  let s: ast.StructDecl = r.prog.structs.get(0);
  t.assert(s.is_pub);
  t.assert_eq(s.name, "S");
  t.assert_eq(s.fields.len(), 2);
  let f0: ast.FieldDecl = s.fields.get(0);
  t.assert(f0.is_pub);
  t.assert_eq(f0.name, "x");
  t.assert_eq(f0.ty.name, "i32");
  let f1: ast.FieldDecl = s.fields.get(1);
  t.assert(!f1.is_pub);
  t.assert_eq(f1.name, "y");
  t.assert_eq(f1.ty.name, "i32");
}

fn test_parse_enum_decl_variants() -> () {
  let src: String = "enum E { A(i32), B(String), None }\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  t.assert_eq(r.prog.enums.len(), 1);
  let e: ast.EnumDecl = r.prog.enums.get(0);
  t.assert(!e.is_pub);
  t.assert_eq(e.name, "E");
  t.assert_eq(e.variants.len(), 3);

  let v0: ast.EnumVariantDecl = e.variants.get(0);
  t.assert_eq(v0.name, "A");
  t.assert_eq(v0.fields.len(), 1);
  t.assert_eq(v0.fields.get(0).name, "i32");

  let v1: ast.EnumVariantDecl = e.variants.get(1);
  t.assert_eq(v1.name, "B");
  t.assert_eq(v1.fields.len(), 1);
  t.assert_eq(v1.fields.get(0).name, "String");

  let v2: ast.EnumVariantDecl = e.variants.get(2);
  t.assert_eq(v2.name, "None");
  t.assert_eq(v2.fields.len(), 0);
}

fn test_parse_let_mut_with_type_ann_and_int_init() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> i32 { let mut x: i32 = 1; return x; }");
  t.assert(ok(r.err));

  let prog: ast.Program = r.prog;
  let funcs: Vec[ast.FuncDecl] = prog.funcs;
  let exprs: ast.ExprPool = prog.exprs;
  let f: ast.FuncDecl = funcs.get(0);
  let stmts: Vec[ast.Stmt] = f.body.stmts;
  t.assert_eq(stmts.len(), 2);

  let st0: ast.Stmt = stmts.get(0);
  let ok0: bool = match st0 {
    ast.Stmt.Let(mutable, name, has_ann, ann, init) =>
      mutable && name == "x" && has_ann && ann.name == "i32" &&
      match ast.expr_pool_get(exprs, init) { ast.ExprNode.Int(v) => v == 1, _ => false },
    _ => false,
  };
  t.assert(ok0);

  let st1: ast.Stmt = stmts.get(1);
  let ok1: bool = match st1 {
    ast.Stmt.Return(has, id) => has && match ast.expr_pool_get(exprs, id) { ast.ExprNode.Ident(s) => s == "x", _ => false },
    _ => false,
  };
  t.assert(ok1);
}

fn test_parse_member_call_and_add() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> i32 { return a.b(1 + 2); }");
  t.assert(ok(r.err));

  let prog: ast.Program = r.prog;
  let exprs: ast.ExprPool = prog.exprs;
  let funcs: Vec[ast.FuncDecl] = prog.funcs;
  let f: ast.FuncDecl = funcs.get(0);
  let stmts: Vec[ast.Stmt] = f.body.stmts;
  let st: ast.Stmt = stmts.get(0);
  let rid: i32 = match st { ast.Stmt.Return(_, id) => id, _ => -1 };

  // return <call>
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, args) =>
      args.len() == 1 &&
      match ast.expr_pool_get(exprs, callee) {
        ast.ExprNode.Member(recv, name) =>
          name == "b" &&
          match ast.expr_pool_get(exprs, recv) { ast.ExprNode.Ident(s) => s == "a", _ => false },
        _ => false,
      } &&
      match ast.expr_pool_get(exprs, args.get(0)) {
        ast.ExprNode.Binary(op, l, r) =>
          match op { ast.BinaryOp.Add => true, _ => false } &&
          match ast.expr_pool_get(exprs, l) { ast.ExprNode.Int(v) => v == 1, _ => false } &&
          match ast.expr_pool_get(exprs, r) { ast.ExprNode.Int(v) => v == 2, _ => false },
        _ => false,
      },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_if_while_assign_and_expr_stmt() -> () {
  // Stage0 does not support String concatenation with `+`, so keep it as a single literal.
  let src: String = "fn main(x: i32) -> i32 {\n  let mut y: i32 = 0;\n  if x < 3 { y = 1; } else { y = 2; }\n  while y < 10 { y = y + 1; }\n  print(\"ok\");\n  return y;\n}";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.params.len(), 1);
  t.assert_eq(f.body.stmts.len(), 5);

  t.assert(match f.body.stmts.get(2) { ast.Stmt.While(_, _) => true, _ => false });
  t.assert(match f.body.stmts.get(3) { ast.Stmt.Expr(_) => true, _ => false });
  t.assert(match f.body.stmts.get(4) { ast.Stmt.Return(_, _) => true, _ => false });
}

fn test_parse_reports_lex_error() -> () {
  let r: p.ParseResult = p.parse_text("@");
  t.assert(match r.err { p.ParseError.Lex(_) => true, _ => false });
}
