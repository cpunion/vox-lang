import "std/testing" as t
import "parse" as p
import "ast" as ast

fn ok(e: p.ParseError) -> bool {
  // ParseError is an enum; equality on unit variant keeps this helper concise.
  return e == p.ParseError.None;
}

fn ty_is0(tn: ast.TypeName, name: String) -> bool {
  return tn.parts.len() == 1 && tn.parts.get(0) == name && tn.args.len() == 0;
}

fn ty_is_vec1(tn: ast.TypeName, elem: String) -> bool {
  return tn.parts.len() == 1 && tn.parts.get(0) == "Vec" && tn.args.len() == 1 && ty_is0(tn.args.get(0), elem);
}

fn ty_is_const_arg(tn: ast.TypeName, text: String) -> bool {
  return tn.parts.len() == 2 && tn.parts.get(0) == "@const" && tn.parts.get(1) == text && tn.args.len() == 0;
}

fn op_matches_index(op: ast.BinaryOp, idx: i32) -> bool {
  return match idx {
    0 => match op { ast.BinaryOp.Add => true, _ => false },
    1 => match op { ast.BinaryOp.Sub => true, _ => false },
    2 => match op { ast.BinaryOp.Mul => true, _ => false },
    3 => match op { ast.BinaryOp.Div => true, _ => false },
    4 => match op { ast.BinaryOp.Mod => true, _ => false },
    5 => match op { ast.BinaryOp.BitAnd => true, _ => false },
    6 => match op { ast.BinaryOp.BitOr => true, _ => false },
    7 => match op { ast.BinaryOp.BitXor => true, _ => false },
    8 => match op { ast.BinaryOp.Shl => true, _ => false },
    9 => match op { ast.BinaryOp.Shr => true, _ => false },
    _ => false,
  };
}

fn test_parse_single_fn_return_int() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> i32 { return 0; }");
  t.assert(ok(r.err));

  let prog: ast.Program = r.prog;
  let imports: Vec[ast.ImportDecl] = prog.imports;
  t.assert_eq(imports.len(), 0);
  t.assert_eq(prog.structs.len(), 0);
  t.assert_eq(prog.enums.len(), 0);
  let funcs: Vec[ast.FuncDecl] = prog.funcs;
  t.assert_eq(funcs.len(), 1);
  let exprs: ast.ExprPool = prog.exprs;

  let f: ast.FuncDecl = funcs.get(0);
  t.assert_eq(f.name, "main");
  t.assert_eq(f.type_params.len(), 0);
  let params: Vec[ast.Param] = f.params;
  t.assert_eq(params.len(), 0);
  t.assert(ty_is0(f.ret, "i32"));
  let stmts: Vec[ast.Stmt] = f.body.stmts;
  t.assert_eq(stmts.len(), 1);

		  let st: ast.Stmt = stmts.get(0);
		  let is_ret0: bool = match st {
		    ast.Stmt.ReturnStmt(_sp, has, id) => has && match ast.expr_pool_get(exprs, id) {
		      ast.ExprNode.Int(v) => v == "0",
		      _ => false,
		    },
		    _ => false,
		  };
  t.assert(is_ret0);
}

fn test_parse_single_fn_return_float() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> f64 { return 1.25; }");
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert(ty_is0(f.ret, "f64"));
  let st: ast.Stmt = f.body.stmts.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match st {
    ast.Stmt.ReturnStmt(_sp, has, id) => has && match ast.expr_pool_get(exprs, id) {
      ast.ExprNode.Float(v) => v == "1.25",
      _ => false,
    },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_single_fn_return_float_scientific_and_suffix() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> f64 { let a: f64 = 1e3; let b: f32 = 2.5e-2f32; return a + (b as f64); }");
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.body.stmts.len(), 3);
  let exprs: ast.ExprPool = r.prog.exprs;

  let st0: ast.Stmt = f.body.stmts.get(0);
  let ok0: bool = match st0 {
    ast.Stmt.Let(_sp, _is_mut, _name, _has_ty, _ty, id) =>
      match ast.expr_pool_get(exprs, id) { ast.ExprNode.Float(v) => v == "1e3", _ => false },
    _ => false,
  };
  t.assert(ok0);

  let st1: ast.Stmt = f.body.stmts.get(1);
  let ok1: bool = match st1 {
    ast.Stmt.Let(_sp, _is_mut, _name, _has_ty, _ty, id) =>
      match ast.expr_pool_get(exprs, id) { ast.ExprNode.Float(v) => v == "2.5e-2f32", _ => false },
    _ => false,
  };
  t.assert(ok1);
}

fn test_parse_import_as_alias() -> () {
  let r: p.ParseResult = p.parse_text("import \"dep\" as d\nfn main() -> i32 { return 0; }");
  t.assert(ok(r.err));

  let prog: ast.Program = r.prog;
  let imports: Vec[ast.ImportDecl] = prog.imports;
  t.assert_eq(imports.len(), 1);
  let imp: ast.ImportDecl = imports.get(0);
  t.assert_eq(imp.path, "dep");
  t.assert_eq(imp.alias, "d");
  t.assert_eq(imp.names.len(), 0);

  let funcs: Vec[ast.FuncDecl] = prog.funcs;
  t.assert_eq(funcs.len(), 1);
  t.assert_eq(funcs.get(0).name, "main");
}

fn test_parse_named_import_from() -> () {
  let src: String = "import { one as uno, two } from \"dep\"\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.imports.len(), 1);
  let imp: ast.ImportDecl = r.prog.imports.get(0);
  t.assert_eq(imp.path, "dep");
  t.assert_eq(imp.alias, "");
  t.assert_eq(imp.names.len(), 2);
  t.assert_eq(imp.names.get(0).name, "one");
  t.assert_eq(imp.names.get(0).alias, "uno");
  t.assert_eq(imp.names.get(1).name, "two");
  t.assert_eq(imp.names.get(1).alias, "");
}

fn test_parse_generic_type_names_with_brackets() -> () {
  let src: String = "fn f(xs: Vec[i32]) -> Vec[String] { return xs; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.type_params.len(), 0);
  t.assert_eq(f.params.len(), 1);
  let p0: ast.Param = f.params.get(0);
  t.assert_eq(p0.name, "xs");
  t.assert(ty_is_vec1(p0.ty, "i32"));
  t.assert(ty_is_vec1(f.ret, "String"));
}

fn test_parse_string_escapes_newline() -> () {
  let src: String = "fn main() -> i32 { print(\"a\\n\"); return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.body.stmts.len(), 2);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;

	  let ok0: bool = match st0 {
	    ast.Stmt.ExprStmt(_sp, eid) => match ast.expr_pool_get(exprs, eid) {
	      ast.ExprNode.Call(_callee, _targs, args) =>
	        args.len() == 1 && match ast.expr_pool_get(exprs, args.get(0)) {
	          ast.ExprNode.Str(s) => s == "a\n",
	          _ => false,
	        },
      _ => false,
    },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_fn_type_params() -> () {
  let src: String = "fn id[T](x: T) -> T { return x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.type_params.len(), 1);
  t.assert_eq(f.type_params.get(0), "T");
  t.assert_eq(f.params.len(), 1);
  t.assert(ty_is0(f.params.get(0).ty, "T"));
  t.assert(ty_is0(f.ret, "T"));
}

fn test_parse_fn_const_params() -> () {
  let src: String = "fn pick[T, const N: i32](x: T) -> T { return x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.type_params.len(), 1);
  t.assert_eq(f.type_params.get(0), "T");
  t.assert_eq(f.const_params.len(), 1);
  let cp: ast.ConstParamDecl = f.const_params.get(0);
  t.assert_eq(cp.name, "N");
  t.assert(ty_is0(cp.ty, "i32"));
  t.assert(!cp.has_default);
}

fn test_parse_fn_const_params_default_value() -> () {
  let src: String = "fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.const_params.len(), 1);
  let cp: ast.ConstParamDecl = f.const_params.get(0);
  t.assert(cp.has_default);
  t.assert_eq(cp.default_text, "3");
}

fn test_parse_fn_const_params_default_value_negative() -> () {
  let src: String = "fn addn[const N: i32 = -5](x: i32) -> i32 { return x + N; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.const_params.len(), 1);
  let cp: ast.ConstParamDecl = f.const_params.get(0);
  t.assert(cp.has_default);
  t.assert_eq(cp.default_text, "-5");
}

fn test_parse_fn_const_params_default_must_be_trailing() -> () {
  let src: String = "fn addn[const A: i32 = 1, const B: i32](x: i32) -> i32 { return x + A + B; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!ok(r.err));
}

fn test_parse_fn_type_param_trait_bounds() -> () {
  let src: String = "fn eq[T: Eq + Show](x: T, y: T) -> bool { return Eq.eq(x, y); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.type_params.len(), 1);
  t.assert_eq(f.type_param_bounds.len(), 1);
  let b0: ast.TypeParamBoundsDecl = f.type_param_bounds.get(0);
  t.assert_eq(b0.name, "T");
  t.assert_eq(b0.bounds.len(), 2);
  t.assert_eq(b0.bounds.get(0).parts.len(), 1);
  t.assert_eq(b0.bounds.get(0).parts.get(0), "Eq");
  t.assert_eq(b0.bounds.get(1).parts.len(), 1);
  t.assert_eq(b0.bounds.get(1).parts.get(0), "Show");
}

fn test_parse_fn_where_trait_bounds() -> () {
  let src: String = "fn eq[T](x: T, y: T) -> bool where T: Eq + Show { return Eq.eq(x, y); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.type_params.len(), 1);
  t.assert_eq(f.type_param_bounds.len(), 1);
  let b0: ast.TypeParamBoundsDecl = f.type_param_bounds.get(0);
  t.assert_eq(b0.name, "T");
  t.assert_eq(b0.bounds.len(), 2);
  t.assert_eq(b0.bounds.get(0).parts.get(0), "Eq");
  t.assert_eq(b0.bounds.get(1).parts.get(0), "Show");
  t.assert_eq(f.const_where_bounds.len(), 0);
}

fn test_parse_fn_where_comptime_bounds() -> () {
  let src: String = "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0, comptime N <= 8 { return x + N; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.const_params.len(), 1);
  t.assert_eq(f.const_where_bounds.len(), 2);
  let c0: ast.ConstWhereDecl = f.const_where_bounds.get(0);
  t.assert_eq(c0.name, "N");
  t.assert(match c0.op { ast.BinaryOp.Gt => true, _ => false });
  t.assert(!c0.rhs_is_param);
  t.assert_eq(c0.rhs_param, "");
  t.assert_eq(c0.rhs_text, "0");
  let c1: ast.ConstWhereDecl = f.const_where_bounds.get(1);
  t.assert_eq(c1.name, "N");
  t.assert(match c1.op { ast.BinaryOp.Le => true, _ => false });
  t.assert(!c1.rhs_is_param);
  t.assert_eq(c1.rhs_param, "");
  t.assert_eq(c1.rhs_text, "8");
}

fn test_parse_fn_where_comptime_bound_rhs_param() -> () {
  let src: String = "fn addnm[const N: i32, const M: i32](x: i32) -> i32 where comptime N < M { return x + N; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.const_where_bounds.len(), 1);
  let c0: ast.ConstWhereDecl = f.const_where_bounds.get(0);
  t.assert_eq(c0.name, "N");
  t.assert(match c0.op { ast.BinaryOp.Lt => true, _ => false });
  t.assert(c0.rhs_is_param);
  t.assert_eq(c0.rhs_param, "M");
  t.assert_eq(c0.rhs_text, "M");
}

fn test_parse_struct_decl_and_pub_fields() -> () {
  let src: String = "pub struct S { pub x: i32, y: i32 }\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  t.assert_eq(r.prog.structs.len(), 1);
  let s: ast.StructDecl = r.prog.structs.get(0);
  t.assert(s.is_pub);
  t.assert_eq(s.name, "S");
  t.assert_eq(s.fields.len(), 2);
  let f0: ast.FieldDecl = s.fields.get(0);
  t.assert(f0.is_pub);
  t.assert_eq(f0.name, "x");
  t.assert(ty_is0(f0.ty, "i32"));
  let f1: ast.FieldDecl = s.fields.get(1);
  t.assert(!f1.is_pub);
  t.assert_eq(f1.name, "y");
  t.assert(ty_is0(f1.ty, "i32"));
}

fn test_parse_struct_decl_type_params() -> () {
  let src: String = "struct Pair[T] { a: T, b: T }\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.structs.len(), 1);
  let s: ast.StructDecl = r.prog.structs.get(0);
  t.assert_eq(s.name, "Pair");
  t.assert_eq(s.type_params.len(), 1);
  t.assert_eq(s.type_params.get(0), "T");
  t.assert_eq(s.fields.len(), 2);
  t.assert(ty_is0(s.fields.get(0).ty, "T"));
  t.assert(ty_is0(s.fields.get(1).ty, "T"));
}

fn test_parse_enum_decl_variants() -> () {
  let src: String = "enum E { A(i32), B(String), None }\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  t.assert_eq(r.prog.enums.len(), 1);
  let e: ast.EnumDecl = r.prog.enums.get(0);
  t.assert(!e.is_pub);
  t.assert_eq(e.name, "E");
  t.assert_eq(e.variants.len(), 3);

  let v0: ast.EnumVariantDecl = e.variants.get(0);
  t.assert_eq(v0.name, "A");
  t.assert_eq(v0.fields.len(), 1);
  t.assert(ty_is0(v0.fields.get(0), "i32"));

  let v1: ast.EnumVariantDecl = e.variants.get(1);
  t.assert_eq(v1.name, "B");
  t.assert_eq(v1.fields.len(), 1);
  t.assert(ty_is0(v1.fields.get(0), "String"));

  let v2: ast.EnumVariantDecl = e.variants.get(2);
  t.assert_eq(v2.name, "None");
  t.assert_eq(v2.fields.len(), 0);
}

fn test_parse_enum_decl_type_params() -> () {
  let src: String = "enum Option[T] { Some(T), None }\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.enums.len(), 1);
  let e: ast.EnumDecl = r.prog.enums.get(0);
  t.assert_eq(e.name, "Option");
  t.assert_eq(e.type_params.len(), 1);
  t.assert_eq(e.type_params.get(0), "T");
  t.assert_eq(e.variants.len(), 2);
  t.assert_eq(e.variants.get(0).name, "Some");
  t.assert_eq(e.variants.get(0).fields.len(), 1);
  t.assert(ty_is0(e.variants.get(0).fields.get(0), "T"));
}

fn test_parse_typed_path_struct_lit() -> () {
  let src: String = "struct Pair[T] { a: T, b: T }\nfn main() -> i32 { let p = Pair[i32] { a: 1, b: 2 }; return p.a + p.b; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st: ast.Stmt = f.body.stmts.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match st {
    ast.Stmt.Let(_sp, _m, _name, _has_ty, _ty, id) =>
      match ast.expr_pool_get(exprs, id) {
        ast.ExprNode.StructLit(ty_expr, _fields) =>
          match ast.expr_pool_get(exprs, ty_expr) {
            ast.ExprNode.Call(callee, targs, args) =>
              args.len() == 0 && targs.len() == 1 && ty_is0(targs.get(0), "i32") &&
              match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(n) => n == "Pair", _ => false },
            _ => false,
          },
        _ => false,
      },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_typed_path_enum_variant_ctor_and_member() -> () {
  let src: String = "enum Option[T] { Some(T), None }\nfn main() -> i32 { let a = Option[i32].Some(1); let b = Option[i32].None; return match a { Option.Some(v) => v, Option.None => 0 }; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;

  let st0: ast.Stmt = f.body.stmts.get(0);
  let ok_ctor: bool = match st0 {
    ast.Stmt.Let(_sp, _m, _name, _has_ty, _ty, id) =>
      match ast.expr_pool_get(exprs, id) {
        ast.ExprNode.Call(callee, _targs, args) =>
          args.len() == 1 &&
          match ast.expr_pool_get(exprs, callee) {
            ast.ExprNode.Member(recv, name) =>
              name == "Some" &&
              match ast.expr_pool_get(exprs, recv) {
                ast.ExprNode.Call(c2, t2, a2) =>
                  a2.len() == 0 && t2.len() == 1 && ty_is0(t2.get(0), "i32") &&
                  match ast.expr_pool_get(exprs, c2) { ast.ExprNode.Ident(n) => n == "Option", _ => false },
                _ => false,
              },
            _ => false,
          },
        _ => false,
      },
    _ => false,
  };
  t.assert(ok_ctor);

  let st1: ast.Stmt = f.body.stmts.get(1);
  let ok_member: bool = match st1 {
    ast.Stmt.Let(_sp, _m, _name, _has_ty, _ty, id) =>
      match ast.expr_pool_get(exprs, id) {
        ast.ExprNode.Member(recv, name) =>
          name == "None" &&
          match ast.expr_pool_get(exprs, recv) {
            ast.ExprNode.Call(c2, t2, a2) =>
              a2.len() == 0 && t2.len() == 1 && ty_is0(t2.get(0), "i32") &&
              match ast.expr_pool_get(exprs, c2) { ast.ExprNode.Ident(n) => n == "Option", _ => false },
            _ => false,
          },
        _ => false,
      },
    _ => false,
  };
  t.assert(ok_member);
}

fn test_parse_trait_and_impl_decl_smoke() -> () {
  let src: String = "pub trait Show {\n  fn show(x: Self) -> String;\n}\nstruct I { v: i32 }\nimpl Show for I {\n  fn show(x: I) -> String { return \"ok\"; }\n}\nfn main() -> i32 { let x: I = I { v: 1 }; let _s: String = Show.show(x); return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.traits.len(), 1);
  t.assert_eq(r.prog.impls.len(), 1);

  let td: ast.TraitDecl = r.prog.traits.get(0);
  t.assert(td.is_pub);
  t.assert_eq(td.name, "Show");
  t.assert_eq(td.assoc_types.len(), 0);
  t.assert_eq(td.methods.len(), 1);
  t.assert_eq(td.methods.get(0).name, "show");

  let id: ast.ImplDecl = r.prog.impls.get(0);
  t.assert_eq(id.assoc_types.len(), 0);
  t.assert_eq(id.methods.len(), 1);
  t.assert_eq(id.methods.get(0).name, "show");
}

fn test_parse_trait_assoc_type_and_impl_binding_smoke() -> () {
  let src: String = "trait Iter { type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { let x: I = I { v: 1 }; return Iter.next(x); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.traits.len(), 1);
  t.assert_eq(r.prog.impls.len(), 1);
  let td: ast.TraitDecl = r.prog.traits.get(0);
  t.assert_eq(td.assoc_types.len(), 1);
  t.assert_eq(td.assoc_types.get(0).name, "Item");
  t.assert_eq(td.methods.len(), 1);
  let id: ast.ImplDecl = r.prog.impls.get(0);
  t.assert_eq(id.assoc_types.len(), 1);
  t.assert_eq(id.assoc_types.get(0).name, "Item");
  t.assert(ty_is0(id.assoc_types.get(0).ty, "i32"));
}

fn test_parse_impl_type_params_and_bounds_smoke() -> () {
  let src: String = "trait Show { fn show(x: Self) -> String; }\nimpl[T: Show] Show for Vec[T] {\n  fn show(x: Vec[T]) -> String { return \"ok\"; }\n}\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.impls.len(), 1);
  let id: ast.ImplDecl = r.prog.impls.get(0);
  t.assert_eq(id.type_params.len(), 1);
  t.assert_eq(id.type_params.get(0), "T");
  t.assert_eq(id.type_param_bounds.len(), 1);
  t.assert_eq(id.type_param_bounds.get(0).name, "T");
  t.assert_eq(id.type_param_bounds.get(0).bounds.len(), 1);
  t.assert_eq(id.type_param_bounds.get(0).bounds.get(0).parts.get(0), "Show");
  t.assert_eq(id.for_ty.parts.len(), 1);
  t.assert_eq(id.for_ty.parts.get(0), "Vec");
  t.assert_eq(id.for_ty.args.len(), 1);
  t.assert_eq(id.for_ty.args.get(0).parts.get(0), "T");
}

fn test_parse_trait_default_method_body() -> () {
  let src: String = "trait Show {\n  fn show(x: Self) -> String { return \"x\"; }\n}\nstruct I { v: i32 }\nimpl Show for I {}\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.traits.len(), 1);
  let td: ast.TraitDecl = r.prog.traits.get(0);
  t.assert_eq(td.methods.len(), 1);
  let md: ast.TraitMethodDecl = td.methods.get(0);
  t.assert(md.has_body);
  t.assert_eq(md.body.stmts.len(), 1);
}

fn test_parse_trait_multiple_methods_semicolon_separated() -> () {
  let src: String = "trait T { fn a(x: Self) -> i32; fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl T for I { fn a(x: I) -> i32 { return 1; } fn b(x: I) -> i32 { return 2; } }\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.traits.len(), 1);
  let td: ast.TraitDecl = r.prog.traits.get(0);
  t.assert_eq(td.methods.len(), 2);
  t.assert_eq(td.methods.get(0).name, "a");
  t.assert_eq(td.methods.get(1).name, "b");
}

fn test_parse_trait_supertraits() -> () {
  let src: String = "trait Child: A + B { fn go(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Child for I { fn go(x: I) -> i32 { return 1; } }\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.traits.len(), 1);
  let td: ast.TraitDecl = r.prog.traits.get(0);
  t.assert_eq(td.supers.len(), 2);
  t.assert_eq(td.supers.get(0).parts.get(0), "A");
  t.assert_eq(td.supers.get(1).parts.get(0), "B");
}

fn test_parse_trait_method_type_params_and_where_bounds() -> () {
  let src: String = "trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T where T: Show; }\nstruct I { v: i32 }\nimpl Wrap for I { fn wrap[T: Eq](x: I, v: T) -> T where T: Show { return v; } }\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let td: ast.TraitDecl = r.prog.traits.get(0);
  let md: ast.TraitMethodDecl = td.methods.get(0);
  t.assert_eq(md.type_params.len(), 1);
  t.assert_eq(md.type_params.get(0), "T");
  t.assert_eq(md.type_param_bounds.len(), 2);
  t.assert_eq(md.type_param_bounds.get(0).name, "T");
  t.assert_eq(md.type_param_bounds.get(1).name, "T");
  t.assert_eq(md.const_where_bounds.len(), 0);
}

fn test_parse_trait_method_where_comptime_bounds() -> () {
  let src: String = "trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N >= 1; }\nstruct I { v: i32 }\nimpl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N >= 1 { return v + N; } }\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let td: ast.TraitDecl = r.prog.traits.get(0);
  let md: ast.TraitMethodDecl = td.methods.get(0);
  t.assert_eq(md.const_where_bounds.len(), 1);
  let c0: ast.ConstWhereDecl = md.const_where_bounds.get(0);
  t.assert_eq(c0.name, "N");
  t.assert(match c0.op { ast.BinaryOp.Ge => true, _ => false });
  t.assert(!c0.rhs_is_param);
  t.assert_eq(c0.rhs_param, "");
  t.assert_eq(c0.rhs_text, "1");
}

fn test_parse_trait_method_const_params() -> () {
  let src: String = "trait Wrap { fn addn[const N: i32](x: Self, v: i32) -> i32; }\nstruct I { v: i32 }\nimpl Wrap for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }\nfn main() -> i32 { let x: I = I { v: 1 }; return Wrap.addn[3](x, 4); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let td: ast.TraitDecl = r.prog.traits.get(0);
  let md: ast.TraitMethodDecl = td.methods.get(0);
  t.assert_eq(md.const_params.len(), 1);
  let cp: ast.ConstParamDecl = md.const_params.get(0);
  t.assert_eq(cp.name, "N");
  t.assert(ty_is0(cp.ty, "i32"));
}

fn test_parse_let_mut_with_type_ann_and_int_init() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> i32 { let mut x: i32 = 1; return x; }");
  t.assert(ok(r.err));

  let prog: ast.Program = r.prog;
  let funcs: Vec[ast.FuncDecl] = prog.funcs;
  let exprs: ast.ExprPool = prog.exprs;
  let f: ast.FuncDecl = funcs.get(0);
  let stmts: Vec[ast.Stmt] = f.body.stmts;
  t.assert_eq(stmts.len(), 2);

  let st0: ast.Stmt = stmts.get(0);
	  let ok0: bool = match st0 {
	    ast.Stmt.Let(_sp, mutable, name, has_ann, ann, init) =>
	      mutable && name == "x" && has_ann && ty_is0(ann, "i32") &&
	      match ast.expr_pool_get(exprs, init) { ast.ExprNode.Int(v) => v == "1", _ => false },
	    _ => false,
	  };
  t.assert(ok0);

	  let st1: ast.Stmt = stmts.get(1);
	  let ok1: bool = match st1 {
	    ast.Stmt.ReturnStmt(_sp, has, id) => has && match ast.expr_pool_get(exprs, id) { ast.ExprNode.Ident(s) => s == "x", _ => false },
	    _ => false,
	  };
  t.assert(ok1);
}

fn test_parse_call_explicit_type_args() -> () {
  let src: String = "fn id[T](x: T) -> T { return x; }\nfn main() -> i32 { return id[i32](1); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let prog: ast.Program = r.prog;
  t.assert_eq(prog.funcs.len(), 2);
  let f: ast.FuncDecl = prog.funcs.get(1);
	  let exprs: ast.ExprPool = prog.exprs;
	  let st: ast.Stmt = f.body.stmts.get(0);
	  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
	  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "id", _ => false } &&
      targs.len() == 1 && ty_is0(targs.get(0), "i32") &&
      args.len() == 1 && match ast.expr_pool_get(exprs, args.get(0)) { ast.ExprNode.Int(v) => v == "1", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_call_explicit_const_args() -> () {
  let src: String = "fn idn[const N: i32](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return idn[3](1); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let prog: ast.Program = r.prog;
  t.assert_eq(prog.funcs.len(), 2);
  let f: ast.FuncDecl = prog.funcs.get(1);
  let exprs: ast.ExprPool = prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "idn", _ => false } &&
      targs.len() == 1 && ty_is_const_arg(targs.get(0), "3") &&
      args.len() == 1 && match ast.expr_pool_get(exprs, args.get(0)) { ast.ExprNode.Int(v) => v == "1", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_call() -> () {
  let src: String = "fn main() -> usize { return @size_of(i32); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 && ty_is0(targs.get(0), "i32") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@size_of", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_unknown_rejected() -> () {
  let src: String = "fn main() -> usize { return @foo(i32); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!ok(r.err));
}

fn test_parse_reflect_intrinsic_type_pred_call() -> () {
  let src: String = "fn main() -> bool { return @is_integer(i32); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 && ty_is0(targs.get(0), "i32") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@is_integer", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_signed_int_pred_call() -> () {
  let src: String = "fn main() -> bool { return @is_signed_int(i32); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 && ty_is0(targs.get(0), "i32") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@is_signed_int", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_unsigned_int_pred_call() -> () {
  let src: String = "fn main() -> bool { return @is_unsigned_int(u32); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 && ty_is0(targs.get(0), "u32") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@is_unsigned_int", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_is_vec_call() -> () {
  let src: String = "fn main() -> bool { return @is_vec(Vec[i32]); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@is_vec", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_is_range_call() -> () {
  let src: String = "type R = @range(0..=7) i32\nfn main() -> bool { return @is_range(R); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@is_range", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_is_bool_call() -> () {
  let src: String = "fn main() -> bool { return @is_bool(bool); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@is_bool", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_is_string_call() -> () {
  let src: String = "fn main() -> bool { return @is_string(String); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@is_string", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_same_type_call() -> () {
  let src: String = "fn main() -> bool { return @same_type(i32, i64); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 2 &&
      ty_is0(targs.get(0), "i32") &&
      ty_is0(targs.get(1), "i64") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@same_type", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_type_id_call() -> () {
  let src: String = "fn main() -> usize { return @type(i32); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 && ty_is0(targs.get(0), "i32") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@type", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_field_count_call() -> () {
  let src: String = "struct S { a: i32, b: i64 }\nfn main() -> usize { return @field_count(S); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 && ty_is0(targs.get(0), "S") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@field_count", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_field_name_call() -> () {
  let src: String = "struct S { a: i32, b: i64 }\nfn main() -> String { return @field_name(S, 1); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 2 &&
      ty_is0(targs.get(0), "S") &&
      ty_is_const_arg(targs.get(1), "1") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@field_name", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_field_type_call() -> () {
  let src: String = "struct S { a: i32, b: i64 }\nfn main() -> String { return @field_type(S, 1); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 2 &&
      ty_is0(targs.get(0), "S") &&
      ty_is_const_arg(targs.get(1), "1") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@field_type", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_field_type_id_call() -> () {
  let src: String = "struct S { a: i32, b: i64 }\nfn main() -> TypeId { return @field_type_id(S, 1); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 2 &&
      ty_is0(targs.get(0), "S") &&
      ty_is_const_arg(targs.get(1), "1") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@field_type_id", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_assignable_to_call() -> () {
  let src: String = "fn main() -> bool { return @assignable_to(i32, i64); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 2 &&
      ty_is0(targs.get(0), "i32") &&
      ty_is0(targs.get(1), "i64") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@assignable_to", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_castable_to_call() -> () {
  let src: String = "fn main() -> bool { return @castable_to(i32, f64); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 2 &&
      ty_is0(targs.get(0), "i32") &&
      ty_is0(targs.get(1), "f64") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@castable_to", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_is_eq_comparable_call() -> () {
  let src: String = "struct S { a: i32 }\nfn main() -> bool { return @is_eq_comparable(S); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 &&
      ty_is0(targs.get(0), "S") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@is_eq_comparable", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_is_ordered_call() -> () {
  let src: String = "fn main() -> bool { return @is_ordered(String); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 &&
      ty_is0(targs.get(0), "String") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@is_ordered", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_is_unit_call() -> () {
  let src: String = "fn main() -> bool { return @is_unit(()); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 &&
      ty_is0(targs.get(0), "()") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@is_unit", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_is_numeric_call() -> () {
  let src: String = "fn main() -> bool { return @is_numeric(i64); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 &&
      ty_is0(targs.get(0), "i64") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@is_numeric", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_is_zero_sized_call() -> () {
  let src: String = "fn main() -> bool { return @is_zero_sized(()); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 1 &&
      ty_is0(targs.get(0), "()") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@is_zero_sized", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_eq_comparable_with_call() -> () {
  let src: String = "fn main() -> bool { return @eq_comparable_with(i32, i32); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 2 &&
      ty_is0(targs.get(0), "i32") &&
      ty_is0(targs.get(1), "i32") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@eq_comparable_with", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_same_layout_call() -> () {
  let src: String = "fn main() -> bool { return @same_layout(i32, u32); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 2 &&
      ty_is0(targs.get(0), "i32") &&
      ty_is0(targs.get(1), "u32") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@same_layout", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_bitcastable_call() -> () {
  let src: String = "fn main() -> bool { return @bitcastable(i32, u32); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 2 &&
      ty_is0(targs.get(0), "i32") &&
      ty_is0(targs.get(1), "u32") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@bitcastable", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_reflect_intrinsic_ordered_with_call() -> () {
  let src: String = "fn main() -> bool { return @ordered_with(String, String); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      args.len() == 0 && targs.len() == 2 &&
      ty_is0(targs.get(0), "String") &&
      ty_is0(targs.get(1), "String") &&
      match ast.expr_pool_get(exprs, callee) { ast.ExprNode.Ident(s) => s == "@ordered_with", _ => false },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_member_call_and_add() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> i32 { return a.b(1 + 2); }");
  t.assert(ok(r.err));

  let prog: ast.Program = r.prog;
  let exprs: ast.ExprPool = prog.exprs;
  let funcs: Vec[ast.FuncDecl] = prog.funcs;
  let f: ast.FuncDecl = funcs.get(0);
  let stmts: Vec[ast.Stmt] = f.body.stmts;
  let st: ast.Stmt = stmts.get(0);
  let rid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };

  // return <call>
  let ok_call: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Call(callee, targs, args) =>
      targs.len() == 0 && args.len() == 1 &&
      match ast.expr_pool_get(exprs, callee) {
        ast.ExprNode.Member(recv, name) =>
          name == "b" &&
          match ast.expr_pool_get(exprs, recv) { ast.ExprNode.Ident(s) => s == "a", _ => false },
        _ => false,
      } &&
      match ast.expr_pool_get(exprs, args.get(0)) {
        ast.ExprNode.Binary(op, l, r) =>
          match op { ast.BinaryOp.Add => true, _ => false } &&
          match ast.expr_pool_get(exprs, l) { ast.ExprNode.Int(v) => v == "1", _ => false } &&
          match ast.expr_pool_get(exprs, r) { ast.ExprNode.Int(v) => v == "2", _ => false },
        _ => false,
      },
    _ => false,
  };
  t.assert(ok_call);
}

fn test_parse_postfix_after_paren_expr() -> () {
  // `(expr).foo(...)` should parse as a normal postfix member call.
  let r: p.ParseResult = p.parse_text("fn main() -> i32 { return (a).b(); }");
  t.assert(ok(r.err));
}

fn test_parse_field_assign_stmt() -> () {
  let r: p.ParseResult = p.parse_text("struct S { x: i32 }\nfn main() -> i32 { let mut s: S = S { x: 1 }; s.x = 2; return 0; }");
  t.assert(ok(r.err));
}

fn test_parse_nested_field_assign_stmt() -> () {
  let src: String = "struct I { x: i32 }\nstruct O { i: I }\nfn main() -> i32 { let mut o: O = O { i: I { x: 1 } }; o.i.x = 2; return o.i.x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st1: ast.Stmt = f.body.stmts.get(1);
  let ok0: bool = match st1 {
    ast.Stmt.AssignField(_sp, recv, field, _id) => recv == "o" && field == "i.x",
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_compound_assign_stmt() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> i32 { let mut x: i32 = 1; x += 2; return x; }");
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st1: ast.Stmt = f.body.stmts.get(1);
  let ok0: bool = match st1 {
    ast.Stmt.Assign(_sp, name, id) =>
      name == "x" &&
      match ast.expr_pool_get(exprs, id) {
        ast.ExprNode.Binary(op, l, rhs) =>
          match op { ast.BinaryOp.Add => true, _ => false } &&
          match ast.expr_pool_get(exprs, l) { ast.ExprNode.Ident(s) => s == "x", _ => false } &&
          match ast.expr_pool_get(exprs, rhs) { ast.ExprNode.Int(v) => v == "2", _ => false },
        _ => false,
      },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_compound_field_assign_stmt() -> () {
  let src: String = "struct S { x: i32 }\nfn main() -> i32 { let mut s: S = S { x: 1 }; s.x <<= 1; return s.x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st1: ast.Stmt = f.body.stmts.get(1);
  let ok0: bool = match st1 {
    ast.Stmt.AssignField(_sp, recv, field, id) =>
      recv == "s" && field == "x" &&
      match ast.expr_pool_get(exprs, id) {
        ast.ExprNode.Binary(op, l, rhs) =>
          match op { ast.BinaryOp.Shl => true, _ => false } &&
          match ast.expr_pool_get(exprs, l) {
            ast.ExprNode.Member(recv_id, name) =>
              name == "x" && match ast.expr_pool_get(exprs, recv_id) { ast.ExprNode.Ident(s) => s == "s", _ => false },
            _ => false,
          } &&
          match ast.expr_pool_get(exprs, rhs) { ast.ExprNode.Int(v) => v == "1", _ => false },
        _ => false,
      },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_compound_nested_field_assign_stmt() -> () {
  let src: String = "struct I { x: i32 }\nstruct O { i: I }\nfn main() -> i32 { let mut o: O = O { i: I { x: 1 } }; o.i.x += 3; return o.i.x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st1: ast.Stmt = f.body.stmts.get(1);
  let ok0: bool = match st1 {
    ast.Stmt.AssignField(_sp, recv, field, id) =>
      recv == "o" && field == "i.x" &&
      match ast.expr_pool_get(exprs, id) {
        ast.ExprNode.Binary(op, l, rhs) =>
          match op { ast.BinaryOp.Add => true, _ => false } &&
          match ast.expr_pool_get(exprs, l) {
            ast.ExprNode.Member(l0, n1) =>
              n1 == "x" && match ast.expr_pool_get(exprs, l0) {
                ast.ExprNode.Member(l1, n0) =>
                  n0 == "i" && match ast.expr_pool_get(exprs, l1) { ast.ExprNode.Ident(s) => s == "o", _ => false },
                _ => false,
              },
            _ => false,
          } &&
          match ast.expr_pool_get(exprs, rhs) { ast.ExprNode.Int(v) => v == "3", _ => false },
        _ => false,
      },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_compound_assign_all_ops() -> () {
  let src: String = "fn main() -> i32 {\n  let mut x: i32 = 0;\n  x += 1;\n  x -= 2;\n  x *= 3;\n  x /= 4;\n  x %= 5;\n  x &= 6;\n  x |= 7;\n  x ^= 8;\n  x <<= 9;\n  x >>= 10;\n  return x;\n}";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let mut ok_all: bool = f.body.stmts.len() == 12;
  let mut i: i32 = 0;
  while ok_all && i < 10 {
    let st: ast.Stmt = f.body.stmts.get(1 + i);
    let ok_i: bool = match st {
      ast.Stmt.Assign(_sp, name, id) =>
        name == "x" &&
        match ast.expr_pool_get(exprs, id) {
          ast.ExprNode.Binary(op, l, _rhs) =>
            op_matches_index(op, i) &&
            match ast.expr_pool_get(exprs, l) { ast.ExprNode.Ident(s) => s == "x", _ => false },
          _ => false,
        },
      _ => false,
    };
    ok_all = ok_all && ok_i;
    i = i + 1;
  }
  t.assert(ok_all);
}

fn test_parse_compound_field_assign_all_ops() -> () {
  let src: String = "struct S { x: i32 }\nfn main() -> i32 {\n  let mut s: S = S { x: 0 };\n  s.x += 1;\n  s.x -= 2;\n  s.x *= 3;\n  s.x /= 4;\n  s.x %= 5;\n  s.x &= 6;\n  s.x |= 7;\n  s.x ^= 8;\n  s.x <<= 9;\n  s.x >>= 10;\n  return s.x;\n}";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let mut ok_all: bool = f.body.stmts.len() == 12;
  let mut i: i32 = 0;
  while ok_all && i < 10 {
    let st: ast.Stmt = f.body.stmts.get(1 + i);
    let ok_i: bool = match st {
      ast.Stmt.AssignField(_sp, recv, field, id) =>
        recv == "s" && field == "x" &&
        match ast.expr_pool_get(exprs, id) {
          ast.ExprNode.Binary(op, l, _rhs) =>
            op_matches_index(op, i) &&
            match ast.expr_pool_get(exprs, l) {
              ast.ExprNode.Member(recv_id, name) =>
                name == "x" && match ast.expr_pool_get(exprs, recv_id) { ast.ExprNode.Ident(s) => s == "s", _ => false },
              _ => false,
            },
          _ => false,
        },
      _ => false,
    };
    ok_all = ok_all && ok_i;
    i = i + 1;
  }
  t.assert(ok_all);
}

fn test_parse_struct_literal_expr() -> () {
  let src: String = "struct S { x: i32, y: i32 }\nfn main() -> i32 { let s: S = S { x: 1, y: 2 }; return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_, _, _, _, _, id) => id, _ => -1 };
  let ok_lit: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.StructLit(ty, fields) =>
      match ast.expr_pool_get(exprs, ty) { ast.ExprNode.Ident(s) => s == "S", _ => false } &&
      fields.len() == 2 &&
      fields.get(0).name == "x" &&
      match ast.expr_pool_get(exprs, fields.get(0).expr) { ast.ExprNode.Int(v) => v == "1", _ => false } &&
      fields.get(1).name == "y" &&
      match ast.expr_pool_get(exprs, fields.get(1).expr) { ast.ExprNode.Int(v) => v == "2", _ => false },
    _ => false,
  };
  t.assert(ok_lit);
}

fn test_parse_type_alias_decl() -> () {
  let src: String = "type I = i32\ntype V = Vec[I]\nfn main() -> i32 { let x: I = 1; let mut v: V = Vec(); v.push(x); return v.len(); }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.funcs.len(), 1);
  // Type aliases are covered more directly in typecheck tests; parser smoke is enough here.
}

fn test_parse_union_type_decl_smoke() -> () {
  let src: String = "type Value = I32: i32 | Str: String\nfn main() -> i32 { let x: Value = .I32(1); return match x { .I32(v) => v, .Str(_s) => 0 }; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.enums.len(), 1);
  t.assert_eq(r.prog.enums.get(0).name, "Value");
  t.assert_eq(r.prog.enums.get(0).variants.len(), 2);
  t.assert_eq(r.prog.enums.get(0).variants.get(0).name, "I32");
  t.assert_eq(r.prog.enums.get(0).variants.get(1).name, "Str");
}

fn test_parse_const_decl_smoke() -> () {
  let src: String = "const N: i32 = 1 + 2\npub const M: i64 = 3\nfn main() -> i32 { return N; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.consts.len(), 2);
  t.assert_eq(r.prog.consts.get(0).name, "N");
  t.assert_eq(r.prog.consts.get(1).name, "M");
  t.assert(r.prog.consts.get(1).is_pub);
}

fn test_parse_pub_restricted_visibility_smoke() -> () {
  let src: String = "pub(crate) const N: i32 = 1\npub(super) fn main() -> i32 { return N; }\npub struct S { pub(crate) x: i32, pub(super) y: i32 }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  t.assert_eq(r.prog.consts.len(), 1);
  t.assert(r.prog.consts.get(0).is_pub);
  t.assert_eq(r.prog.consts.get(0).vis, ast.vis_crate());
  t.assert_eq(r.prog.funcs.len(), 1);
  t.assert(r.prog.funcs.get(0).is_pub);
  t.assert_eq(r.prog.funcs.get(0).vis, ast.vis_super());
  t.assert_eq(r.prog.structs.len(), 1);
  t.assert_eq(r.prog.structs.get(0).vis, ast.vis_pub());
  t.assert_eq(r.prog.structs.get(0).fields.len(), 2);
  t.assert(r.prog.structs.get(0).fields.get(0).is_pub);
  t.assert(r.prog.structs.get(0).fields.get(1).is_pub);
  t.assert_eq(r.prog.structs.get(0).fields.get(0).vis, ast.vis_crate());
  t.assert_eq(r.prog.structs.get(0).fields.get(1).vis, ast.vis_super());
}

fn test_parse_const_block_rejects_while_with_extra_semicolon() -> () {
  let src: String = "const N: i32 = { while true { break; }; 1 }\nfn main() -> i32 { return N; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!ok(r.err));
}

fn test_parse_match_expr_enum_variant_pattern() -> () {
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 { let x: E = E.None; return match x { E.A(v) => v, E.None => 0, _ => 1 }; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st1: ast.Stmt = f.body.stmts.get(1);
  let rid: i32 = match st1 { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_match: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Match(scr, arms) =>
      match ast.expr_pool_get(exprs, scr) { ast.ExprNode.Ident(s) => s == "x", _ => false } &&
      arms.len() == 3 &&
      match arms.get(0).pat {
        ast.Pat.EnumVariant(_sp, enum_parts, vname, args) =>
          enum_parts.len() == 1 && enum_parts.get(0) == "E" && vname == "A" && args.len() == 1 &&
          match args.get(0) { ast.Pat.Bind(_sp2, n) => n == "v", _ => false },
        _ => false
      } &&
      match arms.get(1).pat { ast.Pat.EnumVariant(_sp, enum_parts, vname, args) => enum_parts.len() == 1 && enum_parts.get(0) == "E" && vname == "None" && args.len() == 0, _ => false } &&
      match arms.get(2).pat { ast.Pat.Wild(_sp) => true, _ => false },
    _ => false,
  };
  t.assert(ok_match);
}

fn test_parse_match_expr_enum_variant_pattern_shorthand() -> () {
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 { let x: E = .None; return match x { .A(v) => v, .None => 0, _ => 1 }; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_, _, _, _, _, id) => id, _ => -1 };
  t.assert(match ast.expr_pool_get(exprs, init) { ast.ExprNode.DotIdent(s) => s == "None", _ => false });

  let st1: ast.Stmt = f.body.stmts.get(1);
  let rid: i32 = match st1 { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_match: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Match(_scr, arms) =>
      arms.len() == 3 &&
      match arms.get(0).pat {
        ast.Pat.EnumVariant(_sp, enum_parts, vname, args) =>
          enum_parts.len() == 0 && vname == "A" && args.len() == 1 &&
          match args.get(0) { ast.Pat.Bind(_sp2, n) => n == "v", _ => false },
        _ => false
      } &&
      match arms.get(1).pat { ast.Pat.EnumVariant(_sp, enum_parts, vname, args) => enum_parts.len() == 0 && vname == "None" && args.len() == 0, _ => false } &&
      match arms.get(2).pat { ast.Pat.Wild(_sp) => true, _ => false },
    _ => false,
  };
  t.assert(ok_match);
}

fn test_parse_match_expr_bool_pattern() -> () {
  let src: String = "fn main(x: bool) -> i32 { return match x { true => 1, false => 0 }; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let st0: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st0 { ast.Stmt.ReturnStmt(_sp, _, id) => id, _ => -1 };
  let ok_match: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Match(_scr, arms) =>
      arms.len() == 2 &&
      match arms.get(0).pat { ast.Pat.Bool(_sp, b) => b, _ => false } &&
      match arms.get(1).pat { ast.Pat.Bool(_sp, b) => !b, _ => false },
    _ => false,
  };
  t.assert(ok_match);
}

fn test_parse_if_while_assign_and_expr_stmt() -> () {
  // Stage0 does not support String concatenation with `+`, so keep it as a single literal.
  let src: String = "fn main(x: i32) -> i32 {\n  let mut y: i32 = 0;\n  if x < 3 { y = 1; } else { y = 2; }\n  while y < 10 { y = y + 1; }\n  print(\"ok\");\n  return y;\n}";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.params.len(), 1);
  t.assert_eq(f.body.stmts.len(), 5);

  t.assert(match f.body.stmts.get(2) { ast.Stmt.WhileStmt(_, _, _) => true, _ => false });
  t.assert(match f.body.stmts.get(3) { ast.Stmt.ExprStmt(_, _) => true, _ => false });
  t.assert(match f.body.stmts.get(4) { ast.Stmt.ReturnStmt(_, _, _) => true, _ => false });
}

fn test_parse_if_expr() -> () {
  // if-expression: `if cond { expr } else { expr }`
  let src: String = "fn main(x: i32) -> i32 {\n  let y: i32 = if x < 3 { 1 } else { 2 };\n  return if y < 0 { 0 } else { y };\n}";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
}

fn test_parse_if_expr_branches_are_block_exprs() -> () {
  let src: String = "fn main(x: i32) -> i32 {\n  let y: i32 = if x < 3 { let z: i32 = 1; z } else { 2 };\n  return y;\n}";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.body.stmts.len(), 2);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  let exprs: ast.ExprPool = r.prog.exprs;

  let ok0: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.If(_c, t_id, e_id) =>
      match ast.expr_pool_get(exprs, t_id) {
        ast.ExprNode.Block(b) =>
          b.stmts.len() == 1 &&
          match b.stmts.get(0) {
            ast.Stmt.Let(_sp, _m, name, _ha, _ann, init2) =>
              name == "z" && match ast.expr_pool_get(exprs, init2) { ast.ExprNode.Int(v) => v == "1", _ => false },
            _ => false,
          } &&
          b.has_tail && match ast.expr_pool_get(exprs, b.tail) { ast.ExprNode.Ident(s) => s == "z", _ => false },
        _ => false,
      } &&
      match ast.expr_pool_get(exprs, e_id) {
        ast.ExprNode.Block(b2) =>
          b2.stmts.len() == 0 && b2.has_tail && match ast.expr_pool_get(exprs, b2.tail) { ast.ExprNode.Int(v) => v == "2", _ => false },
        _ => false,
      },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_block_expr_tail_can_be_if_expr() -> () {
  let src: String = "fn main() -> i32 {\n  let y: i32 = { if true { 1 } else { 2 } };\n  return y;\n}";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.body.stmts.len(), 2);

  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  let exprs: ast.ExprPool = r.prog.exprs;

  let ok0: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.Block(b) =>
      b.stmts.len() == 0 &&
      b.has_tail &&
      match ast.expr_pool_get(exprs, b.tail) { ast.ExprNode.If(_c, _t, _e) => true, _ => false },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_match_arm_block_expr() -> () {
  let src: String = "fn main(x: i32) -> i32 { return match x { 0 => { let y: i32 = 1; y }, _ => { 2 } }; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.body.stmts.len(), 1);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let rid: i32 = match st0 { ast.Stmt.ReturnStmt(_sp, _has, id) => id, _ => -1 };
  let exprs: ast.ExprPool = r.prog.exprs;

  let ok0: bool = match ast.expr_pool_get(exprs, rid) {
    ast.ExprNode.Match(_scr, arms) =>
      {
        let mut ok: bool = arms.len() == 2;
        if ok {
          let a0: ast.MatchArm = arms.get(0);
          let a1: ast.MatchArm = arms.get(1);
          let ok0: bool = match ast.expr_pool_get(exprs, a0.expr) {
            ast.ExprNode.Block(b) =>
              b.stmts.len() == 1 &&
              match b.stmts.get(0) {
                ast.Stmt.Let(_sp, _m, name, _ha, _ann, init2) =>
                  name == "y" && match ast.expr_pool_get(exprs, init2) { ast.ExprNode.Int(v) => v == "1", _ => false },
                _ => false,
              } &&
              b.has_tail && match ast.expr_pool_get(exprs, b.tail) { ast.ExprNode.Ident(s) => s == "y", _ => false },
            _ => false,
          };
          let ok1: bool = match ast.expr_pool_get(exprs, a1.expr) {
            ast.ExprNode.Block(b2) =>
              b2.stmts.len() == 0 && b2.has_tail && match ast.expr_pool_get(exprs, b2.tail) { ast.ExprNode.Int(v) => v == "2", _ => false },
            _ => false,
          };
          ok = ok0 && ok1;
        }
        ok
      },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_reports_lex_error() -> () {
  let r: p.ParseResult = p.parse_text("#");
  t.assert(match r.err { p.ParseError.Lex(_) => true, _ => false });
}

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn test_parse_error_format_includes_line_col_unexpected_token() -> () {
  let file: String = "src/main.vox";
  // Parse a valid item, then hit "else" at line 2, col 1.
  let src: String = "fn main() -> i32 { return 0; }\nelse";
  let r: p.ParseResult = p.parse_text_with_path(file, src);
  t.assert(r.err != p.ParseError.None);
  let msg: String = p.parse_error_to_string_with_source(file, src, r.err);
  t.assert(contains(msg, "src/main.vox:2:1"));
  t.assert(contains(msg, "expected fn"));
}

fn test_parse_error_format_includes_line_col_lex_unexpected_char() -> () {
  let file: String = "src/main.vox";
  // '#' at line 2, col 3 (two spaces indentation).
  let src: String = "fn main() -> i32 {\n  #\n  return 0;\n}";
  let r: p.ParseResult = p.parse_text_with_path(file, src);
  t.assert(r.err != p.ParseError.None);
  let msg: String = p.parse_error_to_string_with_source(file, src, r.err);
  t.assert(contains(msg, "src/main.vox:2:3"));
  t.assert(contains(msg, "lex error"));
}
