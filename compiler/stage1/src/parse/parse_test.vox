import "std/testing" as t
import "parse" as p
import "ast" as ast

fn ok(e: p.ParseError) -> bool {
  return match e {
    p.ParseError.None => true,
    _ => false,
  };
}

fn test_parse_single_fn_return_int() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> i32 { return 0; }");
  t.assert(ok(r.err));

  let prog: ast.Program = r.prog;
  let funcs: Vec[ast.FuncDecl] = prog.funcs;
  t.assert_eq(funcs.len(), 1);

  let f: ast.FuncDecl = funcs.get(0);
  t.assert_eq(f.name, "main");
  t.assert_eq(f.ret.name, "i32");
  let stmts: Vec[ast.Stmt] = f.body.stmts;
  t.assert_eq(stmts.len(), 1);

  let st: ast.Stmt = stmts.get(0);
  let is_ret0: bool = match st {
    ast.Stmt.Return(ex) => match ex {
      ast.Expr.Int(v) => v == 0,
      _ => false,
    },
    _ => false,
  };
  t.assert(is_ret0);
}

fn test_parse_let_mut_with_type_ann_and_int_init() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> i32 { let mut x: i32 = 1; return x; }");
  t.assert(ok(r.err));

  let funcs: Vec[ast.FuncDecl] = r.prog.funcs;
  let f: ast.FuncDecl = funcs.get(0);
  let stmts: Vec[ast.Stmt] = f.body.stmts;
  t.assert_eq(stmts.len(), 2);

  let st0: ast.Stmt = stmts.get(0);
  let ok0: bool = match st0 {
    ast.Stmt.Let(mutable, name, has_ann, ann, init) =>
      mutable && name == "x" && has_ann && ann.name == "i32" &&
      match init { ast.Expr.Int(v) => v == 1, _ => false },
    _ => false,
  };
  t.assert(ok0);

  let st1: ast.Stmt = stmts.get(1);
  let ok1: bool = match st1 {
    ast.Stmt.Return(ex) => match ex { ast.Expr.Ident(s) => s == "x", _ => false },
    _ => false,
  };
  t.assert(ok1);
}

fn test_parse_reports_lex_error() -> () {
  let r: p.ParseResult = p.parse_text("@");
  t.assert(match r.err { p.ParseError.Lex(_) => true, _ => false });
}
