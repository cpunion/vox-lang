// std/sync for stage1.
//
// Stage0 self-host constraint currently prefers concrete APIs over fully generic
// nominal signatures. We provide i32+i64 concrete families on top of runtime
// handle intrinsics.

pub struct MutexI32 {
  handle: i64,
}

pub fn mutex_i32(v: i32) -> MutexI32 {
  return MutexI32 { handle: __mutex_i32_new(v) };
}

pub fn mutex_i32_load(m: MutexI32) -> i32 {
  return __mutex_i32_load(m.handle);
}

pub fn mutex_i32_store(m: MutexI32, v: i32) -> MutexI32 {
  __mutex_i32_store(m.handle, v);
  return m;
}

pub fn mutex_i32_into_inner(m: MutexI32) -> i32 {
  return __mutex_i32_load(m.handle);
}

pub struct AtomicI32 {
  handle: i64,
}

pub fn atomic_i32(v: i32) -> AtomicI32 {
  return AtomicI32 { handle: __atomic_i32_new(v) };
}

pub fn atomic_i32_load(a: AtomicI32) -> i32 {
  return __atomic_i32_load(a.handle);
}

pub fn atomic_i32_store(a: AtomicI32, v: i32) -> AtomicI32 {
  __atomic_i32_store(a.handle, v);
  return a;
}

pub fn atomic_i32_fetch_add(a: AtomicI32, delta: i32) -> AtomicI32 {
  __atomic_i32_fetch_add(a.handle, delta);
  return a;
}

pub fn atomic_i32_swap(a: AtomicI32, v: i32) -> AtomicI32 {
  __atomic_i32_swap(a.handle, v);
  return a;
}

pub fn atomic_i32_fetch_add_prev(a: AtomicI32, delta: i32) -> i32 {
  return __atomic_i32_fetch_add(a.handle, delta);
}

pub fn atomic_i32_swap_prev(a: AtomicI32, v: i32) -> i32 {
  return __atomic_i32_swap(a.handle, v);
}

pub struct MutexI64 {
  handle: i64,
}

pub fn mutex_i64(v: i64) -> MutexI64 {
  return MutexI64 { handle: __mutex_i64_new(v) };
}

pub fn mutex_i64_load(m: MutexI64) -> i64 {
  return __mutex_i64_load(m.handle);
}

pub fn mutex_i64_store(m: MutexI64, v: i64) -> MutexI64 {
  __mutex_i64_store(m.handle, v);
  return m;
}

pub fn mutex_i64_into_inner(m: MutexI64) -> i64 {
  return __mutex_i64_load(m.handle);
}

pub struct AtomicI64 {
  handle: i64,
}

pub fn atomic_i64(v: i64) -> AtomicI64 {
  return AtomicI64 { handle: __atomic_i64_new(v) };
}

pub fn atomic_i64_load(a: AtomicI64) -> i64 {
  return __atomic_i64_load(a.handle);
}

pub fn atomic_i64_store(a: AtomicI64, v: i64) -> AtomicI64 {
  __atomic_i64_store(a.handle, v);
  return a;
}

pub fn atomic_i64_fetch_add(a: AtomicI64, delta: i64) -> AtomicI64 {
  __atomic_i64_fetch_add(a.handle, delta);
  return a;
}

pub fn atomic_i64_swap(a: AtomicI64, v: i64) -> AtomicI64 {
  __atomic_i64_swap(a.handle, v);
  return a;
}

pub fn atomic_i64_fetch_add_prev(a: AtomicI64, delta: i64) -> i64 {
  return __atomic_i64_fetch_add(a.handle, delta);
}

pub fn atomic_i64_swap_prev(a: AtomicI64, v: i64) -> i64 {
  return __atomic_i64_swap(a.handle, v);
}
