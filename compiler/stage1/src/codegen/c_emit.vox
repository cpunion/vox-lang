import "ir" as ir

pub enum DriverMainKind { User, Tool }

pub struct EmitOptions {
  pub emit_driver_main: bool,
  pub driver_main_kind: DriverMainKind,
  pub emit_test_main: bool,
  pub test_funcs: Vec[String], // qualified IR names
}

fn emit_header_lines() -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("// generated by vox stage1");
  out.push("#include <stdint.h>");
  out.push("#include <stdbool.h>");
  out.push("#include <inttypes.h>");
  out.push("#include <stdio.h>");
  out.push("#include <stdlib.h>");
  out.push("");
  out.push("#include <string.h>");
  out.push("");
  out.push("#include <limits.h>");
  out.push("");
  out.push("#include <math.h>");
  out.push("");
  out.push("#include <stddef.h>");
  out.push("");
  out.push("#include <dirent.h>");
  out.push("");
  out.push("#include <sys/stat.h>");
  out.push("");
  out.push("#if defined(_WIN32)");
  out.push("#include <direct.h>");
  out.push("#endif");
  out.push("");
  return out;
}

fn append_lines(out0: Vec[String], lines: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = out0;
  let mut i: i32 = 0;
  while i < lines.len() {
    out.push(lines.get(i));
    i = i + 1;
  }
  return out;
}

fn emit_forward_decl(pool: ir.TyPool, f: ir.Func) -> String {
  let mut s: String = "static ".concat(c_type(pool, f.ret)).concat(" ").concat(c_fn_name(f.name)).concat("(");
  let mut i: i32 = 0;
  while i < f.params.len() {
    if i != 0 { s = s.concat(", "); }
    let pa: ir.Param = f.params.get(i);
    s = s.concat(c_type(pool, pa.ty)).concat(" ").concat(c_param_name(i));
    i = i + 1;
  }
  return s.concat(");");
}

fn find_main(p: ir.Program) -> MainResult {
  let mut i: i32 = 0;
  while i < p.funcs.len() {
    let f: ir.Func = p.funcs.get(i);
    if f.name == "main" { return MainResult { found: true, f: f }; }
    i = i + 1;
  }
  return MainResult { found: false, f: ir.Func { name: "", params: Vec(), ret: -1, blocks: Vec() } };
}

struct MainResult { found: bool, f: ir.Func }

fn emit_driver_main(pool: ir.TyPool, main_fn: ir.Func, kind: DriverMainKind) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("int main(int argc, char** argv) {");
  out.push("  vox__argc = argc;");
  out.push("  vox__argv = argv;");
  let rt: ir.Ty = ir.ty_pool_get(pool, main_fn.ret);
  if kind == DriverMainKind.User {
    if rt.kind == ir.TyKind.Unit {
      out.push("  ".concat(c_fn_name("main")).concat("();"));
    } else if rt.kind == ir.TyKind.Bool {
      out.push("  bool v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%s\\n\", v ? \"true\" : \"false\");");
    } else if rt.kind == ir.TyKind.I8 {
      out.push("  int8_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRId8 \"\\n\", v);");
    } else if rt.kind == ir.TyKind.U8 {
      out.push("  uint8_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRIu8 \"\\n\", v);");
    } else if rt.kind == ir.TyKind.I16 {
      out.push("  int16_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRId16 \"\\n\", v);");
    } else if rt.kind == ir.TyKind.U16 {
      out.push("  uint16_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRIu16 \"\\n\", v);");
    } else if rt.kind == ir.TyKind.I32 {
      out.push("  int32_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRId32 \"\\n\", v);");
    } else if rt.kind == ir.TyKind.U32 {
      out.push("  uint32_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRIu32 \"\\n\", v);");
    } else if rt.kind == ir.TyKind.I64 {
      out.push("  int64_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRId64 \"\\n\", v);");
    } else if rt.kind == ir.TyKind.ISize {
      out.push("  int64_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRId64 \"\\n\", v);");
    } else if rt.kind == ir.TyKind.U64 || rt.kind == ir.TyKind.USize {
      out.push("  uint64_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRIu64 \"\\n\", v);");
    } else if rt.kind == ir.TyKind.F32 {
      out.push("  float v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%.9g\\n\", (double)v);");
    } else if rt.kind == ir.TyKind.F64 {
      out.push("  double v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%.17g\\n\", v);");
    } else if rt.kind == ir.TyKind.String {
      out.push("  const char* v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%s\\n\", v ? v : \"\");");
    } else {
      panic("unsupported main return type in driver");
    }
    out.push("  return 0;");
  } else {
    if rt.kind == ir.TyKind.Unit {
      out.push("  ".concat(c_fn_name("main")).concat("();"));
      out.push("  return 0;");
    } else if rt.kind == ir.TyKind.Bool {
      out.push("  bool rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return rc ? 0 : 1;");
    } else if rt.kind == ir.TyKind.I8 {
      out.push("  int8_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rt.kind == ir.TyKind.U8 {
      out.push("  uint8_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rt.kind == ir.TyKind.I16 {
      out.push("  int16_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rt.kind == ir.TyKind.U16 {
      out.push("  uint16_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rt.kind == ir.TyKind.I32 {
      out.push("  int32_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rt.kind == ir.TyKind.U32 {
      out.push("  uint32_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rt.kind == ir.TyKind.I64 {
      out.push("  int64_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rt.kind == ir.TyKind.ISize {
      out.push("  int64_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rt.kind == ir.TyKind.U64 || rt.kind == ir.TyKind.USize {
      out.push("  uint64_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rt.kind == ir.TyKind.F32 {
      out.push("  float rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rt.kind == ir.TyKind.F64 {
      out.push("  double rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else {
      panic("unsupported main return type in tool driver (expected ()/bool/<int>/<float>)");
    }
  }
  out.push("}");
  return out;
}

fn emit_test_main(test_funcs: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("int main(int argc, char** argv) {");
  out.push("  vox__argc = argc;");
  out.push("  vox__argv = argv;");
  out.push("  if (argc < 2 || !argv[1]) {");
  out.push("    fprintf(stderr, \"missing test name\\n\");");
  out.push("    return 1;");
  out.push("  }");
  out.push("  const char* name = argv[1];");
  let mut i: i32 = 0;
  while i < test_funcs.len() {
    let n: String = test_funcs.get(i);
    out.push("  if (strcmp(name, \"".concat(n).concat("\") == 0) { ").concat(c_fn_name(n)).concat("(); return 0; }"));
    i = i + 1;
  }
  out.push("  fprintf(stderr, \"unknown test: %s\\n\", name);");
  out.push("  return 1;");
  out.push("}");
  return out;
}

pub fn emit_c(p: ir.Program, opts: EmitOptions) -> String {
  let pool: ir.TyPool = p.pool;
  let mut out: Vec[String] = emit_header_lines();
  out = append_lines(out, emit_runtime_lines());
  out = append_lines(out, emit_nominal_types(pool, p));
  out = append_lines(out, emit_nominal_eq_lines(pool, p));

  // Forward decls
  let mut i: i32 = 0;
  while i < p.funcs.len() {
    out.push(emit_forward_decl(pool, p.funcs.get(i)));
    i = i + 1;
  }
  out.push("");

  // Func defs
  let mut j: i32 = 0;
  while j < p.funcs.len() {
    out = append_lines(out, emit_func(pool, p, p.funcs.get(j)));
    out.push("");
    j = j + 1;
  }

  if opts.emit_driver_main && opts.emit_test_main {
    panic("cannot emit both driver main and test main");
  }

  if opts.emit_driver_main {
    let mr: MainResult = find_main(p);
    if !mr.found { panic("missing function main"); }
    out = append_lines(out, emit_driver_main(pool, mr.f, opts.driver_main_kind));
  }
  if opts.emit_test_main {
    out = append_lines(out, emit_test_main(opts.test_funcs));
  }

  return out.join("\n").concat("\n");
}
