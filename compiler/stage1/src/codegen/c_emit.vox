import "ir" as ir

pub struct EmitOptions { pub emit_driver_main: bool }

fn emit_header_lines() -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("// generated by vox stage1");
  out.push("#include <stdint.h>");
  out.push("#include <stdbool.h>");
  out.push("#include <inttypes.h>");
  out.push("#include <stdio.h>");
  out.push("#include <stdlib.h>");
  out.push("");
  out.push("#include <string.h>");
  out.push("");
  out.push("#include <limits.h>");
  out.push("");
  out.push("#include <stddef.h>");
  out.push("");
  out.push("#include <dirent.h>");
  out.push("");
  out.push("#include <sys/stat.h>");
  out.push("");
  return out;
}

fn append_lines(out0: Vec[String], lines: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = out0;
  let mut i: i32 = 0;
  while i < lines.len() {
    out.push(lines.get(i));
    i = i + 1;
  }
  return out;
}

fn emit_forward_decl(pool: ir.TyPool, f: ir.Func) -> String {
  let mut s: String = "static ".concat(c_type(pool, f.ret)).concat(" ").concat(c_fn_name(f.name)).concat("(");
  let mut i: i32 = 0;
  while i < f.params.len() {
    if i != 0 { s = s.concat(", "); }
    let pa: ir.Param = f.params.get(i);
    s = s.concat(c_type(pool, pa.ty)).concat(" ").concat(c_param_name(i));
    i = i + 1;
  }
  return s.concat(");");
}

fn find_main(p: ir.Program) -> MainResult {
  let mut i: i32 = 0;
  while i < p.funcs.len() {
    let f: ir.Func = p.funcs.get(i);
    if f.name == "main" { return MainResult { found: true, f: f }; }
    i = i + 1;
  }
  return MainResult { found: false, f: ir.Func { name: "", params: Vec(), ret: -1, blocks: Vec() } };
}

struct MainResult { found: bool, f: ir.Func }

fn emit_driver_main(pool: ir.TyPool, main_fn: ir.Func) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("int main(int argc, char** argv) {");
  out.push("  vox__argc = argc;");
  out.push("  vox__argv = argv;");
  let rt: ir.Ty = ir.ty_pool_get(pool, main_fn.ret);
  if rt.kind == ir.TyKind.Unit {
    out.push("  ".concat(c_fn_name("main")).concat("();"));
  } else if rt.kind == ir.TyKind.Bool {
    out.push("  bool v = ".concat(c_fn_name("main")).concat("();"));
    out.push("  printf(\"%s\\n\", v ? \"true\" : \"false\");");
  } else if rt.kind == ir.TyKind.I32 {
    out.push("  int32_t v = ".concat(c_fn_name("main")).concat("();"));
    out.push("  printf(\"%\" PRId32 \"\\n\", v);");
  } else if rt.kind == ir.TyKind.I64 {
    out.push("  int64_t v = ".concat(c_fn_name("main")).concat("();"));
    out.push("  printf(\"%\" PRId64 \"\\n\", v);");
  } else if rt.kind == ir.TyKind.String {
    out.push("  const char* v = ".concat(c_fn_name("main")).concat("();"));
    out.push("  printf(\"%s\\n\", v ? v : \"\");");
  } else {
    panic("unsupported main return type in driver");
  }
  out.push("  return 0;");
  out.push("}");
  return out;
}

pub fn emit_c(p: ir.Program, opts: EmitOptions) -> String {
  let pool: ir.TyPool = p.pool;
  let mut out: Vec[String] = emit_header_lines();
  out = append_lines(out, emit_runtime_lines());
  out = append_lines(out, emit_nominal_types(pool, p));

  // Forward decls
  let mut i: i32 = 0;
  while i < p.funcs.len() {
    out.push(emit_forward_decl(pool, p.funcs.get(i)));
    i = i + 1;
  }
  out.push("");

  // Func defs
  let mut j: i32 = 0;
  while j < p.funcs.len() {
    out = append_lines(out, emit_func(pool, p, p.funcs.get(j)));
    out.push("");
    j = j + 1;
  }

  if opts.emit_driver_main {
    let mr: MainResult = find_main(p);
    if !mr.found { panic("missing function main"); }
    out = append_lines(out, emit_driver_main(pool, mr.f));
  }

  return out.join("\n").concat("\n");
}
