import "ir" as ir

pub fn c_type(pool: ir.TyPool, ty_idx: i32) -> String {
  let t: ir.Ty = ir.ty_pool_get(pool, ty_idx);
  if t.kind == ir.TyKind.Param { panic("unresolved type param in codegen"); }
  // Range types are represented as their base integer type in the C backend.
  if t.kind == ir.TyKind.Range { return c_type(pool, t.elem); }
  return match t.kind {
    ir.TyKind.Unit => "void",
    ir.TyKind.Bool => "bool",
    ir.TyKind.I8 => "int8_t",
    ir.TyKind.U8 => "uint8_t",
    ir.TyKind.I16 => "int16_t",
    ir.TyKind.U16 => "uint16_t",
    ir.TyKind.I32 => "int32_t",
    ir.TyKind.U32 => "uint32_t",
    ir.TyKind.I64 => "int64_t",
    ir.TyKind.U64 => "uint64_t",
    ir.TyKind.ISize => "int64_t",
    ir.TyKind.USize => "uint64_t",
    ir.TyKind.String => "const char*",
    ir.TyKind.Struct => c_struct_type_name(ty_qname(t)),
    ir.TyKind.Enum => c_enum_type_name(ty_qname(t)),
    ir.TyKind.Vec => "vox_vec",
    _ => "void",
  };
}
