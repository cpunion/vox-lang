import "std/testing" as t
import "parse" as p
import "typecheck" as tc
import "irgen" as irgen
import "codegen" as cg

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn compile_to_c(src: String) -> String {
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "main", r.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert(gr.ok);
  return cg.emit_c(gr.prog, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
}

fn test_codegen_smoke_main_i32() -> () {
  let c: String = compile_to_c("fn main() -> i32 { return 0; }");
  t.assert(contains(c, "int main(int argc, char** argv) {"));
  t.assert(contains(c, "int32_t v = vox_fn_mmain();"));
}

fn test_codegen_builtin_print() -> () {
  let c: String = compile_to_c("fn main() -> i32 { print(\"hi\"); return 0; }");
  t.assert(contains(c, "vox_builtin_print("));
  t.assert(contains(c, "hi"));
}

fn test_codegen_tool_driver_main_i32_exits() -> () {
  let pr: p.ParseResult = p.parse_text("fn main() -> i32 { return 7; }");
  t.assert(pr.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "main", pr.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert(gr.ok);
  let c: String = cg.emit_c(gr.prog, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.Tool, emit_test_main: false, test_funcs: Vec() });
  t.assert(contains(c, "int32_t rc = vox_fn_mmain();"));
  t.assert(contains(c, "return (int)rc;"));
}
