import "std/testing" as t
import "parse" as p
import "typecheck" as tc
import "irgen" as irgen
import "codegen" as cg

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn compile_to_c(src: String) -> String {
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "main", r.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert(gr.ok);
  return cg.emit_c(gr.prog, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
}

fn test_codegen_smoke_main_i32() -> () {
  let c: String = compile_to_c("fn main() -> i32 { return 0; }");
  t.assert(contains(c, "int main(int argc, char** argv) {"));
  t.assert(contains(c, "int32_t v = vox_fn_mmain();"));
}

fn test_codegen_smoke_main_i8() -> () {
  let c: String = compile_to_c("fn main() -> i8 { return -5; }");
  t.assert(contains(c, "int main(int argc, char** argv) {"));
  t.assert(contains(c, "int8_t v = vox_fn_mmain();"));
}

fn test_codegen_builtin_print() -> () {
  let c: String = compile_to_c("fn main() -> i32 { print(\"hi\"); return 0; }");
  t.assert(contains(c, "vox_builtin_print("));
  t.assert(contains(c, "hi"));
}

fn test_codegen_tool_driver_main_i32_exits() -> () {
  let pr: p.ParseResult = p.parse_text("fn main() -> i32 { return 7; }");
  t.assert(pr.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "main", pr.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert(gr.ok);
  let c: String = cg.emit_c(gr.prog, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.Tool, emit_test_main: false, test_funcs: Vec() });
  t.assert(contains(c, "int32_t rc = vox_fn_mmain();"));
  t.assert(contains(c, "return (int)rc;"));
}

fn test_codegen_i64_to_i32_checked_cast_emits_bounds_check() -> () {
  let c: String = compile_to_c("fn main() -> i32 { let x: i64 = 1; return x as i32; }");
  t.assert(contains(c, "INT32_MIN"));
  t.assert(contains(c, "INT32_MAX"));
  t.assert(contains(c, "i64 to i32 overflow"));
}

fn test_codegen_range_cast_emits_bounds_check() -> () {
  let src: String = "type Tiny = @range(0..=3) i32\nfn main() -> i32 { let x: i32 = 1; let y: Tiny = x as Tiny; return y as i32; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "range check failed"));
  t.assert(contains(c, "(int32_t)0"));
  t.assert(contains(c, "(int32_t)3"));
}

fn test_codegen_int_div_emits_div0_check() -> () {
  let c: String = compile_to_c("fn main() -> i32 { let a: i32 = 1; let b: i32 = 0; return a / b; }");
  t.assert(contains(c, "division by zero"));
}

fn test_codegen_int_mod_emits_div0_check_unsigned() -> () {
  let src: String = "fn main() -> i32 { let a: u32 = 1; let b: u32 = 0; let c: u32 = a % b; return c as i32; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "division by zero"));
}

fn test_codegen_int_add_avoids_signed_overflow_ub() -> () {
  let c: String = compile_to_c("fn main() -> i32 { let a: i32 = 1; let b: i32 = 2; return a + b; }");
  // Signed overflow is UB in C; backend must not rely on it.
  t.assert(contains(c, "#include <string.h>"));
  t.assert(contains(c, "memcpy(&"));
}
