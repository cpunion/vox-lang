pub fn emit_runtime_lines() -> Vec[String] {
  let mut out: Vec[String] = Vec();

  // Minimal Vec runtime (stage0): by-value elements, no drop glue.
  out.push("typedef struct { uint8_t* data; int32_t len; int32_t cap; int32_t elem_size; } vox_vec;");
  out.push("static vox_vec vox_vec_new(int32_t elem_size) {");
  out.push("  vox_vec v; v.data = NULL; v.len = 0; v.cap = 0; v.elem_size = elem_size; return v;");
  out.push("}");
  out.push("static void vox_vec_grow(vox_vec* v, int32_t new_cap) {");
  out.push("  if (new_cap <= v->cap) return;");
  out.push("  if (new_cap < 4) new_cap = 4;");
  out.push("  size_t bytes = (size_t)new_cap * (size_t)v->elem_size;");
  out.push("  // Stage0/Stage1 v0: leak Vec buffers so plain struct copies of `vox_vec` are safe.");
  out.push("  uint8_t* p = (uint8_t*)malloc(bytes);");
  out.push("  if (!p) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  if (v->data && v->len != 0) {");
  out.push("    memcpy(p, v->data, (size_t)v->len * (size_t)v->elem_size);");
  out.push("  }");
  out.push("  v->data = p; v->cap = new_cap;");
  out.push("}");
  out.push("static void vox_vec_push(vox_vec* v, const void* elem) {");
  out.push("  if (v->len == v->cap) { int32_t nc = v->cap == 0 ? 4 : v->cap * 2; vox_vec_grow(v, nc); }");
  out.push("  memcpy(v->data + (size_t)v->len * (size_t)v->elem_size, elem, (size_t)v->elem_size);");
  out.push("  v->len++;");
  out.push("}");
  out.push("static int32_t vox_vec_len(const vox_vec* v) { return v->len; }");
  out.push("static bool vox_vec_eq(const vox_vec* a, const vox_vec* b) {");
  out.push("  if (!a || !b) return false;");
  out.push("  if (a->len != b->len || a->elem_size != b->elem_size) return false;");
  out.push("  size_t bytes = (size_t)a->len * (size_t)a->elem_size;");
  out.push("  if (bytes == 0) return true;");
  out.push("  return memcmp(a->data, b->data, bytes) == 0;");
  out.push("}");
  out.push("static void vox_vec_get(const vox_vec* v, int32_t idx, void* out) {");
  out.push("  if (idx < 0 || idx >= v->len) { fprintf(stderr, \"vec index out of bounds: idx=%\" PRId32 \" len=%\" PRId32 \"\\n\", idx, v->len); exit(1); }");
  out.push("  memcpy(out, v->data + (size_t)idx * (size_t)v->elem_size, (size_t)v->elem_size);");
  out.push("}");
  out.push("");

  // Minimal string runtime helpers (stage0).
  out.push("static int32_t vox_str_len(const char* s) {");
  out.push("  if (!s) return 0;");
  out.push("  size_t n = strlen(s);");
  out.push("  if (n > INT32_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }");
  out.push("  return (int32_t)n;");
  out.push("}");
  out.push("static int32_t vox_str_byte_at(const char* s, int32_t idx) {");
  out.push("  int32_t n = vox_str_len(s);");
  out.push("  if (idx < 0 || idx >= n) { fprintf(stderr, \"string index out of bounds\\n\"); exit(1); }");
  out.push("  return (int32_t)(uint8_t)s[idx];");
  out.push("}");
  out.push("");
  out.push("static const char* vox_str_slice(const char* s, int32_t start, int32_t end) {");
  out.push("  int32_t n = vox_str_len(s);");
  out.push("  if (start < 0 || end < start || end > n) { fprintf(stderr, \"string slice out of bounds\\n\"); exit(1); }");
  out.push("  int32_t m = end - start;");
  out.push("  char* out = (char*)malloc((size_t)m + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, s + start, (size_t)m);");
  out.push("  out[m] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_str_concat(const char* a, const char* b) {");
  out.push("  if (!a) a = \"\";");
  out.push("  if (!b) b = \"\";");
  out.push("  size_t na = strlen(a);");
  out.push("  size_t nb = strlen(b);");
  out.push("  if (na + nb + 1 > SIZE_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc(na + nb + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, a, na);");
  out.push("  memcpy(out + na, b, nb);");
  out.push("  out[na + nb] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_i32_to_string(int32_t v) {");
  out.push("  char buf[32];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%\" PRId32, v);");
  out.push("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_i64_to_string(int64_t v) {");
  out.push("  char buf[32];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%\" PRId64, v);");
  out.push("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_u64_to_string(uint64_t v) {");
  out.push("  char buf[32];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%\" PRIu64, v);");
  out.push("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_f32_to_string(float v) {");
  out.push("  char buf[64];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%.9g\", (double)v);");
  out.push("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_f64_to_string(double v) {");
  out.push("  char buf[64];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%.17g\", v);");
  out.push("  if (n < 0) { fprintf(stderr, \"format failed\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_bool_to_string(bool v) {");
  out.push("  return v ? \"true\" : \"false\";");
  out.push("}");
  out.push("");

  out.push("static const char* vox_str_escape_c(const char* s) {");
  out.push("  if (!s) s = \"\";");
  out.push("  size_t n = strlen(s);");
  out.push("  // First pass: compute output length.");
  out.push("  size_t out_n = 0;");
  out.push("  for (size_t i = 0; i < n; i++) {");
  out.push("    unsigned char ch = (unsigned char)s[i];");
  out.push("    switch (ch) {");
  out.push("    case '\\\\':");
  out.push("    case '\"':");
  out.push("    case '\\n':");
  out.push("    case '\\r':");
  out.push("    case '\\t':");
  out.push("      out_n += 2;");
  out.push("      break;");
  out.push("    default:");
  out.push("      if (ch >= 0x20 && ch <= 0x7e) out_n += 1; else out_n += 4; // \\\\xHH");
  out.push("      break;");
  out.push("    }");
  out.push("  }");
  out.push("  char* out = (char*)malloc(out_n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  size_t j = 0;");
  out.push("  for (size_t i = 0; i < n; i++) {");
  out.push("    unsigned char ch = (unsigned char)s[i];");
  out.push("    switch (ch) {");
  out.push("    case '\\\\': out[j++] = '\\\\'; out[j++] = '\\\\'; break;");
  out.push("    case '\"': out[j++] = '\\\\'; out[j++] = '\"'; break;");
  out.push("    case '\\n': out[j++] = '\\\\'; out[j++] = 'n'; break;");
  out.push("    case '\\r': out[j++] = '\\\\'; out[j++] = 'r'; break;");
  out.push("    case '\\t': out[j++] = '\\\\'; out[j++] = 't'; break;");
  out.push("    default:");
  out.push("      if (ch >= 0x20 && ch <= 0x7e) { out[j++] = (char)ch; }");
  out.push("      else {");
  out.push("        static const char* hex = \"0123456789abcdef\";");
  out.push("        out[j++] = '\\\\'; out[j++] = 'x';");
  out.push("        out[j++] = hex[(ch >> 4) & 0xf];");
  out.push("        out[j++] = hex[ch & 0xf];");
  out.push("      }");
  out.push("      break;");
  out.push("    }");
  out.push("  }");
  out.push("  out[j] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");

  out.push("static const char* vox_vec_str_join(const vox_vec* v, const char* sep) {");
  out.push("  if (!sep) sep = \"\";");
  out.push("  if (!v || v->elem_size != (int32_t)sizeof(const char*)) { fprintf(stderr, \"vec_str_join expects Vec[String]\\n\"); exit(1); }");
  out.push("  int32_t n = v->len;");
  out.push("  const char* const* items = (const char* const*)v->data;");
  out.push("  size_t sep_n = strlen(sep);");
  out.push("  size_t total = 0;");
  out.push("  for (int32_t i = 0; i < n; i++) {");
  out.push("    const char* s = items[i];");
  out.push("    if (!s) s = \"\";");
  out.push("    total += strlen(s);");
  out.push("    if (i + 1 < n) total += sep_n;");
  out.push("  }");
  out.push("  if (total + 1 > SIZE_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }");
  out.push("  char* out = (char*)malloc(total + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  size_t j = 0;");
  out.push("  for (int32_t i = 0; i < n; i++) {");
  out.push("    const char* s = items[i];");
  out.push("    if (!s) s = \"\";");
  out.push("    size_t m = strlen(s);");
  out.push("    memcpy(out + j, s, m);");
  out.push("    j += m;");
  out.push("    if (i + 1 < n && sep_n != 0) {");
  out.push("      memcpy(out + j, sep, sep_n);");
  out.push("      j += sep_n;");
  out.push("    }");
  out.push("  }");
  out.push("  out[j] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");

  // Runtime builtins
  out.push("static int vox__argc = 0;");
  out.push("static char** vox__argv = NULL;");
  out.push("");
  out.push("#if defined(_MSC_VER)");
  out.push("#  define VOX_NORETURN __declspec(noreturn)");
  out.push("#elif defined(__GNUC__) || defined(__clang__)");
  out.push("#  define VOX_NORETURN __attribute__((noreturn))");
  out.push("#else");
  out.push("#  define VOX_NORETURN");
  out.push("#endif");
  out.push("");
  out.push("static VOX_NORETURN void vox_builtin_panic(const char* msg) {");
  out.push("  if (!msg) msg = \"\";");
  out.push("  fprintf(stderr, \"%s\\n\", msg);");
  out.push("  exit(1);");
  out.push("}");
  out.push("");
  out.push("static void vox_builtin_print(const char* msg) {");
  out.push("  if (!msg) msg = \"\";");
  out.push("  fputs(msg, stdout);");
  out.push("  fflush(stdout);");
  out.push("}");
  out.push("");
  out.push("static vox_vec vox_builtin_args(void) {");
  out.push("  vox_vec v = vox_vec_new((int32_t)sizeof(const char*));");
  out.push("  for (int i = 1; i < vox__argc; i++) {");
  out.push("    const char* s = vox__argv[i];");
  out.push("    vox_vec_push(&v, &s);");
  out.push("  }");
  out.push("  return v;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_builtin_exe_path(void) {");
  out.push("  if (!vox__argv || vox__argc <= 0 || !vox__argv[0]) return \"\";");
  out.push("  return vox__argv[0];");
  out.push("}");
  out.push("");
  out.push("static const char* vox_builtin_read_file(const char* path) {");
  out.push("  if (!path) path = \"\";");
  out.push("  FILE* f = fopen(path, \"rb\");");
  out.push("  if (!f) { fprintf(stderr, \"read_file failed: %s\\n\", path); exit(1); }");
  out.push("  if (fseek(f, 0, SEEK_END) != 0) { fprintf(stderr, \"read_file fseek failed: %s\\n\", path); exit(1); }");
  out.push("  long n = ftell(f);");
  out.push("  if (n < 0) { fprintf(stderr, \"read_file ftell failed: %s\\n\", path); exit(1); }");
  out.push("  if (fseek(f, 0, SEEK_SET) != 0) { fprintf(stderr, \"read_file fseek failed: %s\\n\", path); exit(1); }");
  out.push("  char* out = (char*)malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  size_t got = fread(out, 1, (size_t)n, f);");
  out.push("  if (got != (size_t)n) { fprintf(stderr, \"read_file fread failed: %s\\n\", path); exit(1); }");
  out.push("  out[n] = '\\0';");
  out.push("  fclose(f);");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static void vox_builtin_write_file(const char* path, const char* text) {");
  out.push("  if (!path) path = \"\";");
  out.push("  if (!text) text = \"\";");
  out.push("  FILE* f = fopen(path, \"wb\");");
  out.push("  if (!f) { fprintf(stderr, \"write_file failed: %s\\n\", path); exit(1); }");
  out.push("  size_t n = strlen(text);");
  out.push("  if (n != 0) {");
  out.push("    size_t put = fwrite(text, 1, n, f);");
  out.push("    if (put != n) { fprintf(stderr, \"write_file fwrite failed: %s\\n\", path); exit(1); }");
  out.push("  }");
  out.push("  fclose(f);");
  out.push("}");
  out.push("");
  out.push("static bool vox_builtin_path_exists(const char* path) {");
  out.push("  if (!path || path[0] == '\\0') return false;");
  out.push("  struct stat st;");
  out.push("  return stat(path, &st) == 0;");
  out.push("}");
  out.push("");
  out.push("static void vox_builtin_mkdir_p(const char* path) {");
  out.push("  if (!path || path[0] == '\\0') return;");
  out.push("  size_t n = strlen(path);");
  out.push("  char* tmp = (char*)malloc(n + 1);");
  out.push("  if (!tmp) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(tmp, path, n + 1);");
  out.push("  for (size_t i = 1; i < n; i++) {");
  out.push("    char ch = tmp[i];");
  out.push("    if (ch != '/' && ch != '\\\\') continue;");
  out.push("    tmp[i] = '\\0';");
  out.push("    if (tmp[0] != '\\0' && !vox_builtin_path_exists(tmp)) {");
  out.push("#if defined(_WIN32)");
  out.push("      if (_mkdir(tmp) != 0) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }");
  out.push("#else");
  out.push("      if (mkdir(tmp, 0755) != 0) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }");
  out.push("#endif");
  out.push("    }");
  out.push("    tmp[i] = ch;");
  out.push("  }");
  out.push("  if (!vox_builtin_path_exists(tmp)) {");
  out.push("#if defined(_WIN32)");
  out.push("    if (_mkdir(tmp) != 0) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }");
  out.push("#else");
  out.push("    if (mkdir(tmp, 0755) != 0) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }");
  out.push("#endif");
  out.push("  }");
  out.push("  free(tmp);");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_builtin_exec(const char* cmd) {");
  out.push("  if (!cmd) cmd = \"\";");
  out.push("  int r = system(cmd);");
  out.push("  return (int32_t)r;");
  out.push("}");
  out.push("");
  out.push("static bool vox_str_has_suffix(const char* s, const char* suf) {");
  out.push("  if (!s || !suf) return false;");
  out.push("  size_t n = strlen(s);");
  out.push("  size_t m = strlen(suf);");
  out.push("  if (m > n) return false;");
  out.push("  return memcmp(s + (n - m), suf, m) == 0;");
  out.push("}");
  out.push("");
  out.push("static char* vox_path_join2(const char* a, const char* b) {");
  out.push("  if (!a) a = \"\";");
  out.push("  if (!b) b = \"\";");
  out.push("  size_t na = strlen(a);");
  out.push("  size_t nb = strlen(b);");
  out.push("  bool slash = (na != 0 && a[na - 1] != '/');");
  out.push("  size_t n = na + (slash ? 1 : 0) + nb;");
  out.push("  char* out = (char*)malloc(n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, a, na);");
  out.push("  size_t j = na;");
  out.push("  if (slash) out[j++] = '/';");
  out.push("  memcpy(out + j, b, nb);");
  out.push("  out[n] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static void vox_walk_dir(vox_vec* out, const char* root, const char* rel) {");
  out.push("  char* full = rel && rel[0] ? vox_path_join2(root, rel) : vox_path_join2(root, \"\");");
  out.push("  DIR* d = opendir(full);");
  out.push("  if (!d) { free(full); return; }");
  out.push("  struct dirent* ent;");
  out.push("  while ((ent = readdir(d)) != NULL) {");
  out.push("    const char* name = ent->d_name;");
  out.push("    if (!name || name[0] == '\\0') continue;");
  out.push("    if (strcmp(name, \".\") == 0 || strcmp(name, \"..\") == 0) continue;");
  out.push("    char* child_rel = rel && rel[0] ? vox_path_join2(rel, name) : vox_path_join2(\"\", name);");
  out.push("    char* child_full = vox_path_join2(root, child_rel);");
  out.push("    struct stat st;");
  out.push("    if (stat(child_full, &st) == 0 && S_ISDIR(st.st_mode)) {");
  out.push("      vox_walk_dir(out, root, child_rel);");
  out.push("      free(child_rel);");
  out.push("      free(child_full);");
  out.push("      continue;");
  out.push("    }");
  out.push("    if (vox_str_has_suffix(child_rel, \".vox\")) {");
  out.push("      const char* s = child_rel;");
  out.push("      vox_vec_push(out, &s);");
  out.push("    } else {");
  out.push("      free(child_rel);");
  out.push("    }");
  out.push("    free(child_full);");
  out.push("  }");
  out.push("  closedir(d);");
  out.push("  free(full);");
  out.push("}");
  out.push("");
  out.push("static vox_vec vox_builtin_walk_vox_files(const char* root) {");
  out.push("  if (!root || root[0] == '\\0') root = \".\";");
  out.push("  vox_vec out = vox_vec_new((int32_t)sizeof(const char*));");
  out.push("  vox_walk_dir(&out, root, \"src\");");
  out.push("  vox_walk_dir(&out, root, \"tests\");");
  out.push("  return out;");
  out.push("}");
  out.push("");

  return out;
}
