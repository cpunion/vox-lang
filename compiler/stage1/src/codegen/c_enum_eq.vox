import "ir" as ir

fn c_enum_eq_fn_name(enum_qname: String) -> String {
  return "vox_enum_eq_".concat(c_mangle(enum_qname));
}

fn enum_eq_field_expr(pool: ir.TyPool, ty: i32, lhs: String, rhs: String) -> String {
  let t0: ir.Ty = ir.ty_pool_get(pool, ty);
  if t0.kind == ir.TyKind.Range {
    return enum_eq_field_expr(pool, t0.elem, lhs, rhs);
  }
  if t0.kind == ir.TyKind.String {
    return "(strcmp(".concat(lhs).concat(", ").concat(rhs).concat(") == 0)");
  }
  if t0.kind == ir.TyKind.Enum {
    return c_enum_eq_fn_name(ty_qname(t0)).concat("(").concat(lhs).concat(", ").concat(rhs).concat(")");
  }
  return "(".concat(lhs).concat(" == ").concat(rhs).concat(")");
}

fn emit_enum_eq_decl(pool: ir.TyPool, en: ir.EnumDecl) -> String {
  let qn: String = en.name;
  let cty: String = c_enum_type_name(qn);
  let fnn: String = c_enum_eq_fn_name(qn);
  return "static bool ".concat(fnn).concat("(").concat(cty).concat(" a, ").concat(cty).concat(" b);");
}

fn emit_enum_eq_def(pool: ir.TyPool, en: ir.EnumDecl) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let qn: String = en.name;
  let cty: String = c_enum_type_name(qn);
  let fnn: String = c_enum_eq_fn_name(qn);
  out.push("static bool ".concat(fnn).concat("(").concat(cty).concat(" a, ").concat(cty).concat(" b) {"));
  out.push("  if (a.tag != b.tag) return false;");
  out.push("  switch (a.tag) {");
  let mut vi: i32 = 0;
  while vi < en.variants.len() {
    let v: ir.EnumVariant = en.variants.get(vi);
    out.push("    case ".concat(vi.to_string()).concat(": {"));
    if v.fields.len() == 0 {
      out.push("      return true;");
    } else {
      let mut expr: String = "";
      let mut fi: i32 = 0;
      while fi < v.fields.len() {
        let lhs: String = "a.payload.".concat(c_ident(v.name)).concat("._").concat(fi.to_string());
        let rhs: String = "b.payload.".concat(c_ident(v.name)).concat("._").concat(fi.to_string());
        let e: String = enum_eq_field_expr(pool, v.fields.get(fi), lhs, rhs);
        if fi == 0 { expr = e; } else { expr = expr.concat(" && ").concat(e); }
        fi = fi + 1;
      }
      out.push("      return ".concat(expr).concat(";"));
    }
    out.push("    }");
    vi = vi + 1;
  }
  out.push("    default: return false;");
  out.push("  }");
  out.push("}");
  return out;
}

pub fn emit_enum_eq_lines(pool: ir.TyPool, p: ir.Program) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  if p.enums.len() == 0 { return out; }

  // Forward declarations allow recursive enum payload calls across helpers.
  let mut i: i32 = 0;
  while i < p.enums.len() {
    out.push(emit_enum_eq_decl(pool, p.enums.get(i)));
    i = i + 1;
  }
  out.push("");

  i = 0;
  while i < p.enums.len() {
    out = append_lines(out, emit_enum_eq_def(pool, p.enums.get(i)));
    out.push("");
    i = i + 1;
  }
  return out;
}
