// Stage1 AST (initial minimal subset).
//
// Note: In Stage0 subset we avoid references/pointers, so recursive structures
// are modeled directly with nested structs/enums (small programs) or later via
// arena + indices.

pub struct Program {
  pub imports: Vec[ImportDecl],
  pub structs: Vec[StructDecl],
  pub enums: Vec[EnumDecl],
  pub funcs: Vec[FuncDecl],
  pub exprs: ExprPool,
}

pub struct ImportDecl {
  // Source file path (e.g. "src/main.vox"). Used to make imports file-local.
  pub file: String,
  pub path: String,
  // Empty means "no alias" (use default alias rule later).
  pub alias: String,
}

pub struct StructDecl {
  pub file: String,
  pub is_pub: bool,
  pub name: String,
  pub fields: Vec[FieldDecl],
}

pub struct FieldDecl {
  pub is_pub: bool,
  pub name: String,
  pub ty: TypeName,
}

pub struct EnumDecl {
  pub file: String,
  pub is_pub: bool,
  pub name: String,
  pub variants: Vec[EnumVariantDecl],
}

pub struct EnumVariantDecl {
  pub name: String,
  // Payload types; empty means unit variant.
  pub fields: Vec[TypeName],
}

pub struct FuncDecl {
  pub file: String,
  pub is_pub: bool,
  pub name: String,
  pub type_params: Vec[String],
  pub params: Vec[Param],
  pub ret: TypeName,
  pub body: Block,
}

pub struct Param {
  pub name: String,
  pub ty: TypeName,
}

pub struct TypeName {
  // Qualified type path segments, e.g. ["i32"], ["std","io","Reader"].
  pub parts: Vec[String],
  // Generic type args: `Vec[i32]` has args [i32].
  pub args: Vec[TypeName],
}

pub struct Block {
  pub stmts: Vec[Stmt],
}

pub enum Stmt {
  Let(bool, String, bool, TypeName, i32), // mutable, name, has_ann, ann, init expr id
  Assign(String, i32),                    // name, expr id
  AssignField(String, String, i32),       // recv var name, field name, rhs expr id
  Expr(i32),                              // expr id
  If(i32, Block, bool, Block),            // cond, then, has_else, else_block (dummy when !has_else)
  While(i32, Block),                      // cond, body
  Break,
  Continue,
  Return(bool, i32),                      // has_expr, expr id
}
