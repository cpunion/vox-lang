// Stage1 expression arena (by-value pool).

pub struct ExprPool {
  pub nodes: Vec[ExprNode],
}

pub struct AddExprResult {
  pub pool: ExprPool,
  pub id: i32,
}

pub enum UnaryOp { Neg, Not }

pub enum BinaryOp {
  Add, Sub, Mul, Div, Mod,
  Eq, Ne, Lt, Le, Gt, Ge,
  AndAnd, OrOr,
}

pub enum ExprNode {
  Int(i32),
  Bool(bool),
  Ident(String),
  Str(String),
  // Enum variant shorthand when enum type is known from context (expected type / scrutinee type).
  // Examples: `.None`, `.Some(1)`, `match x { .Some(v) => v, .None => 0 }`.
  DotIdent(String),
  // Block expression: `{ stmt*; tailExpr }` (tail is optional; when absent value is unit).
  Block(ExprBlock),
  If(i32, i32, i32), // cond, then, else
  Unary(UnaryOp, i32),
  Binary(BinaryOp, i32, i32),
  Member(i32, String),
  // Call: callee expr, optional explicit type arguments, value arguments.
  Call(i32, Vec[TypeName], Vec[i32]),
  StructLit(i32, Vec[StructLitField]), // type expr id, fields
  Match(i32, Vec[MatchArm]),           // scrutinee expr id, arms
}

pub struct ExprBlock {
  pub stmts: Vec[Stmt],
  pub has_tail: bool,
  pub tail: i32,
}

pub struct StructLitField {
  pub name: String,
  pub expr: i32,
}

pub enum Pat {
  Wild,
  Bind(String),
  Int(i32),
  Str(String),
  // enum_parts like ["dep","Option"] for dep.Option.Some(...)
  EnumVariant(Vec[String], String, Vec[String]), // enum_parts, variant, binders
}

pub struct MatchArm {
  pub pat: Pat,
  pub expr: i32,
}

pub fn expr_pool() -> ExprPool {
  return ExprPool { nodes: Vec() };
}

pub fn expr_pool_add(pool: ExprPool, node: ExprNode) -> AddExprResult {
  let mut p: ExprPool = pool;
  let mut v: Vec[ExprNode] = p.nodes;
  v.push(node);
  let id: i32 = v.len() - 1;
  p.nodes = v;
  return AddExprResult { pool: p, id: id };
}

pub fn expr_pool_get(pool: ExprPool, id: i32) -> ExprNode {
  let v: Vec[ExprNode] = pool.nodes;
  return v.get(id);
}
