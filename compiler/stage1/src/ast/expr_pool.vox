// Stage1 expression arena (by-value pool).

pub struct ExprPool {
  pub nodes: Vec[ExprNode],
}

pub struct AddExprResult {
  pub pool: ExprPool,
  pub id: i32,
}

pub enum UnaryOp { Neg, Not }

pub enum BinaryOp {
  Add, Sub, Mul, Div, Mod,
  Eq, Ne, Lt, Le, Gt, Ge,
  AndAnd, OrOr,
}

pub enum ExprNode {
  Int(i32),
  Ident(String),
  Str(String),
  Unary(UnaryOp, i32),
  Binary(BinaryOp, i32, i32),
  Member(i32, String),
  Call(i32, Vec[i32]),
}

pub fn expr_pool() -> ExprPool {
  return ExprPool { nodes: Vec() };
}

pub fn expr_pool_add(pool: ExprPool, node: ExprNode) -> AddExprResult {
  let mut p: ExprPool = pool;
  let mut v: Vec[ExprNode] = p.nodes;
  v.push(node);
  let id: i32 = v.len() - 1;
  p.nodes = v;
  return AddExprResult { pool: p, id: id };
}

pub fn expr_pool_get(pool: ExprPool, id: i32) -> ExprNode {
  let v: Vec[ExprNode] = pool.nodes;
  return v.get(id);
}

