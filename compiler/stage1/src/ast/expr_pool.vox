// Stage1 expression arena (by-value pool).

pub struct ExprPool {
  pub nodes: Vec[ExprNode],
  pub spans: Vec[Span],
}

pub struct AddExprResult {
  pub pool: ExprPool,
  pub id: i32,
}

pub enum UnaryOp { Neg, Not }

pub enum BinaryOp {
  Add, Sub, Mul, Div, Mod,
  BitAnd, BitOr, BitXor, Shl, Shr,
  Eq, Ne, Lt, Le, Gt, Ge,
  AndAnd, OrOr,
}

pub enum ExprNode {
  // Integer literal text (decimal). Typed later using expected type.
  Int(String),
  // Float literal text (decimal with fractional part). Typed later using expected type.
  Float(String),
  Bool(bool),
  Ident(String),
  Str(String),
  // Enum variant shorthand when enum type is known from context (expected type / scrutinee type).
  // Examples: `.None`, `.Some(1)`, `match x { .Some(v) => v, .None => 0 }`.
  DotIdent(String),
  // Block expression: `{ stmt*; tailExpr }` (tail is optional; when absent value is unit).
  Block(ExprBlock),
  If(i32, i32, i32), // cond, then, else
  Unary(UnaryOp, i32),
  // Cast: `expr as Type`
  As(i32, TypeName),
  Binary(BinaryOp, i32, i32),
  Member(i32, String),
  // Call: callee expr, optional explicit type arguments, value arguments.
  Call(i32, Vec[TypeName], Vec[i32]),
  // Try propagation: `expr?`
  Try(i32),
  StructLit(i32, Vec[StructLitField]), // type expr id, fields
  Match(i32, Vec[MatchArm]),           // scrutinee expr id, arms
}

pub struct ExprBlock {
  pub stmts: Vec[Stmt],
  pub has_tail: bool,
  pub tail: i32,
}

pub struct StructLitField {
  pub name: String,
  pub expr: i32,
}

pub enum Pat {
  Wild(Span),
  Bind(Span, String),
  Bool(Span, bool),
  Int(Span, String),
  Str(Span, String),
  // enum_parts like ["dep","Option"] for dep.Option.Some(...)
  EnumVariant(Span, Vec[String], String, Vec[Pat]), // span, enum_parts, variant, args
}

pub struct MatchArm {
  pub pat: Pat,
  pub expr: i32,
}

pub fn expr_pool() -> ExprPool {
  return ExprPool { nodes: Vec(), spans: Vec() };
}

pub fn expr_pool_add(pool: ExprPool, node: ExprNode, sp: Span) -> AddExprResult {
  let mut p: ExprPool = pool;
  let mut v: Vec[ExprNode] = p.nodes;
  let mut ss: Vec[Span] = p.spans;
  v.push(node);
  ss.push(sp);
  let id: i32 = v.len() - 1;
  p.nodes = v;
  p.spans = ss;
  return AddExprResult { pool: p, id: id };
}

pub fn expr_pool_get(pool: ExprPool, id: i32) -> ExprNode {
  let v: Vec[ExprNode] = pool.nodes;
  return v.get(id);
}

pub fn expr_pool_span(pool: ExprPool, id: i32) -> Span {
  let v: Vec[Span] = pool.spans;
  return v.get(id);
}
