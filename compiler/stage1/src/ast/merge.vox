// Program merge helpers (multi-file modules).
//
// Stage1 AST stores expressions in an index-based pool, so merging programs
// requires shifting expression ids for the appended side.

pub fn program_merge(a: Program, b: Program) -> Program {
  let off: i32 = a.exprs.nodes.len();
  let mut out: Program = a;

  // Imports.
  let mut ii: i32 = 0;
  while ii < b.imports.len() {
    out.imports.push(b.imports.get(ii));
    ii = ii + 1;
  }

  // Type aliases (type-only, no expr shifting needed).
  let mut ti: i32 = 0;
  while ti < b.types.len() {
    out.types.push(b.types.get(ti));
    ti = ti + 1;
  }

  // Consts (shift init expr ids).
  let mut ci: i32 = 0;
  while ci < b.consts.len() {
    out.consts.push(shift_const(b.consts.get(ci), off));
    ci = ci + 1;
  }

  // Nominal decls.
  let mut si: i32 = 0;
  while si < b.structs.len() {
    out.structs.push(b.structs.get(si));
    si = si + 1;
  }
  let mut ei: i32 = 0;
  while ei < b.enums.len() {
    out.enums.push(b.enums.get(ei));
    ei = ei + 1;
  }
  let mut tri: i32 = 0;
  while tri < b.traits.len() {
    out.traits.push(shift_trait(b.traits.get(tri), off));
    tri = tri + 1;
  }
  let mut ii2: i32 = 0;
  while ii2 < b.impls.len() {
    out.impls.push(shift_impl(b.impls.get(ii2), off));
    ii2 = ii2 + 1;
  }

  // Func decls (shift expr ids inside bodies).
  let mut fi: i32 = 0;
  while fi < b.funcs.len() {
    out.funcs.push(shift_func(b.funcs.get(fi), off));
    fi = fi + 1;
  }

  // Expr pool (shift internal ids).
  let mut nodes: Vec[ExprNode] = out.exprs.nodes;
  let mut spans: Vec[Span] = out.exprs.spans;
  let mut ni: i32 = 0;
  while ni < b.exprs.nodes.len() {
    nodes.push(shift_expr_node(b.exprs.nodes.get(ni), off));
    spans.push(b.exprs.spans.get(ni));
    ni = ni + 1;
  }
  out.exprs = ExprPool { nodes: nodes, spans: spans };
  return out;
}

fn shift_trait(td: TraitDecl, off: i32) -> TraitDecl {
  let mut ms: Vec[TraitMethodDecl] = Vec();
  let mut i: i32 = 0;
  while i < td.methods.len() {
    ms.push(shift_trait_method(td.methods.get(i), off));
    i = i + 1;
  }
  return TraitDecl { file: td.file, is_pub: td.is_pub, name: td.name, methods: ms };
}

fn shift_trait_method(md: TraitMethodDecl, off: i32) -> TraitMethodDecl {
  let body: Block = if md.has_body { shift_block(md.body, off) } else { md.body };
  return TraitMethodDecl { name: md.name, params: md.params, ret: md.ret, has_body: md.has_body, body: body };
}

fn shift_func(fd: FuncDecl, off: i32) -> FuncDecl {
  return FuncDecl {
    file: fd.file,
    is_pub: fd.is_pub,
    name: fd.name,
    type_params: fd.type_params,
    type_param_bounds: fd.type_param_bounds,
    params: fd.params,
    ret: fd.ret,
    body: shift_block(fd.body, off),
  };
}

fn shift_impl(id: ImplDecl, off: i32) -> ImplDecl {
  let mut ms: Vec[FuncDecl] = Vec();
  let mut i: i32 = 0;
  while i < id.methods.len() {
    ms.push(shift_func(id.methods.get(i), off));
    i = i + 1;
  }
  return ImplDecl {
    file: id.file,
    trait_name: id.trait_name,
    for_ty: id.for_ty,
    methods: ms,
  };
}

fn shift_const(cd: ConstDecl, off: i32) -> ConstDecl {
  return ConstDecl { file: cd.file, is_pub: cd.is_pub, name: cd.name, ty: cd.ty, init: cd.init + off };
}

fn shift_block(b: Block, off: i32) -> Block {
  let mut out: Vec[Stmt] = Vec();
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    out.push(shift_stmt(b.stmts.get(i), off));
    i = i + 1;
  }
  return Block { stmts: out };
}

fn shift_stmt(s: Stmt, off: i32) -> Stmt {
  return match s {
    Stmt.Let(sp, is_mut, name, has_ann, ann, init) =>
      Stmt.Let(sp, is_mut, name, has_ann, ann, init + off),
    Stmt.Assign(sp, name, ex) => Stmt.Assign(sp, name, ex + off),
    Stmt.AssignField(sp, recv, field, ex) => Stmt.AssignField(sp, recv, field, ex + off),
    Stmt.Expr(sp, ex) => Stmt.Expr(sp, ex + off),
    Stmt.If(sp, cond, then_b, has_else, else_b) =>
      Stmt.If(sp, cond + off, shift_block(then_b, off), has_else, shift_block(else_b, off)),
    Stmt.While(sp, cond, body) => Stmt.While(sp, cond + off, shift_block(body, off)),
    Stmt.Break(sp) => Stmt.Break(sp),
    Stmt.Continue(sp) => Stmt.Continue(sp),
    Stmt.Return(sp, has_ex, ex) =>
      if has_ex { Stmt.Return(sp, true, ex + off) } else { Stmt.Return(sp, false, -1) },
  };
}

fn shift_expr_node(n: ExprNode, off: i32) -> ExprNode {
  return match n {
    ExprNode.Int(v) => ExprNode.Int(v),
    ExprNode.Float(v) => ExprNode.Float(v),
    ExprNode.Bool(v) => ExprNode.Bool(v),
    ExprNode.Ident(s) => ExprNode.Ident(s),
    ExprNode.Str(s) => ExprNode.Str(s),
    ExprNode.DotIdent(s) => ExprNode.DotIdent(s),
    ExprNode.Block(b) => ExprNode.Block(shift_expr_block(b, off)),
    ExprNode.If(c, t, e) => ExprNode.If(c + off, t + off, e + off),
    ExprNode.Unary(op, ex) => ExprNode.Unary(op, ex + off),
    ExprNode.As(ex, tn) => ExprNode.As(ex + off, tn),
    ExprNode.Binary(op, l, r) => ExprNode.Binary(op, l + off, r + off),
    ExprNode.Member(recv, name) => ExprNode.Member(recv + off, name),
    ExprNode.Call(callee, targs, args) => ExprNode.Call(callee + off, targs, shift_ids(args, off)),
    ExprNode.StructLit(tyex, fields) => ExprNode.StructLit(tyex + off, shift_struct_lit_fields(fields, off)),
    ExprNode.Match(scrut, arms) => ExprNode.Match(scrut + off, shift_match_arms(arms, off)),
  };
}

fn shift_expr_block(b: ExprBlock, off: i32) -> ExprBlock {
  let mut ss: Vec[Stmt] = Vec();
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    ss.push(shift_stmt(b.stmts.get(i), off));
    i = i + 1;
  }
  return ExprBlock { stmts: ss, has_tail: b.has_tail, tail: if b.has_tail { b.tail + off } else { -1 } };
}

fn shift_ids(xs: Vec[i32], off: i32) -> Vec[i32] {
  let mut out: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < xs.len() {
    out.push(xs.get(i) + off);
    i = i + 1;
  }
  return out;
}

fn shift_struct_lit_fields(fs: Vec[StructLitField], off: i32) -> Vec[StructLitField] {
  let mut out: Vec[StructLitField] = Vec();
  let mut i: i32 = 0;
  while i < fs.len() {
    let f: StructLitField = fs.get(i);
    out.push(StructLitField { name: f.name, expr: f.expr + off });
    i = i + 1;
  }
  return out;
}

fn shift_match_arms(arms: Vec[MatchArm], off: i32) -> Vec[MatchArm] {
  let mut out: Vec[MatchArm] = Vec();
  let mut i: i32 = 0;
  while i < arms.len() {
    let a: MatchArm = arms.get(i);
    out.push(MatchArm { pat: a.pat, expr: a.expr + off });
    i = i + 1;
  }
  return out;
}
