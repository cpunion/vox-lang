import "ast" as ast
import "parse" as p
import "typecheck" as tc

pub struct SourceFile {
  pub path: String, // e.g. "src/main.vox", "src/a/a.vox", "tests/basic.vox"
  pub text: String,
}

pub struct LoadWorldResult {
  pub ok: bool,
  pub err: String,
  pub world: tc.World,
}

pub fn world_from_files(files: Vec[SourceFile]) -> LoadWorldResult {
  let mut mods: Vec[tc.WorldModule] = Vec();
  let mut origins: Vec[ModOrigin] = Vec();

  let mut i: i32 = 0;
  while i < files.len() {
    let f: SourceFile = files.get(i);
    let mp: String = mod_path_from_file_path(f.path);
    if mp == "" {
      return LoadWorldResult { ok: false, err: "unsupported file path: ".concat(f.path), world: tc.World { mods: Vec() } };
    }
    let is_dep: bool = dep_prefix(f.path) != "";
    let or0: OriginResult = record_mod_origin(origins, mp, is_dep);
    if !or0.ok {
      return LoadWorldResult { ok: false, err: or0.err, world: tc.World { mods: Vec() } };
    }
    origins = or0.origins;

    let r: p.ParseResult = p.parse_text_with_path(f.path, f.text);
    if r.err != p.ParseError.None {
      return LoadWorldResult { ok: false, err: "parse error in: ".concat(f.path).concat(": ").concat(p.parse_error_to_string(r.err)), world: tc.World { mods: Vec() } };
    }

    mods = upsert_mod(mods, mp, r.prog);
    i = i + 1;
  }

  return LoadWorldResult { ok: true, err: "", world: tc.World { mods: mods } };
}

struct ModOrigin { mp: String, has_root: bool, has_dep: bool }

struct OriginResult { ok: bool, err: String, origins: Vec[ModOrigin] }

fn record_mod_origin(origins0: Vec[ModOrigin], mp: String, is_dep: bool) -> OriginResult {
  let mut origins: Vec[ModOrigin] = origins0;
  let mut i: i32 = 0;
  while i < origins.len() {
    let mo: ModOrigin = origins.get(i);
    if mo.mp == mp {
      // Reject ambiguous/merging module keys: same module path cannot be both
      // a dependency package module and a root-package local module.
      if is_dep && mo.has_root {
        return OriginResult { ok: false, err: "module path conflict between local module and dependency package: ".concat(mp), origins: origins0 };
      }
      if !is_dep && mo.has_dep {
        return OriginResult { ok: false, err: "module path conflict between local module and dependency package: ".concat(mp), origins: origins0 };
      }
      // Update flags by rewriting the element.
      let upd: ModOrigin = ModOrigin { mp: mo.mp, has_root: mo.has_root || !is_dep, has_dep: mo.has_dep || is_dep };
      let mut out: Vec[ModOrigin] = Vec();
      let mut j: i32 = 0;
      while j < origins.len() {
        if j == i { out.push(upd); } else { out.push(origins.get(j)); }
        j = j + 1;
      }
      return OriginResult { ok: true, err: "", origins: out };
    }
    i = i + 1;
  }
  origins.push(ModOrigin { mp: mp, has_root: !is_dep, has_dep: is_dep });
  return OriginResult { ok: true, err: "", origins: origins };
}

fn dep_prefix(pth: String) -> String {
  // Dependency file paths are prefixed as "<depName>/src/..." or "<depName>/tests/...".
  let r0: Cut1Result = cut1(pth);
  if r0.ok && (has_prefix(r0.tail, "src/") || has_prefix(r0.tail, "tests/")) {
    let owner: String = r0.head;
    if owner != "src" && owner != "tests" {
      return owner;
    }
  }
  return "";
}

fn upsert_mod(mods: Vec[tc.WorldModule], mp: String, prog: ast.Program) -> Vec[tc.WorldModule] {
  let mut out: Vec[tc.WorldModule] = Vec();
  let mut replaced: bool = false;
  let mut i: i32 = 0;
  while i < mods.len() {
    let m: tc.WorldModule = mods.get(i);
    if m.path == mp {
      out.push(tc.WorldModule { path: mp, prog: ast.program_merge(m.prog, prog) });
      replaced = true;
    } else {
      out.push(m);
    }
    i = i + 1;
  }
  if !replaced {
    out.push(tc.WorldModule { path: mp, prog: prog });
  }
  return out;
}

pub fn mod_path_from_file_path(pth: String) -> String {
  // Optional dependency prefix: "<depName>/src/..." or "<depName>/tests/...".
  let r0: Cut1Result = cut1(pth);
  if r0.ok && (has_prefix(r0.tail, "src/") || has_prefix(r0.tail, "tests/")) {
    let owner: String = r0.head;
    let tail: String = r0.tail;
    if has_prefix(tail, "src/") {
      let rest: String = tail.slice(4, tail.len());
      let dir: String = dir_part(rest);
      if dir == "" { return owner; }
      return owner.concat("/").concat(dir);
    }
    // tests/
    let rest: String = tail.slice(6, tail.len());
    let dir: String = dir_part(rest);
    if dir == "" { return owner.concat("/tests"); }
    return owner.concat("/tests/").concat(dir);
  }

  // Root package.
  if has_prefix(pth, "src/") {
    let rest: String = pth.slice(4, pth.len());
    let dir: String = dir_part(rest);
    if dir == "" { return "main"; }
    return dir;
  }
  if has_prefix(pth, "tests/") {
    let rest: String = pth.slice(6, pth.len());
    let dir: String = dir_part(rest);
    if dir == "" { return "tests"; }
    return "tests/".concat(dir);
  }
  return "";
}

fn has_prefix(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

struct Cut1Result { ok: bool, head: String, tail: String }

fn cut1(s: String) -> Cut1Result {
  let n: i32 = s.len();
  let mut i: i32 = 0;
  while i < n {
    if s.byte_at(i) == 47 { // '/'
      return Cut1Result { ok: true, head: s.slice(0, i), tail: s.slice(i + 1, n) };
    }
    i = i + 1;
  }
  return Cut1Result { ok: false, head: "", tail: "" };
}

fn dir_part(rel: String) -> String {
  // Return directory part of "a/b/c.vox" -> "a/b"; of "x.vox" -> "".
  let n: i32 = rel.len();
  let mut i: i32 = n - 1;
  while i >= 0 {
    if rel.byte_at(i) == 47 { // '/'
      return rel.slice(0, i);
    }
    i = i - 1;
  }
  return "";
}
