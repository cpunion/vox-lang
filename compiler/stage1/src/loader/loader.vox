import "ast" as ast
import "parse" as p
import "typecheck" as tc

pub struct SourceFile {
  pub path: String, // e.g. "src/main.vox", "src/a/a.vox", "tests/basic.vox"
  pub text: String,
}

pub struct LoadWorldResult {
  pub ok: bool,
  pub err: String,
  pub world: tc.World,
}

pub fn world_from_files(files: Vec[SourceFile]) -> LoadWorldResult {
  let mut mods: Vec[tc.WorldModule] = Vec();

  let mut i: i32 = 0;
  while i < files.len() {
    let f: SourceFile = files.get(i);
    let mp: String = mod_path_from_file_path(f.path);
    if mp == "" {
      return LoadWorldResult { ok: false, err: "unsupported file path: ".concat(f.path), world: tc.World { mods: Vec() } };
    }

    let r: p.ParseResult = p.parse_text(f.text);
    if r.err != p.ParseError.None {
      return LoadWorldResult { ok: false, err: "parse error in: ".concat(f.path).concat(": ").concat(p.parse_error_to_string(r.err)), world: tc.World { mods: Vec() } };
    }

    mods = upsert_mod(mods, mp, r.prog);
    i = i + 1;
  }

  return LoadWorldResult { ok: true, err: "", world: tc.World { mods: mods } };
}

fn upsert_mod(mods: Vec[tc.WorldModule], mp: String, prog: ast.Program) -> Vec[tc.WorldModule] {
  let mut out: Vec[tc.WorldModule] = Vec();
  let mut replaced: bool = false;
  let mut i: i32 = 0;
  while i < mods.len() {
    let m: tc.WorldModule = mods.get(i);
    if m.path == mp {
      out.push(tc.WorldModule { path: mp, prog: ast.program_merge(m.prog, prog) });
      replaced = true;
    } else {
      out.push(m);
    }
    i = i + 1;
  }
  if !replaced {
    out.push(tc.WorldModule { path: mp, prog: prog });
  }
  return out;
}

pub fn mod_path_from_file_path(pth: String) -> String {
  // Optional dependency prefix: "<depName>/src/..." or "<depName>/tests/...".
  let r0: Cut1Result = cut1(pth);
  if r0.ok && (has_prefix(r0.tail, "src/") || has_prefix(r0.tail, "tests/")) {
    let owner: String = r0.head;
    let tail: String = r0.tail;
    if has_prefix(tail, "src/") {
      let rest: String = tail.slice(4, tail.len());
      let dir: String = dir_part(rest);
      if dir == "" { return owner; }
      return owner.concat("/").concat(dir);
    }
    // tests/
    let rest: String = tail.slice(6, tail.len());
    let dir: String = dir_part(rest);
    if dir == "" { return owner.concat("/tests"); }
    return owner.concat("/tests/").concat(dir);
  }

  // Root package.
  if has_prefix(pth, "src/") {
    let rest: String = pth.slice(4, pth.len());
    let dir: String = dir_part(rest);
    if dir == "" { return "main"; }
    return dir;
  }
  if has_prefix(pth, "tests/") {
    let rest: String = pth.slice(6, pth.len());
    let dir: String = dir_part(rest);
    if dir == "" { return "tests"; }
    return "tests/".concat(dir);
  }
  return "";
}

fn has_prefix(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

struct Cut1Result { ok: bool, head: String, tail: String }

fn cut1(s: String) -> Cut1Result {
  let n: i32 = s.len();
  let mut i: i32 = 0;
  while i < n {
    if s.byte_at(i) == 47 { // '/'
      return Cut1Result { ok: true, head: s.slice(0, i), tail: s.slice(i + 1, n) };
    }
    i = i + 1;
  }
  return Cut1Result { ok: false, head: "", tail: "" };
}

fn dir_part(rel: String) -> String {
  // Return directory part of "a/b/c.vox" -> "a/b"; of "x.vox" -> "".
  let n: i32 = rel.len();
  let mut i: i32 = n - 1;
  while i >= 0 {
    if rel.byte_at(i) == 47 { // '/'
      return rel.slice(0, i);
    }
    i = i - 1;
  }
  return "";
}
