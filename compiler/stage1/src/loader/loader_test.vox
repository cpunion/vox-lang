import "std/testing" as t

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn test_loader_merges_multi_files_root_module() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "src/a.vox", text: "fn a() -> i32 { return 1; }" });
  fs.push(SourceFile { path: "src/b.vox", text: "fn b() -> i32 { return 2; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(r.ok);
  t.assert_eq(r.world.mods.len(), 1);
  let m = r.world.mods.get(0);
  t.assert_eq(m.path, "main");
  t.assert_eq(m.prog.funcs.len(), 2);
}

fn test_loader_submodule_path() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "src/a/x.vox", text: "fn x() -> i32 { return 0; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(r.ok);
  t.assert_eq(r.world.mods.len(), 1);
  let m = r.world.mods.get(0);
  t.assert_eq(m.path, "a");
}

fn test_loader_tests_module_path() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "tests/basic.vox", text: "fn test_ok() -> () { return; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(r.ok);
  t.assert_eq(r.world.mods.len(), 1);
  let m = r.world.mods.get(0);
  t.assert_eq(m.path, "tests");
}

fn test_loader_dependency_prefix_module_path() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "dep/src/dep.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(SourceFile { path: "dep/src/a/x.vox", text: "pub fn x() -> i32 { return 0; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(r.ok);
  t.assert_eq(r.world.mods.len(), 2);
  // Order not specified; just check both exist.
  let a = r.world.mods.get(0).path;
  let b = r.world.mods.get(1).path;
  t.assert((a == "dep" && b == "dep/a") || (a == "dep/a" && b == "dep"));
}

fn test_loader_rejects_local_module_conflicts_with_dep_pkg() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "src/dep/x.vox", text: "fn x() -> i32 { return 0; }" });
  fs.push(SourceFile { path: "dep/src/dep.vox", text: "pub fn one() -> i32 { return 1; }" });
  let r: LoadWorldResult = world_from_files(fs);
  t.assert(!r.ok);
  t.assert(contains(r.err, "module path conflict"));
  t.assert(contains(r.err, "dep"));
}
