import "std/testing" as t

fn test_loader_merges_multi_files_root_module() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "src/a.vox", text: "fn a() -> i32 { return 1; }" });
  fs.push(SourceFile { path: "src/b.vox", text: "fn b() -> i32 { return 2; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(r.ok);
  t.assert_eq(r.world.mods.len(), 1);
  let m = r.world.mods.get(0);
  t.assert_eq(m.path, "main");
  t.assert_eq(m.prog.funcs.len(), 2);
}

fn test_loader_submodule_path() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "src/a/x.vox", text: "fn x() -> i32 { return 0; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(r.ok);
  t.assert_eq(r.world.mods.len(), 1);
  let m = r.world.mods.get(0);
  t.assert_eq(m.path, "a");
}

fn test_loader_tests_module_path() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "tests/basic.vox", text: "fn test_ok() -> () { return; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(r.ok);
  t.assert_eq(r.world.mods.len(), 1);
  let m = r.world.mods.get(0);
  t.assert_eq(m.path, "tests");
}

fn test_loader_dependency_prefix_module_path() -> () {
  let mut fs: Vec[SourceFile] = Vec();
  fs.push(SourceFile { path: "dep/src/dep.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(SourceFile { path: "dep/src/a/x.vox", text: "pub fn x() -> i32 { return 0; }" });

  let r: LoadWorldResult = world_from_files(fs);
  t.assert(r.ok);
  t.assert_eq(r.world.mods.len(), 2);
  // Order not specified; just check both exist.
  let a = r.world.mods.get(0).path;
  let b = r.world.mods.get(1).path;
  t.assert((a == "dep" && b == "dep/a") || (a == "dep/a" && b == "dep"));
}
