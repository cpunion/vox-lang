import "std/fs" as fs
import "std/dotenv" as dotenv
import "std/net" as net
import "std/process" as proc
import "std/string" as s

fn json_escape(raw: String) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < raw.len() {
    let ch: i32 = raw.byte_at(i);
    if ch == 34 {
      out = out.concat("\\\"");
    } else if ch == 92 {
      out = out.concat("\\\\");
    } else if ch == 10 {
      out = out.concat("\\n");
    } else if ch == 13 {
      out = out.concat("\\r");
    } else if ch == 9 {
      out = out.concat("\\t");
    } else {
      out = out.concat(raw.slice(i, i + 1));
    }
    i = i + 1;
  }
  return out;
}

fn json_unescape(raw: String) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < raw.len() {
    let ch: i32 = raw.byte_at(i);
    if ch == 92 && i + 1 < raw.len() {
      let nx: i32 = raw.byte_at(i + 1);
      if nx == 110 {
        out = out.concat("\n");
      } else if nx == 114 {
        out = out.concat("\r");
      } else if nx == 116 {
        out = out.concat("\t");
      } else if nx == 34 {
        out = out.concat("\"");
      } else if nx == 92 {
        out = out.concat("\\");
      } else {
        out = out.concat(raw.slice(i + 1, i + 2));
      }
      i = i + 2;
    } else {
      out = out.concat(raw.slice(i, i + 1));
      i = i + 1;
    }
  }
  return out;
}

fn json_first_string_field(line: String, field: String) -> String {
  let key: String = "\"".concat(field).concat("\"");
  let at: i32 = s.index_of(s.view_all(line), key);
  if at < 0 { return ""; }

  let mut i: i32 = at + key.len();
  while i < line.len() {
    let ch: i32 = line.byte_at(i);
    if ch == 32 || ch == 9 || ch == 10 || ch == 13 {
      i = i + 1;
    } else {
      break;
    }
  }
  if i >= line.len() || line.byte_at(i) != 58 { return ""; }
  i = i + 1;
  while i < line.len() {
    let ch: i32 = line.byte_at(i);
    if ch == 32 || ch == 9 || ch == 10 || ch == 13 {
      i = i + 1;
    } else {
      break;
    }
  }
  if i >= line.len() || line.byte_at(i) != 34 { return ""; }
  i = i + 1;
  let mut raw: String = "";
  while i < line.len() {
    let ch: i32 = line.byte_at(i);
    if ch == 34 { return json_unescape(raw); }
    if ch == 92 && i + 1 < line.len() {
      raw = raw.concat("\\").concat(line.slice(i + 1, i + 2));
      i = i + 2;
    } else {
      raw = raw.concat(line.slice(i, i + 1));
      i = i + 1;
    }
  }
  return json_unescape(raw);
}

fn shell_quote(raw: String) -> String {
  let mut out: String = "'";
  let mut i: i32 = 0;
  while i < raw.len() {
    if raw.byte_at(i) == 39 {
      out = out.concat("'\\''");
    } else {
      out = out.concat(raw.slice(i, i + 1));
    }
    i = i + 1;
  }
  return out.concat("'");
}

fn limit_text(raw: String, max_n: i32) -> String {
  if raw.len() <= max_n { return raw; }
  if max_n <= 3 { return raw.slice(0, max_n); }
  return raw.slice(0, max_n - 3).concat("...");
}

fn chat_body(model: String, prompt: String) -> String {
  return "{\"model\":\""
    .concat(json_escape(model))
    .concat("\",\"messages\":[{\"role\":\"user\",\"content\":\"")
    .concat(json_escape(prompt))
    .concat("\"}]}");
}

pub fn endpoint_url(host: String, path: String) -> String {
  return "https://".concat(host).concat(path);
}

pub fn dotenv_value(path: String, key: String) -> String {
  return dotenv.value(path, key);
}

pub fn openai_api_key(dotenv_path: String) -> String {
  let env_key: String = proc.getenv("OPENAI_API_KEY");
  if env_key != "" { return env_key; }
  return dotenv_value(dotenv_path, "OPENAI_API_KEY");
}

pub fn build_chat_request(host: String, path: String, model: String, prompt: String, token: String) -> net.HttpRequest {
  let mut req: net.HttpRequest = net.http_request("POST", host, path);
  req = req.with_header("Content-Type", "application/json");
  req = req.with_header("Authorization", "Bearer ".concat(token));
  req = req.with_header("Connection", "close");
  req = req.with_body(chat_body(model, prompt));
  return req;
}

pub fn render_chat_http(host: String, path: String, model: String, prompt: String, token: String) -> String {
  return build_chat_request(host, path, model, prompt, token).render();
}

pub fn parse_status(raw_http: String) -> i32 {
  return net.parse_status_code(raw_http);
}

pub fn chat_complete_text(host: String, path: String, model: String, prompt: String, token: String, workspace: String) -> String {
  fs.mkdir_p(workspace);

  let payload: String = workspace.concat("/chat_request.json");
  let headers: String = workspace.concat("/chat_headers.txt");
  let response: String = workspace.concat("/chat_response.json");

  fs.write_string(payload, chat_body(model, prompt));
  let hs: String = "Authorization: Bearer "
    .concat(token)
    .concat("\nContent-Type: application/json\n");
  fs.write_string(headers, hs);

  let cmd: String = "curl -sS "
    .concat(shell_quote(endpoint_url(host, path)))
    .concat(" -H @")
    .concat(shell_quote(headers))
    .concat(" --data-binary @")
    .concat(shell_quote(payload))
    .concat(" > ")
    .concat(shell_quote(response));

  let rc: i32 = proc.exec(cmd);
  if rc != 0 {
    return "ERROR: curl exit=".concat(rc.to_string());
  }
  if !fs.exists(response) {
    return "ERROR: missing response file";
  }

  let raw: String = fs.read_to_string(response);
  let content: String = json_first_string_field(raw, "content");
  if content != "" { return content; }

  let msg: String = json_first_string_field(raw, "message");
  if msg != "" {
    return "ERROR: ".concat(msg);
  }
  return "ERROR: missing content in response: ".concat(limit_text(raw, 320));
}
