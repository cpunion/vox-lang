pub struct AssistantConfig {
  pub name: String,
  pub model: String,
  pub workspace: String,
  pub api_host: String,
  pub api_path: String,
  pub max_tool_iters: i32,
  pub allow_network: bool,
}

pub fn config_default() -> AssistantConfig {
  return AssistantConfig {
    name: "vox_claw",
    model: "gpt-5-nano",
    workspace: "./target/vox_claw_workspace",
    api_host: "api.openai.com",
    api_path: "/v1/chat/completions",
    max_tool_iters: 12,
    allow_network: true,
  };
}

pub struct ToolSpec {
  pub name: String,
  pub description: String,
  pub requires_network: bool,
}

impl Clone for AssistantConfig {
  fn clone(c: AssistantConfig) -> AssistantConfig {
    return AssistantConfig {
      name: Clone.clone(c.name),
      model: Clone.clone(c.model),
      workspace: Clone.clone(c.workspace),
      api_host: Clone.clone(c.api_host),
      api_path: Clone.clone(c.api_path),
      max_tool_iters: c.max_tool_iters,
      allow_network: c.allow_network,
    };
  }
}

impl Clone for ToolSpec {
  fn clone(t: ToolSpec) -> ToolSpec {
    return ToolSpec {
      name: Clone.clone(t.name),
      description: Clone.clone(t.description),
      requires_network: t.requires_network,
    };
  }
}

pub fn default_tools() -> Vec[ToolSpec] {
  let mut out: Vec[ToolSpec] = Vec();
  out.push(ToolSpec {
    name: "help",
    description: "show tool protocol and examples",
    requires_network: false,
  });
  out.push(ToolSpec {
    name: "memory.put",
    description: "store a memory key/value record",
    requires_network: false,
  });
  out.push(ToolSpec {
    name: "memory.get",
    description: "load memory value by key",
    requires_network: false,
  });
  out.push(ToolSpec {
    name: "memory.keys",
    description: "list known memory keys",
    requires_network: false,
  });
  out.push(ToolSpec {
    name: "schedule.add",
    description: "register periodic task",
    requires_network: false,
  });
  out.push(ToolSpec {
    name: "schedule.due",
    description: "show tasks due now",
    requires_network: false,
  });
  out.push(ToolSpec {
    name: "shell.exec",
    description: "execute shell command with risk policy",
    requires_network: false,
  });
  out.push(ToolSpec {
    name: "web.get",
    description: "fetch url snippet via curl",
    requires_network: true,
  });
  return out;
}

pub fn tool_names() -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let xs: Vec[ToolSpec] = default_tools();
  let mut i: i32 = 0;
  while i < xs.len() {
    out.push(xs.get(i).name);
    i = i + 1;
  }
  return out;
}

pub fn has_tool(name: String) -> bool {
  let xs: Vec[String] = tool_names();
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == name { return true; }
    i = i + 1;
  }
  return false;
}
