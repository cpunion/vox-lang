import { Map, map, Queue, queue } from "std/collections"

pub struct ScheduledTask {
  pub id: i32,
  pub every_s: i32,
  pub prompt: String,
  pub last_run_ns: i64,
}

pub struct Scheduler {
  next_id: i32,
  tasks: Map[i32, ScheduledTask],
  order: Queue[i32],
}

pub struct AddTaskResult {
  pub scheduler: Scheduler,
  pub id: i32,
}

impl Clone for ScheduledTask {
  fn clone(t: ScheduledTask) -> ScheduledTask {
    return ScheduledTask {
      id: t.id,
      every_s: t.every_s,
      prompt: Clone.clone(t.prompt),
      last_run_ns: t.last_run_ns,
    };
  }
}

impl Clone for Scheduler {
  fn clone(s: Scheduler) -> Scheduler {
    return Scheduler {
      next_id: s.next_id,
      tasks: Clone.clone(s.tasks),
      order: Clone.clone(s.order),
    };
  }
}

pub fn scheduler() -> Scheduler {
  return Scheduler {
    next_id: 1,
    tasks: map(),
    order: queue(),
  };
}

pub fn scheduler_add(s: Scheduler, every_s: i32, prompt: String) -> AddTaskResult {
  let mut out: Scheduler = s;
  let id: i32 = out.next_id;
  let mut safe_every: i32 = every_s;
  if safe_every <= 0 { safe_every = 1; }

  let task: ScheduledTask = ScheduledTask {
    id: id,
    every_s: safe_every,
    prompt: prompt,
    last_run_ns: 0,
  };

  out.tasks = out.tasks.set(id, task);
  out.order = out.order.push(id);
  out.next_id = id + 1;

  return AddTaskResult { scheduler: out, id: id };
}

pub fn scheduler_due(s: Scheduler, now_ns: i64) -> Vec[ScheduledTask] {
  let mut out: Vec[ScheduledTask] = Vec();
  let ids: Vec[i32] = s.order.to_vec();
  let mut i: i32 = 0;
  while i < ids.len() {
    let id: i32 = ids.get(i);
    if s.tasks.contains_key(id) {
      let t: ScheduledTask = s.tasks.get(id);
      let interval_ns: i64 = (t.every_s as i64) * (1000000000 as i64);
      if t.last_run_ns == 0 || now_ns - t.last_run_ns >= interval_ns {
        out.push(t);
      }
    }
    i = i + 1;
  }
  return out;
}

pub fn scheduler_mark_run(s: Scheduler, id: i32, now_ns: i64) -> Scheduler {
  let mut out: Scheduler = s;
  if !out.tasks.contains_key(id) { return out; }
  let mut t: ScheduledTask = out.tasks.get(id);
  t.last_run_ns = now_ns;
  out.tasks = out.tasks.set(id, t);
  return out;
}
