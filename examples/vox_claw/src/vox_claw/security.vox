import "std/string" as s

pub enum Risk {
  Low,
  Medium,
  High,
}

pub struct CommandDecision {
  pub risk: Risk,
  pub allowed: bool,
  pub reason: String,
}

pub fn risk_name(r: Risk) -> String {
  return match r {
    Risk.Low => "low",
    Risk.Medium => "medium",
    Risk.High => "high",
  };
}

pub fn blocked_tokens() -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("rm -rf");
  out.push("mkfs");
  out.push("shutdown");
  out.push("reboot");
  out.push("curl | sh");
  return out;
}

pub fn classify_command(cmd: String) -> Risk {
  let v: s.StrView = s.view_all(cmd);
  if s.contains(v, "rm -rf") || s.contains(v, "mkfs") || s.contains(v, "shutdown") {
    return Risk.High;
  }
  if s.contains(v, "sudo") || s.contains(v, "git push") || s.contains(v, "curl ") {
    return Risk.Medium;
  }
  return Risk.Low;
}

pub fn evaluate(blocked: Vec[String], cmd: String) -> CommandDecision {
  let risk: Risk = classify_command(cmd);
  let mut allowed: bool = true;
  let mut reason: String = "ok";

  let xs: Vec[String] = blocked;
  let mut i: i32 = 0;
  while i < xs.len() {
    let tok: String = xs.get(i);
    if s.contains(s.view_all(cmd), tok) {
      allowed = false;
      reason = "matched blocked token: ".concat(tok);
      i = xs.len();
    } else {
      i = i + 1;
    }
  }

  if risk == Risk.High {
    allowed = false;
    if reason == "ok" {
      reason = "high-risk command";
    }
  }

  return CommandDecision {
    risk: risk,
    allowed: allowed,
    reason: reason,
  };
}
