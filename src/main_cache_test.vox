import "std/testing" as t
import "std/fs" as fs
import "vox/loader" as ld

fn build_cache_test_files_ab() -> Vec[ld.SourceFile] {
  let mut xs: Vec[ld.SourceFile] = Vec();
  xs.push(ld.SourceFile { path: "src/b.vox", text: "fn b() -> i32 { return 2; }" });
  xs.push(ld.SourceFile { path: "src/a.vox", text: "fn a() -> i32 { return 1; }" });
  return xs;
}

fn build_cache_test_files_ba() -> Vec[ld.SourceFile] {
  let mut xs: Vec[ld.SourceFile] = Vec();
  xs.push(ld.SourceFile { path: "src/a.vox", text: "fn a() -> i32 { return 1; }" });
  xs.push(ld.SourceFile { path: "src/b.vox", text: "fn b() -> i32 { return 2; }" });
  return xs;
}

fn test_build_cache_enabled_from_env_smoke() -> () {
  t.assert(build_cache_enabled_from_env(""));
  t.assert(build_cache_enabled_from_env("0"));
  t.assert(build_cache_enabled_from_env("false"));
  t.assert(!build_cache_enabled_from_env("1"));
  t.assert(!build_cache_enabled_from_env("true"));
  t.assert(!build_cache_enabled_from_env("on"));
}

fn test_hidden_source_path_smoke() -> () {
  t.assert(is_hidden_source_path(".tmp.c"));
  t.assert(is_hidden_source_path("src/.tmp.c"));
  t.assert(is_hidden_source_path("src/std/.cache/rt.c"));
  t.assert(!is_hidden_source_path("src/std/runtime/rt.c"));
}

fn test_filter_pkg_c_sources_skips_hidden_smoke() -> () {
  let mut xs: Vec[String] = Vec();
  xs.push("src/std/runtime/rt.c");
  xs.push("src/.tmp.c");
  xs.push("src/std/.cache/rt.c");
  xs.push("tests/helper.c");
  let ys: Vec[String] = filter_pkg_c_sources(xs);
  t.assert_eq(ys.len(), 1);
  t.assert_eq(ys.get(0), "src/std/runtime/rt.c");
}

fn test_build_cache_key_is_order_stable() -> () {
  let k0: String = build_cache_key(build_cache_test_files_ab(), "cmd=build");
  let k1: String = build_cache_key(build_cache_test_files_ba(), "cmd=build");
  t.assert_eq(k0, k1);
}

fn test_build_cache_key_changes_with_mode() -> () {
  let k0: String = build_cache_key(build_cache_test_files_ab(), "cmd=build\ntarget=darwin-arm64");
  let k1: String = build_cache_key(build_cache_test_files_ab(), "cmd=build\ntarget=linux-amd64");
  t.assert(k0 != k1);
}

fn test_build_cache_hit_roundtrip_smoke() -> () {
  let out: String = "target/debug/.vox_build_cache_roundtrip";
  let cpath: String = out.concat(".c");
  let bin: String = out;
  let key: String = "key-1";
  fs.mkdir_p("target/debug");
  fs.write_string(cpath, "/*c*/");
  fs.write_string(bin, "bin");
  write_build_cache(out, key);
  t.assert(build_cache_hit(out, key, cpath, bin));
  t.assert(!build_cache_hit(out, "key-2", cpath, bin));
}

fn test_test_build_cache_key_is_order_stable() -> () {
  let mut fs0: Vec[ld.SourceFile] = build_cache_test_files_ab();
  fs0.push(ld.SourceFile { path: "tests/test_a.vox", text: "fn test_a() -> () {}" });
  fs0.push(ld.SourceFile { path: "tests/test_b.vox", text: "fn test_b() -> () {}" });
  let mut fs1: Vec[ld.SourceFile] = build_cache_test_files_ab();
  fs1.push(ld.SourceFile { path: "tests/test_b.vox", text: "fn test_b() -> () {}" });
  fs1.push(ld.SourceFile { path: "tests/test_a.vox", text: "fn test_a() -> () {}" });
  let k0: String = test_build_cache_key(fs0);
  let k1: String = test_build_cache_key(fs1);
  t.assert_eq(k0, k1);
}

fn test_test_build_cache_key_changes_with_test_set() -> () {
  let mut fs0: Vec[ld.SourceFile] = build_cache_test_files_ab();
  fs0.push(ld.SourceFile { path: "tests/test_a.vox", text: "fn test_a() -> () {}" });
  let mut fs1: Vec[ld.SourceFile] = build_cache_test_files_ab();
  fs1.push(ld.SourceFile { path: "tests/test_a.vox", text: "fn test_a() -> () {}" });
  fs1.push(ld.SourceFile { path: "tests/test_b.vox", text: "fn test_b() -> () {}" });
  let k0: String = test_build_cache_key(fs0);
  let k1: String = test_build_cache_key(fs1);
  t.assert(k0 != k1);
}

fn test_test_build_cache_hit_subset_smoke() -> () {
  let out: String = "target/debug/.vox_test_build_cache_roundtrip";
  let cpath: String = out.concat(".test.c");
  let bin: String = out.concat(".test");
  let key: String = "test-key-1";
  fs.mkdir_p("target/debug");
  fs.write_string(cpath, "/*c*/");
  fs.write_string(bin, "bin");
  let mut compiled: Vec[String] = Vec();
  compiled.push("root.test_a");
  compiled.push("root.test_b");
  write_test_build_cache(out, key, compiled);

  let mut need_a: Vec[String] = Vec();
  need_a.push("root.test_a");
  t.assert(test_build_cache_hit(out, key, cpath, bin, need_a));

  let mut need_c: Vec[String] = Vec();
  need_c.push("root.test_c");
  t.assert(!test_build_cache_hit(out, key, cpath, bin, need_c));
}
