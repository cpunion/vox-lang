import "std/testing" as t
import "std/fs" as fs
import "vox/loader" as ld

fn build_cache_test_files_ab() -> Vec[ld.SourceFile] {
  let mut xs: Vec[ld.SourceFile] = Vec();
  xs.push(ld.SourceFile { path: "src/b.vox", text: "fn b() -> i32 { return 2; }" });
  xs.push(ld.SourceFile { path: "src/a.vox", text: "fn a() -> i32 { return 1; }" });
  return xs;
}

fn build_cache_test_files_ba() -> Vec[ld.SourceFile] {
  let mut xs: Vec[ld.SourceFile] = Vec();
  xs.push(ld.SourceFile { path: "src/a.vox", text: "fn a() -> i32 { return 1; }" });
  xs.push(ld.SourceFile { path: "src/b.vox", text: "fn b() -> i32 { return 2; }" });
  return xs;
}

fn test_build_cache_key_is_order_stable() -> () {
  let k0: String = build_cache_key(build_cache_test_files_ab(), "cmd=build");
  let k1: String = build_cache_key(build_cache_test_files_ba(), "cmd=build");
  t.assert_eq(k0, k1);
}

fn test_build_cache_key_changes_with_mode() -> () {
  let k0: String = build_cache_key(build_cache_test_files_ab(), "cmd=build\ntarget=darwin-arm64");
  let k1: String = build_cache_key(build_cache_test_files_ab(), "cmd=build\ntarget=linux-amd64");
  t.assert(k0 != k1);
}

fn test_build_cache_hit_roundtrip_smoke() -> () {
  let out: String = "target/debug/.vox_build_cache_roundtrip";
  let cpath: String = out.concat(".c");
  let bin: String = out;
  let key: String = "key-1";
  fs.mkdir_p("target/debug");
  fs.write_string(cpath, "/*c*/");
  fs.write_string(bin, "bin");
  write_build_cache(out, key);
  t.assert(build_cache_hit(out, key, cpath, bin));
  t.assert(!build_cache_hit(out, "key-2", cpath, bin));
}
