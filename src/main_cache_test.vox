import "std/testing" as t
import "std/fs" as fs
import "vox/loader" as ld

fn build_cache_test_files_ab() -> Vec[ld.SourceFile] {
  let mut xs: Vec[ld.SourceFile] = Vec();
  xs.push(ld.SourceFile { path: "src/b.vox", text: "fn b() -> i32 { return 2; }" });
  xs.push(ld.SourceFile { path: "src/a.vox", text: "fn a() -> i32 { return 1; }" });
  return xs;
}

fn build_cache_test_files_ba() -> Vec[ld.SourceFile] {
  let mut xs: Vec[ld.SourceFile] = Vec();
  xs.push(ld.SourceFile { path: "src/a.vox", text: "fn a() -> i32 { return 1; }" });
  xs.push(ld.SourceFile { path: "src/b.vox", text: "fn b() -> i32 { return 2; }" });
  return xs;
}

fn build_cache_test_files_main_and_dep() -> Vec[ld.SourceFile] {
  let mut xs: Vec[ld.SourceFile] = Vec();
  xs.push(ld.SourceFile { path: "src/a.vox", text: "fn a() -> i32 { return 1; }" });
  xs.push(ld.SourceFile { path: "dep/src/lib.vox", text: "fn dep() -> i32 { return 7; }" });
  return xs;
}

fn pkg_key_for_pkg(xs: Vec[BuildCachePkgKey], pkg: String) -> String {
  let mut i: i32 = 0;
  while i < xs.len() {
    let x: BuildCachePkgKey = xs.get(i);
    if x.pkg == pkg { return x.key; }
    i = i + 1;
  }
  return "";
}

fn test_build_cache_enabled_from_env_smoke() -> () {
  t.assert(build_cache_enabled_from_env(""));
  t.assert(build_cache_enabled_from_env("0"));
  t.assert(build_cache_enabled_from_env("false"));
  t.assert(!build_cache_enabled_from_env("1"));
  t.assert(!build_cache_enabled_from_env("true"));
  t.assert(!build_cache_enabled_from_env("on"));
}

fn test_hidden_source_path_smoke() -> () {
  t.assert(is_hidden_source_path(".tmp.c"));
  t.assert(is_hidden_source_path("src/.tmp.c"));
  t.assert(is_hidden_source_path("src/std/.cache/rt.c"));
  t.assert(!is_hidden_source_path("src/./main.c"));
  t.assert(!is_hidden_source_path("src/foo/../bar.c"));
  t.assert(!is_hidden_source_path("src/std/runtime/rt.c"));
}

fn test_filter_pkg_c_sources_skips_hidden_smoke() -> () {
  let mut xs: Vec[String] = Vec();
  xs.push("src/std/runtime/rt.c");
  xs.push("src/.tmp.c");
  xs.push("src/std/.cache/rt.c");
  xs.push("tests/helper.c");
  let ys: Vec[String] = filter_pkg_c_sources(xs);
  t.assert_eq(ys.len(), 1);
  t.assert_eq(ys.get(0), "src/std/runtime/rt.c");
}

fn test_build_cache_key_is_order_stable() -> () {
  let k0: String = build_cache_key(build_cache_test_files_ab(), "cmd=build");
  let k1: String = build_cache_key(build_cache_test_files_ba(), "cmd=build");
  t.assert_eq(k0, k1);
}

fn test_build_cache_key_changes_with_mode() -> () {
  let k0: String = build_cache_key(build_cache_test_files_ab(), "cmd=build\ntarget=darwin-arm64");
  let k1: String = build_cache_key(build_cache_test_files_ab(), "cmd=build\ntarget=linux-amd64");
  t.assert(k0 != k1);
}

fn test_build_cache_key_from_pkg_source_keys_matches_direct_smoke() -> () {
  let mode: String = "cmd=build\ntarget=linux-amd64";
  let direct: String = build_cache_key(build_cache_test_files_main_and_dep(), mode);
  let via_src: String = build_cache_key_from_pkg_source_keys(build_cache_pkg_source_keys(build_cache_test_files_main_and_dep()), mode);
  t.assert_eq(via_src, direct);
}

fn test_build_cache_key_pair_from_pkg_source_keys_matches_single_derivation_smoke() -> () {
  let compile_mode: String = "cmd=build\ntarget=linux-amd64";
  let link_mode: String = "cmd=build\ntarget=linux-amd64\nartifact=static";
  let pair: BuildCacheKeyPair = build_cache_key_pair_from_pkg_source_keys(build_cache_pkg_source_keys(build_cache_test_files_main_and_dep()), compile_mode, link_mode);
  let compile_direct: String = build_cache_key(build_cache_test_files_main_and_dep(), compile_mode);
  let link_direct: String = build_cache_key(build_cache_test_files_main_and_dep(), link_mode);
  t.assert_eq(pair.compile_key, compile_direct);
  t.assert_eq(pair.link_key, link_direct);
}

fn test_build_cache_pkg_keys_group_by_owner_smoke() -> () {
  let keys: Vec[BuildCachePkgKey] = build_cache_pkg_keys(build_cache_test_files_main_and_dep(), "cmd=build");
  t.assert_eq(keys.len(), 2);
  t.assert_eq(keys.get(0).pkg, "main");
  t.assert_eq(keys.get(1).pkg, "pkg/dep");
}

fn test_build_cache_pkg_keys_keep_other_pkg_stable_smoke() -> () {
  let fs0: Vec[ld.SourceFile] = build_cache_test_files_main_and_dep();
  let mut fs1: Vec[ld.SourceFile] = Vec();
  fs1.push(ld.SourceFile { path: "src/a.vox", text: "fn a() -> i32 { return 42; }" });
  fs1.push(ld.SourceFile { path: "dep/src/lib.vox", text: "fn dep() -> i32 { return 7; }" });

  let k0: Vec[BuildCachePkgKey] = build_cache_pkg_keys(fs0, "cmd=build");
  let k1: Vec[BuildCachePkgKey] = build_cache_pkg_keys(fs1, "cmd=build");
  t.assert_eq(pkg_key_for_pkg(k0, "pkg/dep"), pkg_key_for_pkg(k1, "pkg/dep"));
}

fn test_build_cache_hit_roundtrip_smoke() -> () {
  let key: String = "key-1";
  let cpath: String = build_cache_cpath_for_key(key);
  let bin: String = build_cache_bin_for_key(key, "linux");
  let obj: String = build_cache_obj_path_for_key(key, ".o");
  fs.mkdir_p("target/debug");
  fs.mkdir_p(dir_name(cpath));
  fs.mkdir_p(dir_name(bin));
  fs.mkdir_p(dir_name(obj));
  fs.write_string(cpath, "/*c*/");
  fs.write_string(bin, "bin");
  fs.write_string(obj, "obj");
  write_build_obj_cache(key);
  write_build_cache(key);
  t.assert(build_cache_hit(key, cpath, bin));
  t.assert(build_cache_obj_hit(key, cpath, obj));
  t.assert(!build_cache_hit("key-2", cpath, bin));
  t.assert(!build_cache_obj_hit("key-2", cpath, obj));
}

fn test_build_cache_paths_use_split_link_and_obj_roots() -> () {
  let key: String = "k";
  t.assert(text_contains(build_cache_cpath_for_key(key), "pkg-obj-v1"));
  t.assert(text_contains(build_cache_obj_path_for_key(key, ".o"), "pkg-obj-v1"));
  t.assert(text_contains(build_cache_obj_meta_path_for_key(key), "pkg-obj-v1"));
  t.assert(text_contains(build_cache_bin_for_key(key, "linux"), "link-v1"));
  t.assert(text_contains(build_cache_meta_path_for_key(key), "link-v1"));
}

fn test_test_build_cache_key_is_order_stable() -> () {
  let mut fs0: Vec[ld.SourceFile] = build_cache_test_files_ab();
  fs0.push(ld.SourceFile { path: "tests/test_a.vox", text: "fn test_a() -> () {}" });
  fs0.push(ld.SourceFile { path: "tests/test_b.vox", text: "fn test_b() -> () {}" });
  let mut fs1: Vec[ld.SourceFile] = build_cache_test_files_ab();
  fs1.push(ld.SourceFile { path: "tests/test_b.vox", text: "fn test_b() -> () {}" });
  fs1.push(ld.SourceFile { path: "tests/test_a.vox", text: "fn test_a() -> () {}" });
  let k0: String = test_build_cache_key(fs0, "cmd=test\ntarget=linux-amd64");
  let k1: String = test_build_cache_key(fs1, "cmd=test\ntarget=linux-amd64");
  t.assert_eq(k0, k1);
}

fn test_test_build_cache_key_changes_with_mode() -> () {
  let fs0: Vec[ld.SourceFile] = build_cache_test_files_ab();
  let k0: String = test_build_cache_key(fs0, "cmd=test\ntarget=darwin-arm64");
  let fs1: Vec[ld.SourceFile] = build_cache_test_files_ab();
  let k1: String = test_build_cache_key(fs1, "cmd=test\ntarget=linux-amd64");
  t.assert(k0 != k1);
}

fn test_test_build_cache_key_changes_with_test_set() -> () {
  let mut fs0: Vec[ld.SourceFile] = build_cache_test_files_ab();
  fs0.push(ld.SourceFile { path: "tests/test_a.vox", text: "fn test_a() -> () {}" });
  let mut fs1: Vec[ld.SourceFile] = build_cache_test_files_ab();
  fs1.push(ld.SourceFile { path: "tests/test_a.vox", text: "fn test_a() -> () {}" });
  fs1.push(ld.SourceFile { path: "tests/test_b.vox", text: "fn test_b() -> () {}" });
  let k0: String = test_build_cache_key(fs0, "cmd=test\ntarget=linux-amd64");
  let k1: String = test_build_cache_key(fs1, "cmd=test\ntarget=linux-amd64");
  t.assert(k0 != k1);
}

fn test_test_build_cache_hit_subset_smoke() -> () {
  let key: String = "test-key-1";
  let out: String = test_build_cache_out_for_key(key);
  let cpath: String = test_build_cache_cpath_for_key(key);
  let bin: String = out;
  fs.mkdir_p(dir_name(cpath));
  fs.mkdir_p(dir_name(bin));
  fs.write_string(cpath, "/*c*/");
  fs.write_string(bin, "bin");
  let mut compiled: Vec[String] = Vec();
  compiled.push("root.test_a");
  compiled.push("root.test_b");
  write_test_build_cache(out, key, compiled);

  let mut need_a: Vec[String] = Vec();
  need_a.push("root.test_a");
  t.assert(test_build_cache_hit(out, key, cpath, bin, need_a));

  let mut need_c: Vec[String] = Vec();
  need_c.push("root.test_c");
  t.assert(!test_build_cache_hit(out, key, cpath, bin, need_c));
}

fn test_test_build_cache_paths_use_split_link_and_obj_roots() -> () {
  let key: String = "k";
  t.assert(text_contains(test_build_cache_out_for_key(key), "test-link-v1"));
  t.assert(text_contains(test_build_cache_cpath_for_key(key), "test-pkg-obj-v1"));
}
