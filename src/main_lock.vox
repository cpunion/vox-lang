import "std/fs" as fs
import "vox/manifest" as mf
import "vox/internal/source" as srcw
import "vox/internal/text" as txt

struct LockDep {
  name: String,
  source: String,
  path: String,
  resolved_path: String,
  git: String,
  rev: String,
  registry: String,
  version: String,
  digest: String,
}

struct ParseLockResult { ok: bool, err: String, deps: Vec[LockDep] }

struct LockVerifyResult { ok: bool, err: String }

struct LockFindDepResult { found: bool, dep: LockDep }

fn lock_ok() -> LockVerifyResult { return LockVerifyResult { ok: true, err: "" }; }

fn lock_err(msg: String) -> LockVerifyResult { return LockVerifyResult { ok: false, err: msg }; }

fn empty_lock_dep() -> LockDep {
  return LockDep {
    name: "",
    source: "",
    path: "",
    resolved_path: "",
    git: "",
    rev: "",
    registry: "",
    version: "",
    digest: "",
  };
}

fn parse_lockfile(text: String) -> ParseLockResult {
  let lines: Vec[String] = txt.split_lines(text);
  let mut deps: Vec[LockDep] = Vec();
  let mut in_dep: bool = false;
  let mut cur: LockDep = empty_lock_dep();

  let mut i: i32 = 0;
  while i < lines.len() {
    let line0: String = txt.trim_space(lines.get(i));
    if line0 == "" || txt.has_prefix(line0, "#") {
      i = i + 1;
      continue;
    }
    if line0 == "[[dependency]]" {
      if in_dep {
        deps.push(cur);
      }
      cur = empty_lock_dep();
      in_dep = true;
      i = i + 1;
      continue;
    }
    if !in_dep {
      i = i + 1;
      continue;
    }
    let eq: i32 = txt.index_byte(line0, 61); // '='
    if eq == -1 {
      return ParseLockResult { ok: false, err: "invalid lock line", deps: Vec() };
    }
    let key: String = txt.trim_space(line0.slice(0, eq));
    let val: String = txt.unquote_double_trimmed(line0.slice(eq + 1, line0.len()));
    if key == "name" { cur.name = val; }
    else if key == "source" { cur.source = val; }
    else if key == "path" { cur.path = val; }
    else if key == "resolved_path" { cur.resolved_path = val; }
    else if key == "git" { cur.git = val; }
    else if key == "rev" { cur.rev = val; }
    else if key == "registry" { cur.registry = val; }
    else if key == "version" { cur.version = val; }
    else if key == "digest" { cur.digest = val; }
    i = i + 1;
  }

  if in_dep {
    deps.push(cur);
  }
  return ParseLockResult { ok: true, err: "", deps: deps };
}

fn lock_hash_byte(h0: u64, b: i32) -> u64 {
  let h1: u64 = h0 ^ (b as u64);
  return h1 * (1099511628211 as u64);
}

fn lock_hash_text(h0: u64, s: String) -> u64 {
  let mut h: u64 = h0;
  let n: i32 = s.len();
  let base: rawptr = s as const rawptr as isize as rawptr;
  let mut i: i32 = 0;
  while i < n {
    let b: i32 = @ptr_read[u8](@ptr_offset(base, i as isize)) as i32;
    h = lock_hash_byte(h, b);
    i = i + 1;
  }
  return h;
}

fn lock_insert_sorted(xs0: Vec[String], x: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut inserted: bool = false;
  let mut i: i32 = 0;
  while i < xs0.len() {
    let cur: String = xs0.get(i);
    if !inserted && x < cur {
      out.push(x);
      inserted = true;
    }
    out.push(cur);
    i = i + 1;
  }
  if !inserted { out.push(x); }
  return out;
}

fn lock_sort_strings(xs0: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    out = lock_insert_sorted(out, xs0.get(i));
    i = i + 1;
  }
  return out;
}

fn lock_dep_digest(dep_root: String) -> String {
  let mut h: u64 = 1469598103934665603 as u64;
  let mani_path: String = path_join(dep_root, "vox.toml");
  if fs.exists(mani_path) {
    h = lock_hash_text(h, "vox.toml");
    h = lock_hash_text(h, "\n");
    h = lock_hash_text(h, fs.read_to_string(mani_path));
    h = lock_hash_text(h, "\n");
  }

  let rels0: Vec[String] = srcw.walk_vox_files(dep_root);
  let mut rels1: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < rels0.len() {
    let rel: String = rels0.get(i);
    if txt.has_prefix(rel, "src/") && !is_test_path(rel) {
      rels1.push(rel);
    }
    i = i + 1;
  }
  let rels: Vec[String] = lock_sort_strings(rels1);
  let mut j: i32 = 0;
  while j < rels.len() {
    let rel: String = rels.get(j);
    h = lock_hash_text(h, rel);
    h = lock_hash_text(h, "\n");
    h = lock_hash_text(h, fs.read_to_string(path_join(dep_root, rel)));
    h = lock_hash_text(h, "\n");
    j = j + 1;
  }
  return h.to_string();
}

fn lock_dep_of(d: mf.Dependency) -> LockDep {
  return LockDep {
    name: d.name,
    source: dep_source_kind(d.has_path, d.has_version, d.has_git, d.has_registry),
    path: if d.has_path { d.path } else { "" },
    resolved_path: d.path,
    git: if d.has_git { d.git } else { "" },
    rev: if d.has_rev { d.rev } else { "" },
    registry: if d.has_registry { d.registry } else { "" },
    version: if d.has_version { d.version } else { "" },
    digest: lock_dep_digest(d.path),
  };
}

fn lock_find_dep_by_name(deps: Vec[LockDep], name: String) -> LockFindDepResult {
  let mut i: i32 = 0;
  while i < deps.len() {
    let d: LockDep = deps.get(i);
    if d.name == name {
      return LockFindDepResult { found: true, dep: d };
    }
    i = i + 1;
  }
  return LockFindDepResult { found: false, dep: empty_lock_dep() };
}

fn lock_quote_value(v: String) -> String {
  if v == "" { return "<empty>"; }
  return "\"".concat(v).concat("\"");
}

fn lock_field_mismatch(dep_name: String, field: String, expected: String, actual: String) -> String {
  let mut msg: String = "dependency mismatch: ".concat(dep_name);
  msg = msg.concat(" field ").concat(field);
  msg = msg.concat(" expected=").concat(lock_quote_value(expected));
  msg = msg.concat(" actual=").concat(lock_quote_value(actual));
  return msg;
}

fn lock_dep_mismatch_detail(expected: LockDep, actual: LockDep) -> String {
  if expected.source != actual.source {
    return lock_field_mismatch(expected.name, "source", expected.source, actual.source);
  }
  if expected.path != actual.path {
    return lock_field_mismatch(expected.name, "path", expected.path, actual.path);
  }
  if expected.resolved_path != actual.resolved_path {
    return lock_field_mismatch(expected.name, "resolved_path", expected.resolved_path, actual.resolved_path);
  }
  if expected.git != actual.git {
    return lock_field_mismatch(expected.name, "git", expected.git, actual.git);
  }
  if expected.rev != actual.rev {
    return lock_field_mismatch(expected.name, "rev", expected.rev, actual.rev);
  }
  if expected.registry != actual.registry {
    return lock_field_mismatch(expected.name, "registry", expected.registry, actual.registry);
  }
  if expected.version != actual.version {
    return lock_field_mismatch(expected.name, "version", expected.version, actual.version);
  }
  if expected.digest != actual.digest {
    return lock_field_mismatch(expected.name, "digest", expected.digest, actual.digest);
  }
  return "";
}

fn verify_lockfile_or_ok(deps: Vec[mf.Dependency]) -> LockVerifyResult {
  if !fs.exists("vox.lock") {
    return lock_ok();
  }
  let txt: String = fs.read_to_string("vox.lock");
  let pr: ParseLockResult = parse_lockfile(txt);
  if !pr.ok {
    return lock_err(pr.err);
  }

  let mut expected: Vec[LockDep] = Vec();
  let mut i: i32 = 0;
  while i < deps.len() {
    expected.push(lock_dep_of(deps.get(i)));
    i = i + 1;
  }

  if pr.deps.len() != expected.len() {
    return lock_err(
      "dependency count mismatch: lock=".concat(pr.deps.len().to_string()).concat(
        " resolved=").concat(expected.len().to_string()),
    );
  }

  let mut ei: i32 = 0;
  while ei < expected.len() {
    let e: LockDep = expected.get(ei);
    let fr: LockFindDepResult = lock_find_dep_by_name(pr.deps, e.name);
    if !fr.found {
      return lock_err("missing dependency in vox.lock: ".concat(e.name));
    }
    let mismatch: String = lock_dep_mismatch_detail(e, fr.dep);
    if mismatch != "" {
      return lock_err(mismatch);
    }
    ei = ei + 1;
  }

  let mut ai: i32 = 0;
  while ai < pr.deps.len() {
    let a: LockDep = pr.deps.get(ai);
    let fr: LockFindDepResult = lock_find_dep_by_name(expected, a.name);
    if !fr.found {
      return lock_err("unexpected dependency in vox.lock: ".concat(a.name));
    }
    ai = ai + 1;
  }
  return lock_ok();
}
