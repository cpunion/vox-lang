import "std/fs" as fs
import "vox/loader" as ld
import "vox/internal/text" as txt

fn source_file_insert_sorted(xs0: Vec[ld.SourceFile], x: ld.SourceFile) -> Vec[ld.SourceFile] {
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut inserted: bool = false;
  let mut i: i32 = 0;
  while i < xs0.len() {
    let cur: ld.SourceFile = xs0.get(i);
    if !inserted && x.path < cur.path {
      out.push(x);
      inserted = true;
    }
    out.push(cur);
    i = i + 1;
  }
  if !inserted { out.push(x); }
  return out;
}

fn sort_source_files(xs0: Vec[ld.SourceFile]) -> Vec[ld.SourceFile] {
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    out = source_file_insert_sorted(out, xs0.get(i));
    i = i + 1;
  }
  return out;
}

fn test_build_cache_meta_path(out: String) -> String {
  return out.concat(".test.cache.key");
}

fn test_build_cache_tests_path(out: String) -> String {
  return out.concat(".test.cache.tests");
}

fn test_build_cache_out_for_key(key: String) -> String {
  return path_join(path_join(path_join("target", "cache"), "test-link-v1"), key);
}

fn test_build_cache_cpath_for_key(key: String) -> String {
  return path_join(path_join(path_join("target", "cache"), "test-pkg-obj-v1"), key).concat(".c");
}

fn test_build_cache_key(files0: Vec[ld.SourceFile], mode: String) -> String {
  let mut h: u64 = 1469598103934665603 as u64;
  h = lock_hash_text(h, "test-build-cache-v4\n");
  h = lock_hash_text(h, if host_is_windows() { "windows\n" } else { "posix\n" });
  h = lock_hash_text(h, mode);
  h = lock_hash_text(h, "\n");

  let files: Vec[ld.SourceFile] = sort_source_files(files0);
  let mut i: i32 = 0;
  while i < files.len() {
    let f: ld.SourceFile = files.get(i);
    h = lock_hash_text(h, "F\n");
    h = lock_hash_text(h, f.path);
    h = lock_hash_text(h, "\n");
    h = lock_hash_text(h, f.text);
    h = lock_hash_text(h, "\n");
    i = i + 1;
  }
  return h.to_string();
}

fn parse_test_build_cache_tests(text: String) -> Vec[String] {
  let lines: Vec[String] = txt.split_lines(text);
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < lines.len() {
    let s: String = txt.trim_space(lines.get(i));
    if s != "" { out.push(s); }
    i = i + 1;
  }
  return sort_strings(out);
}

fn format_test_build_cache_tests(tests0: Vec[String]) -> String {
  let tests: Vec[String] = sort_strings(tests0);
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < tests.len() {
    out = out.concat(tests.get(i)).concat("\n");
    i = i + 1;
  }
  return out;
}

fn test_build_cache_contains_all(hay0: Vec[String], need0: Vec[String]) -> bool {
  let hay: Vec[String] = sort_strings(hay0);
  let need: Vec[String] = sort_strings(need0);
  let mut i: i32 = 0;
  while i < need.len() {
    let want: String = need.get(i);
    let mut found: bool = false;
    let mut j: i32 = 0;
    while j < hay.len() {
      if hay.get(j) == want {
        found = true;
        j = hay.len();
      } else {
        j = j + 1;
      }
    }
    if !found { return false; }
    i = i + 1;
  }
  return true;
}

fn test_build_cache_load_tests(out: String, key: String, cpath: String, bin: String) -> Vec[String] {
  let meta: String = test_build_cache_meta_path(out);
  if !fs.exists(meta) { return Vec(); }
  if !fs.exists(cpath) { return Vec(); }
  let has_bin: bool = fs.exists(bin) || fs.exists(bin.concat(".exe"));
  if !has_bin { return Vec(); }
  let cur: String = txt.trim_space(fs.read_to_string(meta));
  if cur != key { return Vec(); }
  let tests_path: String = test_build_cache_tests_path(out);
  if !fs.exists(tests_path) { return Vec(); }
  return parse_test_build_cache_tests(fs.read_to_string(tests_path));
}

fn test_build_cache_hit(out: String, key: String, cpath: String, bin: String, selected0: Vec[String]) -> bool {
  let compiled: Vec[String] = test_build_cache_load_tests(out, key, cpath, bin);
  if compiled.len() == 0 { return false; }
  return test_build_cache_contains_all(compiled, selected0);
}

fn merge_unique_strings(xs0: Vec[String], ys0: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    let s: String = xs0.get(i);
    let mut found: bool = false;
    let mut k: i32 = 0;
    while k < out.len() {
      if out.get(k) == s {
        found = true;
        k = out.len();
      } else {
        k = k + 1;
      }
    }
    if s != "" && !found { out.push(s); }
    i = i + 1;
  }
  let mut j: i32 = 0;
  while j < ys0.len() {
    let s: String = ys0.get(j);
    let mut found: bool = false;
    let mut k: i32 = 0;
    while k < out.len() {
      if out.get(k) == s {
        found = true;
        k = out.len();
      } else {
        k = k + 1;
      }
    }
    if s != "" && !found { out.push(s); }
    j = j + 1;
  }
  return sort_strings(out);
}

fn write_test_build_cache(out: String, key: String, tests: Vec[String]) -> () {
  let meta: String = test_build_cache_meta_path(out);
  fs.mkdir_p(dir_name(meta));
  fs.write_string(meta, key.concat("\n"));
  fs.write_string(test_build_cache_tests_path(out), format_test_build_cache_tests(tests));
}

fn build_cache_link_out_for_key(key: String) -> String {
  return path_join(path_join(path_join("target", "cache"), "link-v1"), key);
}

fn build_cache_obj_out_for_key(key: String) -> String {
  return path_join(path_join(path_join("target", "cache"), "pkg-obj-v1"), key);
}

fn build_cache_meta_path_for_key(key: String) -> String {
  return build_cache_link_out_for_key(key).concat(".build.cache.key");
}

fn build_cache_cpath_for_key(key: String) -> String {
  return build_cache_obj_out_for_key(key).concat(".c");
}

fn build_cache_bin_for_key(key: String, target_os: String) -> String {
  let out: String = build_cache_link_out_for_key(key);
  if target_os == "wasm" { return out.concat(".wasm"); }
  return out.concat(".bin");
}

fn build_cache_key(files0: Vec[ld.SourceFile], mode: String) -> String {
  let mut h: u64 = 1469598103934665603 as u64;
  h = lock_hash_text(h, "build-cache-v1\n");
  h = lock_hash_text(h, if host_is_windows() { "windows\n" } else { "posix\n" });
  h = lock_hash_text(h, mode);
  h = lock_hash_text(h, "\n");

  let files: Vec[ld.SourceFile] = sort_source_files(files0);
  let mut i: i32 = 0;
  while i < files.len() {
    let f: ld.SourceFile = files.get(i);
    h = lock_hash_text(h, "F\n");
    h = lock_hash_text(h, f.path);
    h = lock_hash_text(h, "\n");
    h = lock_hash_text(h, f.text);
    h = lock_hash_text(h, "\n");
    i = i + 1;
  }
  return h.to_string();
}

fn build_cache_hit(key: String, cpath: String, bin: String) -> bool {
  let meta: String = build_cache_meta_path_for_key(key);
  if !fs.exists(meta) { return false; }
  if !fs.exists(cpath) { return false; }
  let has_bin: bool = fs.exists(bin) || fs.exists(bin.concat(".exe"));
  if !has_bin { return false; }
  let cur: String = txt.trim_space(fs.read_to_string(meta));
  return cur == key;
}

fn write_build_cache(key: String) -> () {
  let meta: String = build_cache_meta_path_for_key(key);
  fs.mkdir_p(dir_name(meta));
  fs.write_string(meta, key.concat("\n"));
}

fn discover_tests_cache_key_path() -> String {
  return "target/debug/.vox_test_discover.key";
}

fn discover_tests_cache_list_path() -> String {
  return "target/debug/.vox_test_discover.list";
}

fn discover_tests_cache_key(paths0: Vec[String]) -> String {
  let mut h: u64 = 1469598103934665603 as u64;
  h = lock_hash_text(h, "discover-tests-cache-v1\n");

  let mut test_paths: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths0.len() {
    let p: String = paths0.get(i);
    if is_test_file_for_discovery(p) {
      test_paths.push(p);
    }
    i = i + 1;
  }

  let paths: Vec[String] = sort_strings(test_paths);
  let mut j: i32 = 0;
  while j < paths.len() {
    let pth: String = paths.get(j);
    h = lock_hash_text(h, "P\n");
    h = lock_hash_text(h, pth);
    h = lock_hash_text(h, "\n");
    h = lock_hash_text(h, fs.read_to_string(pth));
    h = lock_hash_text(h, "\n");
    j = j + 1;
  }
  return h.to_string();
}

fn parse_discover_tests_cache_list(text: String) -> Vec[String] {
  let lines: Vec[String] = txt.split_lines(text);
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < lines.len() {
    let s: String = txt.trim_space(lines.get(i));
    if s != "" { out.push(s); }
    i = i + 1;
  }
  return sort_strings(out);
}

fn format_discover_tests_cache_list(tests0: Vec[String]) -> String {
  let tests: Vec[String] = sort_strings(tests0);
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < tests.len() {
    out = out.concat(tests.get(i)).concat("\n");
    i = i + 1;
  }
  return out;
}

fn write_discover_tests_cache(key: String, tests: Vec[String]) -> () {
  fs.mkdir_p("target/debug");
  fs.write_string(discover_tests_cache_key_path(), key.concat("\n"));
  fs.write_string(discover_tests_cache_list_path(), format_discover_tests_cache_list(tests));
}

fn discover_tests_cached(paths: Vec[String]) -> Vec[String] {
  let mut paths_for_key: Vec[String] = Vec();
  let mut pi: i32 = 0;
  while pi < paths.len() {
    paths_for_key.push(paths.get(pi));
    pi = pi + 1;
  }
  let key: String = discover_tests_cache_key(paths_for_key);
  let key_path: String = discover_tests_cache_key_path();
  let list_path: String = discover_tests_cache_list_path();
  if fs.exists(key_path) && fs.exists(list_path) {
    let cached_key: String = txt.trim_space(fs.read_to_string(key_path));
    if cached_key == key {
      return parse_discover_tests_cache_list(fs.read_to_string(list_path));
    }
  }
  let tests: Vec[String] = discover_tests(paths);
  write_discover_tests_cache(key, tests);
  return tests;
}

fn discover_tests_cached_fast(paths: Vec[String]) -> Vec[String] {
  let key_path: String = discover_tests_cache_key_path();
  let list_path: String = discover_tests_cache_list_path();
  if fs.exists(key_path) && fs.exists(list_path) {
    return parse_discover_tests_cache_list(fs.read_to_string(list_path));
  }
  return discover_tests_cached(paths);
}
