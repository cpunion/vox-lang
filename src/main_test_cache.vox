import "std/fs" as fs
import "vox/loader" as ld
import "vox/internal/text" as txt

fn merge_source_files(left: Vec[ld.SourceFile], right: Vec[ld.SourceFile]) -> Vec[ld.SourceFile] {
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut li: i32 = 0;
  let mut ri: i32 = 0;
  while li < left.len() && ri < right.len() {
    let l: ld.SourceFile = left.get(li);
    let r: ld.SourceFile = right.get(ri);
    if l.path <= r.path {
      out.push(l);
      li = li + 1;
    } else {
      out.push(r);
      ri = ri + 1;
    }
  }
  while li < left.len() {
    out.push(left.get(li));
    li = li + 1;
  }
  while ri < right.len() {
    out.push(right.get(ri));
    ri = ri + 1;
  }
  return out;
}

fn sort_source_files(xs0: Vec[ld.SourceFile]) -> Vec[ld.SourceFile] {
  if xs0.len() <= 1 { return xs0; }
  let mid: i32 = xs0.len() / 2;
  let mut left: Vec[ld.SourceFile] = Vec();
  let mut right: Vec[ld.SourceFile] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    if i < mid {
      left.push(xs0.get(i));
    } else {
      right.push(xs0.get(i));
    }
    i = i + 1;
  }
  return merge_source_files(sort_source_files(left), sort_source_files(right));
}

fn test_build_cache_meta_path(out: String) -> String {
  return out.concat(".test.cache.key");
}

fn test_build_cache_tests_path(out: String) -> String {
  return out.concat(".test.cache.tests");
}

fn test_build_cache_root_for_key(root: String, key: String) -> String {
  return path_join(path_join(path_join("target", "cache"), root), key);
}

fn test_build_cache_out_for_key(key: String) -> String {
  return test_build_cache_root_for_key("test-link-v1", key);
}

fn test_build_cache_cpath_for_key(key: String) -> String {
  return test_build_cache_root_for_key("test-pkg-obj-v1", key).concat(".c");
}

fn test_build_cache_key(files0: Vec[ld.SourceFile], mode: String) -> String {
  let mut h: u64 = 1469598103934665603 as u64;
  h = lock_hash_text(h, "test-build-cache-v4\n");
  h = lock_hash_text(h, if host_is_windows() { "windows\n" } else { "posix\n" });
  h = lock_hash_text(h, mode);
  h = lock_hash_text(h, "\n");

  let files: Vec[ld.SourceFile] = sort_source_files(files0);
  let mut i: i32 = 0;
  while i < files.len() {
    let f: ld.SourceFile = files.get(i);
    h = lock_hash_text(h, "F\n");
    h = lock_hash_text(h, f.path);
    h = lock_hash_text(h, "\n");
    h = lock_hash_text(h, f.text);
    h = lock_hash_text(h, "\n");
    i = i + 1;
  }
  return h.to_string();
}

fn parse_test_build_cache_tests(text: String) -> Vec[String] {
  let lines: Vec[String] = txt.split_lines(text);
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < lines.len() {
    let s: String = txt.trim_space(lines.get(i));
    if s != "" { out.push(s); }
    i = i + 1;
  }
  return sort_strings(out);
}

fn format_test_build_cache_tests(tests0: Vec[String]) -> String {
  let tests: Vec[String] = sort_strings(tests0);
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < tests.len() {
    out = out.concat(tests.get(i)).concat("\n");
    i = i + 1;
  }
  return out;
}

fn test_build_cache_contains_all(hay0: Vec[String], need0: Vec[String]) -> bool {
  let hay: Vec[String] = sort_strings(hay0);
  let need: Vec[String] = sort_strings(need0);
  let mut i: i32 = 0; // need idx
  let mut j: i32 = 0; // hay idx
  while i < need.len() {
    let want: String = need.get(i);
    while j < hay.len() && hay.get(j) < want {
      j = j + 1;
    }
    if j >= hay.len() || hay.get(j) != want { return false; }
    i = i + 1;
    j = j + 1;
  }
  return true;
}

fn test_build_cache_load_tests(out: String, key: String, cpath: String, bin: String) -> Vec[String] {
  let meta: String = test_build_cache_meta_path(out);
  if !fs.exists(meta) { return Vec(); }
  if !fs.exists(cpath) { return Vec(); }
  let has_bin: bool = fs.exists(bin) || fs.exists(bin.concat(".exe"));
  if !has_bin { return Vec(); }
  let cur: String = txt.trim_space(fs.read_to_string(meta));
  if cur != key { return Vec(); }
  let tests_path: String = test_build_cache_tests_path(out);
  if !fs.exists(tests_path) { return Vec(); }
  return parse_test_build_cache_tests(fs.read_to_string(tests_path));
}

fn test_build_cache_hit(out: String, key: String, cpath: String, bin: String, selected0: Vec[String]) -> bool {
  let compiled: Vec[String] = test_build_cache_load_tests(out, key, cpath, bin);
  if compiled.len() == 0 { return false; }
  return test_build_cache_contains_all(compiled, selected0);
}

fn merge_unique_strings(xs0: Vec[String], ys0: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    let s: String = xs0.get(i);
    let mut found: bool = false;
    let mut k: i32 = 0;
    while k < out.len() {
      if out.get(k) == s {
        found = true;
        k = out.len();
      } else {
        k = k + 1;
      }
    }
    if s != "" && !found { out.push(s); }
    i = i + 1;
  }
  let mut j: i32 = 0;
  while j < ys0.len() {
    let s: String = ys0.get(j);
    let mut found: bool = false;
    let mut k: i32 = 0;
    while k < out.len() {
      if out.get(k) == s {
        found = true;
        k = out.len();
      } else {
        k = k + 1;
      }
    }
    if s != "" && !found { out.push(s); }
    j = j + 1;
  }
  return sort_strings(out);
}

fn write_test_build_cache(out: String, key: String, tests: Vec[String]) -> () {
  let meta: String = test_build_cache_meta_path(out);
  fs.mkdir_p(dir_name(meta));
  fs.write_string(meta, key.concat("\n"));
  fs.write_string(test_build_cache_tests_path(out), format_test_build_cache_tests(tests));
}

fn build_cache_link_out_for_key(key: String) -> String {
  return path_join(path_join(path_join("target", "cache"), "link-v1"), key);
}

fn build_cache_obj_out_for_key(key: String) -> String {
  return path_join(path_join(path_join("target", "cache"), "pkg-obj-v1"), key);
}

fn build_cache_meta_path_for_key(key: String) -> String {
  return build_cache_link_out_for_key(key).concat(".build.cache.key");
}

fn build_cache_obj_meta_path_for_key(key: String) -> String {
  return build_cache_obj_out_for_key(key).concat(".build.cache.key");
}

fn build_cache_cpath_for_key(key: String) -> String {
  return build_cache_obj_out_for_key(key).concat(".c");
}

fn build_cache_obj_path_for_key(key: String, ext: String) -> String {
  return build_cache_obj_out_for_key(key).concat(ext);
}

fn build_cache_bin_for_key(key: String, target_os: String) -> String {
  let out: String = build_cache_link_out_for_key(key);
  if target_os == "wasm" { return out.concat(".wasm"); }
  return out.concat(".bin");
}

struct BuildCachePkgKey {
  pkg: String,
  key: String,
}

struct BuildCachePkgDigest {
  pkg: String,
  h: u64,
}

struct BuildCacheKeyPair {
  compile_key: String,
  link_key: String,
}

fn build_cache_pkg_from_source_path(path: String) -> String {
  let mp: String = ld.mod_path_from_file_path(path);
  if !txt.has_prefix(mp, "pkg/") { return "main"; }
  let mut i: i32 = 4; // after "pkg/"
  while i < mp.len() {
    if mp.byte_at(i) == 47 { // '/'
      return mp.slice(0, i);
    }
    i = i + 1;
  }
  return mp;
}

fn build_cache_add_pkg_sorted(pkgs0: Vec[String], pkg: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut inserted: bool = false;
  let mut i: i32 = 0;
  while i < pkgs0.len() {
    let cur: String = pkgs0.get(i);
    if cur == pkg { return pkgs0; }
    if !inserted && pkg < cur {
      out.push(pkg);
      inserted = true;
    }
    out.push(cur);
    i = i + 1;
  }
  if !inserted { out.push(pkg); }
  return out;
}

fn build_cache_pkg_digest_init(pkg: String) -> BuildCachePkgDigest {
  let mut h: u64 = 1469598103934665603 as u64;
  h = lock_hash_text(h, "build-cache-pkg-src-v1\n");
  h = lock_hash_text(h, pkg);
  h = lock_hash_text(h, "\n");
  return BuildCachePkgDigest { pkg: pkg, h: h };
}

fn merge_build_cache_pkg_digests(left: Vec[BuildCachePkgDigest], right: Vec[BuildCachePkgDigest]) -> Vec[BuildCachePkgDigest] {
  let mut out: Vec[BuildCachePkgDigest] = Vec();
  let mut li: i32 = 0;
  let mut ri: i32 = 0;
  while li < left.len() && ri < right.len() {
    let l: BuildCachePkgDigest = left.get(li);
    let r: BuildCachePkgDigest = right.get(ri);
    if l.pkg <= r.pkg {
      out.push(l);
      li = li + 1;
    } else {
      out.push(r);
      ri = ri + 1;
    }
  }
  while li < left.len() {
    out.push(left.get(li));
    li = li + 1;
  }
  while ri < right.len() {
    out.push(right.get(ri));
    ri = ri + 1;
  }
  return out;
}

fn sort_build_cache_pkg_digests(ds0: Vec[BuildCachePkgDigest]) -> Vec[BuildCachePkgDigest] {
  if ds0.len() <= 1 { return ds0; }
  let mid: i32 = ds0.len() / 2;
  let mut left: Vec[BuildCachePkgDigest] = Vec();
  let mut right: Vec[BuildCachePkgDigest] = Vec();
  let mut i: i32 = 0;
  while i < ds0.len() {
    if i < mid {
      left.push(ds0.get(i));
    } else {
      right.push(ds0.get(i));
    }
    i = i + 1;
  }
  return merge_build_cache_pkg_digests(sort_build_cache_pkg_digests(left), sort_build_cache_pkg_digests(right));
}

fn build_cache_pkg_source_keys(files0: Vec[ld.SourceFile]) -> Vec[BuildCachePkgKey] {
  let files: Vec[ld.SourceFile] = sort_source_files(files0);
  let mut ds_unsorted: Vec[BuildCachePkgDigest] = Vec();
  let mut i: i32 = 0;
  while i < files.len() {
    let f: ld.SourceFile = files.get(i);
    let pkg: String = build_cache_pkg_from_source_path(f.path);
    let mut di: i32 = -1;
    let mut dj: i32 = 0;
    while dj < ds_unsorted.len() {
      if ds_unsorted.get(dj).pkg == pkg {
        di = dj;
        dj = ds_unsorted.len();
      } else {
        dj = dj + 1;
      }
    }
    if di < 0 {
      ds_unsorted.push(build_cache_pkg_digest_init(pkg.slice(0, pkg.len())));
      di = ds_unsorted.len() - 1;
    }
    let mut d: BuildCachePkgDigest = ds_unsorted.get(di);
    d.h = lock_hash_text(d.h, "F\n");
    d.h = lock_hash_text(d.h, f.path);
    d.h = lock_hash_text(d.h, "\n");
    d.h = lock_hash_text(d.h, f.text);
    d.h = lock_hash_text(d.h, "\n");
    ds_unsorted.set(di, d);
    i = i + 1;
  }

  let ds: Vec[BuildCachePkgDigest] = sort_build_cache_pkg_digests(ds_unsorted);

  let mut out: Vec[BuildCachePkgKey] = Vec();
  let mut di: i32 = 0;
  while di < ds.len() {
    let d: BuildCachePkgDigest = ds.get(di);
    out.push(BuildCachePkgKey { pkg: d.pkg, key: d.h.to_string() });
    di = di + 1;
  }
  return out;
}

fn build_cache_hash_for_mode_prefix(mode: String) -> u64 {
  let mut h: u64 = 1469598103934665603 as u64;
  h = lock_hash_text(h, "build-cache-v3\n");
  h = lock_hash_text(h, if host_is_windows() { "windows\n" } else { "posix\n" });
  h = lock_hash_text(h, mode);
  h = lock_hash_text(h, "\n");
  return h;
}

fn build_cache_pkg_key_from_source_mode(sk: BuildCachePkgKey, mode: String) -> BuildCachePkgKey {
  let mut h: u64 = 1469598103934665603 as u64;
  h = lock_hash_text(h, "build-cache-pkg-v2\n");
  h = lock_hash_text(h, if host_is_windows() { "windows\n" } else { "posix\n" });
  h = lock_hash_text(h, mode);
  h = lock_hash_text(h, "\n");
  h = lock_hash_text(h, sk.pkg);
  h = lock_hash_text(h, "\n");
  h = lock_hash_text(h, sk.key);
  h = lock_hash_text(h, "\n");
  return BuildCachePkgKey { pkg: sk.pkg, key: h.to_string() };
}

fn build_cache_pkg_keys_from_source(pkg_source_keys0: Vec[BuildCachePkgKey], mode: String) -> Vec[BuildCachePkgKey] {
  let mut out: Vec[BuildCachePkgKey] = Vec();
  let mut i: i32 = 0;
  while i < pkg_source_keys0.len() {
    out.push(build_cache_pkg_key_from_source_mode(pkg_source_keys0.get(i), mode));
    i = i + 1;
  }
  return out;
}

fn build_cache_pkg_keys(files0: Vec[ld.SourceFile], mode: String) -> Vec[BuildCachePkgKey] {
  return build_cache_pkg_keys_from_source(build_cache_pkg_source_keys(files0), mode);
}

fn build_cache_key_from_pkg_source_keys(pkg_source_keys0: Vec[BuildCachePkgKey], mode: String) -> String {
  let mut h: u64 = build_cache_hash_for_mode_prefix(mode);
  let pkg_keys: Vec[BuildCachePkgKey] = build_cache_pkg_keys_from_source(pkg_source_keys0, mode);
  let mut i: i32 = 0;
  while i < pkg_keys.len() {
    let pk: BuildCachePkgKey = pkg_keys.get(i);
    h = lock_hash_text(h, "P\n");
    h = lock_hash_text(h, pk.pkg);
    h = lock_hash_text(h, "\n");
    h = lock_hash_text(h, pk.key);
    h = lock_hash_text(h, "\n");
    i = i + 1;
  }
  return h.to_string();
}

fn build_cache_key_pair_from_pkg_source_keys(pkg_source_keys0: Vec[BuildCachePkgKey], compile_mode: String, link_mode: String) -> BuildCacheKeyPair {
  let mut compile_h: u64 = build_cache_hash_for_mode_prefix(compile_mode);
  let mut link_h: u64 = build_cache_hash_for_mode_prefix(link_mode);

  let mut i: i32 = 0;
  while i < pkg_source_keys0.len() {
    let cpk: BuildCachePkgKey = build_cache_pkg_key_from_source_mode(pkg_source_keys0.get(i), compile_mode);
    compile_h = lock_hash_text(compile_h, "P\n");
    compile_h = lock_hash_text(compile_h, cpk.pkg);
    compile_h = lock_hash_text(compile_h, "\n");
    compile_h = lock_hash_text(compile_h, cpk.key);
    compile_h = lock_hash_text(compile_h, "\n");

    let lpk: BuildCachePkgKey = build_cache_pkg_key_from_source_mode(pkg_source_keys0.get(i), link_mode);
    link_h = lock_hash_text(link_h, "P\n");
    link_h = lock_hash_text(link_h, lpk.pkg);
    link_h = lock_hash_text(link_h, "\n");
    link_h = lock_hash_text(link_h, lpk.key);
    link_h = lock_hash_text(link_h, "\n");
    i = i + 1;
  }

  return BuildCacheKeyPair { compile_key: compile_h.to_string(), link_key: link_h.to_string() };
}

fn build_cache_key(files0: Vec[ld.SourceFile], mode: String) -> String {
  return build_cache_key_from_pkg_source_keys(build_cache_pkg_source_keys(files0), mode);
}

fn build_link_cache_hit(key: String, bin: String) -> bool {
  let meta: String = build_cache_meta_path_for_key(key);
  if !fs.exists(meta) { return false; }
  let has_bin: bool = fs.exists(bin) || fs.exists(bin.concat(".exe"));
  if !has_bin { return false; }
  let cur: String = txt.trim_space(fs.read_to_string(meta));
  return cur == key;
}

fn build_cache_obj_hit(key: String, cpath: String, obj: String) -> bool {
  let meta: String = build_cache_obj_meta_path_for_key(key);
  if !fs.exists(meta) { return false; }
  if !fs.exists(cpath) { return false; }
  if !fs.exists(obj) { return false; }
  let cur: String = txt.trim_space(fs.read_to_string(meta));
  return cur == key;
}

fn write_build_obj_cache(key: String) -> () {
  let meta: String = build_cache_obj_meta_path_for_key(key);
  fs.mkdir_p(dir_name(meta));
  fs.write_string(meta, key.concat("\n"));
}

fn write_build_cache(key: String) -> () {
  let meta: String = build_cache_meta_path_for_key(key);
  fs.mkdir_p(dir_name(meta));
  fs.write_string(meta, key.concat("\n"));
}

fn discover_tests_cache_key_path() -> String {
  return "target/debug/.vox_test_discover.key";
}

fn discover_tests_cache_list_path() -> String {
  return "target/debug/.vox_test_discover.list";
}

fn discover_tests_cache_key(paths0: Vec[String]) -> String {
  let mut h: u64 = 1469598103934665603 as u64;
  h = lock_hash_text(h, "discover-tests-cache-v1\n");

  let mut test_paths: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths0.len() {
    let p: String = paths0.get(i);
    if is_test_file_for_discovery(p) {
      test_paths.push(p);
    }
    i = i + 1;
  }

  let paths: Vec[String] = sort_strings(test_paths);
  let mut j: i32 = 0;
  while j < paths.len() {
    let pth: String = paths.get(j);
    h = lock_hash_text(h, "P\n");
    h = lock_hash_text(h, pth);
    h = lock_hash_text(h, "\n");
    h = lock_hash_text(h, fs.read_to_string(pth));
    h = lock_hash_text(h, "\n");
    j = j + 1;
  }
  return h.to_string();
}

fn parse_discover_tests_cache_list(text: String) -> Vec[String] {
  let lines: Vec[String] = txt.split_lines(text);
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < lines.len() {
    let s: String = txt.trim_space(lines.get(i));
    if s != "" { out.push(s); }
    i = i + 1;
  }
  return sort_strings(out);
}

fn format_discover_tests_cache_list(tests0: Vec[String]) -> String {
  let tests: Vec[String] = sort_strings(tests0);
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < tests.len() {
    out = out.concat(tests.get(i)).concat("\n");
    i = i + 1;
  }
  return out;
}

fn write_discover_tests_cache(key: String, tests: Vec[String]) -> () {
  fs.mkdir_p("target/debug");
  fs.write_string(discover_tests_cache_key_path(), key.concat("\n"));
  fs.write_string(discover_tests_cache_list_path(), format_discover_tests_cache_list(tests));
}

fn discover_tests_cached(paths: Vec[String]) -> Vec[String] {
  let mut paths_for_key: Vec[String] = Vec();
  let mut pi: i32 = 0;
  while pi < paths.len() {
    paths_for_key.push(paths.get(pi));
    pi = pi + 1;
  }
  let key: String = discover_tests_cache_key(paths_for_key);
  let key_path: String = discover_tests_cache_key_path();
  let list_path: String = discover_tests_cache_list_path();
  if fs.exists(key_path) && fs.exists(list_path) {
    let cached_key: String = txt.trim_space(fs.read_to_string(key_path));
    if cached_key == key {
      return parse_discover_tests_cache_list(fs.read_to_string(list_path));
    }
  }
  let tests: Vec[String] = discover_tests(paths);
  write_discover_tests_cache(key, tests);
  return tests;
}

fn discover_tests_cached_fast(paths: Vec[String]) -> Vec[String] {
  let key_path: String = discover_tests_cache_key_path();
  let list_path: String = discover_tests_cache_list_path();
  if fs.exists(key_path) && fs.exists(list_path) {
    return parse_discover_tests_cache_list(fs.read_to_string(list_path));
  }
  return discover_tests_cached(paths);
}
