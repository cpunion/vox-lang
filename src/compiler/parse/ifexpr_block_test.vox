import "std/testing" as t
import "compiler/parse" as p
import "compiler/ast" as ast

fn test_parse_if_expr_branch_blocks_allow_stmts() -> () {
  let src: String = "fn main() -> i32 {\n  let x: i32 = if true {\n    let y: i32 = 1;\n    y + 1\n  } else {\n    2\n  };\n  return x;\n}\n";

  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  t.assert(init != -1);

  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.If(c, t0, e0) =>
      match ast.expr_pool_get(exprs, c) { ast.ExprNode.Bool(b) => b == true, _ => false } &&
      match ast.expr_pool_get(exprs, t0) {
        ast.ExprNode.Block(b) =>
          b.stmts.len() == 1 &&
          match b.stmts.get(0) { ast.Stmt.Let(_sp, _m, name, _ha, _ann, _id) => name == "y", _ => false } &&
          b.has_tail &&
          match ast.expr_pool_get(exprs, b.tail) {
            ast.ExprNode.Binary(op, l, r1) =>
              match op { ast.BinaryOp.Add => true, _ => false } &&
              match ast.expr_pool_get(exprs, l) { ast.ExprNode.Ident(s) => s == "y", _ => false } &&
              match ast.expr_pool_get(exprs, r1) { ast.ExprNode.Int(v) => v == "1", _ => false },
            _ => false,
          },
        _ => false,
      } &&
      match ast.expr_pool_get(exprs, e0) {
        ast.ExprNode.Block(b2) =>
          b2.stmts.len() == 0 &&
          b2.has_tail &&
          match ast.expr_pool_get(exprs, b2.tail) { ast.ExprNode.Int(v) => v == "2", _ => false },
        _ => false,
      },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_if_expr_else_if_chain_nests_if_node() -> () {
  let src: String = "fn main(x: i32) -> i32 {\n  let y: i32 = if x < 0 {\n    -1\n  } else if x == 0 {\n    0\n  } else {\n    1\n  };\n  return y;\n}\n";

  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  t.assert(init != -1);

  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.If(_c0, _t0, e0) =>
      match ast.expr_pool_get(exprs, e0) {
        ast.ExprNode.If(_c1, _t1, e1) =>
          match ast.expr_pool_get(exprs, e1) {
            ast.ExprNode.Block(b) =>
              b.stmts.len() == 0 &&
              b.has_tail &&
              match ast.expr_pool_get(exprs, b.tail) { ast.ExprNode.Int(v) => v == "1", _ => false },
            _ => false,
          },
        _ => false,
      },
    _ => false,
  };
  t.assert(ok0);
}
