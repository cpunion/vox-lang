import "compiler/ast" as ast

fn has_prefix_vis(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

fn cut1_vis(s: String) -> String {
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 47 { return s.slice(0, i); } // '/'
    i = i + 1;
  }
  return s;
}

fn cut2_vis(s: String) -> String {
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 47 {
      let t: String = s.slice(i + 1, s.len());
      return s.slice(0, i + 1).concat(cut1_vis(t));
    }
    i = i + 1;
  }
  return s;
}

pub fn module_pkg_key(mod_path: String) -> String {
  if mod_path == "" { return "src"; }
  if has_prefix_vis(mod_path, "pkg/") { return cut2_vis(mod_path); }
  if mod_path == "std" || has_prefix_vis(mod_path, "std/") { return "std"; }
  if mod_path == "tests" || has_prefix_vis(mod_path, "tests/") { return "tests"; }
  return "src";
}

fn module_parent(mod_path: String) -> String {
  if mod_path == "" { return ""; }
  let mut i: i32 = mod_path.len() - 1;
  while i >= 0 {
    if mod_path.byte_at(i) == 47 { return mod_path.slice(0, i); } // '/'
    i = i - 1;
  }
  return "";
}

fn module_in_scope(mod_path: String, scope: String) -> bool {
  if scope == "" { return true; }
  if mod_path == scope { return true; }
  if mod_path.len() <= scope.len() { return false; }
  if mod_path.slice(0, scope.len()) != scope { return false; }
  return mod_path.byte_at(scope.len()) == 47; // '/'
}

pub fn vis_allows(vis: i32, owner_mod: String, user_mod: String) -> bool {
  if owner_mod == user_mod { return true; }
  if vis == ast.vis_private() { return false; }
  if vis == ast.vis_pub() { return true; }
  let same_pkg: bool = module_pkg_key(owner_mod) == module_pkg_key(user_mod);
  if !same_pkg { return false; }
  if vis == ast.vis_crate() { return true; }
  if vis == ast.vis_super() { return module_in_scope(user_mod, module_parent(owner_mod)); }
  return false;
}

pub fn vis_is_pub(vis: i32) -> bool { return vis != ast.vis_private(); }
