import "compiler/ir" as ir

fn c_struct_eq_fn_name(struct_qname: String) -> String {
  return "vox_struct_eq_".concat(c_mangle(struct_qname));
}

fn c_enum_eq_fn_name(enum_qname: String) -> String {
  return "vox_enum_eq_".concat(c_mangle(enum_qname));
}

fn nominal_eq_field_expr(pool: ir.TyPool, ty: i32, lhs: String, rhs: String) -> String {
  let t0: ir.Ty = ir.ty_pool_get(pool, ty);
  if t0.kind == ir.TyKind.Range || t0.kind == ir.TyKind.Ref {
    return nominal_eq_field_expr(pool, t0.elem, lhs, rhs);
  }
  if t0.kind == ir.TyKind.String {
    return "(strcmp(".concat(lhs).concat(", ").concat(rhs).concat(") == 0)");
  }
  if t0.kind == ir.TyKind.Vec {
    return "vox_vec_eq(&".concat(lhs).concat(", &").concat(rhs).concat(")");
  }
  if t0.kind == ir.TyKind.Struct {
    return c_struct_eq_fn_name(ty_qname(t0)).concat("(").concat(lhs).concat(", ").concat(rhs).concat(")");
  }
  if t0.kind == ir.TyKind.Enum {
    return c_enum_eq_fn_name(ty_qname(t0)).concat("(").concat(lhs).concat(", ").concat(rhs).concat(")");
  }
  return "(".concat(lhs).concat(" == ").concat(rhs).concat(")");
}

fn emit_struct_eq_decl(pool: ir.TyPool, st: ir.StructDecl) -> String {
  let qn: String = st.name;
  let cty: String = c_struct_type_name(qn);
  let fnn: String = c_struct_eq_fn_name(qn);
  return "static bool ".concat(fnn).concat("(").concat(cty).concat(" a, ").concat(cty).concat(" b);");
}

fn emit_enum_eq_decl(pool: ir.TyPool, en: ir.EnumDecl) -> String {
  let qn: String = en.name;
  let cty: String = c_enum_type_name(qn);
  let fnn: String = c_enum_eq_fn_name(qn);
  return "static bool ".concat(fnn).concat("(").concat(cty).concat(" a, ").concat(cty).concat(" b);");
}

fn emit_struct_eq_def(pool: ir.TyPool, st: ir.StructDecl) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let qn: String = st.name;
  let cty: String = c_struct_type_name(qn);
  let fnn: String = c_struct_eq_fn_name(qn);
  out.push("static bool ".concat(fnn).concat("(").concat(cty).concat(" a, ").concat(cty).concat(" b) {"));
  if st.fields.len() == 0 {
    out.push("  return true;");
    out.push("}");
    return out;
  }
  let mut expr: String = "";
  let mut fi: i32 = 0;
  while fi < st.fields.len() {
    let f: ir.StructField = st.fields.get(fi);
    let lhs: String = "a.".concat(c_ident(f.name));
    let rhs: String = "b.".concat(c_ident(f.name));
    let e: String = nominal_eq_field_expr(pool, f.ty, lhs, rhs);
    if fi == 0 { expr = e; } else { expr = expr.concat(" && ").concat(e); }
    fi = fi + 1;
  }
  out.push("  return ".concat(expr).concat(";"));
  out.push("}");
  return out;
}

fn emit_enum_eq_def(pool: ir.TyPool, en: ir.EnumDecl) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let qn: String = en.name;
  let cty: String = c_enum_type_name(qn);
  let fnn: String = c_enum_eq_fn_name(qn);
  out.push("static bool ".concat(fnn).concat("(").concat(cty).concat(" a, ").concat(cty).concat(" b) {"));
  out.push("  if (a.tag != b.tag) return false;");
  out.push("  switch (a.tag) {");
  let mut vi: i32 = 0;
  while vi < en.variants.len() {
    let v: ir.EnumVariant = en.variants.get(vi);
    out.push("    case ".concat(vi.to_string()).concat(": {"));
    if v.fields.len() == 0 {
      out.push("      return true;");
    } else {
      let mut expr: String = "";
      let mut fi: i32 = 0;
      while fi < v.fields.len() {
        let lhs: String = "a.payload.".concat(c_ident(v.name)).concat("._").concat(fi.to_string());
        let rhs: String = "b.payload.".concat(c_ident(v.name)).concat("._").concat(fi.to_string());
        let e: String = nominal_eq_field_expr(pool, v.fields.get(fi), lhs, rhs);
        if fi == 0 { expr = e; } else { expr = expr.concat(" && ").concat(e); }
        fi = fi + 1;
      }
      out.push("      return ".concat(expr).concat(";"));
    }
    out.push("    }");
    vi = vi + 1;
  }
  out.push("    default: return false;");
  out.push("  }");
  out.push("}");
  return out;
}

fn append_eq_lines(out0: Vec[String], lines: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = out0;
  let mut i: i32 = 0;
  while i < lines.len() {
    out.push(lines.get(i));
    i = i + 1;
  }
  return out;
}

pub fn emit_nominal_eq_lines(pool: ir.TyPool, p: ir.Program) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut has_nominal: bool = false;
  let mut si0: i32 = 0;
  while si0 < p.structs.len() {
    if !struct_has_param_field(pool, p.structs.get(si0)) { has_nominal = true; }
    si0 = si0 + 1;
  }
  let mut ei0: i32 = 0;
  while ei0 < p.enums.len() {
    if !enum_has_param_field(pool, p.enums.get(ei0)) { has_nominal = true; }
    ei0 = ei0 + 1;
  }
  if !has_nominal { return out; }

  // Forward declarations allow cross nominal calls across helpers.
  let mut si: i32 = 0;
  while si < p.structs.len() {
    let st: ir.StructDecl = p.structs.get(si);
    if !struct_has_param_field(pool, st) {
      out.push(emit_struct_eq_decl(pool, st));
    }
    si = si + 1;
  }
  let mut i: i32 = 0;
  while i < p.enums.len() {
    let en: ir.EnumDecl = p.enums.get(i);
    if !enum_has_param_field(pool, en) {
      out.push(emit_enum_eq_decl(pool, en));
    }
    i = i + 1;
  }
  out.push("");

  si = 0;
  while si < p.structs.len() {
    let st: ir.StructDecl = p.structs.get(si);
    if !struct_has_param_field(pool, st) {
      out = append_eq_lines(out, emit_struct_eq_def(pool, st));
      out.push("");
    }
    si = si + 1;
  }

  i = 0;
  while i < p.enums.len() {
    let en: ir.EnumDecl = p.enums.get(i);
    if !enum_has_param_field(pool, en) {
      out = append_eq_lines(out, emit_enum_eq_def(pool, en));
      out.push("");
    }
    i = i + 1;
  }
  return out;
}
