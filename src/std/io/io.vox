// std/io: minimal IO helpers for stage1 toolchain.
// Keep API tiny and deterministic-friendly; richer abstractions come later.
import "std/runtime" as rt

pub fn out(msg: String) -> () { print(msg); }

fn rt_api() -> rt.Runtime {
  return rt.runtime();
}

pub fn out_ln(msg: String) -> () {
  print(msg);
  print("\n");
}

pub fn fail(msg: String) -> () { panic(msg); }

pub struct File {
  path: String,
}

pub fn file(path: String) -> File {
  return File { path: path };
}

pub fn file_exists(path: String) -> bool {
  return rt_api().path_exists(path);
}

pub fn file_read_all(f: File) -> String {
  return rt_api().read_file(f.path);
}

pub fn file_write_all(f: File, text: String) -> () {
  rt_api().write_file(f.path, text);
  return;
}

pub fn mkdir_p(path: String) -> () {
  rt_api().mkdir_p(path);
  return;
}

pub struct NetAddr {
  host: String,
  port: i32,
}

pub fn net_addr(host: String, port: i32) -> NetAddr {
  return NetAddr { host: host, port: port };
}

pub struct NetConn {
  handle: isize,
}

pub fn net_connect(addr: NetAddr) -> NetConn {
  return NetConn { handle: rt_api().tcp_connect(addr.host, addr.port) };
}

pub fn net_send(c: NetConn, text: String) -> i32 {
  return rt_api().tcp_send(c.handle, text);
}

pub fn net_recv(c: NetConn, max_n: i32) -> String {
  return rt_api().tcp_recv(c.handle, max_n);
}

pub fn net_wait_read(c: NetConn, timeout_ms: i32) -> bool {
  return rt_api().tcp_wait_read(c.handle, timeout_ms);
}

pub fn net_wait_write(c: NetConn, timeout_ms: i32) -> bool {
  return rt_api().tcp_wait_write(c.handle, timeout_ms);
}

pub fn net_close(c: NetConn) -> () {
  rt_api().tcp_close(c.handle);
  return;
}
