// std/io: minimal IO helpers for stage1 toolchain.
// Keep API tiny and deterministic-friendly; richer abstractions come later.
import "std/runtime" as rt

pub fn out(msg: String) -> () { print(msg); }

fn rt_api() -> rt.Runtime {
  return rt.runtime();
}

pub fn out_ln(msg: String) -> () {
  print(msg);
  print("\n");
}

pub fn fail(msg: String) -> () { panic(msg); }

pub struct File {
  path: String,
}

pub fn file(path: String) -> File {
  return File { path: path };
}

impl File {
  fn exists(f: &File) -> bool {
    return rt_api().path_exists(f.path);
  }

  fn read_all(f: &File) -> String {
    return rt_api().read_file(f.path);
  }

  fn write_all(f: &File, text: String) -> () {
    rt_api().write_file(f.path, text);
    return;
  }

  fn mkdir_p(f: &File) -> () {
    rt_api().mkdir_p(f.path);
    return;
  }
}

pub fn file_exists(path: String) -> bool {
  let f: File = file(path);
  return f.exists();
}

pub fn file_read_all(f: File) -> String {
  return f.read_all();
}

pub fn file_write_all(f: File, text: String) -> () {
  f.write_all(text);
  return;
}

pub fn mkdir_p(path: String) -> () {
  let f: File = file(path);
  f.mkdir_p();
  return;
}

pub struct NetAddr {
  host: String,
  port: i32,
}

pub fn net_addr(host: String, port: i32) -> NetAddr {
  return NetAddr { host: host, port: port };
}

impl NetAddr {
  fn connect(addr: NetAddr) -> NetConn {
    return NetConn { handle: rt_api().tcp_connect(addr.host, addr.port) };
  }
}

pub struct NetConn {
  handle: isize,
}

impl NetConn {
  fn send(c: &NetConn, text: String) -> i32 {
    return rt_api().tcp_send(c.handle, text);
  }

  fn recv(c: &NetConn, max_n: i32) -> String {
    return rt_api().tcp_recv(c.handle, max_n);
  }

  fn wait_read(c: &NetConn, timeout_ms: i32) -> bool {
    return rt_api().tcp_wait_read(c.handle, timeout_ms);
  }

  fn wait_write(c: &NetConn, timeout_ms: i32) -> bool {
    return rt_api().tcp_wait_write(c.handle, timeout_ms);
  }

  fn close(c: NetConn) -> () {
    rt_api().tcp_close(c.handle);
    return;
  }
}

pub fn net_connect(addr: NetAddr) -> NetConn {
  return addr.connect();
}

pub fn net_send(c: NetConn, text: String) -> i32 {
  return c.send(text);
}

pub fn net_recv(c: NetConn, max_n: i32) -> String {
  return c.recv(max_n);
}

pub fn net_wait_read(c: NetConn, timeout_ms: i32) -> bool {
  return c.wait_read(timeout_ms);
}

pub fn net_wait_write(c: NetConn, timeout_ms: i32) -> bool {
  return c.wait_write(timeout_ms);
}

pub fn net_close(c: NetConn) -> () {
  c.close();
  return;
}
