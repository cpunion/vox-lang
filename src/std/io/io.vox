// std/io: minimal IO helpers for stage1 toolchain.
// Keep API tiny and deterministic-friendly; richer abstractions come later.
import "std/fs" as fs
import "std/sys" as sys

fn out_raw(msg: String) -> () {
  let total: i32 = msg.len();
  let mut off: i32 = 0;
  while off < total {
    let chunk: String = msg.slice(off, total);
    let wrote: isize = sys.write(1, chunk as const rawptr, chunk.len() as usize);
    if wrote <= 0 { panic("stdout write failed"); }
    let step: i32 = wrote as i32;
    off = off + step;
  }
  return;
}

pub fn out(msg: String) -> () { out_raw(msg); }

pub fn out_ln(msg: String) -> () {
  out_raw(msg);
  out_raw("\n");
}

pub fn fail(msg: String) -> () { panic(msg); }

pub struct File {
  path: String,
}

pub fn file(path: String) -> File {
  return File { path: path };
}

impl File {
  fn exists(f: &File) -> bool {
    return fs.exists(f.path);
  }

  fn read_all(f: &File) -> String {
    return fs.read_to_string(f.path);
  }

  fn write_all(f: &File, text: String) -> () {
    fs.write_string(f.path, text);
    return;
  }

  fn mkdir_p(f: &File) -> () {
    fs.mkdir_p(f.path);
    return;
  }
}

pub fn file_exists(path: String) -> bool {
  let f: File = file(path);
  return f.exists();
}

pub fn mkdir_p(path: String) -> () {
  let f: File = file(path);
  f.mkdir_p();
  return;
}

pub trait Reader {
  fn read(x: &Self, max_n: i32) -> String;
}

pub trait Writer {
  fn write(x: &Self, text: String) -> i32;
}

pub trait Closer {
  fn close(x: Self) -> Self;
}

pub trait ReadWriter {
  fn read(x: &Self, max_n: i32) -> String;
  fn write(x: &Self, text: String) -> i32;
}

pub struct BufReader {
  cap: i32,
  used: i32,
}

pub struct BufWriter {
  cap: i32,
  used: i32,
}

pub fn buf_reader(cap: i32) -> BufReader {
  let mut n: i32 = cap;
  if n <= 0 { n = 1; }
  return BufReader { cap: n, used: 0 };
}

pub fn buf_writer(cap: i32) -> BufWriter {
  let mut n: i32 = cap;
  if n <= 0 { n = 1; }
  return BufWriter { cap: n, used: 0 };
}

impl BufReader {
  fn capacity(b: &BufReader) -> i32 { return b.cap; }
  fn buffered(b: &BufReader) -> i32 { return b.used; }
}

impl BufWriter {
  fn capacity(b: &BufWriter) -> i32 { return b.cap; }
  fn buffered(b: &BufWriter) -> i32 { return b.used; }
}
