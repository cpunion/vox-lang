fn panic_range() -> () { panic("StrView range out of bounds"); }

fn panic_index() -> () { panic("StrView index out of bounds"); }

fn check_range(n: i32, lo: i32, hi: i32) -> () {
  if lo < 0 || hi < lo || hi > n { panic_range(); }
}

pub struct StrView {
  owner: String,
  lo: i32,
  hi: i32,
}

pub fn view_all(owner: String) -> StrView {
  let n: i32 = owner.len();
  return StrView { owner: owner, lo: 0, hi: n };
}

pub fn view_range(owner: String, lo: i32, hi: i32) -> StrView {
  let n: i32 = owner.len();
  check_range(n, lo, hi);
  return StrView { owner: owner, lo: lo, hi: hi };
}

pub fn len(v: StrView) -> i32 { return v.hi - v.lo; }

pub fn is_empty(v: StrView) -> bool { return len(v) == 0; }

pub fn byte_at(v: StrView, idx: i32) -> i32 {
  let n: i32 = len(v);
  if idx < 0 || idx >= n { panic_index(); }
  return v.owner.byte_at(v.lo + idx);
}

pub fn sub(v: StrView, lo: i32, hi: i32) -> StrView {
  let n: i32 = len(v);
  check_range(n, lo, hi);
  return StrView { owner: v.owner, lo: v.lo + lo, hi: v.lo + hi };
}

// View-first helpers: keep substring operations in StrView form and avoid
// forcing owned String materialization for prefix/suffix slicing.
pub fn take_prefix(v: StrView, n: i32) -> StrView {
  let vn: i32 = len(v);
  check_range(vn, 0, n);
  return sub(v, 0, n);
}

pub fn take_suffix(v: StrView, n: i32) -> StrView {
  let vn: i32 = len(v);
  check_range(vn, 0, n);
  return sub(v, vn - n, vn);
}

pub fn drop_prefix(v: StrView, n: i32) -> StrView {
  let vn: i32 = len(v);
  check_range(vn, 0, n);
  return sub(v, n, vn);
}

pub fn drop_suffix(v: StrView, n: i32) -> StrView {
  let vn: i32 = len(v);
  check_range(vn, 0, n);
  return sub(v, 0, vn - n);
}

pub fn to_string(v: StrView) -> String { return v.owner.slice(v.lo, v.hi); }

pub fn release(s: String) -> String { return Release.release(s); }

pub fn starts_with(v: StrView, pre: String) -> bool {
  let pn: i32 = pre.len();
  if pn > len(v) { return false; }
  let mut i: i32 = 0;
  while i < pn {
    if byte_at(v, i) != pre.byte_at(i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn ends_with(v: StrView, suf: String) -> bool {
  let sn: i32 = suf.len();
  let n: i32 = len(v);
  if sn > n { return false; }
  let mut i: i32 = 0;
  while i < sn {
    if byte_at(v, n - sn + i) != suf.byte_at(i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn index_of(v: StrView, needle: String) -> i32 {
  let nn: i32 = needle.len();
  let vn: i32 = len(v);
  if nn == 0 { return 0; }
  if nn > vn { return -1; }
  let mut i: i32 = 0;
  while i <= vn - nn {
    let mut ok: bool = true;
    let mut j: i32 = 0;
    while j < nn {
      if byte_at(v, i + j) != needle.byte_at(j) {
        ok = false;
        j = nn;
      } else {
        j = j + 1;
      }
    }
    if ok { return i; }
    i = i + 1;
  }
  return -1;
}

pub fn last_index_of(v: StrView, needle: String) -> i32 {
  let nn: i32 = needle.len();
  let vn: i32 = len(v);
  if nn == 0 { return vn; }
  if nn > vn { return -1; }
  let mut i: i32 = vn - nn;
  while i >= 0 {
    let mut ok: bool = true;
    let mut j: i32 = 0;
    while j < nn {
      if byte_at(v, i + j) != needle.byte_at(j) {
        ok = false;
        j = nn;
      } else {
        j = j + 1;
      }
    }
    if ok { return i; }
    i = i - 1;
  }
  return -1;
}

pub fn contains(v: StrView, needle: String) -> bool { return index_of(v, needle) >= 0; }

pub fn starts_with_view(v: StrView, pre: StrView) -> bool {
  let pn: i32 = len(pre);
  let vn: i32 = len(v);
  if pn > vn { return false; }
  let mut i: i32 = 0;
  while i < pn {
    if byte_at(v, i) != byte_at(pre, i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn ends_with_view(v: StrView, suf: StrView) -> bool {
  let sn: i32 = len(suf);
  let vn: i32 = len(v);
  if sn > vn { return false; }
  let mut i: i32 = 0;
  while i < sn {
    if byte_at(v, vn - sn + i) != byte_at(suf, i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn index_of_view(v: StrView, needle: StrView) -> i32 {
  let nn: i32 = len(needle);
  let vn: i32 = len(v);
  if nn == 0 { return 0; }
  if nn > vn { return -1; }
  let mut i: i32 = 0;
  while i <= vn - nn {
    let mut ok: bool = true;
    let mut j: i32 = 0;
    while j < nn {
      if byte_at(v, i + j) != byte_at(needle, j) {
        ok = false;
        j = nn;
      } else {
        j = j + 1;
      }
    }
    if ok { return i; }
    i = i + 1;
  }
  return -1;
}

pub fn last_index_of_view(v: StrView, needle: StrView) -> i32 {
  let nn: i32 = len(needle);
  let vn: i32 = len(v);
  if nn == 0 { return vn; }
  if nn > vn { return -1; }
  let mut i: i32 = vn - nn;
  while i >= 0 {
    let mut ok: bool = true;
    let mut j: i32 = 0;
    while j < nn {
      if byte_at(v, i + j) != byte_at(needle, j) {
        ok = false;
        j = nn;
      } else {
        j = j + 1;
      }
    }
    if ok { return i; }
    i = i - 1;
  }
  return -1;
}

pub fn contains_view(v: StrView, needle: StrView) -> bool {
  return index_of_view(v, needle) >= 0;
}

pub fn equals(v: StrView, s: String) -> bool {
  let vn: i32 = len(v);
  if vn != s.len() { return false; }
  let mut i: i32 = 0;
  while i < vn {
    if byte_at(v, i) != s.byte_at(i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn compare(v: StrView, s: String) -> i32 {
  let vn: i32 = len(v);
  let sn: i32 = s.len();
  let mut n: i32 = vn;
  if sn < n { n = sn; }
  let mut i: i32 = 0;
  while i < n {
    let a: i32 = byte_at(v, i);
    let b: i32 = s.byte_at(i);
    if a < b { return -1; }
    if a > b { return 1; }
    i = i + 1;
  }
  if vn < sn { return -1; }
  if vn > sn { return 1; }
  return 0;
}

pub fn equals_view(a: StrView, b: StrView) -> bool {
  let an: i32 = len(a);
  if an != len(b) { return false; }
  let mut i: i32 = 0;
  while i < an {
    if byte_at(a, i) != byte_at(b, i) { return false; }
    i = i + 1;
  }
  return true;
}

pub fn compare_view(a: StrView, b: StrView) -> i32 {
  let an: i32 = len(a);
  let bn: i32 = len(b);
  let mut n: i32 = an;
  if bn < n { n = bn; }
  let mut i: i32 = 0;
  while i < n {
    let av: i32 = byte_at(a, i);
    let bv: i32 = byte_at(b, i);
    if av < bv { return -1; }
    if av > bv { return 1; }
    i = i + 1;
  }
  if an < bn { return -1; }
  if an > bn { return 1; }
  return 0;
}

impl StrView {
  fn len(v: StrView) -> i32 { return v.hi - v.lo; }

  fn is_empty(v: StrView) -> bool { return v.hi == v.lo; }

  fn byte_at(v: StrView, idx: i32) -> i32 {
    let n: i32 = v.hi - v.lo;
    if idx < 0 || idx >= n { panic_index(); }
    return v.owner.byte_at(v.lo + idx);
  }

  fn sub(v: StrView, lo: i32, hi: i32) -> StrView {
    let n: i32 = v.hi - v.lo;
    check_range(n, lo, hi);
    return StrView { owner: v.owner, lo: v.lo + lo, hi: v.lo + hi };
  }

  fn take_prefix(v: StrView, n: i32) -> StrView {
    let vn: i32 = v.hi - v.lo;
    check_range(vn, 0, n);
    return StrView { owner: v.owner, lo: v.lo, hi: v.lo + n };
  }

  fn take_suffix(v: StrView, n: i32) -> StrView {
    let vn: i32 = v.hi - v.lo;
    check_range(vn, 0, n);
    return StrView { owner: v.owner, lo: v.hi - n, hi: v.hi };
  }

  fn drop_prefix(v: StrView, n: i32) -> StrView {
    let vn: i32 = v.hi - v.lo;
    check_range(vn, 0, n);
    return StrView { owner: v.owner, lo: v.lo + n, hi: v.hi };
  }

  fn drop_suffix(v: StrView, n: i32) -> StrView {
    let vn: i32 = v.hi - v.lo;
    check_range(vn, 0, n);
    return StrView { owner: v.owner, lo: v.lo, hi: v.hi - n };
  }

  fn to_string(v: StrView) -> String { return v.owner.slice(v.lo, v.hi); }

  fn starts_with(v: StrView, pre: String) -> bool {
    let pn: i32 = pre.len();
    let vn: i32 = v.hi - v.lo;
    if pn > vn { return false; }
    let mut i: i32 = 0;
    while i < pn {
      if v.owner.byte_at(v.lo + i) != pre.byte_at(i) { return false; }
      i = i + 1;
    }
    return true;
  }

  fn ends_with(v: StrView, suf: String) -> bool {
    let sn: i32 = suf.len();
    let vn: i32 = v.hi - v.lo;
    if sn > vn { return false; }
    let mut i: i32 = 0;
    while i < sn {
      if v.owner.byte_at(v.lo + (vn - sn) + i) != suf.byte_at(i) { return false; }
      i = i + 1;
    }
    return true;
  }

  fn index_of(v: StrView, needle: String) -> i32 {
    let nn: i32 = needle.len();
    let vn: i32 = v.hi - v.lo;
    if nn == 0 { return 0; }
    if nn > vn { return -1; }
    let mut i: i32 = 0;
    while i <= vn - nn {
      let mut ok: bool = true;
      let mut j: i32 = 0;
      while j < nn {
        if v.owner.byte_at(v.lo + i + j) != needle.byte_at(j) {
          ok = false;
          j = nn;
        } else {
          j = j + 1;
        }
      }
      if ok { return i; }
      i = i + 1;
    }
    return -1;
  }

  fn last_index_of(v: StrView, needle: String) -> i32 {
    let nn: i32 = needle.len();
    let vn: i32 = v.hi - v.lo;
    if nn == 0 { return vn; }
    if nn > vn { return -1; }
    let mut i: i32 = vn - nn;
    while i >= 0 {
      let mut ok: bool = true;
      let mut j: i32 = 0;
      while j < nn {
        if v.owner.byte_at(v.lo + i + j) != needle.byte_at(j) {
          ok = false;
          j = nn;
        } else {
          j = j + 1;
        }
      }
      if ok { return i; }
      i = i - 1;
    }
    return -1;
  }

  fn contains(v: StrView, needle: String) -> bool {
    let nn: i32 = needle.len();
    let vn: i32 = v.hi - v.lo;
    if nn == 0 { return true; }
    if nn > vn { return false; }
    let mut i: i32 = 0;
    while i <= vn - nn {
      let mut ok: bool = true;
      let mut j: i32 = 0;
      while j < nn {
        if v.owner.byte_at(v.lo + i + j) != needle.byte_at(j) {
          ok = false;
          j = nn;
        } else {
          j = j + 1;
        }
      }
      if ok { return true; }
      i = i + 1;
    }
    return false;
  }

  fn equals(v: StrView, s: String) -> bool {
    let vn: i32 = v.hi - v.lo;
    if vn != s.len() { return false; }
    let mut i: i32 = 0;
    while i < vn {
      if v.owner.byte_at(v.lo + i) != s.byte_at(i) { return false; }
      i = i + 1;
    }
    return true;
  }

  fn compare(v: StrView, s: String) -> i32 {
    let vn: i32 = v.hi - v.lo;
    let sn: i32 = s.len();
    let mut n: i32 = vn;
    if sn < n { n = sn; }
    let mut i: i32 = 0;
    while i < n {
      let a: i32 = v.owner.byte_at(v.lo + i);
      let b: i32 = s.byte_at(i);
      if a < b { return -1; }
      if a > b { return 1; }
      i = i + 1;
    }
    if vn < sn { return -1; }
    if vn > sn { return 1; }
    return 0;
  }
}
