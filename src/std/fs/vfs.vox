import "std/string" as s

pub trait FS {
  fn read_to_string(x: &Self, path: String) -> String;
  fn exists(x: &Self, path: String) -> bool;
  fn walk_files(x: &Self, root: String) -> Vec[String];
}

pub trait WritableFS {
  fn write_string(x: Self, path: String, text: String) -> Self;
  fn mkdir_p(x: Self, path: String) -> Self;
}

pub struct OsFS {
  marker: i32,
}

pub fn os_fs() -> OsFS {
  return OsFS { marker: 0 };
}

impl OsFS {
  fn read_to_string(_x: &OsFS, p: String) -> String {
    let pp: Path = path(p);
    return pp.read_to_string();
  }

  fn exists(_x: &OsFS, p: String) -> bool {
    let pp: Path = path(p);
    return pp.exists();
  }

  fn walk_files(_x: &OsFS, root: String) -> Vec[String] {
    let pp: Path = path(root);
    return pp.walk_files();
  }

  fn write_string(x: OsFS, p: String, text: String) -> OsFS {
    let pp: Path = path(p);
    pp.write_string(text);
    return x;
  }

  fn mkdir_p(x: OsFS, p: String) -> OsFS {
    let pp: Path = path(p);
    pp.mkdir_p();
    return x;
  }
}

impl FS for OsFS {
  fn read_to_string(x: &OsFS, p: String) -> String { return x.read_to_string(p); }
  fn exists(x: &OsFS, p: String) -> bool { return x.exists(p); }
  fn walk_files(x: &OsFS, root: String) -> Vec[String] { return x.walk_files(root); }
}

impl WritableFS for OsFS {
  fn write_string(x: OsFS, p: String, text: String) -> OsFS {
    return x.write_string(p, text);
  }
  fn mkdir_p(x: OsFS, p: String) -> OsFS {
    return x.mkdir_p(p);
  }
}

pub struct MemEntry {
  path: String,
  text: String,
}

pub struct MemFS {
  files: Vec[MemEntry],
  dirs: Vec[String],
}

pub fn mem_fs() -> MemFS {
  return MemFS { files: Vec(), dirs: Vec() };
}

fn mem_contains_text(xs: Vec[String], needle: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn mem_file_index(xs: Vec[MemEntry], p: String) -> i32 {
  if xs.len() == 0 { return -1; }
  let mut i: i32 = xs.len() - 1;
  while i >= 0 {
    if xs.get(i).path == p { return i; }
    i = i - 1;
  }
  return -1;
}

fn mem_has_prefix(raw: String, pfx: String) -> bool {
  return s.starts_with(s.view_all(raw), pfx);
}

fn mem_has_suffix(raw: String, suf: String) -> bool {
  return s.ends_with(s.view_all(raw), suf);
}

impl MemFS {
  fn read_to_string(x: &MemFS, p: String) -> String {
    let i: i32 = mem_file_index(x.files, p);
    if i < 0 { panic("memfs file not found"); }
    return x.files.get(i).text;
  }

  fn exists(x: &MemFS, p: String) -> bool {
    if mem_file_index(x.files, p) >= 0 { return true; }
    return mem_contains_text(x.dirs, p);
  }

  fn walk_files(x: &MemFS, root: String) -> Vec[String] {
    let mut out: Vec[String] = Vec();
    let mut i: i32 = 0;
    while i < x.files.len() {
      let e: MemEntry = x.files.get(i);
      if mem_has_prefix(e.path, root) && mem_has_suffix(e.path, ".vox") {
        out.push(e.path);
      }
      i = i + 1;
    }
    return out;
  }

  fn write_string(x: MemFS, p: String, text: String) -> MemFS {
    let mut files: Vec[MemEntry] = x.files;
    files.push(MemEntry { path: p, text: text });
    return MemFS { files: files, dirs: x.dirs };
  }

  fn mkdir_p(x: MemFS, p: String) -> MemFS {
    if mem_contains_text(x.dirs, p) { return x; }
    let mut dirs: Vec[String] = x.dirs;
    dirs.push(p);
    return MemFS { files: x.files, dirs: dirs };
  }
}

impl FS for MemFS {
  fn read_to_string(x: &MemFS, p: String) -> String { return x.read_to_string(p); }
  fn exists(x: &MemFS, p: String) -> bool { return x.exists(p); }
  fn walk_files(x: &MemFS, root: String) -> Vec[String] { return x.walk_files(root); }
}

impl WritableFS for MemFS {
  fn write_string(x: MemFS, p: String, text: String) -> MemFS {
    return x.write_string(p, text);
  }
  fn mkdir_p(x: MemFS, p: String) -> MemFS {
    return x.mkdir_p(p);
  }
}

pub fn fs_read_to_string[T: FS](x: T, p: String) -> String {
  return FS.read_to_string(x, p);
}

pub fn fs_exists[T: FS](x: T, p: String) -> bool {
  return FS.exists(x, p);
}

pub fn fs_walk_files[T: FS](x: T, root: String) -> Vec[String] {
  return FS.walk_files(x, root);
}

pub fn fs_write_string[T: WritableFS](x: T, p: String, text: String) -> T {
  return WritableFS.write_string(x, p, text);
}

pub fn fs_mkdir_p[T: WritableFS](x: T, p: String) -> T {
  return WritableFS.mkdir_p(x, p);
}
