import "std/sys" as sys

@ffi_import("c", "vox_fs_opendir")
fn c_opendir(path: String) -> rawptr;

@ffi_import("c", "vox_fs_readdir")
fn c_readdir(dir: rawptr) -> rawptr;

@ffi_import("c", "vox_fs_closedir")
fn c_closedir(dir: rawptr) -> i32;

@ffi_import("c", "vox_fs_dirent_name")
fn c_dirent_name(ent: rawptr) -> String;

@ffi_import("c", "vox_fs_dirent_is_dir")
fn c_dirent_is_dir(full_path: String) -> i32;

// Insertion sort for small string vectors (file lists are typically < 100).
fn fs_sort_strings(v: Vec[String]) -> () {
  let mut arr: Vec[String] = v;
  let n: i32 = arr.len();
  let mut i: i32 = 1;
  while i < n {
    let key: String = arr.get(i);
    let mut j: i32 = i - 1;
    while j >= 0 && arr.get(j) > key {
      arr.set(j + 1, arr.get(j));
      j = j - 1;
    }
    arr.set(j + 1, key);
    i = i + 1;
  }
}

// Recursive directory walk collecting files with a given suffix.
// Returns the updated Vec with discovered relative paths appended.
fn fs_walk_dir_suffix(root: String, rel: String, suffix: String, out: Vec[String]) -> Vec[String] {
  let full: String = if rel == "" { root } else { root.concat("/").concat(rel) };
  let dir: rawptr = c_opendir(full);
  if (dir as isize) == (0 as isize) { return out; }
  let mut result: Vec[String] = out;
  while true {
    let ent: rawptr = c_readdir(dir);
    if (ent as isize) == (0 as isize) { break; }
    let name: String = c_dirent_name(ent);
    if name == "." || name == ".." { continue; }
    let child_rel: String = if rel == "" { name } else { rel.concat("/").concat(name) };
    let child_full: String = root.concat("/").concat(child_rel);
    if c_dirent_is_dir(child_full) == 1 {
      result = fs_walk_dir_suffix(root, child_rel, suffix, result);
    } else if child_rel.ends_with(suffix) {
      result.push(child_rel);
    }
  }
  let _: i32 = c_closedir(dir);
  return result;
}

fn fs_walk_vox_files_impl(root: String) -> Vec[String] {
  let r: String = if root == "" { "." } else { root };
  let mut out: Vec[String] = Vec();
  out = fs_walk_dir_suffix(r, "src", ".vox", out);
  out = fs_walk_dir_suffix(r, "tests", ".vox", out);
  fs_sort_strings(out);
  return out;
}

fn fs_walk_c_files_impl(root: String) -> Vec[String] {
  let r: String = if root == "" { "." } else { root };
  let mut out: Vec[String] = Vec();
  out = fs_walk_dir_suffix(r, "src", ".c", out);
  fs_sort_strings(out);
  return out;
}

pub enum FsError {
  NotFound(String),
  Io(String),
}

pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

fn fs_err_not_found(path: String) -> FsError {
  return FsError.NotFound(path);
}

fn fs_err_io(msg: String) -> FsError {
  return FsError.Io(msg);
}

fn fs_default_file_perm() -> u16 { return 420 as u16; } // 0o644

fn fs_read_to_string_sys(path: String) -> String {
  let fd: i32 = sys.open_read(path);
  if fd < 0 { panic("read_file open failed: ".concat(path)); }
  let size64: i64 = sys.lseek(fd, 0 as i64, sys.seek_end());
  if size64 < 0 {
    let _: i32 = sys.close(fd);
    panic("read_file lseek failed: ".concat(path));
  }
  let _: i64 = sys.lseek(fd, 0 as i64, sys.seek_set());
  let size: i32 = size64 as i32;
  let buf: rawptr = sys.alloc_buf(size);
  // Single read: rawptr has no pointer arithmetic, so we cannot advance
  // the buffer on partial reads. For regular files (compiler sources) a
  // single read always returns the full content.
  let got: isize = sys.read(fd, buf, size as usize);
  let _: i32 = sys.close(fd);
  if got < 0 {
    panic("read_file read failed: ".concat(path));
  }
  return sys.buf_to_string(buf, got as i32);
}

fn fs_write_string_sys(path: String, text: String) -> () {
  let fd: i32 = sys.creat(path, fs_default_file_perm());
  if fd < 0 { panic("write_file open failed: ".concat(path)); }

  let total: i32 = text.len();
  let mut off: i32 = 0;
  while off < total {
    let chunk: String = text.slice(off, total);
    let wrote: isize = sys.write(fd, chunk as const rawptr, chunk.len() as usize);
    if wrote <= 0 {
      let _rc0: i32 = sys.close(fd);
      panic("write_file write failed: ".concat(path));
    }
    let step: i32 = wrote as i32;
    off = off + step;
  }

  let rc: i32 = sys.close(fd);
  if rc != 0 { panic("write_file close failed: ".concat(path)); }
}

fn fs_exists_sys(path: String) -> bool { return sys.access(path, 0) == 0; }

fn fs_mkdir_sys(path: String) -> bool { return sys.mkdir(path, 493 as u16) == 0; }

impl Path {
  fn read_to_string(p: &Path) -> String {
    return fs_read_to_string_sys(p.raw);
  }

  fn write_string(p: &Path, text: String) -> () {
    fs_write_string_sys(p.raw, text);
    return;
  }

  fn exists(p: &Path) -> bool {
    return fs_exists_sys(p.raw);
  }

  fn mkdir_p(p: &Path) -> () {
    if p.raw == "" || p.raw == "." { return; }
    if p.exists() { return; }
    let parent: String = dir_name(p.raw);
    if parent != p.raw && parent != "" {
      let pp: Path = path(parent);
      pp.mkdir_p();
    }
    if !p.exists() {
      if fs_mkdir_sys(p.raw) { return; }
      if p.exists() { return; }
    }
    return;
  }

  fn walk_files(p: &Path) -> Vec[String] {
    return fs_walk_vox_files_impl(p.raw);
  }

  fn try_read_to_string(p: &Path) -> Result[String, FsError] {
    if !p.exists() { return .Err(fs_err_not_found(p.raw)); }
    return .Ok(p.read_to_string());
  }

  fn try_write_string(p: &Path, text: String) -> Result[bool, FsError] {
    let d: String = dir_name(p.raw);
    if d != "." && !exists(d) { return .Err(fs_err_not_found(d)); }
    p.write_string(text);
    return .Ok(true);
  }

  fn try_mkdir_p(p: &Path) -> Result[bool, FsError] {
    p.mkdir_p();
    if p.exists() { return .Ok(true); }
    return .Err(fs_err_io("mkdir_p failed: ".concat(p.raw)));
  }

  fn try_walk_files(p: &Path) -> Result[Vec[String], FsError] {
    if !p.exists() { return .Err(fs_err_not_found(p.raw)); }
    return .Ok(p.walk_files());
  }
}

pub fn read_to_string(raw: String) -> String {
  let p: Path = path(raw);
  return p.read_to_string();
}

pub fn write_string(raw: String, text: String) -> () {
  let p: Path = path(raw);
  p.write_string(text);
  return;
}

pub fn exists(raw: String) -> bool {
  let p: Path = path(raw);
  return p.exists();
}

pub fn mkdir_p(raw: String) -> () {
  let p: Path = path(raw);
  p.mkdir_p();
  return;
}

pub fn walk_files(root: String) -> Vec[String] {
  let p: Path = path(root);
  return p.walk_files();
}

pub fn walk_c_files(root: String) -> Vec[String] {
  return fs_walk_c_files_impl(root);
}

pub fn try_read_to_string(raw: String) -> Result[String, FsError] {
  let p: Path = path(raw);
  return p.try_read_to_string();
}

pub fn try_write_string(raw: String, text: String) -> Result[bool, FsError] {
  let p: Path = path(raw);
  return p.try_write_string(text);
}

pub fn try_mkdir_p(raw: String) -> Result[bool, FsError] {
  let p: Path = path(raw);
  return p.try_mkdir_p();
}

pub fn try_walk_files(root: String) -> Result[Vec[String], FsError] {
  let p: Path = path(root);
  return p.try_walk_files();
}

pub async fn read_to_string_async(raw: String) -> Result[String, FsError] {
  return try_read_to_string(raw);
}

pub async fn write_string_async(raw: String, text: String) -> Result[bool, FsError] {
  return try_write_string(raw, text);
}

pub async fn mkdir_p_async(raw: String) -> Result[bool, FsError] {
  return try_mkdir_p(raw);
}

pub async fn walk_files_async(root: String) -> Result[Vec[String], FsError] {
  return try_walk_files(root);
}
