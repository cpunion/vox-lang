import "std/runtime" as rt
import "std/sys" as sys

pub enum FsError {
  NotFound(String),
  Io(String),
}

pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

fn fs_err_not_found(path: String) -> FsError {
  return FsError.NotFound(path);
}

fn fs_err_io(msg: String) -> FsError {
  return FsError.Io(msg);
}

fn fs_seek_set() -> i32 { return 0; }

fn fs_seek_end() -> i32 { return 2; }

fn fs_read_to_string_sys(path: String) -> String { return rt.read_file(path); }

fn fs_write_string_sys(path: String, text: String) -> () { rt.write_file(path, text); }

fn fs_exists_sys(path: String) -> bool { return sys.access(path, 0) == 0; }

fn fs_mkdir_sys(path: String) -> bool { return sys.mkdir(path, 493 as u16) == 0; }

impl Path {
  fn read_to_string(p: &Path) -> String {
    return fs_read_to_string_sys(p.raw);
  }

  fn write_string(p: &Path, text: String) -> () {
    fs_write_string_sys(p.raw, text);
    return;
  }

  fn exists(p: &Path) -> bool {
    return fs_exists_sys(p.raw);
  }

  fn mkdir_p(p: &Path) -> () {
    if p.raw == "" || p.raw == "." { return; }
    if p.exists() { return; }
    let parent: String = dir_name(p.raw);
    if parent != p.raw && parent != "" {
      let pp: Path = path(parent);
      pp.mkdir_p();
    }
    if !p.exists() {
      if fs_mkdir_sys(p.raw) { return; }
      if p.exists() { return; }
    }
    return;
  }

  fn walk_files(p: &Path) -> Vec[String] {
    return rt.walk_files(p.raw);
  }

  fn try_read_to_string(p: &Path) -> Result[String, FsError] {
    if !p.exists() { return .Err(fs_err_not_found(p.raw)); }
    return .Ok(p.read_to_string());
  }

  fn try_write_string(p: &Path, text: String) -> Result[bool, FsError] {
    let d: String = dir_name(p.raw);
    if d != "." && !exists(d) { return .Err(fs_err_not_found(d)); }
    p.write_string(text);
    return .Ok(true);
  }

  fn try_mkdir_p(p: &Path) -> Result[bool, FsError] {
    p.mkdir_p();
    if p.exists() { return .Ok(true); }
    return .Err(fs_err_io("mkdir_p failed: ".concat(p.raw)));
  }

  fn try_walk_files(p: &Path) -> Result[Vec[String], FsError] {
    if !p.exists() { return .Err(fs_err_not_found(p.raw)); }
    return .Ok(p.walk_files());
  }
}

pub fn read_to_string(raw: String) -> String {
  let p: Path = path(raw);
  return p.read_to_string();
}

pub fn write_string(raw: String, text: String) -> () {
  let p: Path = path(raw);
  p.write_string(text);
  return;
}

pub fn exists(raw: String) -> bool {
  let p: Path = path(raw);
  return p.exists();
}

pub fn mkdir_p(raw: String) -> () {
  let p: Path = path(raw);
  p.mkdir_p();
  return;
}

pub fn walk_files(root: String) -> Vec[String] {
  let p: Path = path(root);
  return p.walk_files();
}

pub fn try_read_to_string(raw: String) -> Result[String, FsError] {
  let p: Path = path(raw);
  return p.try_read_to_string();
}

pub fn try_write_string(raw: String, text: String) -> Result[bool, FsError] {
  let p: Path = path(raw);
  return p.try_write_string(text);
}

pub fn try_mkdir_p(raw: String) -> Result[bool, FsError] {
  let p: Path = path(raw);
  return p.try_mkdir_p();
}

pub fn try_walk_files(root: String) -> Result[Vec[String], FsError] {
  let p: Path = path(root);
  return p.try_walk_files();
}

pub async fn read_to_string_async(raw: String) -> Result[String, FsError] {
  return try_read_to_string(raw);
}

pub async fn write_string_async(raw: String, text: String) -> Result[bool, FsError] {
  return try_write_string(raw, text);
}

pub async fn mkdir_p_async(raw: String) -> Result[bool, FsError] {
  return try_mkdir_p(raw);
}

pub async fn walk_files_async(root: String) -> Result[Vec[String], FsError] {
  return try_walk_files(root);
}
