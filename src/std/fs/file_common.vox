import "std/sys" as sys

@ffi_import("c", "vox_impl_walk_vox_files")
fn fs_walk_vox_files_raw(root: String) -> Vec[String];

pub enum FsError {
  NotFound(String),
  Io(String),
}

pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

fn fs_err_not_found(path: String) -> FsError {
  return FsError.NotFound(path);
}

fn fs_err_io(msg: String) -> FsError {
  return FsError.Io(msg);
}

fn fs_default_file_perm() -> u16 { return 420 as u16; } // 0o644

fn fs_read_to_string_sys(path: String) -> String {
  let fd: i32 = sys.open_read(path);
  if fd < 0 { panic("read_file open failed: ".concat(path)); }
  let size64: i64 = sys.lseek(fd, 0 as i64, sys.seek_end());
  if size64 < 0 {
    let _: i32 = sys.close(fd);
    panic("read_file lseek failed: ".concat(path));
  }
  let _: i64 = sys.lseek(fd, 0 as i64, sys.seek_set());
  let size: i32 = size64 as i32;
  let buf: rawptr = sys.alloc_buf(size);
  // Single read: rawptr has no pointer arithmetic, so we cannot advance
  // the buffer on partial reads. For regular files (compiler sources) a
  // single read always returns the full content.
  let got: isize = sys.read(fd, buf, size as usize);
  let _: i32 = sys.close(fd);
  if got < 0 {
    panic("read_file read failed: ".concat(path));
  }
  return sys.buf_to_string(buf, got as i32);
}

fn fs_write_string_sys(path: String, text: String) -> () {
  let fd: i32 = sys.creat(path, fs_default_file_perm());
  if fd < 0 { panic("write_file open failed: ".concat(path)); }

  let total: i32 = text.len();
  let mut off: i32 = 0;
  while off < total {
    let chunk: String = text.slice(off, total);
    let wrote: isize = sys.write(fd, chunk as const rawptr, chunk.len() as usize);
    if wrote <= 0 {
      let _rc0: i32 = sys.close(fd);
      panic("write_file write failed: ".concat(path));
    }
    let step: i32 = wrote as i32;
    off = off + step;
  }

  let rc: i32 = sys.close(fd);
  if rc != 0 { panic("write_file close failed: ".concat(path)); }
}

fn fs_exists_sys(path: String) -> bool { return sys.access(path, 0) == 0; }

fn fs_mkdir_sys(path: String) -> bool { return sys.mkdir(path, 493 as u16) == 0; }

impl Path {
  fn read_to_string(p: &Path) -> String {
    return fs_read_to_string_sys(p.raw);
  }

  fn write_string(p: &Path, text: String) -> () {
    fs_write_string_sys(p.raw, text);
    return;
  }

  fn exists(p: &Path) -> bool {
    return fs_exists_sys(p.raw);
  }

  fn mkdir_p(p: &Path) -> () {
    if p.raw == "" || p.raw == "." { return; }
    if p.exists() { return; }
    let parent: String = dir_name(p.raw);
    if parent != p.raw && parent != "" {
      let pp: Path = path(parent);
      pp.mkdir_p();
    }
    if !p.exists() {
      if fs_mkdir_sys(p.raw) { return; }
      if p.exists() { return; }
    }
    return;
  }

  fn walk_files(p: &Path) -> Vec[String] {
    return fs_walk_vox_files_raw(p.raw);
  }

  fn try_read_to_string(p: &Path) -> Result[String, FsError] {
    if !p.exists() { return .Err(fs_err_not_found(p.raw)); }
    return .Ok(p.read_to_string());
  }

  fn try_write_string(p: &Path, text: String) -> Result[bool, FsError] {
    let d: String = dir_name(p.raw);
    if d != "." && !exists(d) { return .Err(fs_err_not_found(d)); }
    p.write_string(text);
    return .Ok(true);
  }

  fn try_mkdir_p(p: &Path) -> Result[bool, FsError] {
    p.mkdir_p();
    if p.exists() { return .Ok(true); }
    return .Err(fs_err_io("mkdir_p failed: ".concat(p.raw)));
  }

  fn try_walk_files(p: &Path) -> Result[Vec[String], FsError] {
    if !p.exists() { return .Err(fs_err_not_found(p.raw)); }
    return .Ok(p.walk_files());
  }
}

pub fn read_to_string(raw: String) -> String {
  let p: Path = path(raw);
  return p.read_to_string();
}

pub fn write_string(raw: String, text: String) -> () {
  let p: Path = path(raw);
  p.write_string(text);
  return;
}

pub fn exists(raw: String) -> bool {
  let p: Path = path(raw);
  return p.exists();
}

pub fn mkdir_p(raw: String) -> () {
  let p: Path = path(raw);
  p.mkdir_p();
  return;
}

pub fn walk_files(root: String) -> Vec[String] {
  let p: Path = path(root);
  return p.walk_files();
}

pub fn try_read_to_string(raw: String) -> Result[String, FsError] {
  let p: Path = path(raw);
  return p.try_read_to_string();
}

pub fn try_write_string(raw: String, text: String) -> Result[bool, FsError] {
  let p: Path = path(raw);
  return p.try_write_string(text);
}

pub fn try_mkdir_p(raw: String) -> Result[bool, FsError] {
  let p: Path = path(raw);
  return p.try_mkdir_p();
}

pub fn try_walk_files(root: String) -> Result[Vec[String], FsError] {
  let p: Path = path(root);
  return p.try_walk_files();
}

pub async fn read_to_string_async(raw: String) -> Result[String, FsError] {
  return try_read_to_string(raw);
}

pub async fn write_string_async(raw: String, text: String) -> Result[bool, FsError] {
  return try_write_string(raw, text);
}

pub async fn mkdir_p_async(raw: String) -> Result[bool, FsError] {
  return try_mkdir_p(raw);
}

pub async fn walk_files_async(root: String) -> Result[Vec[String], FsError] {
  return try_walk_files(root);
}
