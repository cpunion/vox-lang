import "std/sys" as sys
import "std/time" as tm

// Insertion sort for small string vectors (file lists are typically < 100).
fn fs_sort_strings(v: Vec[String]) -> () {
  let mut arr: Vec[String] = v;
  let n: i32 = arr.len();
  let mut i: i32 = 1;
  while i < n {
    let key: String = arr.get(i);
    let mut j: i32 = i - 1;
    while j >= 0 && arr.get(j) > key {
      arr.set(j + 1, arr.get(j));
      j = j - 1;
    }
    arr.set(j + 1, key);
    i = i + 1;
  }
}

fn fs_shell_quote(s: String) -> String {
  let mut out: String = "'";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    if ch == 39 {
      out = out.concat("'\"'\"'");
    } else {
      out = out.concat(s.slice(i, i + 1));
    }
    i = i + 1;
  }
  return out.concat("'");
}

fn fs_cmd_quote(s: String) -> String {
  let mut out: String = "\"";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    if ch == 34 {
      out = out.concat("\"\"");
    } else {
      out = out.concat(s.slice(i, i + 1));
    }
    i = i + 1;
  }
  return out.concat("\"");
}

fn fs_to_forward_slashes(s0: String) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < s0.len() {
    if s0.byte_at(i) == 92 {
      out = out.concat("/");
    } else {
      out = out.concat(s0.slice(i, i + 1));
    }
    i = i + 1;
  }
  return out;
}

fn fs_to_windows_slashes(s0: String) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < s0.len() {
    if s0.byte_at(i) == 47 {
      out = out.concat("\\");
    } else {
      out = out.concat(s0.slice(i, i + 1));
    }
    i = i + 1;
  }
  return out;
}

fn fs_normalize_walk_line(line0: String) -> String {
  let mut line: String = fs_to_forward_slashes(line0);
  if line.starts_with("./") { line = line.slice(2, line.len()); }
  if line.starts_with("src/") || line.starts_with("tests/") { return line; }
  let i_tests: i32 = line.index_of("/tests/");
  if i_tests >= 0 {
    return line.slice(i_tests + 1, line.len());
  }
  let i_src: i32 = line.index_of("/src/");
  if i_src >= 0 {
    return line.slice(i_src + 1, line.len());
  }
  return line;
}

fn fs_walk_from_find_output(text: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let n: i32 = text.len();
  let mut start: i32 = 0;
  let mut i: i32 = 0;
  while i <= n {
    if i == n || text.byte_at(i) == 10 {
      let mut line: String = text.slice(start, i);
      if line.ends_with("\r") { line = line.slice(0, line.len() - 1); }
      if line != "" {
        line = fs_normalize_walk_line(line);
        out.push(line);
      }
      start = i + 1;
    }
    i = i + 1;
  }
  fs_sort_strings(out);
  return out;
}

fn fs_walk_find(root: String, find_cmd: String) -> Vec[String] {
  let r: String = if root == "" { "." } else { root };
  let tmp_rel: String = "target/tmp/fs_walk_".concat(tm.now_ns().to_string()).concat(".txt");
  let tmp_full: String = r.concat("/").concat(tmp_rel);
  let _mk_target: bool = fs_mkdir_sys(r.concat("/target"));
  let _mk_tmp: bool = fs_mkdir_sys(r.concat("/target/tmp"));
  let mut cmd: String = "";
  if @target_os() == "windows" {
    let r_win: String = fs_to_windows_slashes(r);
    let tmp_rel_win: String = fs_to_windows_slashes(tmp_rel);
    let find_cmd_win: String = if find_cmd == "find src tests -type f -name '*.vox'" {
      "(for /r src %f in (*.vox) do @echo %f & for /r tests %f in (*.vox) do @echo %f)"
    } else if find_cmd == "find src -type f -name '*.c'" {
      "(for /r src %f in (*.c) do @echo %f)"
    } else {
      ""
    };
    if find_cmd_win == "" {
      return Vec();
    }
    let inner_cmd: String = "cd /d "
      .concat(fs_cmd_quote(r_win))
      .concat(" && ")
      .concat(find_cmd_win)
      .concat(" > ")
      .concat(fs_cmd_quote(tmp_rel_win))
      .concat(" 2>nul");
    // Always force cmd.exe semantics on Windows. This keeps behavior
    // stable even when the parent process is launched from Git Bash.
    cmd = "cmd /C ".concat(fs_cmd_quote(inner_cmd));
  } else {
    cmd = "(cd "
      .concat(fs_shell_quote(r))
      .concat(" && ")
      .concat(find_cmd)
      .concat(" > ")
      .concat(fs_shell_quote(tmp_rel))
      .concat(" 2>/dev/null)");
  }
  let _rc: i32 = sys.system(cmd);
  // `find` may return non-zero when one of multiple roots is missing.
  // As long as output was produced, keep parsing the collected paths.
  if !fs_exists_sys(tmp_full) { return Vec(); }
  let text: String = fs_read_to_string_sys(tmp_full);
  if @target_os() == "windows" {
    let del_cmd: String = "del /f /q ".concat(fs_cmd_quote(fs_to_windows_slashes(tmp_full))).concat(" >nul 2>nul");
    let _: i32 = sys.system("cmd /C ".concat(fs_cmd_quote(del_cmd)));
  } else {
    let _: i32 = sys.system("rm -f ".concat(fs_shell_quote(tmp_full)));
  }
  return fs_walk_from_find_output(text);
}

fn fs_walk_vox_files_impl(root: String) -> Vec[String] {
  return fs_walk_find(root, "find src tests -type f -name '*.vox'");
}

fn fs_walk_c_files_impl(root: String) -> Vec[String] {
  return fs_walk_find(root, "find src -type f -name '*.c'");
}

pub enum FsError {
  NotFound(String),
  Io(String),
}

pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

fn fs_err_not_found(path: String) -> FsError {
  return FsError.NotFound(path);
}

fn fs_err_io(msg: String) -> FsError {
  return FsError.Io(msg);
}

fn fs_default_file_perm() -> u16 { return 420 as u16; } // 0o644

fn fs_read_to_string_sys(path: String) -> String {
  let fd: i32 = sys.open_read(path);
  if fd < 0 { panic("read_file open failed: ".concat(path)); }
  let size64: i64 = sys.lseek(fd, 0 as i64, sys.seek_end());
  if size64 < 0 {
    let _: i32 = sys.close(fd);
    panic("read_file lseek failed: ".concat(path));
  }
  let _: i64 = sys.lseek(fd, 0 as i64, sys.seek_set());
  let size: i32 = size64 as i32;
  let buf: rawptr = sys.alloc_buf(size);
  // Single read: rawptr has no pointer arithmetic, so we cannot advance
  // the buffer on partial reads. For regular files (compiler sources) a
  // single read always returns the full content.
  let got: isize = sys.read(fd, buf, size as usize);
  let _: i32 = sys.close(fd);
  if got < 0 {
    panic("read_file read failed: ".concat(path));
  }
  return sys.buf_to_string(buf, got as i32);
}

fn fs_write_string_sys(path: String, text: String) -> () {
  let fd: i32 = sys.creat(path, fs_default_file_perm());
  if fd < 0 { panic("write_file open failed: ".concat(path)); }

  let total: i32 = text.len();
  let mut off: i32 = 0;
  while off < total {
    let chunk: String = text.slice(off, total);
    let wrote: isize = sys.write(fd, chunk as const rawptr, chunk.len() as usize);
    if wrote <= 0 {
      let _rc0: i32 = sys.close(fd);
      panic("write_file write failed: ".concat(path));
    }
    let step: i32 = wrote as i32;
    off = off + step;
  }

  let rc: i32 = sys.close(fd);
  if rc != 0 { panic("write_file close failed: ".concat(path)); }
}

fn fs_exists_sys(path: String) -> bool { return sys.access(path, 0) == 0; }

fn fs_mkdir_sys(path: String) -> bool { return sys.mkdir(path, 493 as u16) == 0; }

impl Path {
  fn read_to_string(p: &Path) -> String {
    return fs_read_to_string_sys(p.raw);
  }

  fn write_string(p: &Path, text: String) -> () {
    fs_write_string_sys(p.raw, text);
    return;
  }

  fn exists(p: &Path) -> bool {
    return fs_exists_sys(p.raw);
  }

  fn mkdir_p(p: &Path) -> () {
    if p.raw == "" || p.raw == "." { return; }
    if p.exists() { return; }
    let parent: String = dir_name(p.raw);
    if parent != p.raw && parent != "" {
      let pp: Path = path(parent);
      pp.mkdir_p();
    }
    if !p.exists() {
      if fs_mkdir_sys(p.raw) { return; }
      if p.exists() { return; }
    }
    return;
  }

  fn walk_files(p: &Path) -> Vec[String] {
    return fs_walk_vox_files_impl(p.raw);
  }

  fn try_read_to_string(p: &Path) -> Result[String, FsError] {
    if !p.exists() { return .Err(fs_err_not_found(p.raw)); }
    return .Ok(p.read_to_string());
  }

  fn try_write_string(p: &Path, text: String) -> Result[bool, FsError] {
    let d: String = dir_name(p.raw);
    if d != "." && !exists(d) { return .Err(fs_err_not_found(d)); }
    p.write_string(text);
    return .Ok(true);
  }

  fn try_mkdir_p(p: &Path) -> Result[bool, FsError] {
    p.mkdir_p();
    if p.exists() { return .Ok(true); }
    return .Err(fs_err_io("mkdir_p failed: ".concat(p.raw)));
  }

  fn try_walk_files(p: &Path) -> Result[Vec[String], FsError] {
    if !p.exists() { return .Err(fs_err_not_found(p.raw)); }
    return .Ok(p.walk_files());
  }
}

pub fn read_to_string(raw: String) -> String {
  let p: Path = path(raw);
  return p.read_to_string();
}

pub fn write_string(raw: String, text: String) -> () {
  let p: Path = path(raw);
  p.write_string(text);
  return;
}

pub fn exists(raw: String) -> bool {
  let p: Path = path(raw);
  return p.exists();
}

pub fn mkdir_p(raw: String) -> () {
  let p: Path = path(raw);
  p.mkdir_p();
  return;
}

pub fn walk_files(root: String) -> Vec[String] {
  let p: Path = path(root);
  return p.walk_files();
}

pub fn walk_c_files(root: String) -> Vec[String] {
  return fs_walk_c_files_impl(root);
}

pub fn try_read_to_string(raw: String) -> Result[String, FsError] {
  let p: Path = path(raw);
  return p.try_read_to_string();
}

pub fn try_write_string(raw: String, text: String) -> Result[bool, FsError] {
  let p: Path = path(raw);
  return p.try_write_string(text);
}

pub fn try_mkdir_p(raw: String) -> Result[bool, FsError] {
  let p: Path = path(raw);
  return p.try_mkdir_p();
}

pub fn try_walk_files(root: String) -> Result[Vec[String], FsError] {
  let p: Path = path(root);
  return p.try_walk_files();
}

pub async fn read_to_string_async(raw: String) -> Result[String, FsError] {
  return try_read_to_string(raw);
}

pub async fn write_string_async(raw: String, text: String) -> Result[bool, FsError] {
  return try_write_string(raw, text);
}

pub async fn mkdir_p_async(raw: String) -> Result[bool, FsError] {
  return try_mkdir_p(raw);
}

pub async fn walk_files_async(root: String) -> Result[Vec[String], FsError] {
  return try_walk_files(root);
}
