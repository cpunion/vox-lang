import "std/fs" as fs
import "std/runtime" as rt
import "std/testing" as t

fn tmp_dir(prefix: String) -> String {
  let base: String = "target/tmp/"
    .concat(prefix)
    .concat("_")
    .concat(rt.now_ns().to_string());
  fs.mkdir_p(base);
  return base;
}

fn test_fs_path_oop_api_smoke() -> () {
  let dir_raw: String = tmp_dir("std_fs_oop");
  let dir: fs.Path = fs.path(dir_raw);
  let file_raw: String = dir_raw.concat("/a.vox");
  let f: fs.Path = fs.path(file_raw);
  f.write_string("fn main() -> i32 { return 0; }\n");
  t.assert_with(f.exists(), "path.exists false after write");
  let got: String = f.read_to_string();
  t.assert_with(got == "fn main() -> i32 { return 0; }\n", got);
  let _xs: Vec[String] = dir.walk_files();
}

fn test_fs_free_function_compat_smoke() -> () {
  let dir_raw: String = tmp_dir("std_fs_compat");
  let file_raw: String = dir_raw.concat("/b.vox");
  fs.write_string(file_raw, "fn main() -> i32 { return 1; }\n");
  t.assert_with(fs.exists(file_raw), "fs.exists false after write");
  let got: String = fs.read_to_string(file_raw);
  t.assert_with(got == "fn main() -> i32 { return 1; }\n", got);
  let _xs: Vec[String] = fs.walk_files(dir_raw);
}

fn test_fs_result_api_smoke() -> () {
  let dir_raw: String = tmp_dir("std_fs_result");
  let src_dir: String = dir_raw.concat("/src");
  fs.mkdir_p(src_dir);
  let file_raw: String = src_dir.concat("/c.vox");
  let wr: fs.Result[bool, fs.FsError] = fs.try_write_string(file_raw, "ok\n");
  let write_ok: bool = match wr {
    fs.Result.Ok(v) => v,
    _ => false,
  };
  t.assert(write_ok);

  let rr: fs.Result[String, fs.FsError] = fs.try_read_to_string(file_raw);
  let read_ok: bool = match rr {
    fs.Result.Ok(s) => s == "ok\n",
    _ => false,
  };
  t.assert(read_ok);

  let mr: fs.Result[String, fs.FsError] = fs.try_read_to_string(dir_raw.concat("/missing.vox"));
  let miss_ok: bool = match mr {
    fs.Result.Err(_e) => true,
    _ => false,
  };
  t.assert(miss_ok);

  let wrk: fs.Result[Vec[String], fs.FsError] = fs.try_walk_files(dir_raw);
  let walk_ok: bool = match wrk {
    fs.Result.Ok(xs) => xs.len() >= 1,
    _ => false,
  };
  t.assert(walk_ok);
}

fn test_fs_memfs_virtual_fs_smoke() -> () {
  let mut m: fs.MemFS = fs.mem_fs();
  m = m.mkdir_p("/src");
  m = m.write_string("/src/a.vox", "fn main() -> i32 { return 2; }\n");
  t.assert(m.exists("/src"));
  t.assert(m.exists("/src/a.vox"));
  t.assert_eq(m.read_to_string("/src/a.vox"), "fn main() -> i32 { return 2; }\n");

  let xs: Vec[String] = m.walk_files("/src");
  t.assert_eq(xs.len(), 1);
  t.assert_eq(xs.get(0), "/src/a.vox");
}

fn test_fs_virtual_fs_generic_helpers_smoke() -> () {
  let mut m: fs.MemFS = fs.mem_fs();
  m = fs.fs_mkdir_p(m, "/pkg");
  m = fs.fs_write_string(m, "/pkg/lib.vox", "fn lib() -> i32 { return 1; }\n");
  t.assert(fs.fs_exists(m, "/pkg/lib.vox"));
  t.assert_eq(fs.fs_read_to_string(m, "/pkg/lib.vox"), "fn lib() -> i32 { return 1; }\n");
  let xs: Vec[String] = fs.fs_walk_files(m, "/pkg");
  t.assert_eq(xs.len(), 1);
}

fn test_fs_path_helpers_free_function_smoke() -> () {
  t.assert_eq(fs.clean("a//b/./c/.."), "a/b");
  t.assert_eq(fs.clean("/a/../b"), "/b");
  t.assert_eq(fs.clean("C:\\a\\..\\b"), "C:/b");

  t.assert_eq(fs.join("a/b", "c.txt"), "a/b/c.txt");
  t.assert_eq(fs.join("/a/b", "../x"), "/a/x");
  t.assert_eq(fs.join("a/b", "/x/y"), "/x/y");

  t.assert_eq(fs.base_name("/a/b/c.txt"), "c.txt");
  t.assert_eq(fs.dir_name("/a/b/c.txt"), "/a/b");
  t.assert_eq(fs.ext("/a/b/c.txt"), ".txt");
  t.assert_eq(fs.stem("/a/b/c.txt"), "c");

  t.assert(fs.is_abs("/a/b"));
  t.assert(fs.is_abs("C:/a/b"));
  t.assert(!fs.is_abs("a/b"));
}

fn test_fs_path_helpers_oop_smoke() -> () {
  let p0: fs.Path = fs.path("a//b/./c");
  let pc: fs.Path = p0.clean();
  let p1: fs.Path = pc.join("d.txt");
  t.assert_eq(p1.base_name(), "d.txt");
  t.assert_eq(p1.ext(), ".txt");
  t.assert_eq(p1.stem(), "d");
  t.assert_eq(p1.dir_name(), "a/b/c");
  t.assert(!p1.is_abs());

  let p2_in: fs.Path = fs.path("/x/./y/../z");
  let p2: fs.Path = p2_in.clean();
  t.assert_eq(p2.dir_name(), "/x");
  t.assert_eq(p2.base_name(), "z");
  t.assert(p2.is_abs());
}

async fn fs_async_read_probe(path: String) -> fs.Result[String, fs.FsError] {
  return fs.read_to_string_async(path).await;
}

async fn fs_async_write_probe(path: String, text: String) -> fs.Result[bool, fs.FsError] {
  return fs.write_string_async(path, text).await;
}
