import "std/testing" as t
import "std/async" as a

struct TestRuntime {
  n: i32,
}

impl a.Runtime for TestRuntime {
  fn pending_wait(rt: TestRuntime, i: i32, c: a.Context) -> () {
    rt;
    i;
    c;
    return;
  }
  fn park_until_wake(rt: TestRuntime, i: i32, c: a.Context) -> bool {
    rt;
    i;
    c;
    return true;
  }
  fn cancel_requested(rt: TestRuntime, c: a.Context) -> bool {
    rt;
    c;
    return true;
  }
}

fn test_std_async_poll_helpers_smoke() -> () {
  let p0: a.Poll[i32] = a.Poll.Pending;
  let p1: a.Poll[i32] = a.Poll.Ready(7);
  t.assert(a.is_pending(p0));
  t.assert(!a.is_ready(p0));
  t.assert(a.is_ready(p1));
  t.assert(!a.is_pending(p1));
}

fn test_std_async_context_waker_smoke() -> () {
  let w: a.Waker = a.waker(11);
  let cx: a.Context = a.context(w);
  t.assert_eq(cx.waker.token, 11);
}

fn test_std_async_spin_wait_smoke() -> () {
  a.spin_wait(0);
  a.spin_wait(7);
}

fn test_std_async_event_runtime_smoke() -> () {
  let rt: a.EventRuntime = a.event_runtime(2);
  let d: a.EventRuntime = a.default_runtime();
  t.assert(rt.timeout_ms >= 1);
  t.assert(d.timeout_ms >= 1);
}

fn test_std_async_ready_queue_smoke() -> () {
  let mut q: a.ReadyQueue = a.ready_queue();
  t.assert(q.is_empty());
  q = q.push(11);
  q = q.push(22);
  t.assert_eq(q.len(), 2);
  let p0: a.ReadyPop = q.pop();
  t.assert(p0.ok);
  t.assert_eq(p0.token, 11);
  q = p0.q;
  let p1: a.ReadyPop = q.pop();
  t.assert(p1.ok);
  t.assert_eq(p1.token, 22);
  q = p1.q;
  t.assert(q.is_empty());
  let p2: a.ReadyPop = q.pop();
  t.assert(!p2.ok);
}

fn test_std_async_event_source_queue_bridge_smoke() -> () {
  let rt: a.EventRuntime = a.event_runtime(3);
  let cx: a.Context = a.context(a.waker(19));
  let mut q: a.ReadyQueue = a.ready_queue();
  let p0: a.ReadyPoll = a.poll_ready_with(rt, 1, cx);
  t.assert(!p0.ready);
  q = a.enqueue_ready(q, p0);
  t.assert(q.is_empty());

  a.wake(cx);
  let p1: a.ReadyPoll = a.poll_ready_with(rt, 1, cx);
  t.assert(p1.ready);
  t.assert_eq(p1.token, 19);
  q = a.enqueue_ready(q, p1);
  t.assert_eq(q.len(), 1);
}

fn test_std_async_event_source_drain_ready_once_smoke() -> () {
  let rt: a.EventRuntime = a.event_runtime(2);
  let c1: a.Context = a.context(a.waker(31));
  let c2: a.Context = a.context(a.waker(32));
  let mut cs: Vec[a.Context] = Vec();
  cs.push(c1);
  cs.push(c2);
  let mut q: a.ReadyQueue = a.ready_queue();

  q = a.drain_ready_once(rt, 1, cs, q);
  t.assert(q.is_empty());

  a.wake(c2);
  q = a.drain_ready_once(rt, 1, cs, q);
  let p0: a.ReadyPop = q.pop();
  t.assert(p0.ok);
  t.assert_eq(p0.token, 32);
  q = p0.q;
  t.assert(q.is_empty());

  a.wake(c1);
  a.wake(c2);
  q = a.drain_ready_once(rt, 1, cs, q);
  t.assert_eq(q.len(), 2);
  let p1: a.ReadyPop = q.pop();
  t.assert(p1.ok);
  t.assert_eq(p1.token, 31);
  q = p1.q;
  let p2: a.ReadyPop = q.pop();
  t.assert(p2.ok);
  t.assert_eq(p2.token, 32);
}

fn test_std_async_pending_wait_smoke() -> () {
  let w: a.Waker = a.waker(3);
  let cx: a.Context = a.context(w);
  a.pending_wait(0, cx);
  a.pending_wait(5, cx);
}

fn test_std_async_wake_park_smoke() -> () {
  let w: a.Waker = a.waker(7);
  let cx: a.Context = a.context(w);
  a.park(0, cx);
  a.park(4, cx);
  a.wake(cx);
  t.assert(a.park_until_wake(4, cx));
  t.assert(!a.park_until_wake(1, cx));
  t.assert(!a.cancel_requested(cx));
}

fn test_std_async_runtime_trait_smoke() -> () {
  let w: a.Waker = a.waker(9);
  let cx: a.Context = a.context(w);
  a.pending_wait_with(TestRuntime { n: 1 }, 3, cx);
  a.park_with(TestRuntime { n: 1 }, 3, cx);
  t.assert(a.park_until_wake_with(TestRuntime { n: 1 }, 3, cx));
  t.assert(a.cancel_requested_with(TestRuntime { n: 1 }, cx));
  a.pending_wait_with(a.spin_runtime(), 0, cx);
  a.park_with(a.spin_runtime(), 0, cx);
  t.assert(!a.park_until_wake_with(a.spin_runtime(), 0, cx));
  t.assert(!a.cancel_requested_with(a.spin_runtime(), cx));
}

fn test_std_async_cancel_drop_hooks_smoke() -> () {
  let cx: a.Context = a.context(a.waker(17));
  let x0: i32 = a.cancel_drop(cx, 7);
  let x1: i32 = a.cancel_drop_with(a.spin_runtime(), cx, 9);
  t.assert_eq(x0, 7);
  t.assert_eq(x1, 9);
}

fn test_std_async_cancel_hint_hooks_smoke() -> () {
  let cx: a.Context = a.context(a.waker(23));
  let h: a.CancelHint = a.cancel_hint(cx, 3, 11);
  t.assert_eq(h.state, 3);
  t.assert_eq(h.spins, 11);
  t.assert_eq(h.token, 23);
  t.assert_eq(h.reclaim, a.cancel_reclaim_deep());

  let x0: i32 = a.cancel_drop_hint(cx, h, 5);
  let x1: i32 = a.cancel_drop_hint_with(a.spin_runtime(), cx, h, 8);
  t.assert_eq(x0, 5);
  t.assert_eq(x1, 8);

  a.cancel_cleanup_hint(cx, h);
  a.cancel_cleanup_hint_with(a.spin_runtime(), cx, h);
}

fn test_std_async_cancel_reclaim_policy_smoke() -> () {
  t.assert_eq(a.cancel_reclaim_from_state_spins(0, 0), a.cancel_reclaim_keep());
  t.assert_eq(a.cancel_reclaim_from_state_spins(3, 1), a.cancel_reclaim_shallow());
  t.assert_eq(a.cancel_reclaim_from_state_spins(3, 8), a.cancel_reclaim_deep());

  let cx: a.Context = a.context(a.waker(31));
  let h0: a.CancelHint = a.cancel_hint(cx, 0, 99);
  let h1: a.CancelHint = a.cancel_hint(cx, 3, 2);
  let h2: a.CancelHint = a.cancel_hint(cx, 3, 9);
  t.assert_eq(h0.reclaim, a.cancel_reclaim_keep());
  t.assert_eq(h1.reclaim, a.cancel_reclaim_shallow());
  t.assert_eq(h2.reclaim, a.cancel_reclaim_deep());
  t.assert(!a.cancel_reclaim_is_deep(h1));
  t.assert(a.cancel_reclaim_is_deep(h2));
}

fn test_std_async_cancel_cleanup_state_hooks_smoke() -> () {
  let cx: a.Context = a.context(a.waker(37));
  a.cancel_cleanup_state(cx, 1);
  a.cancel_cleanup_state_with(a.spin_runtime(), cx, 2);
  a.cancel_cleanup_with(a.spin_runtime(), cx);
  a.cancel_cleanup(cx);
}
