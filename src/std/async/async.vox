// std/async: pull-based async core contracts.
//
// This module defines the minimal type-level contract used by D03:
// - Future state progresses only when polled by executor.
// - push-style systems can bridge via Sink.

import "std/time" as tm

pub enum Poll[T] {
  Pending,
  Ready(T),
}

pub struct Waker {
  pub token: i64,
}

pub struct Context {
  pub waker: Waker,
}

pub trait Future {
  type Output;
  fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output];
}

// Runtime abstraction for pending scheduling and cancellation polling.
//
// v0 exposes a minimal but pluggable contract:
// - pending_wait: scheduler wait/yield hook
// - park_until_wake: optional evented wait (default falls back to pending_wait)
// - cancel_requested: optional cancellation poll hook (default false)
//
// Different runtimes (tight-loop, evented, epoll-backed, etc.) can provide
// their own impls and be threaded through *_with helpers.
pub trait Runtime {
  fn pending_wait(rt: Self, i: i32, c: Context) -> ();
  fn park_until_wake(rt: Self, i: i32, c: Context) -> bool {
    Runtime.pending_wait(rt, i, c);
    return false;
  }
  fn cancel_requested(rt: Self, c: Context) -> bool {
    rt;
    c;
    return false;
  }
}

pub struct SpinRuntime {
  pub marker: i32,
}

pub struct EventRuntime {
  pub timeout_ms: i32,
}

impl Runtime for SpinRuntime {
  fn pending_wait(rt: SpinRuntime, i: i32, c: Context) -> () {
    rt;
    c;
    spin_wait(i);
    return;
  }
}

fn normalized_timeout_ms(ms: i32) -> i32 {
  if ms <= 0 { return 1; }
  return ms;
}

fn wait_timeout_ms(ms: i32) -> bool {
  let timeout_ms: i32 = normalized_timeout_ms(ms);
  let start: i64 = tm.now_ns();
  let deadline: i64 = start + (timeout_ms as i64) * (1000000 as i64);
  while tm.now_ns() < deadline {
    tm.yield_now();
  }
  return false;
}

impl Runtime for EventRuntime {
  fn pending_wait(rt: EventRuntime, i: i32, c: Context) -> () {
    i;
    c;
    wait_timeout_ms(rt.timeout_ms);
    return;
  }
  fn park_until_wake(rt: EventRuntime, i: i32, c: Context) -> bool {
    i;
    c;
    return wait_timeout_ms(rt.timeout_ms);
  }
}

// Push boundary adapter contract: external event sources can push values into
// a sink that later wakes and feeds a pull-driven Future/Stream.
pub trait Sink {
  type Item;
  fn push(x: &mut Self, v: Self.Item) -> bool;
  fn close(x: &mut Self) -> ();
}

pub fn is_pending[T](p: Poll[T]) -> bool {
  return match p {
    Poll.Pending => true,
    _ => false,
  };
}

pub fn is_ready[T](p: Poll[T]) -> bool {
  return match p {
    Poll.Ready(_v) => true,
    _ => false,
  };
}

pub fn waker(token: i64) -> Waker {
  return Waker { token: token };
}

pub fn context(w: Waker) -> Context {
  return Context { waker: w };
}

pub fn spin_runtime() -> SpinRuntime {
  return SpinRuntime { marker: 0 };
}

pub fn event_runtime(timeout_ms: i32) -> EventRuntime {
  return EventRuntime { timeout_ms: normalized_timeout_ms(timeout_ms) };
}

pub fn io_runtime() -> EventRuntime {
  return event_runtime(1);
}

// Default runtime used by compiler-generated async entry/test wrappers.
pub fn default_runtime() -> EventRuntime {
  return io_runtime();
}

// Minimal wake hook. Evented runtimes may use token -> task mapping.
pub fn wake(c: Context) -> () {
  c;
  return;
}

// v0 executor hook for async entry wrappers.
// Current implementation is intentionally a no-op; hosts/runtimes can provide
// stronger scheduling behavior in later stages.
pub fn spin_wait(i: i32) -> () {
  i;
  tm.yield_now();
  return;
}

pub fn pending_wait_with[R: Runtime](rt: R, i: i32, c: Context) -> () {
  Runtime.pending_wait(rt, i, c);
  return;
}

pub fn park_with[R: Runtime](rt: R, i: i32, c: Context) -> () {
  pending_wait_with(rt, i, c);
  return;
}

// Enhanced pending hook: runtimes may block until an external wake-up source.
// Return value indicates whether wake-up was observed before returning.
pub fn park_until_wake_with[R: Runtime](rt: R, i: i32, c: Context) -> bool {
  return Runtime.park_until_wake(rt, i, c);
}

// Preferred pending hook used by generated async entry wrappers.
pub fn park(i: i32, c: Context) -> () {
  park_with(spin_runtime(), i, c);
  return;
}

pub fn park_until_wake(i: i32, c: Context) -> bool {
  return park_until_wake_with(spin_runtime(), i, c);
}

// Cancellation polling hook for generated async wrappers.
// Hosts can override this in their own std/async module implementation.
//
// Optional return-propagation hooks recognized by compiler wrappers:
// - cancel_cleanup_with(rt, cx)
// - cancel_cleanup(cx)
// - cancel_return_with(rt, cx)
// - cancel_return(cx)
// If absent, wrapper falls back to default return values.
pub fn cancel_requested_with[R: Runtime](rt: R, c: Context) -> bool {
  return Runtime.cancel_requested(rt, c);
}

pub fn cancel_requested(c: Context) -> bool {
  return cancel_requested_with(spin_runtime(), c);
}

// Default pending hook used by generated async entry wrappers.
// Future runtimes can replace this with real wake/park integration.
pub fn pending_wait(i: i32, c: Context) -> () {
  park(i, c);
  return;
}
