import "std/runtime" as rt
import "std/testing" as t

fn test_runtime_intrinsic_abi_and_capability_smoke() -> () {
  t.assert(rt.intrinsic_abi() >= 1);
  t.assert(rt.has_intrinsic("__read_file"));
  t.assert(rt.has_cap(rt.IntrinsicCap.ReadFile));
  t.assert_eq(rt.intrinsic_name(rt.IntrinsicCap.Exec), "__exec");
  t.assert_eq(rt.intrinsic_name(rt.IntrinsicCap.WakeWaitAny), "__wake_wait_any");
  t.assert(rt.has_cap(rt.IntrinsicCap.WakeWaitAny));
  t.assert_eq(rt.intrinsic_name(rt.IntrinsicCap.TcpWaitRead), "__tcp_wait_read");
  t.assert_eq(rt.intrinsic_name(rt.IntrinsicCap.TcpWaitWrite), "__tcp_wait_write");
  t.assert(rt.has_cap(rt.IntrinsicCap.TcpWaitRead));
  t.assert(rt.has_cap(rt.IntrinsicCap.TcpWaitWrite));
  t.assert(!rt.has_intrinsic("not_real_intrinsic"));
}

fn test_runtime_wake_wait_any_smoke() -> () {
  let mut toks: Vec[i64] = Vec();
  toks.push(101 as i64);
  toks.push(102 as i64);
  t.assert_eq(rt.wake_wait_any(toks, 0), -1);
  rt.wake_notify(102 as i64);
  t.assert_eq(rt.wake_wait_any(toks, 1), 1);
}

fn test_runtime_sync_handle_isize_smoke() -> () {
  let h: isize = rt.mutex_i32_new(1);
  t.assert_eq(rt.mutex_i32_load(h), 1);
  rt.mutex_i32_store(h, 3);
  t.assert_eq(rt.mutex_i32_load(h), 3);
  rt.mutex_i32_drop(h);
}
