// std/runtime: low-level runtime capability adapter boundary.
//
// Public std modules should call this layer instead of touching low-level FFI
// symbols directly. This keeps std API stable when runtime mappings evolve.

pub fn intrinsic_abi() -> i32 { return 1; }

// Runtime FFI bridge for capabilities that no longer use reserved `__*` builtins.
@ffi_import("c", "vox_host_args")
fn rt_args_raw() -> Vec[String];

@ffi_import("c", "vox_host_exe_path")
fn rt_exe_path_raw() -> String;

@ffi_import("c", "vox_host_getenv")
fn rt_getenv_raw(key: String) -> String;

@ffi_import("c", "vox_host_now_ns")
fn rt_now_ns_raw() -> i64;

@ffi_import("c", "vox_host_yield_now")
fn rt_yield_now_raw() -> ();

@ffi_import("c", "vox_host_wake_notify")
fn rt_wake_notify_raw(token: i64) -> ();

@ffi_import("c", "vox_host_wake_wait")
fn rt_wake_wait_raw(token: i64, timeout_ms: i32) -> bool;

@ffi_import("c", "vox_host_exec")
fn rt_exec_raw(cmd: String) -> i32;

@ffi_import("c", "vox_host_walk_vox_files")
fn rt_walk_files_raw(root: String) -> Vec[String];

@ffi_import("c", "vox_host_read_file")
fn rt_read_file_raw(path: String) -> String;

@ffi_import("c", "vox_host_tcp_connect")
fn rt_tcp_connect_raw(host: String, port: i32) -> isize;

@ffi_import("c", "vox_host_tcp_recv")
fn rt_tcp_recv_raw(handle: isize, max_n: i32) -> String;

@ffi_import("c", "vox_host_tcp_close")
fn rt_tcp_close_raw(handle: isize) -> ();

@ffi_import("c", "vox_host_tcp_wait_read")
fn rt_tcp_wait_read_raw(handle: isize, timeout_ms: i32) -> bool;

@ffi_import("c", "vox_host_tcp_wait_write")
fn rt_tcp_wait_write_raw(handle: isize, timeout_ms: i32) -> bool;

@ffi_import("c", "vox_host_mutex_i32_new")
fn rt_mutex_i32_new_raw(v: i32) -> isize;

@ffi_import("c", "vox_host_mutex_i32_load")
fn rt_mutex_i32_load_raw(handle: isize) -> i32;

@ffi_import("c", "vox_host_mutex_i32_store")
fn rt_mutex_i32_store_raw(handle: isize, v: i32) -> ();

@ffi_import("c", "vox_host_mutex_i32_drop")
fn rt_mutex_i32_drop_raw(handle: isize) -> ();

@ffi_import("c", "vox_host_atomic_i32_new")
fn rt_atomic_i32_new_raw(v: i32) -> isize;

@ffi_import("c", "vox_host_atomic_i32_load")
fn rt_atomic_i32_load_raw(handle: isize) -> i32;

@ffi_import("c", "vox_host_atomic_i32_store")
fn rt_atomic_i32_store_raw(handle: isize, v: i32) -> ();

@ffi_import("c", "vox_host_atomic_i32_fetch_add")
fn rt_atomic_i32_fetch_add_raw(handle: isize, delta: i32) -> i32;

@ffi_import("c", "vox_host_atomic_i32_swap")
fn rt_atomic_i32_swap_raw(handle: isize, v: i32) -> i32;

@ffi_import("c", "vox_host_atomic_i32_drop")
fn rt_atomic_i32_drop_raw(handle: isize) -> ();

@ffi_import("c", "vox_host_mutex_i64_new")
fn rt_mutex_i64_new_raw(v: i64) -> isize;

@ffi_import("c", "vox_host_mutex_i64_load")
fn rt_mutex_i64_load_raw(handle: isize) -> i64;

@ffi_import("c", "vox_host_mutex_i64_store")
fn rt_mutex_i64_store_raw(handle: isize, v: i64) -> ();

@ffi_import("c", "vox_host_mutex_i64_drop")
fn rt_mutex_i64_drop_raw(handle: isize) -> ();

@ffi_import("c", "vox_host_atomic_i64_new")
fn rt_atomic_i64_new_raw(v: i64) -> isize;

@ffi_import("c", "vox_host_atomic_i64_load")
fn rt_atomic_i64_load_raw(handle: isize) -> i64;

@ffi_import("c", "vox_host_atomic_i64_store")
fn rt_atomic_i64_store_raw(handle: isize, v: i64) -> ();

@ffi_import("c", "vox_host_atomic_i64_fetch_add")
fn rt_atomic_i64_fetch_add_raw(handle: isize, delta: i64) -> i64;

@ffi_import("c", "vox_host_atomic_i64_swap")
fn rt_atomic_i64_swap_raw(handle: isize, v: i64) -> i64;

@ffi_import("c", "vox_host_atomic_i64_drop")
fn rt_atomic_i64_drop_raw(handle: isize) -> ();

// OOP-friendly runtime facade.
// Keep free-function API for compatibility while exposing method-style calls.
pub struct Runtime {
  marker: i32,
}

pub fn runtime() -> Runtime {
  return Runtime { marker: 0 };
}

// Compatibility probe kept for older std code.
// Runtime capabilities are no longer exposed as reserved `__*` intrinsics.
pub fn has_intrinsic(name: String) -> bool {
  name;
  return false;
}

pub fn args() -> Vec[String] { return rt_args_raw(); }

pub fn exe_path() -> String { return rt_exe_path_raw(); }

pub fn getenv(key: String) -> String { return rt_getenv_raw(key); }

pub fn now_ns() -> i64 { return rt_now_ns_raw(); }

pub fn yield_now() -> () {
  rt_yield_now_raw();
  return;
}

pub fn wake_notify(token: i64) -> () {
  rt_wake_notify_raw(token);
  return;
}

pub fn wake_wait(token: i64, timeout_ms: i32) -> bool {
  return rt_wake_wait_raw(token, timeout_ms);
}

pub fn wake_wait_any(tokens: Vec[i64], timeout_ms: i32) -> i32 {
  let n: i32 = tokens.len();
  if n == 0 { return -1; }

  // Non-blocking scan first.
  let mut i: i32 = 0;
  while i < n {
    if wake_wait(tokens.get(i), 0) { return i; }
    i = i + 1;
  }
  if timeout_ms <= 0 { return -1; }

  let deadline: i64 = now_ns() + ((timeout_ms as i64) * (1000 as i64) * (1000 as i64));
  while true {
    let rem_ns: i64 = deadline - now_ns();
    if rem_ns <= 0 { return -1; }
    let mut rem_ms: i32 = (rem_ns / ((1000 as i64) * (1000 as i64))) as i32;
    if rem_ms <= 0 { rem_ms = 1; }
    if wake_wait(tokens.get(0), rem_ms) { return 0; }

    // Re-scan other tokens after one blocking wait on the anchor token.
    let mut j: i32 = 1;
    while j < n {
      if wake_wait(tokens.get(j), 0) { return j; }
      j = j + 1;
    }
  }
  return -1;
}

pub fn read_file(path: String) -> String { return rt_read_file_raw(path); }

pub fn exec(cmd: String) -> i32 { return rt_exec_raw(cmd); }

pub fn walk_files(root: String) -> Vec[String] { return rt_walk_files_raw(root); }

pub fn mutex_i32_new(v: i32) -> isize { return rt_mutex_i32_new_raw(v); }

pub fn mutex_i32_load(handle: isize) -> i32 { return rt_mutex_i32_load_raw(handle); }

pub fn mutex_i32_store(handle: isize, v: i32) -> () {
  rt_mutex_i32_store_raw(handle, v);
  return;
}

pub fn mutex_i32_drop(handle: isize) -> () {
  rt_mutex_i32_drop_raw(handle);
  return;
}

pub fn atomic_i32_new(v: i32) -> isize { return rt_atomic_i32_new_raw(v); }

pub fn atomic_i32_load(handle: isize) -> i32 { return rt_atomic_i32_load_raw(handle); }

pub fn atomic_i32_store(handle: isize, v: i32) -> () {
  rt_atomic_i32_store_raw(handle, v);
  return;
}

pub fn atomic_i32_fetch_add(handle: isize, delta: i32) -> i32 {
  return rt_atomic_i32_fetch_add_raw(handle, delta);
}

pub fn atomic_i32_swap(handle: isize, v: i32) -> i32 {
  return rt_atomic_i32_swap_raw(handle, v);
}

pub fn atomic_i32_drop(handle: isize) -> () {
  rt_atomic_i32_drop_raw(handle);
  return;
}

pub fn mutex_i64_new(v: i64) -> isize { return rt_mutex_i64_new_raw(v); }

pub fn mutex_i64_load(handle: isize) -> i64 { return rt_mutex_i64_load_raw(handle); }

pub fn mutex_i64_store(handle: isize, v: i64) -> () {
  rt_mutex_i64_store_raw(handle, v);
  return;
}

pub fn mutex_i64_drop(handle: isize) -> () {
  rt_mutex_i64_drop_raw(handle);
  return;
}

pub fn atomic_i64_new(v: i64) -> isize { return rt_atomic_i64_new_raw(v); }

pub fn atomic_i64_load(handle: isize) -> i64 { return rt_atomic_i64_load_raw(handle); }

pub fn atomic_i64_store(handle: isize, v: i64) -> () {
  rt_atomic_i64_store_raw(handle, v);
  return;
}

pub fn atomic_i64_fetch_add(handle: isize, delta: i64) -> i64 {
  return rt_atomic_i64_fetch_add_raw(handle, delta);
}

pub fn atomic_i64_swap(handle: isize, v: i64) -> i64 {
  return rt_atomic_i64_swap_raw(handle, v);
}

pub fn atomic_i64_drop(handle: isize) -> () {
  rt_atomic_i64_drop_raw(handle);
  return;
}

pub fn tcp_connect(host: String, port: i32) -> isize {
  return rt_tcp_connect_raw(host, port);
}

pub fn tcp_recv(handle: isize, max_n: i32) -> String {
  return rt_tcp_recv_raw(handle, max_n);
}

pub fn tcp_close(handle: isize) -> () {
  rt_tcp_close_raw(handle);
  return;
}

pub fn tcp_wait_read(handle: isize, timeout_ms: i32) -> bool {
  return rt_tcp_wait_read_raw(handle, timeout_ms);
}

pub fn tcp_wait_write(handle: isize, timeout_ms: i32) -> bool {
  return rt_tcp_wait_write_raw(handle, timeout_ms);
}

impl Runtime {
  fn intrinsic_abi(rt: Runtime) -> i32 {
    rt;
    return intrinsic_abi();
  }

  fn has_intrinsic(rt: Runtime, name: String) -> bool {
    rt;
    return has_intrinsic(name);
  }

  fn read_file(rt: Runtime, path: String) -> String {
    rt;
    return read_file(path);
  }

  fn wake_notify(rt: Runtime, token: i64) -> () {
    rt;
    wake_notify(token);
    return;
  }

  fn wake_wait(rt: Runtime, token: i64, timeout_ms: i32) -> bool {
    rt;
    return wake_wait(token, timeout_ms);
  }

  fn wake_wait_any(rt: Runtime, tokens: Vec[i64], timeout_ms: i32) -> i32 {
    rt;
    return wake_wait_any(tokens, timeout_ms);
  }

  fn tcp_connect(rt: Runtime, host: String, port: i32) -> isize {
    rt;
    return tcp_connect(host, port);
  }

  fn tcp_recv(rt: Runtime, handle: isize, max_n: i32) -> String {
    rt;
    return tcp_recv(handle, max_n);
  }

  fn tcp_close(rt: Runtime, handle: isize) -> () {
    rt;
    tcp_close(handle);
    return;
  }

  fn tcp_wait_read(rt: Runtime, handle: isize, timeout_ms: i32) -> bool {
    rt;
    return tcp_wait_read(handle, timeout_ms);
  }

  fn tcp_wait_write(rt: Runtime, handle: isize, timeout_ms: i32) -> bool {
    rt;
    return tcp_wait_write(handle, timeout_ms);
  }
}
