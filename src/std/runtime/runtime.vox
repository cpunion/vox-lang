// std/runtime: low-level adapter boundary for reserved intrinsics.
//
// Public std modules should call this layer instead of touching `__*` directly.
// This keeps std API stable when intrinsic mappings evolve.

pub fn intrinsic_abi() -> i32 { return 1; }

pub fn has_intrinsic(name: String) -> bool {
  if name == "__args" { return true; }
  if name == "__exe_path" { return true; }
  if name == "__getenv" { return true; }
  if name == "__now_ns" { return true; }
  if name == "__yield_now" { return true; }
  if name == "__wake_notify" { return true; }
  if name == "__wake_wait" { return true; }
  if name == "__read_file" { return true; }
  if name == "__write_file" { return true; }
  if name == "__path_exists" { return true; }
  if name == "__mkdir_p" { return true; }
  if name == "__exec" { return true; }
  if name == "__walk_vox_files" { return true; }
  if name == "__mutex_i32_new" { return true; }
  if name == "__mutex_i32_load" { return true; }
  if name == "__mutex_i32_store" { return true; }
  if name == "__mutex_i32_drop" { return true; }
  if name == "__atomic_i32_new" { return true; }
  if name == "__atomic_i32_load" { return true; }
  if name == "__atomic_i32_store" { return true; }
  if name == "__atomic_i32_fetch_add" { return true; }
  if name == "__atomic_i32_swap" { return true; }
  if name == "__atomic_i32_drop" { return true; }
  if name == "__mutex_i64_new" { return true; }
  if name == "__mutex_i64_load" { return true; }
  if name == "__mutex_i64_store" { return true; }
  if name == "__mutex_i64_drop" { return true; }
  if name == "__atomic_i64_new" { return true; }
  if name == "__atomic_i64_load" { return true; }
  if name == "__atomic_i64_store" { return true; }
  if name == "__atomic_i64_fetch_add" { return true; }
  if name == "__atomic_i64_swap" { return true; }
  if name == "__atomic_i64_drop" { return true; }
  if name == "__tcp_connect" { return true; }
  if name == "__tcp_send" { return true; }
  if name == "__tcp_recv" { return true; }
  if name == "__tcp_close" { return true; }
  return false;
}

pub fn args() -> Vec[String] { return __args(); }

pub fn exe_path() -> String { return __exe_path(); }

pub fn getenv(key: String) -> String { return __getenv(key); }

pub fn now_ns() -> i64 { return __now_ns(); }

pub fn yield_now() -> () {
  __yield_now();
  return;
}

pub fn wake_notify(token: i64) -> () {
  __wake_notify(token);
  return;
}

pub fn wake_wait(token: i64, timeout_ms: i32) -> bool {
  return __wake_wait(token, timeout_ms);
}

pub fn read_file(path: String) -> String { return __read_file(path); }

pub fn write_file(path: String, text: String) -> () {
  __write_file(path, text);
  return;
}

pub fn path_exists(path: String) -> bool { return __path_exists(path); }

pub fn mkdir_p(path: String) -> () {
  __mkdir_p(path);
  return;
}

pub fn exec(cmd: String) -> i32 { return __exec(cmd); }

pub fn walk_vox_files(root: String) -> Vec[String] { return __walk_vox_files(root); }

pub fn mutex_i32_new(v: i32) -> isize { return __mutex_i32_new(v) as isize; }
pub fn mutex_i32_load(handle: isize) -> i32 { return __mutex_i32_load(handle as i64); }
pub fn mutex_i32_store(handle: isize, v: i32) -> () {
  __mutex_i32_store(handle as i64, v);
  return;
}
pub fn mutex_i32_drop(handle: isize) -> () {
  __mutex_i32_drop(handle as i64);
  return;
}

pub fn atomic_i32_new(v: i32) -> isize { return __atomic_i32_new(v) as isize; }
pub fn atomic_i32_load(handle: isize) -> i32 { return __atomic_i32_load(handle as i64); }
pub fn atomic_i32_store(handle: isize, v: i32) -> () {
  __atomic_i32_store(handle as i64, v);
  return;
}
pub fn atomic_i32_fetch_add(handle: isize, delta: i32) -> i32 {
  return __atomic_i32_fetch_add(handle as i64, delta);
}
pub fn atomic_i32_swap(handle: isize, v: i32) -> i32 {
  return __atomic_i32_swap(handle as i64, v);
}
pub fn atomic_i32_drop(handle: isize) -> () {
  __atomic_i32_drop(handle as i64);
  return;
}

pub fn mutex_i64_new(v: i64) -> isize { return __mutex_i64_new(v) as isize; }
pub fn mutex_i64_load(handle: isize) -> i64 { return __mutex_i64_load(handle as i64); }
pub fn mutex_i64_store(handle: isize, v: i64) -> () {
  __mutex_i64_store(handle as i64, v);
  return;
}
pub fn mutex_i64_drop(handle: isize) -> () {
  __mutex_i64_drop(handle as i64);
  return;
}

pub fn atomic_i64_new(v: i64) -> isize { return __atomic_i64_new(v) as isize; }
pub fn atomic_i64_load(handle: isize) -> i64 { return __atomic_i64_load(handle as i64); }
pub fn atomic_i64_store(handle: isize, v: i64) -> () {
  __atomic_i64_store(handle as i64, v);
  return;
}
pub fn atomic_i64_fetch_add(handle: isize, delta: i64) -> i64 {
  return __atomic_i64_fetch_add(handle as i64, delta);
}
pub fn atomic_i64_swap(handle: isize, v: i64) -> i64 {
  return __atomic_i64_swap(handle as i64, v);
}
pub fn atomic_i64_drop(handle: isize) -> () {
  __atomic_i64_drop(handle as i64);
  return;
}

pub fn tcp_connect(host: String, port: i32) -> isize {
  return __tcp_connect(host, port) as isize;
}
pub fn tcp_send(handle: isize, text: String) -> i32 {
  return __tcp_send(handle as i64, text);
}
pub fn tcp_recv(handle: isize, max_n: i32) -> String {
  return __tcp_recv(handle as i64, max_n);
}
pub fn tcp_close(handle: isize) -> () {
  __tcp_close(handle as i64);
  return;
}
