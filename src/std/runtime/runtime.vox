// std/runtime: low-level adapter boundary for reserved intrinsics.
//
// Public std modules should call this layer instead of touching `__*` directly.
// This keeps std API stable when intrinsic mappings evolve.

pub fn intrinsic_abi() -> i32 { return 1; }

// Runtime FFI bridge for capabilities that no longer use reserved `__*` builtins.
@ffi_import("c", "vox_builtin_exe_path")
fn rt_exe_path_raw() -> String;
@ffi_import("c", "vox_builtin_getenv")
fn rt_getenv_raw(key: String) -> String;
@ffi_import("c", "vox_builtin_now_ns")
fn rt_now_ns_raw() -> i64;
@ffi_import("c", "vox_builtin_yield_now")
fn rt_yield_now_raw() -> ();
@ffi_import("c", "vox_builtin_exec")
fn rt_exec_raw(cmd: String) -> i32;

// OOP-friendly runtime facade.
// Keep free-function API for compatibility while exposing method-style calls.
pub struct Runtime {
  marker: i32,
}

pub fn runtime() -> Runtime {
  return Runtime { marker: 0 };
}

pub enum IntrinsicCap {
  Args,
  ExePath,
  Getenv,
  NowNs,
  YieldNow,
  WakeNotify,
  WakeWait,
  WakeWaitAny,
  ReadFile,
  WriteFile,
  PathExists,
  MkdirP,
  Exec,
  WalkFiles,
  MutexI32New,
  MutexI32Load,
  MutexI32Store,
  MutexI32Drop,
  AtomicI32New,
  AtomicI32Load,
  AtomicI32Store,
  AtomicI32FetchAdd,
  AtomicI32Swap,
  AtomicI32Drop,
  MutexI64New,
  MutexI64Load,
  MutexI64Store,
  MutexI64Drop,
  AtomicI64New,
  AtomicI64Load,
  AtomicI64Store,
  AtomicI64FetchAdd,
  AtomicI64Swap,
  AtomicI64Drop,
  TcpConnect,
  TcpSend,
  TcpRecv,
  TcpClose,
  TcpWaitRead,
  TcpWaitWrite,
}

pub fn intrinsic_name(cap: IntrinsicCap) -> String {
  return match cap {
      .Args => "__args",
      .ExePath => "__exe_path",
      .Getenv => "__getenv",
      .NowNs => "__now_ns",
      .YieldNow => "__yield_now",
      .WakeNotify => "__wake_notify",
      .WakeWait => "__wake_wait",
      .WakeWaitAny => "__wake_wait_any",
      .ReadFile => "__read_file",
      .WriteFile => "__write_file",
      .PathExists => "__path_exists",
      .MkdirP => "__mkdir_p",
      .Exec => "__exec",
      .WalkFiles => "__walk_vox_files",
      .MutexI32New => "__mutex_i32_new",
      .MutexI32Load => "__mutex_i32_load",
      .MutexI32Store => "__mutex_i32_store",
      .MutexI32Drop => "__mutex_i32_drop",
      .AtomicI32New => "__atomic_i32_new",
      .AtomicI32Load => "__atomic_i32_load",
      .AtomicI32Store => "__atomic_i32_store",
      .AtomicI32FetchAdd => "__atomic_i32_fetch_add",
      .AtomicI32Swap => "__atomic_i32_swap",
      .AtomicI32Drop => "__atomic_i32_drop",
      .MutexI64New => "__mutex_i64_new",
      .MutexI64Load => "__mutex_i64_load",
      .MutexI64Store => "__mutex_i64_store",
      .MutexI64Drop => "__mutex_i64_drop",
      .AtomicI64New => "__atomic_i64_new",
      .AtomicI64Load => "__atomic_i64_load",
      .AtomicI64Store => "__atomic_i64_store",
      .AtomicI64FetchAdd => "__atomic_i64_fetch_add",
      .AtomicI64Swap => "__atomic_i64_swap",
      .AtomicI64Drop => "__atomic_i64_drop",
      .TcpConnect => "__tcp_connect",
      .TcpSend => "__tcp_send",
      .TcpRecv => "__tcp_recv",
      .TcpClose => "__tcp_close",
      .TcpWaitRead => "__tcp_wait_read",
      .TcpWaitWrite => "__tcp_wait_write",
  };
}

pub fn has_cap(cap: IntrinsicCap) -> bool { return has_intrinsic(intrinsic_name(cap)); }

pub fn has_intrinsic(name: String) -> bool {
  if name == "__args" { return true; }
  if name == "__exe_path" { return true; }
  if name == "__getenv" { return true; }
  if name == "__now_ns" { return true; }
  if name == "__yield_now" { return true; }
  if name == "__wake_notify" { return true; }
  if name == "__wake_wait" { return true; }
  if name == "__wake_wait_any" { return true; }
  if name == "__read_file" { return true; }
  if name == "__write_file" { return true; }
  if name == "__path_exists" { return true; }
  if name == "__mkdir_p" { return true; }
  if name == "__exec" { return true; }
  if name == "__walk_vox_files" { return true; }
  if name == "__mutex_i32_new" { return true; }
  if name == "__mutex_i32_load" { return true; }
  if name == "__mutex_i32_store" { return true; }
  if name == "__mutex_i32_drop" { return true; }
  if name == "__atomic_i32_new" { return true; }
  if name == "__atomic_i32_load" { return true; }
  if name == "__atomic_i32_store" { return true; }
  if name == "__atomic_i32_fetch_add" { return true; }
  if name == "__atomic_i32_swap" { return true; }
  if name == "__atomic_i32_drop" { return true; }
  if name == "__mutex_i64_new" { return true; }
  if name == "__mutex_i64_load" { return true; }
  if name == "__mutex_i64_store" { return true; }
  if name == "__mutex_i64_drop" { return true; }
  if name == "__atomic_i64_new" { return true; }
  if name == "__atomic_i64_load" { return true; }
  if name == "__atomic_i64_store" { return true; }
  if name == "__atomic_i64_fetch_add" { return true; }
  if name == "__atomic_i64_swap" { return true; }
  if name == "__atomic_i64_drop" { return true; }
  if name == "__tcp_connect" { return true; }
  if name == "__tcp_send" { return true; }
  if name == "__tcp_recv" { return true; }
  if name == "__tcp_close" { return true; }
  if name == "__tcp_wait_read" { return true; }
  if name == "__tcp_wait_write" { return true; }
  return false;
}

pub fn args() -> Vec[String] { return __args(); }

pub fn exe_path() -> String { return rt_exe_path_raw(); }

pub fn getenv(key: String) -> String { return rt_getenv_raw(key); }

pub fn now_ns() -> i64 { return rt_now_ns_raw(); }

pub fn yield_now() -> () {
  rt_yield_now_raw();
  return;
}

pub fn wake_notify(token: i64) -> () {
  __wake_notify(token);
  return;
}

pub fn wake_wait(token: i64, timeout_ms: i32) -> bool {
  return __wake_wait(token, timeout_ms);
}

pub fn wake_wait_any(tokens: Vec[i64], timeout_ms: i32) -> i32 {
  return __wake_wait_any(tokens, timeout_ms);
}

pub fn read_file(path: String) -> String { return __read_file(path); }

pub fn write_file(path: String, text: String) -> () {
  __write_file(path, text);
  return;
}

pub fn path_exists(path: String) -> bool { return __path_exists(path); }

pub fn mkdir_p(path: String) -> () {
  __mkdir_p(path);
  return;
}

pub fn exec(cmd: String) -> i32 { return rt_exec_raw(cmd); }

pub fn walk_files(root: String) -> Vec[String] { return __walk_vox_files(root); }

pub fn mutex_i32_new(v: i32) -> isize { return __mutex_i32_new(v) as isize; }
pub fn mutex_i32_load(handle: isize) -> i32 { return __mutex_i32_load(handle as i64); }
pub fn mutex_i32_store(handle: isize, v: i32) -> () {
  __mutex_i32_store(handle as i64, v);
  return;
}
pub fn mutex_i32_drop(handle: isize) -> () {
  __mutex_i32_drop(handle as i64);
  return;
}

pub fn atomic_i32_new(v: i32) -> isize { return __atomic_i32_new(v) as isize; }
pub fn atomic_i32_load(handle: isize) -> i32 { return __atomic_i32_load(handle as i64); }
pub fn atomic_i32_store(handle: isize, v: i32) -> () {
  __atomic_i32_store(handle as i64, v);
  return;
}
pub fn atomic_i32_fetch_add(handle: isize, delta: i32) -> i32 {
  return __atomic_i32_fetch_add(handle as i64, delta);
}
pub fn atomic_i32_swap(handle: isize, v: i32) -> i32 {
  return __atomic_i32_swap(handle as i64, v);
}
pub fn atomic_i32_drop(handle: isize) -> () {
  __atomic_i32_drop(handle as i64);
  return;
}

pub fn mutex_i64_new(v: i64) -> isize { return __mutex_i64_new(v) as isize; }
pub fn mutex_i64_load(handle: isize) -> i64 { return __mutex_i64_load(handle as i64); }
pub fn mutex_i64_store(handle: isize, v: i64) -> () {
  __mutex_i64_store(handle as i64, v);
  return;
}
pub fn mutex_i64_drop(handle: isize) -> () {
  __mutex_i64_drop(handle as i64);
  return;
}

pub fn atomic_i64_new(v: i64) -> isize { return __atomic_i64_new(v) as isize; }
pub fn atomic_i64_load(handle: isize) -> i64 { return __atomic_i64_load(handle as i64); }
pub fn atomic_i64_store(handle: isize, v: i64) -> () {
  __atomic_i64_store(handle as i64, v);
  return;
}
pub fn atomic_i64_fetch_add(handle: isize, delta: i64) -> i64 {
  return __atomic_i64_fetch_add(handle as i64, delta);
}
pub fn atomic_i64_swap(handle: isize, v: i64) -> i64 {
  return __atomic_i64_swap(handle as i64, v);
}
pub fn atomic_i64_drop(handle: isize) -> () {
  __atomic_i64_drop(handle as i64);
  return;
}

pub fn tcp_connect(host: String, port: i32) -> isize {
  return __tcp_connect(host, port) as isize;
}
pub fn tcp_send(handle: isize, text: String) -> i32 {
  return __tcp_send(handle as i64, text);
}
pub fn tcp_recv(handle: isize, max_n: i32) -> String {
  return __tcp_recv(handle as i64, max_n);
}
pub fn tcp_close(handle: isize) -> () {
  __tcp_close(handle as i64);
  return;
}
pub fn tcp_wait_read(handle: isize, timeout_ms: i32) -> bool {
  return __tcp_wait_read(handle as i64, timeout_ms);
}
pub fn tcp_wait_write(handle: isize, timeout_ms: i32) -> bool {
  return __tcp_wait_write(handle as i64, timeout_ms);
}

impl Runtime {
  fn intrinsic_abi(rt: Runtime) -> i32 {
    rt;
    return intrinsic_abi();
  }

  fn intrinsic_name(rt: Runtime, cap: IntrinsicCap) -> String {
    rt;
    return intrinsic_name(cap);
  }

  fn has_intrinsic(rt: Runtime, name: String) -> bool {
    rt;
    return has_intrinsic(name);
  }

  fn has_cap(rt: Runtime, cap: IntrinsicCap) -> bool {
    rt;
    return has_cap(cap);
  }

  fn path_exists(rt: Runtime, path: String) -> bool {
    rt;
    return path_exists(path);
  }

  fn read_file(rt: Runtime, path: String) -> String {
    rt;
    return read_file(path);
  }

  fn write_file(rt: Runtime, path: String, text: String) -> () {
    rt;
    write_file(path, text);
    return;
  }

  fn mkdir_p(rt: Runtime, path: String) -> () {
    rt;
    mkdir_p(path);
    return;
  }

  fn wake_notify(rt: Runtime, token: i64) -> () {
    rt;
    wake_notify(token);
    return;
  }

  fn wake_wait(rt: Runtime, token: i64, timeout_ms: i32) -> bool {
    rt;
    return wake_wait(token, timeout_ms);
  }

  fn wake_wait_any(rt: Runtime, tokens: Vec[i64], timeout_ms: i32) -> i32 {
    rt;
    return wake_wait_any(tokens, timeout_ms);
  }

  fn tcp_connect(rt: Runtime, host: String, port: i32) -> isize {
    rt;
    return tcp_connect(host, port);
  }

  fn tcp_send(rt: Runtime, handle: isize, text: String) -> i32 {
    rt;
    return tcp_send(handle, text);
  }

  fn tcp_recv(rt: Runtime, handle: isize, max_n: i32) -> String {
    rt;
    return tcp_recv(handle, max_n);
  }

  fn tcp_close(rt: Runtime, handle: isize) -> () {
    rt;
    tcp_close(handle);
    return;
  }

  fn tcp_wait_read(rt: Runtime, handle: isize, timeout_ms: i32) -> bool {
    rt;
    return tcp_wait_read(handle, timeout_ms);
  }

  fn tcp_wait_write(rt: Runtime, handle: isize, timeout_ms: i32) -> bool {
    rt;
    return tcp_wait_write(handle, timeout_ms);
  }
}
