// std/runtime: low-level runtime capability adapter boundary.
//
// Public std modules should call this layer instead of touching low-level FFI
// symbols directly. This keeps std API stable when runtime mappings evolve.

import "std/sys" as sys
import "std/time" as tm

pub fn intrinsic_abi() -> i32 { return 1; }

// Atomic helpers — use @atomic_* intrinsics on raw calloc'd buffers.
fn rt_atomic_i32_load_raw(handle: isize) -> i32 {
  return @atomic_load[i32](handle as rawptr);
}
fn rt_atomic_i32_fetch_add_raw(handle: isize, delta: i32) -> i32 {
  return @atomic_fetch_add[i32](handle as rawptr, delta);
}
fn rt_atomic_i32_cas_raw(handle: isize, expected: i32, desired: i32) -> bool {
  return @atomic_cas[i32](handle as rawptr, expected, desired);
}
fn rt_atomic_i64_load_raw(handle: isize) -> i64 {
  return @atomic_load[i64](handle as rawptr);
}
fn rt_atomic_i64_cas_raw(handle: isize, expected: i64, desired: i64) -> bool {
  return @atomic_cas[i64](handle as rawptr, expected, desired);
}

// Compatibility probe kept for older std code.
// Runtime capabilities are no longer exposed as reserved `__*` intrinsics.
pub fn has_intrinsic(name: String) -> bool {
  name;
  return false;
}

// === Event loop: pure Vox wake table + platform poller ===
//
// Wake table is a 256-slot open-addressing hash map of tokens → pending counts.
// Slot arrays are heap-allocated contiguous _Atomic int64_t / _Atomic int32_t.
// Platform-specific poller (el_darwin/linux/windows/wasm.vox) provides
// el_init_poller(), el_wake_poller(), el_wait_poller(timeout_ms).

fn EL_SLOTS() -> i32 { return 256; }

static mut el_inited: bool = false;
static mut el_token_buf: isize = 0;
static mut el_pending_buf: isize = 0;

fn el_init() -> () {
  if el_inited { return; }
  // Allocate contiguous _Atomic arrays. calloc zeros memory which is a valid
  // atomic initial value for integer types on all supported platforms.
  el_token_buf = sys.calloc(EL_SLOTS() as usize, 8 as usize) as isize;
  el_pending_buf = sys.calloc(EL_SLOTS() as usize, 4 as usize) as isize;
  el_init_poller();
  el_inited = true;
  return;
}

fn el_token_handle(idx: i32) -> isize {
  return el_token_buf + (idx as isize) * (8 as isize);
}

fn el_pending_handle(idx: i32) -> isize {
  return el_pending_buf + (idx as isize) * (4 as isize);
}

// Pure Vox wake table algorithm using heap-allocated atomic arrays.
fn el_slot_index(token: i64) -> i32 {
  let n: i32 = EL_SLOTS();
  let mut probe: i32 = 0;
  while probe < n {
    let raw: i64 = (token + (probe as i64)) % (n as i64);
    let idx: i32 = if raw < 0 { (raw + (n as i64)) as i32 } else { raw as i32 };
    let th: isize = el_token_handle(idx);
    let seen: i64 = rt_atomic_i64_load_raw(th);
    if seen == token { return idx; }
    if seen == 0 {
      if rt_atomic_i64_cas_raw(th, 0, token) { return idx; }
      let after: i64 = rt_atomic_i64_load_raw(th);
      if after == token { return idx; }
    }
    probe = probe + 1;
  }
  return -1;
}

fn el_try_consume(token: i64) -> bool {
  let idx: i32 = el_slot_index(token);
  if idx < 0 { return false; }
  let ph: isize = el_pending_handle(idx);
  while true {
    let cur: i32 = rt_atomic_i32_load_raw(ph);
    if cur <= 0 { return false; }
    if rt_atomic_i32_cas_raw(ph, cur, cur - 1) { return true; }
  }
  return false;
}

pub fn wake_notify(token: i64) -> () {
  el_init();
  let idx: i32 = el_slot_index(token);
  if idx < 0 { return; }
  let old: i32 = rt_atomic_i32_fetch_add_raw(el_pending_handle(idx), 1);
  old;
  el_wake_poller();
  return;
}

pub fn wake_wait(token: i64, timeout_ms: i32) -> bool {
  el_init();
  if el_try_consume(token) { return true; }
  if timeout_ms <= 0 { return el_try_consume(token); }
  let deadline: i64 = tm.now_ns() + ((timeout_ms as i64) * (1000 as i64) * (1000 as i64));
  while true {
    if el_try_consume(token) { return true; }
    let rem_ns: i64 = deadline - tm.now_ns();
    if rem_ns <= 0 { return el_try_consume(token); }
    let mut rem_ms: i32 = (rem_ns / ((1000 as i64) * (1000 as i64))) as i32;
    if rem_ms <= 0 { rem_ms = 1; }
    el_wait_poller(rem_ms);
  }
  return el_try_consume(token);
}

pub fn wake_wait_any(tokens: Vec[i64], timeout_ms: i32) -> i32 {
  el_init();
  let n: i32 = tokens.len();
  if n == 0 { return -1; }

  // Non-blocking scan first.
  let mut i: i32 = 0;
  while i < n {
    if el_try_consume(tokens.get(i)) { return i; }
    i = i + 1;
  }
  if timeout_ms <= 0 { return -1; }

  let deadline: i64 = tm.now_ns() + ((timeout_ms as i64) * (1000 as i64) * (1000 as i64));
  while true {
    let rem_ns: i64 = deadline - tm.now_ns();
    if rem_ns <= 0 { return -1; }
    let mut rem_ms: i32 = (rem_ns / ((1000 as i64) * (1000 as i64))) as i32;
    if rem_ms <= 0 { rem_ms = 1; }
    el_wait_poller(rem_ms);

    // Re-scan all tokens after blocking wait.
    let mut j: i32 = 0;
    while j < n {
      if el_try_consume(tokens.get(j)) { return j; }
      j = j + 1;
    }
  }
  return -1;
}
