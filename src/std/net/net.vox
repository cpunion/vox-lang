import "std/string" as s
import "std/sys" as sys

fn is_ascii_alnum(ch: i32) -> bool {
  if ch >= 48 && ch <= 57 { return true; }
  if ch >= 65 && ch <= 90 { return true; }
  if ch >= 97 && ch <= 122 { return true; }
  return false;
}

fn hex_byte(ch: i32) -> String {
  let table: String = "0123456789ABCDEF";
  let hi: i32 = ch / 16;
  let lo: i32 = ch % 16;
  return "%".concat(table.slice(hi, hi + 1)).concat(table.slice(lo, lo + 1));
}

fn parse_decimal(raw: String) -> i32 {
  if raw.len() == 0 { return -1; }
  let mut i: i32 = 0;
  let mut out: i32 = 0;
  while i < raw.len() {
    let ch: i32 = raw.byte_at(i);
    if ch < 48 || ch > 57 { return -1; }
    out = out * 10 + (ch - 48);
    i = i + 1;
  }
  return out;
}

fn trim_left_ws(raw: String) -> String {
  let mut i: i32 = 0;
  while i < raw.len() {
    let ch: i32 = raw.byte_at(i);
    if ch == 32 || ch == 9 {
      i = i + 1;
    } else {
      return raw.slice(i, raw.len());
    }
  }
  return "";
}

fn first_line(text: String) -> String {
  let v: s.StrView = s.view_all(text);
  let crlf: i32 = s.index_of(v, "\r\n");
  if crlf >= 0 { return text.slice(0, crlf); }
  let lf: i32 = s.index_of(v, "\n");
  if lf >= 0 { return text.slice(0, lf); }
  return text;
}

fn line_end_at(text: String, start: i32) -> i32 {
  if start >= text.len() { return text.len(); }
  let rest: String = text.slice(start, text.len());
  let crlf: i32 = s.index_of(s.view_all(rest), "\r\n");
  if crlf >= 0 { return start + crlf; }
  let lf: i32 = s.index_of(s.view_all(rest), "\n");
  if lf >= 0 { return start + lf; }
  return text.len();
}

fn next_line_start(text: String, end: i32) -> i32 {
  if end >= text.len() { return text.len(); }
  if end + 1 < text.len() && text.byte_at(end) == 13 && text.byte_at(end + 1) == 10 {
    return end + 2;
  }
  return end + 1;
}

fn header_section(text: String) -> String {
  let full: s.StrView = s.view_all(text);
  let sep_crlf: i32 = s.index_of(full, "\r\n\r\n");
  if sep_crlf >= 0 { return text.slice(0, sep_crlf); }
  let sep_lf: i32 = s.index_of(full, "\n\n");
  if sep_lf >= 0 { return text.slice(0, sep_lf); }
  return text;
}

pub struct Url {
  pub scheme: String,
  pub host: String,
  pub port: i32,
  pub path: String,
  pub query: String,
}

pub struct QueryItem {
  pub key: String,
  pub value: String,
}

pub struct HttpHeader {
  pub name: String,
  pub value: String,
}

pub struct HttpRequest {
  pub method: String,
  pub host: String,
  pub path: String,
  pub headers: Vec[HttpHeader],
  pub body: String,
}

pub struct HttpResponseHead {
  pub code: i32,
  pub reason: String,
}

pub struct Request {
  pub url: String,
  pub inner: HttpRequest,
}

pub struct RequestResult {
  pub ok: bool,
  pub err: String,
  pub req: Request,
}

pub struct Response {
  pub raw: String,
  pub status: HttpResponseHead,
  pub body: String,
}

pub struct ResponseResult {
  pub ok: bool,
  pub err: String,
  pub resp: Response,
}

pub struct RoundtripResult {
  pub ok: bool,
  pub err: String,
  pub raw: String,
}

pub struct Client {
  recv_limit: i32,
}

pub enum NetProto {
  Tcp,
  Udp,
}

pub struct SocketAddr {
  pub proto: NetProto,
  pub host: String,
  pub port: i32,
}

pub struct SocketAddrParseResult {
  pub ok: bool,
  pub err: String,
  pub addr: SocketAddr,
}

pub struct UdpSocket {
  local: SocketAddr,
}

pub struct NetConn {
  handle: isize,
  closed: bool,
}

pub struct NetI32Result {
  pub ok: bool,
  pub err: String,
  pub n: i32,
}

pub struct NetStringResult {
  pub ok: bool,
  pub err: String,
  pub text: String,
}

pub struct NetBoolResult {
  pub ok: bool,
  pub err: String,
  pub ready: bool,
}

pub struct NetCloseResult {
  pub ok: bool,
  pub err: String,
  pub conn: NetConn,
  pub closed_now: bool,
}

pub struct TcpListener {
  handle: isize,
  closed: bool,
}

fn bad_addr() -> SocketAddr {
  return SocketAddr { proto: NetProto.Tcp, host: "", port: 0 };
}

fn bad_request() -> Request {
  return Request { url: "", inner: http_request("GET", "", "/") };
}

fn bad_response() -> Response {
  return Response { raw: "", status: HttpResponseHead { code: -1, reason: "" }, body: "" };
}

fn net_conn_closed_err() -> String {
  return "net conn is closed";
}

fn net_conn_is_closed0(c: &NetConn) -> bool {
  return c.closed || c.handle < 0;
}

fn net_i32_ok(n: i32) -> NetI32Result {
  return NetI32Result { ok: true, err: "", n: n };
}

fn net_i32_err(err: String) -> NetI32Result {
  return NetI32Result { ok: false, err: err, n: 0 };
}

fn net_string_ok(text: String) -> NetStringResult {
  return NetStringResult { ok: true, err: "", text: text };
}

fn net_string_err(err: String) -> NetStringResult {
  return NetStringResult { ok: false, err: err, text: "" };
}

fn net_bool_ok(ready: bool) -> NetBoolResult {
  return NetBoolResult { ok: true, err: "", ready: ready };
}

fn net_bool_err(err: String) -> NetBoolResult {
  return NetBoolResult { ok: false, err: err, ready: false };
}

fn net_close_ok(conn: NetConn, closed_now: bool) -> NetCloseResult {
  return NetCloseResult { ok: true, err: "", conn: conn, closed_now: closed_now };
}

fn listener_closed(l: &TcpListener) -> bool {
  return l.closed || l.handle < 0;
}

pub fn closed_conn() -> NetConn {
  return NetConn { handle: -1 as isize, closed: true };
}

pub fn net_conn_open(handle: isize) -> NetConn {
  return NetConn { handle: handle, closed: false };
}

pub fn closed_listener() -> TcpListener {
  return TcpListener { handle: -1 as isize, closed: true };
}

pub fn socket_addr(proto: NetProto, host: String, port: i32) -> SocketAddr {
  return SocketAddr { proto: proto, host: host, port: port };
}

pub fn tcp_addr(host: String, port: i32) -> SocketAddr {
  return socket_addr(NetProto.Tcp, host, port);
}

pub fn udp_addr(host: String, port: i32) -> SocketAddr {
  return socket_addr(NetProto.Udp, host, port);
}

fn proto_scheme(proto: NetProto) -> String {
  return match proto {
      .Tcp => "tcp",
      .Udp => "udp",
  };
}

impl SocketAddr {
  fn is_tcp(a: &SocketAddr) -> bool {
    return match a.proto { NetProto.Tcp => true, _ => false };
  }

  fn is_udp(a: &SocketAddr) -> bool {
    return match a.proto { NetProto.Udp => true, _ => false };
  }

  fn uri(a: &SocketAddr) -> String {
    return proto_scheme(a.proto)
      .concat("://")
      .concat(a.host)
      .concat(":")
      .concat(a.port.to_string());
  }

  fn tcp_connect(a: &SocketAddr) -> NetConn {
    if !a.is_tcp() { panic("tcp_connect requires tcp:// address"); }
    let h: isize = sys.connect(a.host, a.port);
    return net_conn_open(h);
  }

  fn listen(a: &SocketAddr, backlog: i32) -> TcpListener {
    if !a.is_tcp() { panic("listen requires tcp:// address"); }
    let h: isize = sys.listen(a.host, a.port, backlog);
    return TcpListener { handle: h, closed: false };
  }

  fn bind_udp(a: SocketAddr) -> UdpSocket {
    if !a.is_udp() { panic("bind_udp requires udp:// address"); }
    return UdpSocket { local: a };
  }
}

pub fn parse_socket_uri(raw: String) -> SocketAddrParseResult {
  let u: Url = parse_url(raw);
  if u.scheme != "tcp" && u.scheme != "udp" {
    return SocketAddrParseResult { ok: false, err: "socket uri scheme must be tcp or udp", addr: bad_addr() };
  }
  if u.host == "" {
    return SocketAddrParseResult { ok: false, err: "socket uri host is empty", addr: bad_addr() };
  }
  if u.port <= 0 {
    return SocketAddrParseResult { ok: false, err: "socket uri port must be > 0", addr: bad_addr() };
  }
  if u.path != "/" && u.path != "" {
    return SocketAddrParseResult { ok: false, err: "socket uri path is not supported", addr: bad_addr() };
  }
  if u.query != "" {
    return SocketAddrParseResult { ok: false, err: "socket uri query is not supported", addr: bad_addr() };
  }
  let proto: NetProto = if u.scheme == "tcp" { NetProto.Tcp } else { NetProto.Udp };
  return SocketAddrParseResult { ok: true, err: "", addr: socket_addr(proto, u.host, u.port) };
}

impl UdpSocket {
  fn local_addr(x: &UdpSocket) -> SocketAddr {
    return x.local;
  }

  fn send_to(_x: &UdpSocket, _to: SocketAddr, _data: String) -> i32 {
    panic("udp send_to is not supported yet");
    return 0;
  }

  fn recv_from(_x: &UdpSocket, _max_n: i32) -> String {
    panic("udp recv_from is not supported yet");
    return "";
  }
}

impl NetConn {
  fn is_closed(c: &NetConn) -> bool {
    return net_conn_is_closed0(c);
  }

  fn try_send(c: &NetConn, text: String) -> NetI32Result {
    if c.is_closed() { return net_i32_err(net_conn_closed_err()); }
    return net_i32_ok(sys.send(c.handle, text, text.len() as usize));
  }

  fn send(c: &NetConn, text: String) -> i32 {
    let r: NetI32Result = c.try_send(text);
    if !r.ok { panic(r.err); }
    return r.n;
  }

  fn try_recv(c: &NetConn, max_n: i32) -> NetStringResult {
    if c.is_closed() { return net_string_err(net_conn_closed_err()); }
    return net_string_ok(sys.recv(c.handle, max_n));
  }

  fn recv(c: &NetConn, max_n: i32) -> String {
    let r: NetStringResult = c.try_recv(max_n);
    if !r.ok { panic(r.err); }
    return r.text;
  }

  fn try_wait_read(c: &NetConn, timeout_ms: i32) -> NetBoolResult {
    if c.is_closed() { return net_bool_err(net_conn_closed_err()); }
    return net_bool_ok(sys.wait_read(c.handle, timeout_ms));
  }

  fn wait_read(c: &NetConn, timeout_ms: i32) -> bool {
    let r: NetBoolResult = c.try_wait_read(timeout_ms);
    if !r.ok { panic(r.err); }
    return r.ready;
  }

  fn try_wait_write(c: &NetConn, timeout_ms: i32) -> NetBoolResult {
    if c.is_closed() { return net_bool_err(net_conn_closed_err()); }
    return net_bool_ok(sys.wait_write(c.handle, timeout_ms));
  }

  fn wait_write(c: &NetConn, timeout_ms: i32) -> bool {
    let r: NetBoolResult = c.try_wait_write(timeout_ms);
    if !r.ok { panic(r.err); }
    return r.ready;
  }

  fn try_close(c0: NetConn) -> NetCloseResult {
    let mut c: NetConn = c0;
    if c.is_closed() {
      c.handle = -1 as isize;
      c.closed = true;
      return net_close_ok(c, false);
    }
    sys.close_socket(c.handle);
    c.handle = -1 as isize;
    c.closed = true;
    return net_close_ok(c, true);
  }

  fn close(c: NetConn) -> NetConn {
    return c.try_close().conn;
  }
}

impl TcpListener {
  fn is_closed(l: &TcpListener) -> bool {
    return listener_closed(l);
  }

  fn close(l0: TcpListener) -> TcpListener {
    let mut l: TcpListener = l0;
    if l.is_closed() {
      l.handle = -1 as isize;
      l.closed = true;
      return l;
    }
    sys.close_socket(l.handle);
    l.handle = -1 as isize;
    l.closed = true;
    return l;
  }

  fn accept(l: &TcpListener) -> NetConn {
    l;
    panic("tcp accept is not supported yet");
    return closed_conn();
  }
}

pub fn default_port(scheme: String) -> i32 {
  if scheme == "https" { return 443; }
  if scheme == "http" { return 80; }
  return 0;
}

pub fn query_item(key: String, value: String) -> QueryItem {
  return QueryItem { key: key, value: value };
}

pub fn query_escape(raw: String) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < raw.len() {
    let ch: i32 = raw.byte_at(i);
    if is_ascii_alnum(ch) || ch == 45 || ch == 46 || ch == 95 || ch == 126 {
      out = out.concat(raw.slice(i, i + 1));
    } else if ch == 32 {
      out = out.concat("+");
    } else {
      out = out.concat(hex_byte(ch));
    }
    i = i + 1;
  }
  return out;
}

pub fn build_query(items: Vec[QueryItem]) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < items.len() {
    let it: QueryItem = items.get(i);
    if i > 0 { out = out.concat("&"); }
    out = out.concat(query_escape(it.key));
    out = out.concat("=");
    out = out.concat(query_escape(it.value));
    i = i + 1;
  }
  return out;
}

pub fn parse_url(raw: String) -> Url {
  let mut scheme: String = "http";
  let mut rest: String = raw;

  let sep: i32 = s.index_of(s.view_all(raw), "://");
  if sep >= 0 {
    scheme = raw.slice(0, sep);
    rest = raw.slice(sep + 3, raw.len());
  }

  let mut cut: i32 = rest.len();
  let slash: i32 = s.index_of(s.view_all(rest), "/");
  let qmark: i32 = s.index_of(s.view_all(rest), "?");
  if slash >= 0 { cut = slash; }
  if qmark >= 0 && qmark < cut { cut = qmark; }

  let authority: String = rest.slice(0, cut);
  let tail: String = rest.slice(cut, rest.len());

  let mut host: String = authority;
  let mut port: i32 = default_port(scheme);
  let colon: i32 = s.last_index_of(s.view_all(authority), ":");
  if colon > 0 {
    let parsed: i32 = parse_decimal(authority.slice(colon + 1, authority.len()));
    if parsed > 0 {
      host = authority.slice(0, colon);
      port = parsed;
    }
  }

  let mut path: String = "/";
  let mut query: String = "";
  if tail.len() > 0 {
    if s.starts_with(s.view_all(tail), "?") {
      query = tail.slice(1, tail.len());
    } else {
      let i: i32 = s.index_of(s.view_all(tail), "?");
      if i >= 0 {
        path = tail.slice(0, i);
        query = tail.slice(i + 1, tail.len());
      } else {
        path = tail;
      }
    }
  }
  if path == "" { path = "/"; }

  return Url {
    scheme: scheme,
    host: host,
    port: port,
    path: path,
    query: query,
  };
}

impl Url {
  fn to_string(u: &Url) -> String {
    let mut out: String = u.scheme.concat("://").concat(u.host);
    let dp: i32 = default_port(u.scheme);
    if u.port > 0 && u.port != dp {
      out = out.concat(":").concat(u.port.to_string());
    }
    out = out.concat(u.path);
    if u.query != "" {
      out = out.concat("?").concat(u.query);
    }
    return out;
  }
}

pub fn http_header(name: String, value: String) -> HttpHeader {
  return HttpHeader { name: name, value: value };
}

fn header_index(headers: Vec[HttpHeader], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < headers.len() {
    if headers.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn ensure_path(path: String) -> String {
  if path == "" { return "/"; }
  if s.starts_with(s.view_all(path), "/") { return path; }
  return "/".concat(path);
}

pub fn http_request(method: String, host: String, path: String) -> HttpRequest {
  return HttpRequest {
    method: method,
    host: host,
    path: ensure_path(path),
    headers: Vec(),
    body: "",
  };
}

impl HttpRequest {
  fn with_header(r: HttpRequest, name: String, value: String) -> HttpRequest {
    let mut out: HttpRequest = r;
    let i: i32 = header_index(out.headers, name);
    let h: HttpHeader = HttpHeader { name: name, value: value };
    if i >= 0 {
      out.headers.set(i, h);
    } else {
      out.headers.push(h);
    }
    return out;
  }

  fn with_body(r: HttpRequest, body: String) -> HttpRequest {
    let mut out: HttpRequest = r;
    out.body = body;
    out = out.with_header("Content-Length", out.body.len().to_string());
    return out;
  }

  fn render(r: HttpRequest) -> String {
    let mut out: String = r.method
      .concat(" ")
      .concat(ensure_path(r.path))
      .concat(" HTTP/1.1\r\n");

    if header_index(r.headers, "Host") < 0 {
      out = out.concat("Host: ").concat(r.host).concat("\r\n");
    }

    let mut i: i32 = 0;
    while i < r.headers.len() {
      let h: HttpHeader = r.headers.get(i);
      out = out.concat(h.name).concat(": ").concat(h.value).concat("\r\n");
      i = i + 1;
    }

    if r.body.len() > 0 && header_index(r.headers, "Content-Length") < 0 {
      out = out.concat("Content-Length: ").concat(r.body.len().to_string()).concat("\r\n");
    }

    out = out.concat("\r\n");
    if r.body.len() > 0 {
      out = out.concat(r.body);
    }
    return out;
  }
}

pub fn new_request(method: String, url: String) -> RequestResult {
  let u: Url = parse_url(url);
  if u.host == "" {
    return RequestResult { ok: false, err: "request url host is empty", req: bad_request() };
  }
  if u.port <= 0 {
    return RequestResult { ok: false, err: "request url port must be > 0", req: bad_request() };
  }

  let mut path: String = u.path;
  if u.query != "" {
    path = path.concat("?").concat(u.query);
  }
  let req: HttpRequest = http_request(method, u.host, path);
  return RequestResult { ok: true, err: "", req: Request { url: url, inner: req } };
}

pub fn request(method: String, url: String) -> Request {
  let rr: RequestResult = new_request(method, url);
  if !rr.ok { panic(rr.err); }
  return rr.req;
}

impl Request {
  fn with_header(r: Request, name: String, value: String) -> Request {
    let mut out: Request = r;
    out.inner = out.inner.with_header(name, value);
    return out;
  }

  fn with_body(r: Request, body: String) -> Request {
    let mut out: Request = r;
    out.inner = out.inner.with_body(body);
    return out;
  }

  fn render(r: &Request) -> String {
    return r.inner.render();
  }
}

pub fn parse_status(resp: String) -> HttpResponseHead {
  let line: String = first_line(resp);
  let first_sp: i32 = s.index_of(s.view_all(line), " ");
  if first_sp < 0 {
    return HttpResponseHead { code: -1, reason: "" };
  }
  let rest: String = line.slice(first_sp + 1, line.len());
  let second_sp: i32 = s.index_of(s.view_all(rest), " ");
  if second_sp < 0 {
    let only_code: i32 = parse_decimal(rest);
    return HttpResponseHead { code: only_code, reason: "" };
  }
  let code: i32 = parse_decimal(rest.slice(0, second_sp));
  let reason: String = rest.slice(second_sp + 1, rest.len());
  return HttpResponseHead { code: code, reason: reason };
}

pub fn response_from_raw(raw: String) -> Response {
  return Response {
    raw: raw,
    status: parse_status(raw),
    body: response_body(raw),
  };
}

impl Response {
  fn status_code(r: &Response) -> i32 {
    return r.status.code;
  }

  fn reason(r: &Response) -> String {
    return r.status.reason;
  }

  fn header(r: &Response, name: String) -> String {
    return header_value(r.raw, name);
  }
}

pub fn parse_status_code(resp: String) -> i32 {
  return parse_status(resp).code;
}

pub fn response_body(resp: String) -> String {
  let v: s.StrView = s.view_all(resp);
  let sep_crlf: i32 = s.index_of(v, "\r\n\r\n");
  if sep_crlf >= 0 { return resp.slice(sep_crlf + 4, resp.len()); }
  let sep_lf: i32 = s.index_of(v, "\n\n");
  if sep_lf >= 0 { return resp.slice(sep_lf + 2, resp.len()); }
  return "";
}

pub fn header_value(resp: String, name: String) -> String {
  let head: String = header_section(resp);
  let prefix: String = name.concat(":");
  let mut at: i32 = 0;
  while at < head.len() {
    let end: i32 = line_end_at(head, at);
    let line: String = head.slice(at, end);
    if s.starts_with(s.view_all(line), prefix) {
      return trim_left_ws(line.slice(prefix.len(), line.len()));
    }
    at = next_line_start(head, end);
  }
  return "";
}

pub fn http_roundtrip_checked(url: String, req: HttpRequest, recv_limit: i32) -> RoundtripResult {
  if recv_limit <= 0 {
    return RoundtripResult { ok: false, err: "recv_limit must be > 0", raw: "" };
  }

  let u: Url = parse_url(url);
  if u.host == "" {
    return RoundtripResult { ok: false, err: "http url host is empty", raw: "" };
  }
  if u.port <= 0 {
    return RoundtripResult { ok: false, err: "http url port must be > 0", raw: "" };
  }
  let mut out_req: HttpRequest = req;

  if out_req.host == "" {
    out_req.host = u.host;
  }

  if out_req.path == "" || out_req.path == "/" {
    out_req.path = u.path;
    if u.query != "" {
      out_req.path = out_req.path.concat("?").concat(u.query);
    }
  }

  let addr: SocketAddr = tcp_addr(u.host, u.port);
  let mut conn: NetConn = addr.tcp_connect();
  let raw: String = out_req.render();
  conn.send(raw);
  let resp: String = conn.recv(recv_limit);
  conn = conn.close();
  return RoundtripResult { ok: true, err: "", raw: resp };
}

pub fn http_roundtrip(url: String, req: HttpRequest, recv_limit: i32) -> String {
  let rr: RoundtripResult = http_roundtrip_checked(url, req, recv_limit);
  if !rr.ok { panic(rr.err); }
  return rr.raw;
}

pub fn client() -> Client {
  return Client { recv_limit: 8192 };
}

impl Client {
  fn with_recv_limit(c: Client, recv_limit: i32) -> Client {
    let mut out: Client = c;
    out.recv_limit = recv_limit;
    return out;
  }

  fn recv_limit(c: &Client) -> i32 {
    return c.recv_limit;
  }

  fn try_send(c: &Client, req: Request) -> ResponseResult {
    let rr: RoundtripResult = http_roundtrip_checked(req.url, req.inner, c.recv_limit);
    if !rr.ok {
      return ResponseResult { ok: false, err: rr.err, resp: bad_response() };
    }
    return ResponseResult { ok: true, err: "", resp: response_from_raw(rr.raw) };
  }

  fn send(c: &Client, req: Request) -> Response {
    let rr: ResponseResult = c.try_send(req);
    if !rr.ok { panic(rr.err); }
    return rr.resp;
  }

  fn try_get(c: &Client, url: String) -> ResponseResult {
    let rq: RequestResult = new_request("GET", url);
    if !rq.ok {
      return ResponseResult { ok: false, err: rq.err, resp: bad_response() };
    }
    let req: Request = rq.req.with_header("Connection", "close");
    return c.try_send(req);
  }

  fn get(c: &Client, url: String) -> Response {
    let rr: ResponseResult = c.try_get(url);
    if !rr.ok { panic(rr.err); }
    return rr.resp;
  }
}

pub fn http_get(url: String, recv_limit: i32) -> String {
  let c: Client = client().with_recv_limit(recv_limit);
  let r: Response = c.get(url);
  return r.raw;
}
