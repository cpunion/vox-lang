import "std/testing" as t
import "std/net" as net

fn test_url_parse_and_format_smoke() -> () {
  let u: net.Url = net.parse_url("https://api.example.com:8443/v1/chat?model=vox");
  t.assert_eq(u.scheme, "https");
  t.assert_eq(u.host, "api.example.com");
  t.assert_eq(u.port, 8443);
  t.assert_eq(u.path, "/v1/chat");
  t.assert_eq(u.query, "model=vox");

  t.assert_eq(u.to_string(), "https://api.example.com:8443/v1/chat?model=vox");
}

fn test_url_parse_default_port_and_query_only_smoke() -> () {
  let u0: net.Url = net.parse_url("http://a.io");
  t.assert_eq(u0.port, 80);
  t.assert_eq(u0.path, "/");

  let u1: net.Url = net.parse_url("https://a.io?x=1");
  t.assert_eq(u1.port, 443);
  t.assert_eq(u1.path, "/");
  t.assert_eq(u1.query, "x=1");
}

fn test_query_escape_and_build_smoke() -> () {
  t.assert_eq(net.query_escape("vox lang"), "vox+lang");

  let mut qs: Vec[net.QueryItem] = Vec();
  qs.push(net.query_item("q", "vox lang"));
  qs.push(net.query_item("page", "1"));
  t.assert_eq(net.build_query(qs), "q=vox+lang&page=1");
}

fn test_http_request_render_smoke() -> () {
  let mut req: net.HttpRequest = net.http_request("POST", "example.com", "/v1/run");
  req = req.with_header("Content-Type", "application/json");
  req = req.with_body("{\"ok\":true}");

  let text: String = req.render();
  t.assert(net.parse_status_code("HTTP/1.1 200 OK\r\n\r\n") == 200);
  t.assert(net.header_value(text, "Host") == "example.com");
  t.assert(net.header_value(text, "Content-Length") == "11");
}

fn test_http_response_helpers_smoke() -> () {
  let raw: String = "HTTP/1.1 404 Not Found\r\nContent-Type: text/plain\r\n\r\nmissing";
  let st: net.HttpResponseHead = net.parse_status(raw);
  t.assert_eq(st.code, 404);
  t.assert_eq(st.reason, "Not Found");
  t.assert_eq(net.response_body(raw), "missing");
  t.assert_eq(net.header_value(raw, "Content-Type"), "text/plain");
}

fn test_socket_addr_uri_and_parse_smoke() -> () {
  let a: net.SocketAddr = net.tcp_addr("127.0.0.1", 9000);
  t.assert(a.is_tcp());
  t.assert(!a.is_udp());
  let u: String = a.uri();
  t.assert_eq(u, "tcp://127.0.0.1:9000");
  t.assert_eq(a.uri(), "tcp://127.0.0.1:9000");

  let pr: net.SocketAddrParseResult = net.parse_socket_uri(u);
  t.assert(pr.ok);
  t.assert(pr.addr.is_tcp());
  t.assert_eq(pr.addr.host, "127.0.0.1");
  t.assert_eq(pr.addr.port, 9000);

  let b: net.SocketAddr = net.udp_addr("localhost", 53);
  t.assert(b.is_udp());
  t.assert_eq(b.uri(), "udp://localhost:53");
  let s: net.UdpSocket = b.bind_udp();
  let l: net.SocketAddr = s.local_addr();
  t.assert(l.is_udp());
  t.assert_eq(l.host, "localhost");
  t.assert_eq(l.port, 53);
}

fn test_socket_addr_parse_error_smoke() -> () {
  let bad_scheme: net.SocketAddrParseResult = net.parse_socket_uri("http://x:1");
  t.assert(!bad_scheme.ok);
  t.assert(net.parse_socket_uri("tcp://x").ok == false);
  t.assert(net.parse_socket_uri("udp://").ok == false);
  t.assert(net.parse_socket_uri("tcp://x:3/path").ok == false);
  t.assert(net.parse_socket_uri("udp://x:53?q=1").ok == false);
}

fn test_request_response_api_smoke() -> () {
  let rq: net.RequestResult = net.new_request("POST", "https://api.example.com/v1/run?q=1");
  t.assert(rq.ok);
  let mut req: net.Request = rq.req;
  req = req.with_header("Content-Type", "application/json");
  req = req.with_body("{\"ok\":true}");
  let raw_req: String = req.render();
  t.assert(net.header_value(raw_req, "Host") == "api.example.com");
  t.assert(net.header_value(raw_req, "Content-Length") == "11");

  let raw_resp: String = "HTTP/1.1 201 Created\r\nX-Req: abc\r\n\r\nok";
  let resp: net.Response = net.response_from_raw(raw_resp);
  t.assert_eq(resp.status_code(), 201);
  t.assert_eq(resp.reason(), "Created");
  t.assert_eq(resp.body, "ok");
  t.assert_eq(resp.header("X-Req"), "abc");
}

fn test_request_and_client_error_result_smoke() -> () {
  let bad_req: net.RequestResult = net.new_request("GET", "http://");
  t.assert(!bad_req.ok);
  t.assert(bad_req.err != "");

  let c: net.Client = net.client().with_recv_limit(64);
  t.assert_eq(c.recv_limit(), 64);
  let bad_resp: net.ResponseResult = c.try_get("http://");
  t.assert(!bad_resp.ok);
  t.assert(bad_resp.err != "");
}

fn test_net_closed_conn_checked_api_smoke() -> () {
  let mut c0: net.NetConn = net.closed_conn();
  t.assert(c0.is_closed());

  let s0: net.NetI32Result = c0.try_send("x");
  t.assert(!s0.ok);
  t.assert_eq(s0.err, "net conn is closed");

  let r0: net.NetStringResult = c0.try_recv(8);
  t.assert(!r0.ok);
  t.assert_eq(r0.err, "net conn is closed");

  let rd: net.NetBoolResult = c0.try_wait_read(1);
  t.assert(!rd.ok);
  t.assert_eq(rd.err, "net conn is closed");

  let wr: net.NetBoolResult = c0.try_wait_write(1);
  t.assert(!wr.ok);
  t.assert_eq(wr.err, "net conn is closed");

  let c1r: net.NetCloseResult = c0.try_close();
  t.assert(c1r.ok);
  t.assert(!c1r.closed_now);
  c0 = c1r.conn;
  t.assert(c0.is_closed());

  let c2: net.NetConn = c0.close();
  t.assert(c2.is_closed());
}

fn test_net_closed_conn_method_style_smoke() -> () {
  let c0: net.NetConn = net.closed_conn();
  t.assert(c0.is_closed());

  let s0: net.NetI32Result = c0.try_send("x");
  t.assert(!s0.ok);
  t.assert_eq(s0.err, "net conn is closed");

  let r0: net.NetStringResult = c0.try_recv(4);
  t.assert(!r0.ok);
  t.assert_eq(r0.err, "net conn is closed");

  let c1r: net.NetCloseResult = c0.try_close();
  t.assert(c1r.ok);
  t.assert(!c1r.closed_now);

  let c2: net.NetConn = c1r.conn.close();
  t.assert(c2.is_closed());
}
