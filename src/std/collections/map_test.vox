import "std/testing" as t
import "std/collections" as c

fn test_map_set_contains_len_smoke() -> () {
  let mut m: c.Map[String, i32] = c.map();
  t.assert(m.is_empty());

  m = m.set("a", 1);
  m = m.set("b", 2);
  t.assert_eq(m.len(), 2);
  t.assert(!m.is_empty());
  t.assert(m.contains_key("a"));
  t.assert(m.contains_key("b"));
  t.assert(!m.contains_key("x"));
  t.assert_eq(m.index_of_key("a"), 0);
  t.assert_eq(m.index_of_key("b"), 1);
  t.assert_eq(m.index_of_key("x"), -1);
}

fn test_map_set_overwrite_preserves_keyset_smoke() -> () {
  let mut m: c.Map[i32, String] = c.map();
  m = m.set(7, "old");
  m = m.set(7, "new");
  t.assert_eq(m.len(), 1);
  t.assert(m.contains_key(7));
  t.assert_eq(m.index_of_key(7), 0);
}

fn test_map_remove_smoke() -> () {
  let mut m: c.Map[i32, i32] = c.map();
  m = m.set(1, 10);
  m = m.set(2, 20);
  m = m.remove(1);
  t.assert_eq(m.len(), 1);
  t.assert(!m.contains_key(1));
  t.assert(m.contains_key(2));

  m = m.remove(9);
  t.assert_eq(m.len(), 1);
}

fn test_map_index_of_key_smoke() -> () {
  let mut m: c.Map[String, i32] = c.map();
  m = m.set("x", 7);
  m = m.set("y", 9);
  t.assert_eq(m.index_of_key("x"), 0);
  t.assert_eq(m.index_of_key("y"), 1);
  t.assert_eq(m.index_of_key("z"), -1);
}

fn test_map_clear_smoke() -> () {
  let mut m: c.Map[i32, String] = c.map();
  m = m.set(1, "a");
  m = m.set(2, "b");
  t.assert_eq(m.len(), 2);

  m = m.clear();
  t.assert(m.is_empty());
  t.assert_eq(m.len(), 0);
}

fn test_map_method_style_smoke() -> () {
  let mut m: c.Map[String, i32] = c.map();
  m = m.set("a", 1);
  m = m.set("b", 2);
  t.assert_eq(m.len(), 2);
  t.assert(!m.is_empty());
  t.assert(m.contains_key("a"));
  t.assert_eq(m.index_of_key("b"), 1);
  t.assert_eq(m.get("a"), 1);
  t.assert_eq(m.get_or("missing", 7), 7);

  let ks: Vec[String] = m.keys();
  let vs: Vec[i32] = m.values();
  t.assert_eq(ks.get(0), "a");
  t.assert_eq(vs.get(1), 2);

  m = m.remove("a");
  t.assert_eq(m.len(), 1);
  t.assert(!m.contains_key("a"));
  m = m.clear();
  t.assert(m.is_empty());
}

fn test_map_set_overwrite_updates_value_smoke() -> () {
  let mut m: c.Map[i32, String] = c.map();
  m = m.set(7, "old");
  m = m.set(7, "new");
  t.assert_eq(m.len(), 1);
  t.assert_eq(m.get(7), "new");
}

fn test_map_remove_preserves_parallel_order_smoke() -> () {
  let mut m: c.Map[i32, String] = c.map();
  m = m.set(1, "a");
  m = m.set(2, "b");
  m = m.set(3, "c");
  m = m.remove(2);

  let ks: Vec[i32] = m.keys();
  let vs: Vec[String] = m.values();
  t.assert_eq(ks.len(), 2);
  t.assert_eq(vs.len(), 2);
  t.assert_eq(ks.get(0), 1);
  t.assert_eq(vs.get(0), "a");
  t.assert_eq(ks.get(1), 3);
  t.assert_eq(vs.get(1), "c");
}

fn test_map_clone_deep_smoke() -> () {
  let mut m: c.Map[i32, String] = c.map();
  m = m.set(1, "a");
  m = m.set(2, "b");

  let mut cp: c.Map[i32, String] = Clone.clone(m);
  cp = cp.set(1, "x");
  cp = cp.remove(2);

  t.assert_eq(m.get(1), "a");
  t.assert(m.contains_key(2));
  t.assert_eq(cp.get(1), "x");
  t.assert(!cp.contains_key(2));
}

fn test_map_release_alias_safe_smoke() -> () {
  let mut m: c.Map[i32, String] = c.map();
  m = m.set(1, "a");
  m = m.set(2, "b");
  let keep: c.Map[i32, String] = m;

  m = m.release();

  t.assert(m.is_empty());
  t.assert_eq(m.len(), 0);
  t.assert(keep.contains_key(1));
  t.assert(keep.contains_key(2));
  t.assert_eq(keep.get(1), "a");
}
