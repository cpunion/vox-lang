fn panic_queue_empty() -> () { panic("Queue is empty"); }

pub struct Queue[T] {
  data: Vec[T],
  head: i32,
}

pub fn queue[T]() -> Queue[T] {
  return Queue { data: Vec(), head: 0 };
}

impl[T] Queue[T] {
  fn len(q: Queue[T]) -> i32 { return q.data.len() - q.head; }

  fn is_empty(q: Queue[T]) -> bool { return q.data.len() == q.head; }

  fn push(q: Queue[T], v: T) -> Queue[T] {
    let mut out = q;
    out.data.push(v);
    return out;
  }

  fn front(q: Queue[T]) -> T {
    if q.data.len() == q.head {
      panic_queue_empty();
      // Unreachable, keeps type checker satisfied.
      return q.data.get(0);
    }
    return q.data.get(q.head);
  }

  fn pop(q: Queue[T]) -> Queue[T] {
    let mut out = q;
    if out.data.len() == out.head {
      panic_queue_empty();
      return out;
    }
    out.head = out.head + 1;
    if out.head > 0 && out.head * 2 >= out.data.len() {
      let mut compact: Vec[T] = Vec();
      let mut i: i32 = out.head;
      while i < out.data.len() {
        compact.push(out.data.get(i));
        i = i + 1;
      }
      out.data = compact;
      out.head = 0;
    }
    return out;
  }

  fn clear(_q: Queue[T]) -> Queue[T] { return Queue { data: Vec(), head: 0 }; }

  fn to_vec(q: Queue[T]) -> Vec[T] {
    let mut out: Vec[T] = Vec();
    let mut i: i32 = q.head;
    while i < q.data.len() {
      out.push(q.data.get(i));
      i = i + 1;
    }
    return out;
  }

  fn release(_q: Queue[T]) -> Queue[T] { return Queue { data: Vec(), head: 0 }; }
}

pub fn queue_contains[T: Eq](q: Queue[T], v: T) -> bool {
  let mut i: i32 = q.head;
  while i < q.data.len() {
    if q.data.get(i) == v { return true; }
    i = i + 1;
  }
  return false;
}

impl[T: Clone] Clone for Queue[T] {
  fn clone(q: Queue[T]) -> Queue[T] {
    let mut out: Vec[T] = Vec();
    let mut i: i32 = q.head;
    while i < q.data.len() {
      out.push(Clone.clone(q.data.get(i)));
      i = i + 1;
    }
    return Queue { data: out, head: 0 };
  }
}

impl[T] Release for Queue[T] {
  fn release(_q: Queue[T]) -> Queue[T] { return Queue { data: Vec(), head: 0 }; }
}
