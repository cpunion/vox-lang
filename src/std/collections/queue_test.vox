import "std/testing" as t
import "std/collections" as c

fn test_queue_push_front_pop_smoke() -> () {
  let mut q: c.Queue[i32] = c.queue();
  q = q.push(10);
  q = q.push(20);
  q = q.push(30);
  t.assert_eq(q.len(), 3);
  t.assert_eq(q.front(), 10);

  q = q.pop();
  t.assert_eq(q.front(), 20);
  t.assert_eq(q.len(), 2);

  q = q.pop();
  q = q.pop();
  t.assert(q.is_empty());
}

fn test_queue_to_vec_and_contains_smoke() -> () {
  let mut q: c.Queue[i32] = c.queue();
  q = q.push(10);
  q = q.push(20);
  q = q.push(30);
  q = q.pop();

  let xs: Vec[i32] = Clone.clone(q).to_vec();
  t.assert_eq(xs.len(), 2);
  t.assert_eq(xs.get(0), 20);
  t.assert_eq(xs.get(1), 30);

  t.assert(c.queue_contains(Clone.clone(q), 20));
  t.assert(!c.queue_contains(q, 10));
}

fn test_queue_contains_method_style_smoke() -> () {
  let mut q0: c.Queue[i32] = c.queue();
  q0 = q0.push(1);
  q0 = q0.push(2);
  q0 = q0.push(3);
  q0 = q0.pop();
  t.assert(q0.contains(2));

  let mut q1: c.Queue[i32] = c.queue();
  q1 = q1.push(1);
  q1 = q1.push(2);
  q1 = q1.push(3);
  q1 = q1.pop();
  t.assert(!q1.contains(1));
}

fn test_queue_clone_and_release_alias_safe_smoke() -> () {
  let mut q: c.Queue[i32] = c.queue();
  q = q.push(10);
  q = q.push(20);
  q = q.push(30);
  let mut cpy: c.Queue[i32] = Clone.clone(q);

  q = q.pop();
  q = q.push(40);

  t.assert_eq(cpy.front(), 10);
  cpy = cpy.pop();
  t.assert_eq(cpy.front(), 20);
  t.assert_eq(q.front(), 20);

  let keep: c.Queue[i32] = q;
  q = q.release();
  t.assert(q.is_empty());
  t.assert_eq(keep.len(), 3);
}

fn test_queue_compact_path_smoke() -> () {
  let mut q: c.Queue[i32] = c.queue();
  let mut i: i32 = 0;
  while i < 8 {
    q = q.push(i);
    i = i + 1;
  }
  i = 0;
  while i < 6 {
    q = q.pop();
    i = i + 1;
  }

  // Internal compact should keep logical order correct.
  t.assert_eq(q.len(), 2);
  t.assert_eq(q.front(), 6);
  q = q.pop();
  t.assert_eq(q.front(), 7);
}
