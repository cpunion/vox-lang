fn panic_key_not_found() -> () { panic("Map key not found"); }

fn map_find_idx[K: Eq](keys: Vec[K], key: K) -> i32 {
  let mut i: i32 = 0;
  let n: i32 = keys.len();
  while i < n {
    if keys.get(i) == key { return i; }
    i = i + 1;
  }
  return 0 - 1;
}

fn vec_copy[T](xs: Vec[T]) -> Vec[T] {
  let mut out: Vec[T] = Vec();
  let mut i: i32 = 0;
  let n: i32 = xs.len();
  while i < n {
    out.push(xs.get(i));
    i = i + 1;
  }
  return out;
}

pub struct Map[K, V] {
  keys: Vec[K],
  vals: Vec[V],
}

pub struct MapGetOrSetResult[K, V] {
  pub map: Map[K, V],
  pub value: V,
  pub inserted: bool,
}

impl[K: Eq, V] Map[K, V] {
  fn len(x: Map[K, V]) -> i32 { return x.keys.len(); }
  fn is_empty(x: Map[K, V]) -> bool { return x.keys.len() == 0; }

  fn index_of_key(x: Map[K, V], key: K) -> i32 {
    return map_find_idx(x.keys, key);
  }

  fn contains_key(x: Map[K, V], key: K) -> bool {
    return map_find_idx(x.keys, key) >= 0;
  }

  fn get(x: Map[K, V], key: K) -> V {
    let i: i32 = map_find_idx(x.keys, key);
    if i < 0 {
      panic_key_not_found();
      // Unreachable at runtime; keeps IR builder happy for generic return type.
      return x.vals.get(0);
    }
    return x.vals.get(i);
  }

  fn get_or(x: Map[K, V], key: K, fallback: V) -> V {
    let i: i32 = map_find_idx(x.keys, key);
    if i < 0 { return fallback; }
    return x.vals.get(i);
  }

  fn keys(x: Map[K, V]) -> Vec[K] {
    let mut out: Vec[K] = Vec();
    let mut i: i32 = 0;
    let n: i32 = x.keys.len();
    while i < n {
      out.push(x.keys.get(i));
      i = i + 1;
    }
    return out;
  }

  fn values(x: Map[K, V]) -> Vec[V] {
    let mut out: Vec[V] = Vec();
    let mut i: i32 = 0;
    let n: i32 = x.vals.len();
    while i < n {
      out.push(x.vals.get(i));
      i = i + 1;
    }
    return out;
  }

  // Bootstrap-safe path: only rely on Vec.push/len/get for bootstrap compatibility.
  fn set(x: Map[K, V], key: K, val: V) -> Map[K, V] {
    let mut out = x;
    let i: i32 = map_find_idx(out.keys, key);
    if i >= 0 {
      // In-place update avoids allocating/copying the whole values vector.
      out.vals.set(i, val);
      return out;
    }
    out.keys.push(key);
    out.vals.push(val);
    return out;
  }

  fn set_if_absent(x: Map[K, V], key: K, val: V) -> Map[K, V] {
    let mut out = x;
    let i: i32 = map_find_idx(out.keys, key);
    if i >= 0 { return out; }
    out.keys.push(key);
    out.vals.push(val);
    return out;
  }

  fn get_or_set(x: Map[K, V], key: K, fallback: V) -> MapGetOrSetResult[K, V] {
    let mut out = x;
    let i: i32 = map_find_idx(out.keys, key);
    if i >= 0 {
      return MapGetOrSetResult { map: out, value: out.vals.get(i), inserted: false };
    }
    out.keys.push(key);
    out.vals.push(fallback);
    return MapGetOrSetResult { map: out, value: fallback, inserted: true };
  }

  fn clear(_x: Map[K, V]) -> Map[K, V] {
    return Map { keys: Vec(), vals: Vec() };
  }

  fn release(_x: Map[K, V]) -> Map[K, V] { return Map { keys: Vec(), vals: Vec() }; }

  fn remove(x: Map[K, V], key: K) -> Map[K, V] {
    let mut out = x;
    let i: i32 = map_find_idx(out.keys, key);
    if i < 0 { return out; }
    // Remove in place keeps behavior while reducing per-call copy cost.
    out.keys.remove(i);
    out.vals.remove(i);
    return out;
  }
}

impl[K: Eq, V] Clone for Map[K, V] {
  fn clone(x: Map[K, V]) -> Map[K, V] {
    return Map { keys: vec_copy(x.keys), vals: vec_copy(x.vals) };
  }
}

pub fn map[K, V]() -> Map[K, V] {
  return Map { keys: Vec(), vals: Vec() };
}

impl[K: Eq, V] Release for Map[K, V] {
  fn release(x: Map[K, V]) -> Map[K, V] {
    return Map { keys: Vec(), vals: Vec() };
  }
}
