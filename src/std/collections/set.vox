fn set_find_idx[T: Eq](items: Vec[T], v: T) -> i32 {
  let mut i: i32 = 0;
  while i < items.len() {
    if items.get(i) == v { return i; }
    i = i + 1;
  }
  return -1;
}

pub struct Set[T: Eq] {
  items: Vec[T],
}

pub fn set[T: Eq]() -> Set[T] {
  return Set { items: Vec() };
}

impl[T: Eq] Set[T] {
  fn len(s: Set[T]) -> i32 { return s.items.len(); }

  fn is_empty(s: Set[T]) -> bool { return s.items.len() == 0; }

  fn contains(s: Set[T], v: T) -> bool { return set_find_idx(s.items, v) >= 0; }

  fn add(s: Set[T], v: T) -> Set[T] {
    let mut out = s;
    if set_find_idx(out.items, v) >= 0 { return out; }
    out.items.push(v);
    return out;
  }

  fn remove(s: Set[T], v: T) -> Set[T] {
    let mut out = s;
    let idx = set_find_idx(out.items, v);
    if idx < 0 { return out; }
    out.items.remove(idx);
    return out;
  }

  fn add_all(s: Set[T], xs: Vec[T]) -> Set[T] {
    let mut out = s;
    let mut i: i32 = 0;
    while i < xs.len() {
      let v = xs.get(i);
      if set_find_idx(out.items, v) < 0 {
        out.items.push(v);
      }
      i = i + 1;
    }
    return out;
  }

  fn contains_all(s: Set[T], xs: Vec[T]) -> bool {
    let mut i: i32 = 0;
    while i < xs.len() {
      if set_find_idx(s.items, xs.get(i)) < 0 { return false; }
      i = i + 1;
    }
    return true;
  }

  fn clear(_s: Set[T]) -> Set[T] { return Set { items: Vec() }; }

  fn values(s: Set[T]) -> Vec[T] {
    let mut out: Vec[T] = Vec();
    let mut i: i32 = 0;
    while i < s.items.len() {
      out.push(s.items.get(i));
      i = i + 1;
    }
    return out;
  }

  fn release(_s: Set[T]) -> Set[T] { return Set { items: Vec() }; }
}

impl[T: Eq + Clone] Clone for Set[T] {
  fn clone(s: Set[T]) -> Set[T] {
    let mut out: Vec[T] = Vec();
    let mut i: i32 = 0;
    while i < s.items.len() {
      out.push(Clone.clone(s.items.get(i)));
      i = i + 1;
    }
    return Set { items: out };
  }
}

impl[T: Eq] Release for Set[T] {
  fn release(_s: Set[T]) -> Set[T] { return Set { items: Vec() }; }
}
