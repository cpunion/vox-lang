@build(linux)
@ffi_import("c", "read")
fn c_read(fd: i32, buf: rawptr, n: usize) -> isize;

@ffi_import("c", "open")
fn c_open(path: String, flags: i32) -> i32;

pub fn open_read(path: String) -> i32 {
  // O_RDONLY = 0 on POSIX.
  return c_open(path, 0);
}

pub fn read(fd: i32, buf: rawptr, n: usize) -> isize {
  return c_read(fd, buf, n);
}

@ffi_import("c", "write")
fn c_write(fd: i32, buf: const rawptr, n: usize) -> isize;

pub fn write(fd: i32, buf: const rawptr, n: usize) -> isize {
  return c_write(fd, buf, n);
}

@ffi_import("c", "sched_yield")
fn c_sched_yield() -> i32;

pub fn yield_now() -> () {
  let _rc: i32 = c_sched_yield();
  _rc;
  return;
}

@ffi_import("c", "send")
fn c_send(fd: i32, buf: const rawptr, n: usize, flags: i32) -> isize;

fn handle_to_fd(h: isize) -> i32 {
  if h < -2147483648 as isize || h > 2147483647 as isize {
    panic("sys socket handle out of i32 range");
  }
  return h as i32;
}

pub fn socket_send(handle: isize, buf: String, n: usize) -> isize {
  let fd: i32 = handle_to_fd(handle);
  return c_send(fd, buf as const rawptr, n, 0);
}

@ffi_import("c", "recv")
fn c_recv(fd: i32, buf: rawptr, len: usize, flags: i32) -> isize;

pub fn connect(host: String, port: i32) -> isize {
  if port <= 0 || port > 65535 { panic("invalid tcp port"); }
  let port_str: String = port.to_string();
  let hints: rawptr = calloc(1 as usize, ADDRINFO_SIZE() as usize);
  @ptr_write[i32](@ptr_offset(hints, ADDRINFO_OFF_SOCKTYPE()), SOCK_STREAM());
  let res_buf: rawptr = calloc(1 as usize, 8 as usize);
  let rc: i32 = sock_getaddrinfo(host, port_str, hints, res_buf);
  free(hints);
  if rc != 0 {
    free(res_buf);
    panic("tcp connect resolve failed");
  }
  let res: isize = @ptr_read[isize](res_buf);
  free(res_buf);
  if res == (0 as isize) { panic("tcp connect resolve failed"); }
  let mut fd: i32 = -1;
  let mut p: isize = res;
  while p != (0 as isize) {
    let pp: rawptr = p as rawptr;
    let family: i32 = @ptr_read[i32](@ptr_offset(pp, ADDRINFO_OFF_FAMILY()));
    let socktype: i32 = @ptr_read[i32](@ptr_offset(pp, ADDRINFO_OFF_SOCKTYPE()));
    let protocol: i32 = @ptr_read[i32](@ptr_offset(pp, ADDRINFO_OFF_PROTOCOL()));
    let addrlen: u32 = @ptr_read[u32](@ptr_offset(pp, ADDRINFO_OFF_ADDRLEN()));
    let addr: rawptr = (@ptr_read[isize](@ptr_offset(pp, ADDRINFO_OFF_ADDR()))) as rawptr;
    fd = sock_socket(family, socktype, protocol);
    if fd >= 0 {
      if sock_connect(fd, addr, addrlen) == 0 {
        sock_freeaddrinfo(res as rawptr);
        return fd as isize;
      }
      c_close(fd);
      fd = -1;
    }
    p = @ptr_read[isize](@ptr_offset(pp, ADDRINFO_OFF_NEXT()));
  }
  sock_freeaddrinfo(res as rawptr);
  panic("tcp connect failed");
  return -1 as isize;
}

pub fn listen(host: String, port: i32, backlog: i32) -> isize {
  if port < 0 || port > 65535 { panic("invalid tcp port"); }
  let bind_host: String = if host == "" { "0.0.0.0" } else { host };
  let bk: i32 = if backlog <= 0 { 16 } else { backlog };
  let port_str: String = port.to_string();
  let hints: rawptr = calloc(1 as usize, ADDRINFO_SIZE() as usize);
  if (hints as isize) == (0 as isize) { panic("tcp listen alloc hints failed"); }
  @ptr_write[i32](@ptr_offset(hints, ADDRINFO_OFF_SOCKTYPE()), SOCK_STREAM());
  @ptr_write[i32](@ptr_offset(hints, ADDRINFO_OFF_PROTOCOL()), IPPROTO_TCP());
  let res_buf: rawptr = calloc(1 as usize, 8 as usize);
  if (res_buf as isize) == (0 as isize) {
    free(hints);
    panic("tcp listen alloc result buffer failed");
  }
  let rc: i32 = sock_getaddrinfo(bind_host, port_str, hints, res_buf);
  free(hints);
  if rc != 0 {
    free(res_buf);
    panic("tcp listen resolve failed");
  }
  let res: isize = @ptr_read[isize](res_buf);
  free(res_buf);
  if res == (0 as isize) { panic("tcp listen resolve failed"); }
  let mut fd: i32 = -1;
  let mut p: isize = res;
  while p != (0 as isize) {
    let pp: rawptr = p as rawptr;
    let family: i32 = @ptr_read[i32](@ptr_offset(pp, ADDRINFO_OFF_FAMILY()));
    let socktype: i32 = @ptr_read[i32](@ptr_offset(pp, ADDRINFO_OFF_SOCKTYPE()));
    let protocol: i32 = @ptr_read[i32](@ptr_offset(pp, ADDRINFO_OFF_PROTOCOL()));
    let addrlen: u32 = @ptr_read[u32](@ptr_offset(pp, ADDRINFO_OFF_ADDRLEN()));
    let addr: rawptr = (@ptr_read[isize](@ptr_offset(pp, ADDRINFO_OFF_ADDR()))) as rawptr;
    fd = sock_socket(family, socktype, protocol);
    if fd >= 0 {
      let one: rawptr = calloc(1 as usize, 4 as usize);
      if (one as isize) != (0 as isize) {
        @ptr_write[i32](one, 1);
        let _sorc: i32 = sock_setsockopt_i32(fd, SOL_SOCKET(), SO_REUSEADDR(), one);
        _sorc;
        free(one);
      }
      if sock_bind(fd, addr, addrlen) == 0 && sock_listen(fd, bk) == 0 {
        sock_freeaddrinfo(res as rawptr);
        return fd as isize;
      }
      c_close(fd);
      fd = -1;
    }
    p = @ptr_read[isize](@ptr_offset(pp, ADDRINFO_OFF_NEXT()));
  }
  sock_freeaddrinfo(res as rawptr);
  panic("tcp listen failed");
  return -1 as isize;
}

pub fn accept(handle: isize) -> isize {
  let fd: i32 = handle_to_fd(handle);
  if fd < 0 { panic("invalid tcp handle"); }
  let cfd: i32 = sock_accept(fd, null_rawptr(), null_rawptr());
  if cfd < 0 { panic("tcp accept failed"); }
  return cfd as isize;
}

pub fn recv(handle: isize, max_n: i32) -> String {
  let fd: i32 = handle_to_fd(handle);
  if fd < 0 { panic("invalid tcp handle"); }
  if max_n <= 0 { return ""; }
  let buf: rawptr = calloc(1 as usize, (max_n as usize) + (1 as usize));
  let n: isize = c_recv(fd, buf, max_n as usize, 0);
  if n < (0 as isize) { panic("tcp recv failed"); }
  return buf_to_string(buf, n as i32);
}

pub fn close_socket(handle: isize) -> () {
  if handle < 0 { return; }
  let _rc: i32 = c_close(handle_to_fd(handle));
  _rc;
  return;
}

fn tcp_wait_fd(fd: i32, want_write: bool, timeout_ms: i32) -> bool {
  if fd < 0 { panic("invalid tcp handle"); }
  let tms: i32 = if timeout_ms < 0 { 0 } else { timeout_ms };
  let ep: i32 = epoll_create();
  if ep < 0 { panic("tcp epoll create failed"); }
  let ev_buf: rawptr = calloc(1 as usize, EPOLL_EVENT_SIZE() as usize);
  let events: u32 = if want_write { EPOLLOUT() | EPOLLERR() | EPOLLHUP() } else { EPOLLIN() | EPOLLERR() | EPOLLHUP() };
  epoll_event_set(ev_buf, 0, events, 1 as u64);
  if epoll_ctl(ep, EPOLL_CTL_ADD(), fd, ev_buf) != 0 {
    free(ev_buf);
    close_fd(ep);
    panic("tcp epoll ctl failed");
  }
  let n: i32 = epoll_wait_events(ep, ev_buf, 1, tms);
  free(ev_buf);
  close_fd(ep);
  return n > 0;
}

pub fn wait_read(handle: isize, timeout_ms: i32) -> bool {
  return tcp_wait_fd(handle_to_fd(handle), false, timeout_ms);
}

pub fn wait_write(handle: isize, timeout_ms: i32) -> bool {
  return tcp_wait_fd(handle_to_fd(handle), true, timeout_ms);
}

@ffi_import("c", "close")
fn c_close(fd: i32) -> i32;

pub fn close(fd: i32) -> i32 {
  return c_close(fd);
}

@ffi_import("c", "lseek")
fn c_lseek(fd: i32, offset: i64, whence: i32) -> i64;

pub fn lseek(fd: i32, offset: i64, whence: i32) -> i64 {
  return c_lseek(fd, offset, whence);
}

@ffi_import("c", "access")
fn c_access(path: String, mode: i32) -> i32;

pub fn access(path: String, mode: i32) -> i32 {
  return c_access(path, mode);
}

@ffi_import("c", "mkdir")
fn c_mkdir(path: String, mode: u32) -> i32;

pub fn mkdir(path: String, mode: u16) -> i32 {
  return c_mkdir(path, mode as u32);
}

@ffi_import("c", "creat")
fn c_creat(path: String, mode: u32) -> i32;

pub fn creat(path: String, mode: u16) -> i32 {
  return c_creat(path, mode as u32);
}
