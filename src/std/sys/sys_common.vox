static mut g_argc: i32 = 0;
static mut g_argv: isize = 0;

@ffi_import("c", "system")
pub fn system(cmd: String) -> i32;

pub fn listen(host: String, port: i32, backlog: i32) -> isize {
  host;
  port;
  backlog;
  panic("sys.listen is not supported yet");
  return -1 as isize;
}

pub fn accept(handle: isize) -> isize {
  handle;
  panic("sys.accept is not supported yet");
  return -1 as isize;
}

// C getenv returns char* (not const char*), which conflicts with vox String
// (const char*) at the C declaration level. The c_runtime shim bridges the
// type mismatch and converts NULL → "".
@ffi_import("c", "vox_impl_getenv")
fn c_getenv(key: String) -> String;

pub fn getenv(key: String) -> String {
  return c_getenv(key);
}

fn argv_get(i: i32) -> String {
  if g_argv == 0 as isize || i < 0 { return ""; }
  // g_argv is char** — each element is a pointer (8 bytes on 64-bit).
  let p: rawptr = @ptr_offset(g_argv as rawptr, (i as isize) * (8 as isize));
  let sp: rawptr = @ptr_read[rawptr](p);
  if (sp as isize) == 0 as isize { return ""; }
  return sp as String;
}

pub fn args() -> Vec[String] {
  let mut result: Vec[String] = Vec();
  let mut i: i32 = 1;
  while i < g_argc {
    result.push(argv_get(i));
    i = i + 1;
  }
  return result;
}

pub fn exe_path() -> String {
  if g_argc <= 0 { return ""; }
  return argv_get(0);
}

pub fn alloc_buf(size: i32) -> rawptr {
  let safe: i32 = if size < 0 { 0 } else { size };
  let p: rawptr = calloc(1 as usize, (safe + 1) as usize);
  return p;
}

pub fn buf_to_string(buf: rawptr, len: i32) -> String {
  if (buf as isize) == 0 as isize { return ""; }
  let safe_len: i32 = if len < 0 { 0 } else { len };
  @ptr_write[u8](@ptr_offset(buf, safe_len as isize), 0 as u8);
  return buf as String;
}

pub fn seek_set() -> i32 { return 0; }
pub fn seek_end() -> i32 { return 2; }

pub fn null_rawptr() -> rawptr { return 0 as isize as rawptr; }

@ffi_import("c", "calloc")
pub fn calloc(nmemb: usize, size: usize) -> rawptr;

@ffi_import("c", "free")
pub fn free(p: rawptr) -> ();
