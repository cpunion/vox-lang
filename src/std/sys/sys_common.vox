@ffi_import("c", "system")
pub fn system(cmd: String) -> i32;

pub fn listen(host: String, port: i32, backlog: i32) -> isize {
  host;
  port;
  backlog;
  panic("sys.listen is not supported yet");
  return -1 as isize;
}

pub fn accept(handle: isize) -> isize {
  handle;
  panic("sys.accept is not supported yet");
  return -1 as isize;
}

@ffi_import("c", "getenv")
fn c_getenv(key: const rawptr) -> rawptr;

pub fn getenv(key: String) -> String {
  let v: rawptr = c_getenv(key as const rawptr);
  if (v as isize) == (0 as isize) { return ""; }
  return v as String;
}

static mut g_argc: i32 = 0;
static mut g_argv: isize = 0;

// Read argv[i] from an intptr_t argv handle (char** as isize).
fn argv_get(argv: isize, i: i32) -> String {
  if argv == (0 as isize) || i < 0 { return ""; }
  let ptr: rawptr = @ptr_offset(argv as rawptr, (i as isize) * PTR_SIZE());
  let val: isize = @ptr_read[isize](ptr);
  if val == (0 as isize) { return ""; }
  return (val as rawptr) as String;
}

pub fn args() -> Vec[String] {
  let mut v: Vec[String] = Vec();
  let mut i: i32 = 1;
  while i < g_argc {
    v.push(argv_get(g_argv, i));
    i = i + 1;
  }
  return v;
}

pub fn exe_path() -> String {
  if g_argc <= 0 { return ""; }
  return argv_get(g_argv, 0);
}

pub fn null_rawptr() -> rawptr { return (0 as isize) as rawptr; }

pub fn alloc_buf(size: i32) -> rawptr {
  let n: usize = if size < 0 { 1 as usize } else { (size as usize) + (1 as usize) };
  return calloc(1 as usize, n);
}

pub fn buf_to_string(buf: rawptr, len: i32) -> String {
  if (buf as isize) == (0 as isize) { return ""; }
  let actual_len: i32 = if len < 0 { 0 } else { len };
  let end: rawptr = @ptr_offset(buf, actual_len as isize);
  @ptr_write[u8](end, 0 as u8);
  return buf as String;
}

pub fn seek_set() -> i32 { return 0; }
pub fn seek_end() -> i32 { return 2; }

pub fn strlen(s: String) -> usize {
  let p: rawptr = (s as const rawptr) as isize as rawptr;
  let mut i: i32 = 0;
  while @ptr_read[u8](@ptr_offset(p, i as isize)) != (0 as u8) {
    i = i + 1;
  }
  return i as usize;
}

@ffi_import("c", "malloc")
pub fn malloc(size: usize) -> rawptr;

pub fn calloc(nmemb: usize, size: usize) -> rawptr {
  if nmemb == (0 as usize) || size == (0 as usize) {
    return malloc(0 as usize);
  }
  let total: usize = nmemb * size;
  if (total / nmemb) != size { return null_rawptr(); }
  let p: rawptr = malloc(total);
  if (p as isize) == (0 as isize) { return p; }
  let mut cur: rawptr = p;
  let mut rem: usize = total;
  while rem > (0 as usize) {
    @ptr_write[u8](cur, 0 as u8);
    cur = @ptr_offset(cur, 1 as isize);
    rem = rem - (1 as usize);
  }
  return p;
}

pub fn memcpy(dest: rawptr, src: const rawptr, n: usize) -> rawptr {
  let mut i: usize = 0 as usize;
  while i < n {
    let b: u8 = @ptr_read[u8](@ptr_offset(src as isize as rawptr, i as isize));
    @ptr_write[u8](@ptr_offset(dest, i as isize), b);
    i = i + (1 as usize);
  }
  return dest;
}

@ffi_import("c", "free")
pub fn free(p: rawptr) -> ();
