@ffi_import("c", "system")
pub fn system(cmd: String) -> i32;

@ffi_import("c", "vox_impl_args")
fn c_args() -> Vec[String];

@ffi_import("c", "vox_impl_exe_path")
fn c_exe_path() -> String;

@ffi_import("c", "vox_impl_getenv")
fn c_getenv(key: String) -> String;

@ffi_import("c", "vox_impl_walk_vox_files")
fn c_walk_files(root: String) -> Vec[String];

@ffi_import("c", "vox_impl_read_file")
fn c_read_file(path: String) -> String;

@ffi_import("c", "vox_impl_now_ns")
fn c_now_ns() -> i64;

@ffi_import("c", "vox_impl_yield_now")
fn c_yield_now() -> ();

@ffi_import("c", "vox_impl_tcp_connect")
fn c_tcp_connect(host: String, port: i32) -> isize;

@ffi_import("c", "vox_impl_tcp_recv")
fn c_tcp_recv(handle: isize, max_n: i32) -> String;

@ffi_import("c", "vox_impl_tcp_close")
fn c_tcp_close(handle: isize) -> ();

@ffi_import("c", "vox_impl_tcp_wait_read")
fn c_tcp_wait_read(handle: isize, timeout_ms: i32) -> bool;

@ffi_import("c", "vox_impl_tcp_wait_write")
fn c_tcp_wait_write(handle: isize, timeout_ms: i32) -> bool;

pub fn args() -> Vec[String] {
  return c_args();
}

pub fn exe_path() -> String {
  return c_exe_path();
}

pub fn getenv(key: String) -> String {
  return c_getenv(key);
}

pub fn walk_files(root: String) -> Vec[String] {
  return c_walk_files(root);
}

pub fn read_file(path: String) -> String {
  return c_read_file(path);
}

pub fn now_ns() -> i64 {
  return c_now_ns();
}

pub fn yield_now() -> () {
  c_yield_now();
  return;
}

pub fn connect(host: String, port: i32) -> isize {
  return c_tcp_connect(host, port);
}

pub fn listen(host: String, port: i32, backlog: i32) -> isize {
  host;
  port;
  backlog;
  panic("sys.listen is not supported yet");
  return -1 as isize;
}

pub fn accept(handle: isize) -> isize {
  handle;
  panic("sys.accept is not supported yet");
  return -1 as isize;
}

pub fn recv(handle: isize, max_n: i32) -> String {
  return c_tcp_recv(handle, max_n);
}

pub fn close_socket(handle: isize) -> () {
  c_tcp_close(handle);
  return;
}

pub fn wait_read(handle: isize, timeout_ms: i32) -> bool {
  return c_tcp_wait_read(handle, timeout_ms);
}

pub fn wait_write(handle: isize, timeout_ms: i32) -> bool {
  return c_tcp_wait_write(handle, timeout_ms);
}

pub fn send(handle: isize, text: String, n: usize) -> i32 {
  return socket_send_text(handle, text, n);
}

@ffi_import("c", "calloc")
pub fn calloc(nmemb: usize, size: usize) -> rawptr;

@ffi_import("c", "free")
pub fn free(p: rawptr) -> ();
