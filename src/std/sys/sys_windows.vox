@build(windows && amd64)
@ffi_import("c", "_read")
fn c_read(fd: i32, buf: rawptr, n: u32) -> i32;

@ffi_import("c", "_sopen_s")
fn c_sopen_s(fd_out: &mut i32, path: String, flags: i32, shflag: i32, mode: i32) -> i32;

pub fn open_read(path: String) -> i32 {
  // `_sopen_s` avoids varargs and works with x86 CRT calling convention.
  // - flags O_RDONLY = 0
  // - share _SH_DENYNO = 0x40
  let mut fd: i32 = -1;
  let rc: i32 = c_sopen_s(fd, path, 0, 64, 0);
  if rc != 0 { return -1; }
  return fd;
}

@ffi_import("c", "_write")
fn c_write(fd: i32, buf: const rawptr, n: u32) -> i32;

fn count_to_u32(n: usize) -> u32 {
  if n > 4294967295 as usize { panic("sys count too large for windows"); }
  return n as u32;
}

pub fn read(fd: i32, buf: rawptr, n: usize) -> isize {
  return c_read(fd, buf, count_to_u32(n)) as isize;
}

pub fn write(fd: i32, buf: const rawptr, n: usize) -> isize {
  return c_write(fd, buf, count_to_u32(n)) as isize;
}

@ffi_import("c", "usleep")
fn c_usleep(usec: u32) -> i32;

pub fn yield_now() -> () {
  let _rc: i32 = c_usleep(0 as u32);
  _rc;
  return;
}

@ffi_import("c", "send")
fn c_send(sock: usize, buf: String, n: i32, flags: i32) -> i32;

fn count_to_i32(n: usize) -> i32 {
  if n > 2147483647 as usize { panic("sys count too large for windows send"); }
  return n as i32;
}

pub fn socket_send(handle: isize, buf: String, n: usize) -> isize {
  if handle < 0 { return -1 as isize; }
  return c_send(handle as usize, buf, count_to_i32(n), 0) as isize;
}

@ffi_import("c", "WSAStartup")
fn c_wsa_startup(version: u16, data: rawptr) -> i32;

@ffi_import("c", "recv")
fn c_recv_raw(sock: usize, buf: rawptr, n: i32, flags: i32) -> i32;

@ffi_import("c", "closesocket")
fn c_closesocket(sock: usize) -> i32;

@ffi_import("c", "select")
fn c_select(nfds: i32, readfds: rawptr, writefds: rawptr, exceptfds: rawptr, timeout: rawptr) -> i32;

static mut g_wsa_inited: bool = false;

fn ensure_wsa() -> () {
  if g_wsa_inited { return; }
  // WSADATA is ~400 bytes; allocate 512 to be safe.
  let wsa_buf: rawptr = calloc(1 as usize, 512 as usize);
  // MAKEWORD(2,2) = 2 | (2 << 8) = 514
  let rc: i32 = c_wsa_startup(514 as u16, wsa_buf);
  free(wsa_buf);
  if rc != 0 { panic("tcp wsa startup failed"); }
  g_wsa_inited = true;
  return;
}

pub fn connect(host: String, port: i32) -> isize {
  ensure_wsa();
  if port <= 0 || port > 65535 { panic("invalid tcp port"); }
  let port_str: String = port.to_string();
  // addrinfo hints: ai_family=AF_UNSPEC(0), ai_socktype=SOCK_STREAM, ai_protocol=IPPROTO_TCP
  let hints: rawptr = calloc(1 as usize, ADDRINFO_SIZE() as usize);
  @ptr_write[i32](@ptr_offset(hints, ADDRINFO_OFF_SOCKTYPE()), SOCK_STREAM());
  @ptr_write[i32](@ptr_offset(hints, ADDRINFO_OFF_PROTOCOL()), IPPROTO_TCP());
  // resolve
  let res_buf: rawptr = calloc(1 as usize, 8 as usize);
  let rc: i32 = sock_getaddrinfo(host, port_str, hints, res_buf);
  free(hints);
  if rc != 0 {
    free(res_buf);
    panic("tcp connect resolve failed");
  }
  let res: rawptr = @ptr_read[rawptr](res_buf);
  // loop through results
  let mut fd: i32 = -1;
  let mut p: rawptr = res;
  while (p as isize) != 0 as isize && fd < 0 {
    let family: i32 = @ptr_read[i32](@ptr_offset(p, ADDRINFO_OFF_FAMILY()));
    let socktype: i32 = @ptr_read[i32](@ptr_offset(p, ADDRINFO_OFF_SOCKTYPE()));
    let protocol: i32 = @ptr_read[i32](@ptr_offset(p, ADDRINFO_OFF_PROTOCOL()));
    let sfd: i32 = sock_socket(family, socktype, protocol);
    if sfd >= 0 {
      let addr: rawptr = @ptr_read[rawptr](@ptr_offset(p, ADDRINFO_OFF_ADDR()));
      let addrlen: u32 = @ptr_read[u32](@ptr_offset(p, ADDRINFO_OFF_ADDRLEN()));
      if sock_connect(sfd, addr, addrlen) == 0 {
        fd = sfd;
      } else {
        let _cr: i32 = c_closesocket(sfd as usize);
        _cr;
      }
    }
    if fd < 0 {
      p = @ptr_read[rawptr](@ptr_offset(p, ADDRINFO_OFF_NEXT()));
    }
  }
  sock_freeaddrinfo(res);
  free(res_buf);
  if fd < 0 { panic("tcp connect failed"); }
  return fd as isize;
}

pub fn recv(handle: isize, max_n: i32) -> String {
  if handle < 0 { panic("invalid tcp handle"); }
  let sock: usize = handle as usize;
  if max_n <= 0 { return ""; }
  let buf: rawptr = calloc(1 as usize, (max_n + 1) as usize);
  let n: i32 = c_recv_raw(sock, buf, max_n, 0);
  if n < 0 { panic("tcp recv failed"); }
  @ptr_write[u8](@ptr_offset(buf, n as isize), 0 as u8);
  return buf as String;
}

pub fn close_socket(handle: isize) -> () {
  if handle < 0 { return; }
  let _rc: i32 = c_closesocket(handle as usize);
  _rc;
  return;
}

// Windows fd_set layout (x64):
//   fd_count: u32 (4 bytes, offset 0)
//   padding:  4 bytes (offset 4, for 8-byte SOCKET alignment)
//   fd_array: SOCKET[64] (512 bytes, offset 8)
// Total: 520 bytes
// Windows timeval layout:
//   tv_sec:  i32 (4 bytes, long on Windows = 4 bytes)
//   tv_usec: i32 (4 bytes)

fn win_select_wait(sock: usize, want_write: bool, timeout_ms: i32) -> bool {
  // Build fd_set with one socket.
  let fds: rawptr = calloc(1 as usize, 520 as usize);
  @ptr_write[u32](fds, 1 as u32);
  @ptr_write[usize](@ptr_offset(fds, 8 as isize), sock);
  // Build timeval.
  let tv: rawptr = calloc(1 as usize, 8 as usize);
  @ptr_write[i32](tv, timeout_ms / 1000);
  @ptr_write[i32](@ptr_offset(tv, 4 as isize), (timeout_ms % 1000) * 1000);
  // nfds is ignored on Windows.
  let n: i32 = if want_write {
    c_select(0, null_rawptr(), fds, null_rawptr(), tv)
  } else {
    c_select(0, fds, null_rawptr(), null_rawptr(), tv)
  };
  free(fds);
  free(tv);
  return n > 0;
}

pub fn wait_read(handle: isize, timeout_ms: i32) -> bool {
  if handle < 0 { panic("invalid tcp handle"); }
  return win_select_wait(handle as usize, false, if timeout_ms < 0 { 0 } else { timeout_ms });
}

pub fn wait_write(handle: isize, timeout_ms: i32) -> bool {
  if handle < 0 { panic("invalid tcp handle"); }
  return win_select_wait(handle as usize, true, if timeout_ms < 0 { 0 } else { timeout_ms });
}

@ffi_import("c", "_lseeki64")
fn c_lseek(fd: i32, offset: i64, whence: i32) -> i64;

pub fn lseek(fd: i32, offset: i64, whence: i32) -> i64 {
  return c_lseek(fd, offset, whence);
}

@ffi_import("c", "_close")
fn c_close(fd: i32) -> i32;

pub fn close(fd: i32) -> i32 {
  return c_close(fd);
}

@ffi_import("c", "_access")
fn c_access(path: String, mode: i32) -> i32;

pub fn access(path: String, mode: i32) -> i32 {
  return c_access(path, mode);
}

@ffi_import("c", "_mkdir")
fn c_mkdir(path: String) -> i32;

pub fn mkdir(path: String, _mode: u16) -> i32 {
  return c_mkdir(path);
}

@ffi_import("c", "_creat")
fn c_creat(path: String, mode: i32) -> i32;

pub fn creat(path: String, mode: u16) -> i32 {
  // Windows CRT creat only honors owner read/write bits.
  let mut pmode: i32 = mode as i32;
  if pmode > 384 { pmode = 384; }
  if pmode <= 0 { pmode = 384; }
  return c_creat(path, pmode);
}

@ffi_import("c", "vox_impl_get_tick_count64")
fn c_get_tick_count64() -> u64;

pub fn now_ns() -> i64 {
  return (c_get_tick_count64() as i64) * 1000000 as i64;
}
