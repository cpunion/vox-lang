@build(windows && amd64)
@ffi_import("c", "_read")
fn c_read(fd: i32, buf: rawptr, n: u32) -> i32;

@ffi_import("c", "vox_open_read_binary")
fn c_open_read_binary(path: String) -> i32;

pub fn open_read(path: String) -> i32 {
  return c_open_read_binary(path);
}

@ffi_import("c", "_write")
fn c_write(fd: i32, buf: const rawptr, n: u32) -> i32;

fn count_to_u32(n: usize) -> u32 {
  if n > 4294967295 as usize { panic("sys count too large for windows"); }
  return n as u32;
}

pub fn read(fd: i32, buf: rawptr, n: usize) -> isize {
  return c_read(fd, buf, count_to_u32(n)) as isize;
}

pub fn write(fd: i32, buf: const rawptr, n: usize) -> isize {
  return c_write(fd, buf, count_to_u32(n)) as isize;
}

@ffi_import("c", "usleep")
fn c_usleep(usec: u32) -> i32;

pub fn yield_now() -> () {
  let _rc: i32 = c_usleep(0 as u32);
  _rc;
  return;
}

@ffi_import("c", "send")
fn c_send(sock: usize, buf: String, n: i32, flags: i32) -> i32;

fn count_to_i32(n: usize) -> i32 {
  if n > 2147483647 as usize { panic("sys count too large for windows send"); }
  return n as i32;
}

pub fn socket_send(handle: isize, buf: String, n: usize) -> isize {
  if handle < 0 { return -1 as isize; }
  return c_send(handle as usize, buf, count_to_i32(n), 0) as isize;
}

@ffi_import("c", "vox_impl_tcp_connect")
fn c_tcp_connect(host: String, port: i32) -> isize;

@ffi_import("c", "vox_impl_tcp_recv")
fn c_tcp_recv(handle: isize, max_n: i32) -> String;

@ffi_import("c", "vox_impl_tcp_close")
fn c_tcp_close(handle: isize) -> ();

@ffi_import("c", "vox_impl_tcp_wait_read")
fn c_tcp_wait_read(handle: isize, timeout_ms: i32) -> bool;

@ffi_import("c", "vox_impl_tcp_wait_write")
fn c_tcp_wait_write(handle: isize, timeout_ms: i32) -> bool;

pub fn connect(host: String, port: i32) -> isize {
  return c_tcp_connect(host, port);
}

pub fn recv(handle: isize, max_n: i32) -> String {
  return c_tcp_recv(handle, max_n);
}

pub fn close_socket(handle: isize) -> () {
  c_tcp_close(handle);
  return;
}

pub fn wait_read(handle: isize, timeout_ms: i32) -> bool {
  return c_tcp_wait_read(handle, timeout_ms);
}

pub fn wait_write(handle: isize, timeout_ms: i32) -> bool {
  return c_tcp_wait_write(handle, timeout_ms);
}

@ffi_import("c", "_lseeki64")
fn c_lseek(fd: i32, offset: i64, whence: i32) -> i64;

pub fn lseek(fd: i32, offset: i64, whence: i32) -> i64 {
  return c_lseek(fd, offset, whence);
}

@ffi_import("c", "_close")
fn c_close(fd: i32) -> i32;

pub fn close(fd: i32) -> i32 {
  return c_close(fd);
}

@ffi_import("c", "_access")
fn c_access(path: String, mode: i32) -> i32;

pub fn access(path: String, mode: i32) -> i32 {
  return c_access(path, mode);
}

@ffi_import("c", "_mkdir")
fn c_mkdir(path: String) -> i32;

pub fn mkdir(path: String, _mode: u16) -> i32 {
  return c_mkdir(path);
}

@ffi_import("c", "_creat")
fn c_creat(path: String, mode: i32) -> i32;

pub fn creat(path: String, mode: u16) -> i32 {
  // Windows CRT creat only honors owner read/write bits.
  let mut pmode: i32 = mode as i32;
  if pmode > 384 { pmode = 384; }
  if pmode <= 0 { pmode = 384; }
  return c_creat(path, pmode);
}
