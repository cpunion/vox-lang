@build(windows)
@ffi_import("c", "_read")
fn c_read(fd: i32, buf: rawptr, n: u32) -> i32;

@ffi_import("c", "CreateFileA")
fn c_create_file_a(
  path: String,
  desired_access: u32,
  share_mode: u32,
  sec_attrs: rawptr,
  creation_disposition: u32,
  flags_attrs: u32,
  template_file: rawptr,
) -> rawptr;

@ffi_import("c", "_open_osfhandle")
fn c_open_osfhandle(os_handle: isize, flags: i32) -> i32;

@ffi_import("c", "CloseHandle")
fn c_close_handle(h: rawptr) -> i32;

fn win_invalid_handle_value() -> rawptr {
  return (-1 as isize) as rawptr;
}

pub fn open_read(path: String) -> i32 {
  // Bridge Win32 handle -> CRT fd so read/write/close keep a single fd API.
  // GENERIC_READ=0x80000000, share=READ|WRITE|DELETE(0x7), OPEN_EXISTING=3, FILE_ATTRIBUTE_NORMAL=0x80.
  let h: rawptr =
    c_create_file_a(path, 2147483648 as u32, 7 as u32, 0 as rawptr, 3 as u32, 128 as u32, 0 as rawptr);
  if h == win_invalid_handle_value() { return -1; }
  let fd: i32 = c_open_osfhandle(h as isize, 0);
  if fd < 0 {
    let _rc: i32 = c_close_handle(h);
    return -1;
  }
  return fd;
}

@ffi_import("c", "_write")
fn c_write(fd: i32, buf: const rawptr, n: u32) -> i32;

fn count_to_u32(n: usize) -> u32 {
  if n > 4294967295 as usize { panic("sys count too large for windows"); }
  return n as u32;
}

pub fn read(fd: i32, buf: rawptr, n: usize) -> isize {
  return c_read(fd, buf, count_to_u32(n)) as isize;
}

pub fn write(fd: i32, buf: const rawptr, n: usize) -> isize {
  return c_write(fd, buf, count_to_u32(n)) as isize;
}

@ffi_import("c", "_close")
fn c_close(fd: i32) -> i32;

pub fn close(fd: i32) -> i32 {
  return c_close(fd);
}

@ffi_import("c", "_access")
fn c_access(path: String, mode: i32) -> i32;

pub fn access(path: String, mode: i32) -> i32 {
  return c_access(path, mode);
}

@ffi_import("c", "_mkdir")
fn c_mkdir(path: String) -> i32;

pub fn mkdir(path: String, _mode: u16) -> i32 {
  return c_mkdir(path);
}

@ffi_import("c", "_creat")
fn c_creat(path: String, mode: i32) -> i32;

pub fn creat(path: String, mode: u16) -> i32 {
  // Windows CRT creat only honors owner read/write bits.
  let mut pmode: i32 = mode as i32;
  if pmode > 384 { pmode = 384; }
  if pmode <= 0 { pmode = 384; }
  return c_creat(path, pmode);
}
