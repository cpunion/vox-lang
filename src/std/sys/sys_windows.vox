@build(windows)
@ffi_import("c", "_read")
fn c_read(fd: i32, buf: rawptr, n: u32) -> i32;

@ffi_import("c", "CreateFileA")
fn c_create_file(path: String, desired_access: u32, share_mode: u32, security_attrs: isize, creation_disposition: u32, flags_and_attrs: u32, template_file: isize) -> isize;

@ffi_import("c", "_open_osfhandle")
fn c_open_osfhandle(os_handle: isize, flags: i32) -> i32;

pub fn open_read(path: String) -> i32 {
  // CreateFileA + _open_osfhandle bridge:
  // - desired_access: GENERIC_READ (0x80000000)
  // - share_mode: FILE_SHARE_READ|WRITE|DELETE (0x1|0x2|0x4)
  // - creation_disposition: OPEN_EXISTING (3)
  let h: isize = c_create_file(path, 2147483648 as u32, 7 as u32, 0 as isize, 3 as u32, 0 as u32, 0 as isize);
  return c_open_osfhandle(h, 0);
}

@ffi_import("c", "_write")
fn c_write(fd: i32, buf: const rawptr, n: u32) -> i32;

fn count_to_u32(n: usize) -> u32 {
  if n > 4294967295 as usize { panic("sys count too large for windows"); }
  return n as u32;
}

pub fn read(fd: i32, buf: rawptr, n: usize) -> isize {
  return c_read(fd, buf, count_to_u32(n)) as isize;
}

pub fn write(fd: i32, buf: const rawptr, n: usize) -> isize {
  return c_write(fd, buf, count_to_u32(n)) as isize;
}

@ffi_import("c", "_close")
fn c_close(fd: i32) -> i32;

pub fn close(fd: i32) -> i32 {
  return c_close(fd);
}

@ffi_import("c", "_access")
fn c_access(path: String, mode: i32) -> i32;

pub fn access(path: String, mode: i32) -> i32 {
  return c_access(path, mode);
}

@ffi_import("c", "_mkdir")
fn c_mkdir(path: String) -> i32;

pub fn mkdir(path: String, _mode: u16) -> i32 {
  return c_mkdir(path);
}

@ffi_import("c", "_creat")
fn c_creat(path: String, mode: i32) -> i32;

pub fn creat(path: String, mode: u16) -> i32 {
  // Windows CRT creat only honors owner read/write bits.
  let mut pmode: i32 = mode as i32;
  if pmode > 384 { pmode = 384; }
  if pmode <= 0 { pmode = 384; }
  return c_creat(path, pmode);
}
