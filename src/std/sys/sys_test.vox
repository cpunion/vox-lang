import "std/fs" as fs
import "std/sys" as sys
import "std/testing" as t

fn test_sys_rawptr_read_smoke() -> () {
  let p: rawptr = sys.calloc(1 as usize, 1 as usize);
  let nr: isize = sys.read(0, p, 0 as usize);
  sys.free(p);
  t.assert(nr >= 0 || nr < 0);
}

fn test_sys_calloc_zero_init_smoke() -> () {
  let p: rawptr = sys.calloc(4 as usize, 1 as usize);
  t.assert_with((p as isize) != (0 as isize), "expected calloc non-null for small allocation");
  let b0: u8 = @ptr_read[u8](p);
  let b1: u8 = @ptr_read[u8](@ptr_offset(p, 1 as isize));
  let b2: u8 = @ptr_read[u8](@ptr_offset(p, 2 as isize));
  let b3: u8 = @ptr_read[u8](@ptr_offset(p, 3 as isize));
  sys.free(p);
  t.assert_eq(b0, 0 as u8);
  t.assert_eq(b1, 0 as u8);
  t.assert_eq(b2, 0 as u8);
  t.assert_eq(b3, 0 as u8);
}

fn test_sys_const_rawptr_write_smoke() -> () {
  let nw: isize = sys.write(1, "" as const rawptr, 0 as usize);
  t.assert_eq(nw, 0 as isize);
}

fn test_sys_socket_send_ptr_len_signature_smoke() -> () {
  // Compile-time API smoke only: do not execute invalid socket send path.
  if false {
    let _n: isize = sys.socket_send(-1 as isize, "" as const rawptr, 0 as usize);
    _n;
  }
  t.assert(true);
}

fn test_sys_net_primitives_signature_smoke() -> () {
  // Compile-time API smoke only: do not execute invalid socket paths.
  if false {
    let h0: isize = sys.connect("127.0.0.1", 0);
    let h1: isize = sys.listen("127.0.0.1", 0, 16);
    let h2: isize = sys.accept(h1);
    let n0: isize = sys.socket_send(h0, "" as const rawptr, 0 as usize);
    let s0: String = sys.recv(h0, 0);
    let b0: bool = sys.wait_read(h0, 0);
    let b1: bool = sys.wait_write(h0, 0);
    sys.close_socket(h0);
    sys.close_socket(h1);
    sys.close_socket(h2);
    h0;
    h1;
    h2;
    n0;
    s0;
    b0;
    b1;
  }
  t.assert(true);
}

fn test_sys_listen_close_smoke() -> () {
  let h: isize = sys.listen("127.0.0.1", 0, 16);
  t.assert_with(h >= 0 as isize, "expected listen success on loopback");
  if h >= 0 as isize {
    sys.close_socket(h);
  }
}

fn test_sys_open_read_missing_path_smoke() -> () {
  let fd: i32 = sys.open_read("__vox_missing_path_should_not_exist__.tmp");
  if fd >= 0 {
    let _rc: i32 = sys.close(fd);
  }
  t.assert_with(fd < 0, "expected open_read fail on missing path");
}

fn test_sys_open_read_existing_path_smoke() -> () {
  let path: String = "target_sys_open_read_smoke.tmp";

  let fdw: i32 = sys.creat(path, 384);
  t.assert_with(fdw >= 0, "expected creat success");
  if fdw >= 0 {
    let nw: isize = sys.write(fdw, "ok" as const rawptr, 2 as usize);
    t.assert_with(nw >= 0, "expected write success");
    let _c0: i32 = sys.close(fdw);
  }

  let fdr: i32 = sys.open_read(path);
  t.assert_with(fdr >= 0, "expected open_read success");
  if fdr >= 0 {
    let _c1: i32 = sys.close(fdr);
  }
}

fn test_sys_write_ptr_len_controls_written_bytes() -> () {
  let path: String = "target_sys_write_ptr_len.tmp";
  let fd: i32 = sys.creat(path, 384);
  t.assert_with(fd >= 0, "expected creat success");
  if fd >= 0 {
    let nw: isize = sys.write(fd, "ABCDE" as const rawptr, 2 as usize);
    t.assert_with(nw == 2 as isize, "expected write len=2");
    let _c: i32 = sys.close(fd);
  }
  let got: String = fs.read_to_string(path);
  t.assert_with(got == "AB", "expected ptr+len write boundary");
}

fn test_sys_system_smoke() -> () {
  let rc: i32 = sys.system("");
  t.assert(rc >= 0 || rc < 0);
}

fn test_sys_lseek_smoke() -> () {
  let path: String = "target_sys_open_read_smoke.tmp";
  let fd: i32 = sys.open_read(path);
  if fd >= 0 {
    let end: i64 = sys.lseek(fd, 0 as i64, sys.seek_end());
    t.assert_with(end >= 0 as i64, "expected lseek to end >= 0");
    let begin: i64 = sys.lseek(fd, 0 as i64, sys.seek_set());
    t.assert_with(begin == 0 as i64, "expected lseek to start == 0");
    let _: i32 = sys.close(fd);
  }
  t.assert(true);
}

fn test_sys_getenv_smoke() -> () {
  // Unset var returns empty string.
  let missing: String = sys.getenv("__VOX_TEST_UNSET_VAR_12345__");
  t.assert_eq(missing, "");

  // PATH is typically always set on all platforms.
  let path: String = sys.getenv("PATH");
  t.assert_with(path.len() > 0, "expected PATH to be non-empty");
}
