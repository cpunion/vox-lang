@build(windows)

// Socket constants.
pub fn AF_INET() -> i32 { return 2; }
pub fn AF_INET6() -> i32 { return 23; }
pub fn SOCK_STREAM() -> i32 { return 1; }
pub fn SOCK_DGRAM() -> i32 { return 2; }
pub fn SOL_SOCKET() -> i32 { return 65535; }   // 0xffff
pub fn SO_REUSEADDR() -> i32 { return 4; }
pub fn IPPROTO_TCP() -> i32 { return 6; }
pub fn TCP_NODELAY() -> i32 { return 1; }
pub fn FIONBIO() -> i32 { return -2147195266; }  // 0x8004667e (signed)
pub fn EAGAIN() -> i32 { return 10035; }    // WSAEWOULDBLOCK
pub fn EINPROGRESS() -> i32 { return 10036; }  // WSAEINPROGRESS

// struct sockaddr_in layout (Windows, 16 bytes):
//   sin_family: u16 (2 bytes, offset 0)
//   sin_port:   u16 (2 bytes, offset 2)
//   sin_addr:   u32 (4 bytes, offset 4)
//   sin_zero:   [u8; 8] (8 bytes, offset 8)
pub fn SOCKADDR_IN_SIZE() -> u32 { return 16; }

// struct addrinfo layout (Windows x86_64, 48 bytes):
//   ai_flags:     i32 (4 bytes, offset 0)
//   ai_family:    i32 (4 bytes, offset 4)
//   ai_socktype:  i32 (4 bytes, offset 8)
//   ai_protocol:  i32 (4 bytes, offset 12)
//   ai_addrlen:   usize (8 bytes, offset 16) - size_t on Windows
//   ai_canonname: rawptr (8 bytes, offset 24)
//   ai_addr:      rawptr (8 bytes, offset 32)
//   ai_next:      rawptr (8 bytes, offset 40)
pub fn ADDRINFO_SIZE() -> isize { return 48; }
pub fn ADDRINFO_OFF_FLAGS() -> isize { return 0; }
pub fn ADDRINFO_OFF_FAMILY() -> isize { return 4; }
pub fn ADDRINFO_OFF_SOCKTYPE() -> isize { return 8; }
pub fn ADDRINFO_OFF_PROTOCOL() -> isize { return 12; }
pub fn ADDRINFO_OFF_ADDRLEN() -> isize { return 16; }
pub fn ADDRINFO_OFF_ADDR() -> isize { return 32; }
pub fn ADDRINFO_OFF_NEXT() -> isize { return 40; }

@calling_convention("system")
@ffi_import("c", "socket") fn win_socket(domain: i32, ty: i32, proto: i32) -> usize;
@calling_convention("system")
@ffi_import("c", "connect") fn win_connect(fd: usize, addr: const rawptr, len: i32) -> i32;
@calling_convention("system")
@ffi_import("c", "bind") fn win_bind(fd: usize, addr: const rawptr, len: i32) -> i32;
@calling_convention("system")
@ffi_import("c", "accept") fn win_accept(fd: usize, addr: rawptr, len: rawptr) -> usize;
@calling_convention("system")
@ffi_import("c", "listen") fn win_listen(fd: usize, backlog: i32) -> i32;
@calling_convention("system")
@ffi_import("c", "setsockopt") fn win_setsockopt(fd: usize, level: i32, name: i32, val: const rawptr, len: i32) -> i32;
@calling_convention("system")
@ffi_import("c", "getaddrinfo") fn win_getaddrinfo(node: String, service: String, hints: const rawptr, res: rawptr) -> i32;
@calling_convention("system")
@ffi_import("c", "freeaddrinfo") fn win_freeaddrinfo(res: rawptr) -> ();
@calling_convention("system")
@ffi_import("c", "ioctlsocket") fn win_ioctlsocket(fd: usize, cmd: i32, argp: rawptr) -> i32;

fn c_htons(v: u16) -> u16 { return ((v >> 8) | (v << 8)) as u16; }
fn INVALID_SOCKET() -> usize { return (0 as usize) - (1 as usize); }

pub fn sock_socket(domain: i32, ty: i32, proto: i32) -> i32 {
  let s: usize = win_socket(domain, ty, proto);
  if s == INVALID_SOCKET() { return -1; }
  if s > 2147483647 as usize { panic("windows socket handle overflow"); }
  return s as i32;
}

pub fn sock_connect(fd: i32, addr: rawptr, len: u32) -> i32 {
  return win_connect(fd as usize, addr, len as i32);
}

pub fn sock_bind(fd: i32, addr: rawptr, len: u32) -> i32 {
  return win_bind(fd as usize, addr, len as i32);
}

pub fn sock_listen(fd: i32, backlog: i32) -> i32 {
  return win_listen(fd as usize, backlog);
}

pub fn sock_accept(fd: i32, addr: rawptr, len: rawptr) -> i32 {
  let s: usize = win_accept(fd as usize, addr, len);
  if s == INVALID_SOCKET() { return -1; }
  if s > 2147483647 as usize { panic("windows socket handle overflow"); }
  return s as i32;
}

pub fn sock_setsockopt_i32(fd: i32, level: i32, name: i32, val: rawptr) -> i32 {
  return win_setsockopt(fd as usize, level, name, val, 4);
}

pub fn sock_htons(v: u16) -> u16 {
  return c_htons(v);
}

pub fn sock_set_nonblock(fd: i32) -> i32 {
  let buf: rawptr = calloc(1 as usize, 4 as usize);
  @ptr_write[u32](buf, 1 as u32);
  let rc: i32 = win_ioctlsocket(fd as usize, FIONBIO(), buf);
  free(buf);
  return rc;
}

pub fn sock_getaddrinfo(node: String, service: String, hints: rawptr, res: rawptr) -> i32 {
  return win_getaddrinfo(node, service, hints, res);
}

pub fn sock_freeaddrinfo(res: rawptr) -> () {
  win_freeaddrinfo(res);
  return;
}
