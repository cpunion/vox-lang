@build(windows)

@ffi_import("c", "vox_impl_create_iocp") fn c_create_iocp(file: isize, existing: isize, key: usize, threads: u32) -> isize;
@ffi_import("c", "vox_impl_post_iocp") fn c_post_iocp(iocp: isize, bytes: u32, key: usize, overlapped: rawptr) -> i32;
@ffi_import("c", "vox_impl_get_iocp") fn c_get_iocp(iocp: isize, bytes: rawptr, key: rawptr, overlapped: rawptr, timeout: u32) -> i32;
@ffi_import("c", "vox_impl_close_handle") fn c_close_handle(h: isize) -> i32;

pub fn INVALID_HANDLE() -> isize { return -1 as isize; }

pub fn iocp_create() -> isize {
  return c_create_iocp(INVALID_HANDLE(), 0 as isize, 0, 0);
}

pub fn iocp_post(iocp: isize, key: usize) -> i32 {
  return c_post_iocp(iocp, 0, key, null_rawptr());
}

pub fn iocp_get(iocp: isize, bytes_out: rawptr, key_out: rawptr, overlapped_out: rawptr, timeout_ms: u32) -> i32 {
  return c_get_iocp(iocp, bytes_out, key_out, overlapped_out, timeout_ms);
}

pub fn close_handle(h: isize) -> i32 {
  return c_close_handle(h);
}

// IOCP wait helper (bridged via C runtime for bootstrap compat).
@ffi_import("c", "vox_impl_iocp_wait_ms")
fn c_iocp_wait_ms(iocp: isize, timeout_ms: i32) -> bool;

pub fn iocp_wait_ms(iocp: isize, timeout_ms: i32) -> bool {
  return c_iocp_wait_ms(iocp, timeout_ms);
}
