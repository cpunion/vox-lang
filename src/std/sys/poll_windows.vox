@build(windows)

@calling_convention("system")
@ffi_import("c", "CreateIoCompletionPort") fn win_CreateIoCompletionPort(file: rawptr, existing: rawptr, key: usize, threads: u32) -> rawptr;
@calling_convention("system")
@ffi_import("c", "PostQueuedCompletionStatus") fn win_PostQCS(iocp: rawptr, bytes: u32, key: usize, ov: rawptr) -> i32;
@calling_convention("system")
@ffi_import("c", "GetQueuedCompletionStatus") fn win_GetQCS(iocp: rawptr, bytes: rawptr, key: rawptr, ov: rawptr, timeout: u32) -> i32;
@calling_convention("system")
@ffi_import("c", "CloseHandle") fn win_CloseHandle(h: rawptr) -> i32;

pub fn INVALID_HANDLE() -> isize { return -1 as isize; }

pub fn iocp_create() -> isize {
  return win_CreateIoCompletionPort(INVALID_HANDLE() as rawptr, (0 as isize) as rawptr, 0, 0) as isize;
}

pub fn iocp_post(iocp: isize, key: usize) -> i32 {
  let rc: i32 = win_PostQCS(iocp as rawptr, 0, key, null_rawptr());
  return if rc != 0 { 1 } else { 0 };
}

pub fn iocp_get(iocp: isize, bytes_out: rawptr, key_out: rawptr, overlapped_out: rawptr, timeout_ms: u32) -> i32 {
  let rc: i32 = win_GetQCS(iocp as rawptr, bytes_out, key_out, overlapped_out, timeout_ms);
  return if rc != 0 { 1 } else { 0 };
}

pub fn close_handle(h: isize) -> i32 {
  let rc: i32 = win_CloseHandle(h as rawptr);
  return if rc != 0 { 1 } else { 0 };
}

pub fn iocp_wait_ms(iocp: isize, timeout_ms: i32) -> bool {
  let bytes: rawptr = calloc(1 as usize, 4 as usize);
  let key: rawptr = calloc(1 as usize, 8 as usize);
  let ov: rawptr = calloc(1 as usize, 8 as usize);
  let rc: i32 = win_GetQCS(iocp as rawptr, bytes, key, ov, timeout_ms as u32);
  free(bytes);
  free(key);
  free(ov);
  return rc != 0;
}
