@build(linux)

@repr(C, packed)
struct EpollEvent {
  events: u32,
  data: u64,
}

pub fn EPOLL_EVENT_SIZE() -> isize { return 12; }

// epoll constants.
pub fn EPOLL_CLOEXEC() -> i32 { return 524288; }  // 0x80000

pub fn EPOLL_CTL_ADD() -> i32 { return 1; }
pub fn EPOLL_CTL_DEL() -> i32 { return 2; }
pub fn EPOLL_CTL_MOD() -> i32 { return 3; }

pub fn EPOLLIN() -> u32 { return 1; }      // 0x001
pub fn EPOLLOUT() -> u32 { return 4; }     // 0x004
pub fn EPOLLERR() -> u32 { return 8; }     // 0x008
pub fn EPOLLHUP() -> u32 { return 16; }    // 0x010
pub fn EPOLLET() -> u32 { return 2147483648; }  // 0x80000000 (1 << 31)
pub fn EPOLLONESHOT() -> u32 { return 1073741824; }  // 0x40000000 (1 << 30)

pub fn EFD_NONBLOCK() -> i32 { return 2048; }  // 0x800
pub fn EFD_CLOEXEC() -> i32 { return 524288; }  // 0x80000

@ffi_import("c", "epoll_create1") fn c_epoll_create1(flags: i32) -> i32;
@ffi_c_types("", "", "", "struct epoll_event*")
@ffi_import("c", "epoll_ctl") fn c_epoll_ctl(epfd: i32, op: i32, fd: i32, event: rawptr) -> i32;
@ffi_c_types("", "struct epoll_event*", "", "")
@ffi_import("c", "epoll_wait") fn c_epoll_wait(epfd: i32, events: rawptr, max: i32, timeout: i32) -> i32;
@ffi_import("c", "eventfd") fn c_eventfd(initval: u32, flags: i32) -> i32;
@ffi_import("c", "close") fn c_close_fd(fd: i32) -> i32;

pub fn epoll_create() -> i32 {
  return c_epoll_create1(EPOLL_CLOEXEC());
}

pub fn epoll_ctl(epfd: i32, op: i32, fd: i32, event: rawptr) -> i32 {
  return c_epoll_ctl(epfd, op, fd, event);
}

pub fn epoll_wait_events(epfd: i32, events_buf: rawptr, max: i32, timeout_ms: i32) -> i32 {
  return c_epoll_wait(epfd, events_buf, max, timeout_ms);
}

pub fn eventfd_create() -> i32 {
  return c_eventfd(0, EFD_NONBLOCK() | EFD_CLOEXEC());
}

pub fn close_fd(fd: i32) -> i32 {
  return c_close_fd(fd);
}

pub fn epoll_event_set(buf: rawptr, index: i32, events: u32, data: u64) -> () {
  let ev: EpollEvent = EpollEvent { events: events, data: data };
  @ptr_write[EpollEvent](@ptr_offset(buf, (index as isize) * EPOLL_EVENT_SIZE()), ev);
  return;
}

// eventfd helpers â€” pure Vox using existing read/write from sys_linux.vox.

pub fn eventfd_signal(fd: i32) -> () {
  let buf: rawptr = calloc(1 as usize, 8 as usize);
  @ptr_write[u64](buf, 1 as u64);
  let _n: isize = write(fd, buf, 8 as usize);
  free(buf);
  return;
}

pub fn eventfd_drain(fd: i32) -> () {
  let buf: rawptr = calloc(1 as usize, 8 as usize);
  let mut n: isize = read(fd, buf, 8 as usize);
  while n > (0 as isize) {
    n = read(fd, buf, 8 as usize);
  }
  free(buf);
  return;
}
