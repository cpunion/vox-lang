// std/time: minimal wall-clock helpers for tooling/test reporting.
import "std/sys" as sys

pub const nanosecond: i64 = 1 as i64;

pub const nanoseconds: i64 = nanosecond;

pub const ns: i64 = nanosecond;

pub const microsecond: i64 = 1000 as i64;

pub const microseconds: i64 = microsecond;

pub const us: i64 = microsecond;

pub const millisecond: i64 = 1000000 as i64;

pub const milliseconds: i64 = millisecond;

pub const ms: i64 = millisecond;

pub const second: i64 = 1000000000 as i64;

pub const seconds: i64 = second;

pub const s: i64 = second;

// Duration stores elapsed time in nanoseconds using signed 64-bit.
pub struct Duration {
  pub ns: i64,
}

pub fn duration_ns(ns: i64) -> Duration {
  return Duration { ns: ns };
}

pub fn duration_us(us: i64) -> Duration {
  return duration_ns(us * microsecond);
}

pub fn duration_ms(ms: i64) -> Duration {
  return duration_ns(ms * millisecond);
}

pub fn duration_s(sec: i64) -> Duration {
  return duration_ns(sec * second);
}

pub fn now_ns() -> i64 { return sys.now_ns(); }

// Stable scheduling-yield API for std/runtime hooks.
// Backed by compiler/runtime intrinsic after bootstrap lock alignment.
pub fn yield_now() -> () {
  sys.yield_now();
  return;
}

impl Duration {
  fn ns(d: Duration) -> i64 { return d.ns; }

  fn us(d: Duration) -> i64 { return d.ns / microsecond; }

  fn ms(d: Duration) -> i64 { return d.ns / millisecond; }

  fn s(d: Duration) -> i64 { return d.ns / second; }

  fn as_ns(d: Duration) -> i64 { return d.ns; }

  fn as_us(d: Duration) -> i64 { return d.ns / microsecond; }

  fn as_ms(d: Duration) -> i64 { return d.ns / millisecond; }

  fn as_s(d: Duration) -> i64 { return d.ns / second; }
}

// Unit conversion sugar without language-level operator overloading:
// `(1 * tm.s).ns()` and `3.ms()` produce Duration values.
pub trait DurationScalar {
  fn ns(x: Self) -> Duration;
  fn us(x: Self) -> Duration;
  fn ms(x: Self) -> Duration;
  fn s(x: Self) -> Duration;
}

impl DurationScalar for i64 {
  fn ns(x: i64) -> Duration { return duration_ns(x); }

  fn us(x: i64) -> Duration { return duration_us(x); }

  fn ms(x: i64) -> Duration { return duration_ms(x); }

  fn s(x: i64) -> Duration { return duration_s(x); }
}
