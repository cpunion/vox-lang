// std/sync: Mutex[T] backed by C atomic FFI (no std/runtime import).

@ffi_import("c", "vox_impl_atomic_i32_new")
fn rt_atomic_i32_new(v: i32) -> isize;

@ffi_import("c", "vox_impl_atomic_i32_load")
fn rt_atomic_i32_load(handle: isize) -> i32;

@ffi_import("c", "vox_impl_atomic_i32_store")
fn rt_atomic_i32_store(handle: isize, v: i32) -> ();

@ffi_import("c", "vox_impl_atomic_i32_drop")
fn rt_atomic_i32_drop(handle: isize) -> ();

@ffi_import("c", "vox_impl_atomic_i64_new")
fn rt_atomic_i64_new(v: i64) -> isize;

@ffi_import("c", "vox_impl_atomic_i64_load")
fn rt_atomic_i64_load(handle: isize) -> i64;

@ffi_import("c", "vox_impl_atomic_i64_store")
fn rt_atomic_i64_store(handle: isize, v: i64) -> ();

@ffi_import("c", "vox_impl_atomic_i64_drop")
fn rt_atomic_i64_drop(handle: isize) -> ();

pub trait SyncScalar {
  fn mutex_new(v: Self) -> isize;
  fn mutex_load(sample: Self, handle: isize) -> Self;
  fn mutex_store(v: Self, handle: isize) -> ();
  fn mutex_drop(sample: Self, handle: isize) -> ();
}

impl SyncScalar for i32 {
  fn mutex_new(v: i32) -> isize { return rt_atomic_i32_new(v); }
  fn mutex_load(sample: i32, handle: isize) -> i32 { return rt_atomic_i32_load(handle); }
  fn mutex_store(v: i32, handle: isize) -> () { rt_atomic_i32_store(handle, v); }
  fn mutex_drop(sample: i32, handle: isize) -> () {
    sample;
    rt_atomic_i32_drop(handle);
  }
}

impl SyncScalar for i64 {
  fn mutex_new(v: i64) -> isize { return rt_atomic_i64_new(v); }
  fn mutex_load(sample: i64, handle: isize) -> i64 { return rt_atomic_i64_load(handle); }
  fn mutex_store(v: i64, handle: isize) -> () { rt_atomic_i64_store(handle, v); }
  fn mutex_drop(sample: i64, handle: isize) -> () {
    sample;
    rt_atomic_i64_drop(handle);
  }
}

pub struct Mutex[T: SyncScalar] {
  handle: isize,
  sample: T,
}

pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] {
  return Mutex { handle: SyncScalar.mutex_new(v), sample: v };
}

pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T {
  return SyncScalar.mutex_load(m.sample, m.handle);
}

pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
  SyncScalar.mutex_store(v, m.handle);
  return Mutex { handle: m.handle, sample: v };
}

pub fn mutex_into_inner[T: SyncScalar](m: Mutex[T]) -> T {
  return SyncScalar.mutex_load(m.sample, m.handle);
}

pub fn mutex_drop[T: SyncScalar](m: Mutex[T]) -> () {
  SyncScalar.mutex_drop(m.sample, m.handle);
}
