import "std/sys" as sys

fn vec_str_as_ptr(s: String) -> rawptr {
  let cp: const rawptr = s as const rawptr;
  let ip: isize = cp as isize;
  return ip as rawptr;
}

fn vec_ptr_add_i32(p: rawptr, off: i32) -> rawptr {
  return @ptr_offset(p, off as isize);
}

impl Vec[String] {
  fn join(v: Vec[String], sep: String) -> String {
    let n: i32 = v.len();
    if n == 0 { return ""; }
    let sep_len: i32 = sep.len();
    let mut total_len: i64 = 0 as i64;
    let mut i: i32 = 0;
    while i < n {
      total_len = total_len + (v.get(i).len() as i64);
      i = i + 1;
    }
    if sep_len > 0 && n > 1 {
      total_len = total_len + ((sep_len as i64) * ((n - 1) as i64));
    }
    if total_len < 0 as i64 { panic("string too long"); }
    let alloc_len: i64 = total_len + (1 as i64);
    if alloc_len <= 0 as i64 { panic("string too long"); }
    let alloc_size: usize = alloc_len as usize;
    if (alloc_size as i64) != alloc_len { panic("string too long"); }
    let out: rawptr = sys.malloc(alloc_size);
    if (out as isize) == (0 as isize) { panic("out of memory"); }
    let mut out_p: rawptr = out;
    i = 0;
    while i < n {
      if i > 0 && sep_len > 0 {
        let _: rawptr = sys.memcpy(out_p, vec_str_as_ptr(sep) as const rawptr, sep_len as usize);
        out_p = vec_ptr_add_i32(out_p, sep_len);
      }
      let part: String = v.get(i);
      let part_len: i32 = part.len();
      if part_len > 0 {
        let _: rawptr = sys.memcpy(out_p, vec_str_as_ptr(part) as const rawptr, part_len as usize);
        out_p = vec_ptr_add_i32(out_p, part_len);
      }
      i = i + 1;
    }
    @ptr_write[u8](out_p, 0 as u8);
    return out as String;
  }
}
