// stage1 std/prelude default traits.
//
// v0 keeps dispatch static: Trait.method(x, ...).

pub trait Eq {
  fn eq(a: Self, b: Self) -> bool;
}

pub trait Ord {
  fn lt(a: Self, b: Self) -> bool;
  fn le(a: Self, b: Self) -> bool;
  fn gt(a: Self, b: Self) -> bool;
  fn ge(a: Self, b: Self) -> bool;
}

pub trait Show {
  fn show(x: Self) -> String;
}

pub trait Clone {
  fn clone(x: Self) -> Self;
}

pub trait Release {
  fn release(x: Self) -> Self;
}

pub trait Into {
  type Target;
  fn into(x: Self) -> Self.Target;
}

// Marker traits: resolved by compiler auto-derivation in stage2.
pub trait Send {}
pub trait Sync {}

impl Eq for bool {
  fn eq(a: bool, b: bool) -> bool { return a == b; }
}

impl Eq for i8 {
  fn eq(a: i8, b: i8) -> bool { return a == b; }
}

impl Eq for u8 {
  fn eq(a: u8, b: u8) -> bool { return a == b; }
}

impl Eq for i16 {
  fn eq(a: i16, b: i16) -> bool { return a == b; }
}

impl Eq for u16 {
  fn eq(a: u16, b: u16) -> bool { return a == b; }
}

impl Eq for i32 {
  fn eq(a: i32, b: i32) -> bool { return a == b; }
}

impl Eq for u32 {
  fn eq(a: u32, b: u32) -> bool { return a == b; }
}

impl Eq for i64 {
  fn eq(a: i64, b: i64) -> bool { return a == b; }
}

impl Eq for u64 {
  fn eq(a: u64, b: u64) -> bool { return a == b; }
}

impl Eq for isize {
  fn eq(a: isize, b: isize) -> bool { return a == b; }
}

impl Eq for usize {
  fn eq(a: usize, b: usize) -> bool { return a == b; }
}

impl Eq for f32 {
  fn eq(a: f32, b: f32) -> bool { return a == b; }
}

impl Eq for f64 {
  fn eq(a: f64, b: f64) -> bool { return a == b; }
}

impl Eq for String {
  fn eq(a: String, b: String) -> bool { return a == b; }
}

impl Ord for i8 {
  fn lt(a: i8, b: i8) -> bool { return a < b; }
  fn le(a: i8, b: i8) -> bool { return a <= b; }
  fn gt(a: i8, b: i8) -> bool { return a > b; }
  fn ge(a: i8, b: i8) -> bool { return a >= b; }
}

impl Ord for u8 {
  fn lt(a: u8, b: u8) -> bool { return a < b; }
  fn le(a: u8, b: u8) -> bool { return a <= b; }
  fn gt(a: u8, b: u8) -> bool { return a > b; }
  fn ge(a: u8, b: u8) -> bool { return a >= b; }
}

impl Ord for i16 {
  fn lt(a: i16, b: i16) -> bool { return a < b; }
  fn le(a: i16, b: i16) -> bool { return a <= b; }
  fn gt(a: i16, b: i16) -> bool { return a > b; }
  fn ge(a: i16, b: i16) -> bool { return a >= b; }
}

impl Ord for u16 {
  fn lt(a: u16, b: u16) -> bool { return a < b; }
  fn le(a: u16, b: u16) -> bool { return a <= b; }
  fn gt(a: u16, b: u16) -> bool { return a > b; }
  fn ge(a: u16, b: u16) -> bool { return a >= b; }
}

impl Ord for i32 {
  fn lt(a: i32, b: i32) -> bool { return a < b; }
  fn le(a: i32, b: i32) -> bool { return a <= b; }
  fn gt(a: i32, b: i32) -> bool { return a > b; }
  fn ge(a: i32, b: i32) -> bool { return a >= b; }
}

impl Ord for u32 {
  fn lt(a: u32, b: u32) -> bool { return a < b; }
  fn le(a: u32, b: u32) -> bool { return a <= b; }
  fn gt(a: u32, b: u32) -> bool { return a > b; }
  fn ge(a: u32, b: u32) -> bool { return a >= b; }
}

impl Ord for i64 {
  fn lt(a: i64, b: i64) -> bool { return a < b; }
  fn le(a: i64, b: i64) -> bool { return a <= b; }
  fn gt(a: i64, b: i64) -> bool { return a > b; }
  fn ge(a: i64, b: i64) -> bool { return a >= b; }
}

impl Ord for u64 {
  fn lt(a: u64, b: u64) -> bool { return a < b; }
  fn le(a: u64, b: u64) -> bool { return a <= b; }
  fn gt(a: u64, b: u64) -> bool { return a > b; }
  fn ge(a: u64, b: u64) -> bool { return a >= b; }
}

impl Ord for isize {
  fn lt(a: isize, b: isize) -> bool { return a < b; }
  fn le(a: isize, b: isize) -> bool { return a <= b; }
  fn gt(a: isize, b: isize) -> bool { return a > b; }
  fn ge(a: isize, b: isize) -> bool { return a >= b; }
}

impl Ord for usize {
  fn lt(a: usize, b: usize) -> bool { return a < b; }
  fn le(a: usize, b: usize) -> bool { return a <= b; }
  fn gt(a: usize, b: usize) -> bool { return a > b; }
  fn ge(a: usize, b: usize) -> bool { return a >= b; }
}

impl Ord for f32 {
  fn lt(a: f32, b: f32) -> bool { return a < b; }
  fn le(a: f32, b: f32) -> bool { return a <= b; }
  fn gt(a: f32, b: f32) -> bool { return a > b; }
  fn ge(a: f32, b: f32) -> bool { return a >= b; }
}

impl Ord for f64 {
  fn lt(a: f64, b: f64) -> bool { return a < b; }
  fn le(a: f64, b: f64) -> bool { return a <= b; }
  fn gt(a: f64, b: f64) -> bool { return a > b; }
  fn ge(a: f64, b: f64) -> bool { return a >= b; }
}

impl Ord for String {
  fn lt(a: String, b: String) -> bool { return a < b; }
  fn le(a: String, b: String) -> bool { return a <= b; }
  fn gt(a: String, b: String) -> bool { return a > b; }
  fn ge(a: String, b: String) -> bool { return a >= b; }
}

impl Show for bool {
  fn show(x: bool) -> String { return x.to_string(); }
}

impl Show for i8 {
  fn show(x: i8) -> String { return x.to_string(); }
}

impl Show for u8 {
  fn show(x: u8) -> String { return x.to_string(); }
}

impl Show for i16 {
  fn show(x: i16) -> String { return x.to_string(); }
}

impl Show for u16 {
  fn show(x: u16) -> String { return x.to_string(); }
}

impl Show for i32 {
  fn show(x: i32) -> String { return x.to_string(); }
}

impl Show for u32 {
  fn show(x: u32) -> String { return x.to_string(); }
}

impl Show for i64 {
  fn show(x: i64) -> String { return x.to_string(); }
}

impl Show for u64 {
  fn show(x: u64) -> String { return x.to_string(); }
}

impl Show for isize {
  fn show(x: isize) -> String { return x.to_string(); }
}

impl Show for usize {
  fn show(x: usize) -> String { return x.to_string(); }
}

impl Show for f32 {
  fn show(x: f32) -> String { return x.to_string(); }
}

impl Show for f64 {
  fn show(x: f64) -> String { return x.to_string(); }
}

impl Show for String {
  fn show(x: String) -> String { return x; }
}


impl Clone for bool {
  fn clone(x: bool) -> bool { return x; }
}

impl Clone for i8 {
  fn clone(x: i8) -> i8 { return x; }
}

impl Clone for u8 {
  fn clone(x: u8) -> u8 { return x; }
}

impl Clone for i16 {
  fn clone(x: i16) -> i16 { return x; }
}

impl Clone for u16 {
  fn clone(x: u16) -> u16 { return x; }
}

impl Clone for i32 {
  fn clone(x: i32) -> i32 { return x; }
}

impl Clone for u32 {
  fn clone(x: u32) -> u32 { return x; }
}

impl Clone for i64 {
  fn clone(x: i64) -> i64 { return x; }
}

impl Clone for u64 {
  fn clone(x: u64) -> u64 { return x; }
}

impl Clone for isize {
  fn clone(x: isize) -> isize { return x; }
}

impl Clone for usize {
  fn clone(x: usize) -> usize { return x; }
}

impl Clone for f32 {
  fn clone(x: f32) -> f32 { return x; }
}

impl Clone for f64 {
  fn clone(x: f64) -> f64 { return x; }
}

impl Clone for String {
  fn clone(x: String) -> String {
    if x.len() == 0 { return ""; }
    return x.slice(0, x.len());
  }
}

impl[T: Clone] Clone for Vec[T] {
  fn clone(x: Vec[T]) -> Vec[T] {
    let mut out: Vec[T] = Vec();
    let mut i: i32 = 0;
    while i < x.len() {
      out.push(Clone.clone(x.get(i)));
      i = i + 1;
    }
    return out;
  }
}

impl Release for String {
  fn release(x: String) -> String { return ""; }
}

impl[T] Release for Vec[T] {
  fn release(x: Vec[T]) -> Vec[T] { return Vec(); }
}
