import "std/sys" as sys

// Helper: convert String to rawptr (String is const char*; cast through const rawptr -> isize -> rawptr).
fn str_as_ptr(s: String) -> rawptr {
  let cp: const rawptr = s as const rawptr;
  let ip: isize = cp as isize;
  return ip as rawptr;
}

fn ptr_next(p: rawptr) -> rawptr {
  return @ptr_offset(p, 1 as isize);
}

fn ptr_prev(p: rawptr) -> rawptr {
  return @ptr_offset(p, -1 as isize);
}

fn ptr_add_i32(p: rawptr, off: i32) -> rawptr {
  return @ptr_offset(p, off as isize);
}

fn ptr_write_u8_next(p: rawptr, b: u8) -> rawptr {
  @ptr_write[u8](p, b);
  return ptr_next(p);
}

impl String {
  fn len(s: String) -> i32 {
    let n: usize = sys.strlen(s);
    return n as i32;
  }

  fn is_empty(s: String) -> bool {
    return @ptr_read[u8](str_as_ptr(s)) == (0 as u8);
  }

  fn byte_at(s: String, idx: i32) -> i32 {
    let n: i32 = s.len();
    if idx < 0 || idx >= n { panic("string index out of bounds"); }
    let p: rawptr = ptr_add_i32(str_as_ptr(s), idx);
    let b: i32 = @ptr_read[u8](p) as i32;
    return b;
  }

  fn slice(s: String, start: i32, end: i32) -> String {
    let n: i32 = s.len();
    if start < 0 || end < start || end > n { panic("string slice out of bounds"); }
    let m: i32 = end - start;
    let out: rawptr = sys.malloc((m as usize) + (1 as usize));
    if (out as isize) == (0 as isize) { panic("out of memory"); }
    let src: rawptr = ptr_add_i32(str_as_ptr(s), start);
    let _: rawptr = sys.memcpy(out, src as const rawptr, m as usize);
    @ptr_write[u8](ptr_add_i32(out, m), 0 as u8);
    return out as String;
  }

  fn concat(s: String, other: String) -> String {
    let la: i32 = s.len();
    let lb: i32 = other.len();
    let out: rawptr = sys.malloc(((la + lb) as usize) + (1 as usize));
    if (out as isize) == (0 as isize) { panic("out of memory"); }
    let _: rawptr = sys.memcpy(out, str_as_ptr(s) as const rawptr, la as usize);
    let _: rawptr = sys.memcpy(ptr_add_i32(out, la), str_as_ptr(other) as const rawptr, lb as usize);
    @ptr_write[u8](ptr_add_i32(out, la + lb), 0 as u8);
    return out as String;
  }

  fn starts_with(s: String, pre: String) -> bool {
    let pn: i32 = pre.len();
    let sn: i32 = s.len();
    if pn > sn { return false; }
    let mut sp: rawptr = str_as_ptr(s);
    let mut pp: rawptr = str_as_ptr(pre);
    let mut i: i32 = 0;
    while i < pn {
      let sb: u8 = @ptr_read[u8](sp);
      let pb: u8 = @ptr_read[u8](pp);
      if sb != pb { return false; }
      sp = ptr_next(sp);
      pp = ptr_next(pp);
      i = i + 1;
    }
    return true;
  }

  fn ends_with(s: String, suf: String) -> bool {
    let sn: i32 = suf.len();
    let n: i32 = s.len();
    if sn > n { return false; }
    let mut sp: rawptr = ptr_add_i32(str_as_ptr(s), n - sn);
    let mut pp: rawptr = str_as_ptr(suf);
    let mut i: i32 = 0;
    while i < sn {
      let sb: u8 = @ptr_read[u8](sp);
      let pb: u8 = @ptr_read[u8](pp);
      if sb != pb { return false; }
      sp = ptr_next(sp);
      pp = ptr_next(pp);
      i = i + 1;
    }
    return true;
  }

  fn contains(s: String, needle: String) -> bool {
    return s.index_of(needle) >= 0;
  }

  fn index_of(s: String, needle: String) -> i32 {
    let nn: i32 = needle.len();
    let sn: i32 = s.len();
    if nn == 0 { return 0; }
    if nn > sn { return -1; }
    let mut sp_i: rawptr = str_as_ptr(s);
    let np: rawptr = str_as_ptr(needle);
    let mut i: i32 = 0;
    while i <= sn - nn {
      let mut ok: bool = true;
      let mut j: i32 = 0;
      let mut sp_j: rawptr = sp_i;
      let mut np_j: rawptr = np;
      while j < nn {
        let sb: u8 = @ptr_read[u8](sp_j);
        let nb: u8 = @ptr_read[u8](np_j);
        if sb != nb { ok = false; j = nn; }
        else {
          sp_j = ptr_next(sp_j);
          np_j = ptr_next(np_j);
          j = j + 1;
        }
      }
      if ok { return i; }
      sp_i = ptr_next(sp_i);
      i = i + 1;
    }
    return -1;
  }

  fn last_index_of(s: String, needle: String) -> i32 {
    let nn: i32 = needle.len();
    let sn: i32 = s.len();
    if nn == 0 { return sn; }
    if nn > sn { return -1; }
    let mut sp_i: rawptr = ptr_add_i32(str_as_ptr(s), sn - nn);
    let np: rawptr = str_as_ptr(needle);
    let mut i: i32 = sn - nn;
    while i >= 0 {
      let mut ok: bool = true;
      let mut j: i32 = 0;
      let mut sp_j: rawptr = sp_i;
      let mut np_j: rawptr = np;
      while j < nn {
        let sb: u8 = @ptr_read[u8](sp_j);
        let nb: u8 = @ptr_read[u8](np_j);
        if sb != nb { ok = false; j = nn; }
        else {
          sp_j = ptr_next(sp_j);
          np_j = ptr_next(np_j);
          j = j + 1;
        }
      }
      if ok { return i; }
      if i == 0 { break; }
      sp_i = ptr_prev(sp_i);
      i = i - 1;
    }
    return -1;
  }

  fn escape_c(s: String) -> String {
    let n: i32 = s.len();
    let mut in_p: rawptr = str_as_ptr(s);
    // Pass 1: count output size.
    let mut out_n64: i64 = 0 as i64;
    let mut i: i32 = 0;
    while i < n {
      let ch: i32 = @ptr_read[u8](in_p) as i32;
      if ch == 92 || ch == 34 || ch == 10 || ch == 13 || ch == 9 {
        out_n64 = out_n64 + (2 as i64);
      } else if ch >= 32 && ch <= 126 {
        out_n64 = out_n64 + (1 as i64);
      } else {
        out_n64 = out_n64 + (4 as i64);
      }
      in_p = ptr_next(in_p);
      i = i + 1;
    }
    // Pass 2: allocate and fill.
    if out_n64 < 0 as i64 { panic("string too long"); }
    let alloc_n64: i64 = out_n64 + (1 as i64);
    if alloc_n64 <= 0 as i64 { panic("string too long"); }
    let out: rawptr = sys.malloc(alloc_n64 as usize);
    if (out as isize) == (0 as isize) { panic("out of memory"); }
    in_p = str_as_ptr(s);
    let mut out_p: rawptr = out;
    i = 0;
    while i < n {
      let ch: i32 = @ptr_read[u8](in_p) as i32;
      if ch == 92 {
        out_p = ptr_write_u8_next(out_p, 92 as u8);
        out_p = ptr_write_u8_next(out_p, 92 as u8);
      } else if ch == 34 {
        out_p = ptr_write_u8_next(out_p, 92 as u8);
        out_p = ptr_write_u8_next(out_p, 34 as u8);
      } else if ch == 10 {
        out_p = ptr_write_u8_next(out_p, 92 as u8);
        out_p = ptr_write_u8_next(out_p, 110 as u8);
      } else if ch == 13 {
        out_p = ptr_write_u8_next(out_p, 92 as u8);
        out_p = ptr_write_u8_next(out_p, 114 as u8);
      } else if ch == 9 {
        out_p = ptr_write_u8_next(out_p, 92 as u8);
        out_p = ptr_write_u8_next(out_p, 116 as u8);
      } else if ch >= 32 && ch <= 126 {
        out_p = ptr_write_u8_next(out_p, ch as u8);
      } else {
        // \xHH encoding
        out_p = ptr_write_u8_next(out_p, 92 as u8);
        out_p = ptr_write_u8_next(out_p, 120 as u8);
        let hi: i32 = (ch / 16) % 16;
        let lo: i32 = ch % 16;
        out_p = ptr_write_u8_next(out_p, (if hi < 10 { hi + 48 } else { hi - 10 + 97 }) as u8);
        out_p = ptr_write_u8_next(out_p, (if lo < 10 { lo + 48 } else { lo - 10 + 97 }) as u8);
      }
      in_p = ptr_next(in_p);
      i = i + 1;
    }
    @ptr_write[u8](out_p, 0 as u8);
    return out as String;
  }

  fn to_string(s: String) -> String { return s; }
}

fn fmt_u64(v0: u64) -> String {
  let rev: rawptr = sys.malloc((32 as usize) + (1 as usize));
  if (rev as isize) == (0 as isize) { panic("out of memory"); }
  let mut rev_p: rawptr = rev;
  let mut v: u64 = v0;
  let mut n: i32 = 0;
  while true {
    let d: i32 = (v % (10 as u64)) as i32;
    rev_p = ptr_write_u8_next(rev_p, (48 + d) as u8);
    n = n + 1;
    v = v / (10 as u64);
    if v == (0 as u64) { break; }
  }
  let out: rawptr = sys.malloc((n as usize) + (1 as usize));
  if (out as isize) == (0 as isize) { panic("out of memory"); }
  let mut out_p: rawptr = out;
  let mut src_p: rawptr = ptr_prev(rev_p);
  let mut i: i32 = 0;
  while i < n {
    let b: u8 = @ptr_read[u8](src_p);
    out_p = ptr_write_u8_next(out_p, b);
    if i + 1 < n { src_p = ptr_prev(src_p); }
    i = i + 1;
  }
  @ptr_write[u8](out_p, 0 as u8);
  return out as String;
}

fn fmt_i64(v: i64) -> String {
  if v >= (0 as i64) { return fmt_u64(v as u64); }
  let mag: u64 = ((-(v + (1 as i64))) as u64) + (1 as u64);
  return "-".concat(fmt_u64(mag));
}

impl bool {
  fn to_string(v: bool) -> String {
    if v { return "true"; }
    return "false";
  }
}

impl i8 {
  fn to_string(v: i8) -> String { return fmt_i64(v as i64); }
}

impl u8 {
  fn to_string(v: u8) -> String { return fmt_u64(v as u64); }
}

impl i16 {
  fn to_string(v: i16) -> String { return fmt_i64(v as i64); }
}

impl u16 {
  fn to_string(v: u16) -> String { return fmt_u64(v as u64); }
}

impl i32 {
  fn to_string(v: i32) -> String { return fmt_i64(v as i64); }
}

impl u32 {
  fn to_string(v: u32) -> String { return fmt_u64(v as u64); }
}

impl i64 {
  fn to_string(v: i64) -> String { return fmt_i64(v); }
}

impl u64 {
  fn to_string(v: u64) -> String { return fmt_u64(v); }
}

impl isize {
  fn to_string(v: isize) -> String { return fmt_i64(v as i64); }
}

impl usize {
  fn to_string(v: usize) -> String { return fmt_u64(v as u64); }
}

impl f32 {
  fn to_string(v: f32) -> String { return fmt_i64(v as i64); }
}

impl f64 {
  fn to_string(v: f64) -> String { return fmt_i64(v as i64); }
}
