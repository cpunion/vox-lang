import "std/os" as os
import "std/process" as proc
import "std/string" as s
import "std/testing" as t

fn test_process_command_render_smoke() -> () {
  let c: proc.Command = proc.command("vox")
    .env("A", "1 2")
    .arg("hello world")
    .arg("\"x\"");
  let r: String = c.render();
  t.assert(s.contains(s.view_all(r), "A=\"1 2\""));
  t.assert(s.contains(s.view_all(r), "\"vox\""));
  t.assert(s.contains(s.view_all(r), "\"hello world\""));
  t.assert(s.contains(s.view_all(r), "\\\"x\\\""));
}

fn test_process_command_env_remove_and_clear_env_smoke() -> () {
  let c: proc.Command = proc.command("vox")
    .env("A", "1")
    .env("B", "2")
    .env_remove("A");
  let r: String = c.render();
  t.assert(!s.contains(s.view_all(r), "A=\"1\""));
  t.assert(s.contains(s.view_all(r), "B=\"2\""));

  let c2: proc.Command = c.clear_env();
  let r2: String = c2.render();
  t.assert(!s.contains(s.view_all(r2), "B=\"2\""));
  t.assert(s.contains(s.view_all(r2), "\"vox\""));
}

fn test_process_command_cwd_render_smoke() -> () {
  let c: proc.Command = proc.command("vox").cwd("/tmp/vox test");
  let r: String = c.render();
  t.assert(s.starts_with(s.view_all(r), "cd \"/tmp/vox test\" && "));
  t.assert(s.contains(s.view_all(r), "\"vox\""));
}

fn test_process_command_run_smoke() -> () {
  let exe: String = proc.exe_path();
  if exe == "" { return; }
  if s.contains(s.view_all(exe), "vox.test") { return; }
  let cmd: proc.Command = proc.command(exe).arg("version");
  let rc: i32 = cmd.run();
  t.assert_eq(rc, 0);
}

fn test_process_exec_compat_with_command_render_smoke() -> () {
  let exe: String = proc.exe_path();
  if exe == "" { return; }
  if s.contains(s.view_all(exe), "vox.test") { return; }
  let cmd: proc.Command = proc.command(exe).arg("version");
  let cmdline: String = cmd.render();
  let rc: i32 = proc.exec(cmdline);
  t.assert_eq(rc, 0);
}

fn test_process_getenv_uses_os_surface_smoke() -> () {
  let key: String = "__VOX_MISSING_ENV_SHOULD_NOT_EXIST__";
  let a: String = proc.getenv(key);
  let b: String = os.getenv(key);
  t.assert_eq(a.len(), b.len());
}

fn test_process_args_and_exe_path_use_os_surface_smoke() -> () {
  let a: Vec[String] = proc.args();
  let b: Vec[String] = os.args();
  t.assert_eq(a.len(), b.len());

  let p0: String = proc.exe_path();
  let p1: String = os.exe_path();
  t.assert_eq(p0.len(), p1.len());
}
