// Vox compiler entry.
//
// Minimal CLI:
// - build/test/run/install/list/fmt/lsp/version

import "std/process" as proc
import "std/fs" as fs
import "std/time" as tm
import "vox/loader" as ld
import "vox/compile" as c
import "vox/manifest" as mf
import "vox/codegen" as cg
import "vox/parse" as p
import "vox/ast" as ast
import "vox/list" as lst
import "vox/buildinfo" as bi
import "vox/fmt" as vf
import "vox/internal/path" as pth
import "vox/internal/source" as srcw
import "vox/internal/strset" as ss
import "vox/internal/text" as txt

fn path_base_name(p: String) -> String {
  return pth.base_name(p);
}

fn host_is_windows() -> bool {
  let os: String = proc.getenv("OS");
  if os == "Windows_NT" { return true; }
  let exe: String = proc.exe_path();
  if exe.len() >= 4 && exe.slice(exe.len() - 4, exe.len()) == ".exe" { return true; }
  if exe.len() >= 2 && exe.byte_at(1) == 58 && pth.is_alpha_ascii(exe.byte_at(0)) { return true; } // C:
  if exe.len() >= 3 && exe.byte_at(0) == 47 && pth.is_alpha_ascii(exe.byte_at(1)) && exe.byte_at(2) == 47 { return true; } // /c/
  return false;
}

fn normalize_host_fs_path(p0: String) -> String {
  if !host_is_windows() { return p0; }
  return pth.normalize_msys_drive_path(p0);
}

fn shell_exec_path(p0: String) -> String {
  let p: String = normalize_host_fs_path(p0);
  if !host_is_windows() { return p; }
  let out: String = pth.to_back_slashes(p);
  if !is_abs_path(out) && !txt.has_prefix(out, ".\\") && !txt.has_prefix(out, "..\\") {
    return ".\\".concat(out);
  }
  return out;
}

fn cc_link_flags() -> String {
  if host_is_windows() { return " -lws2_32 -static -Wl,--stack,67108864"; }
  return "";
}

fn cc_cmd() -> String {
  let cc_env: String = proc.getenv("CC");
  if cc_env != "" { return cc_env; }
  if host_is_windows() { return "gcc"; }
  return "cc";
}

fn cc_common_flags() -> String {
  if host_is_windows() { return ""; }
  return " -D_POSIX_C_SOURCE=200809L -D_DEFAULT_SOURCE -D_FILE_OFFSET_BITS=64";
}

struct CliTargetSpec {
  ok: bool,
  err: String,
  raw: String,
  os: String,
  arch: String,
  abi: String,
  canon: String,
  triple: String,
}

fn target_abi_from_text(s: String) -> String {
  if text_contains(s, "msvc") { return "msvc"; }
  if text_contains(s, "mingw") || text_contains(s, "gnu") || text_contains(s, "w64") { return "gnu"; }
  if text_contains(s, "wasi") { return "wasi"; }
  if text_contains(s, "emscripten") { return "emscripten"; }
  return "";
}

fn target_triple_for(os: String, arch: String, abi0: String) -> String {
  let mut abi: String = abi0;
  if os == "windows" && abi == "" { abi = "gnu"; }

  if os == "linux" {
    if arch == "amd64" { return "x86_64-unknown-linux-gnu"; }
    if arch == "x86" { return "i686-unknown-linux-gnu"; }
    return "aarch64-unknown-linux-gnu";
  }
  if os == "darwin" {
    if arch == "amd64" { return "x86_64-apple-darwin"; }
    return "aarch64-apple-darwin";
  }
  if os == "windows" {
    if abi == "msvc" {
      if arch == "amd64" { return "x86_64-pc-windows-msvc"; }
      if arch == "x86" { return "i686-pc-windows-msvc"; }
      return "aarch64-pc-windows-msvc";
    }
    if arch == "amd64" { return "x86_64-w64-mingw32"; }
    if arch == "x86" { return "i686-w64-mingw32"; }
    return "aarch64-w64-mingw32";
  }
  if os == "wasm" {
    if abi == "wasi" { return "wasm32-wasi"; }
    if abi == "emscripten" { return "wasm32-unknown-emscripten"; }
    return "wasm32-unknown-unknown";
  }
  return os.concat("-").concat(arch);
}

fn cli_target_spec_ok(raw: String, os: String, arch: String, abi0: String) -> CliTargetSpec {
  let mut abi: String = abi0;
  if os != "windows" && os != "wasm" { abi = ""; }
  if os == "windows" && abi == "" { abi = "gnu"; }
  if os == "wasm" && abi == "" { abi = "unknown"; }
  let canon: String = os.concat("-").concat(arch);
  return CliTargetSpec {
    ok: true,
    err: "",
    raw: raw,
    os: os,
    arch: arch,
    abi: abi,
    canon: canon,
    triple: target_triple_for(os, arch, abi),
  };
}

fn cli_target_spec_err(raw: String, msg: String) -> CliTargetSpec {
  return CliTargetSpec {
    ok: false,
    err: msg,
    raw: raw,
    os: "",
    arch: "",
    abi: "",
    canon: "",
    triple: "",
  };
}

fn target_os_supported(os: String) -> bool {
  return os == "linux" || os == "darwin" || os == "windows" || os == "wasm";
}

fn target_arch_supported(arch: String) -> bool {
  return arch == "amd64" || arch == "arm64" || arch == "x86" || arch == "wasm32";
}

fn target_ptr_bits(arch: String) -> i32 {
  if arch == "x86" || arch == "wasm32" { return 32; }
  return 64;
}

fn target_pair_supported(os: String, arch: String) -> bool {
  if os == "darwin" && arch == "x86" { return false; }
  if os == "wasm" && arch != "wasm32" { return false; }
  return true;
}

fn target_os_from_text(s: String) -> String {
  if s == "windows" || s == "win" || s == "win32" || text_contains(s, "windows") || text_contains(s, "mingw") || text_contains(s, "w64") || text_contains(s, "msvc") {
    return "windows";
  }
  if s == "darwin" || s == "macos" || s == "mac" || text_contains(s, "darwin") || text_contains(s, "apple") {
    return "darwin";
  }
  if s == "linux" || text_contains(s, "linux") { return "linux"; }
  if s == "wasm" || text_contains(s, "wasm") || text_contains(s, "wasi") { return "wasm"; }
  return "";
}

fn target_arch_from_text(s: String) -> String {
  if text_contains(s, "wasm32") { return "wasm32"; }
  if text_contains(s, "x86_64") || text_contains(s, "amd64") || text_contains(s, "x64") || text_contains(s, "x86-64") {
    return "amd64";
  }
  if text_contains(s, "aarch64") || text_contains(s, "arm64") {
    return "arm64";
  }
  if s == "x86" || text_contains(s, "i386") || text_contains(s, "i486") || text_contains(s, "i586") || text_contains(s, "i686") || text_contains(s, "x86") {
    return "x86";
  }
  return "";
}

fn platform_os_part(p: String) -> String {
  let mut i: i32 = 0;
  while i < p.len() {
    if p.byte_at(i) == 45 { return p.slice(0, i); } // '-'
    i = i + 1;
  }
  if p == "" { return "linux"; }
  return p;
}

fn platform_arch_part(p: String) -> String {
  let mut i: i32 = 0;
  while i < p.len() {
    if p.byte_at(i) == 45 {
      if i + 1 >= p.len() { return "amd64"; }
      return p.slice(i + 1, p.len());
    }
    i = i + 1;
  }
  return "amd64";
}

fn parse_cli_target_spec(raw0: String, host_os: String, host_arch: String) -> CliTargetSpec {
  let raw: String = txt.trim_space(raw0);
  let s: String = tc_ascii_lower(raw);
  if s == "" || s == "host" || s == "native" {
    return cli_target_spec_ok(raw, host_os, host_arch, "");
  }

  let os: String = target_os_from_text(s);
  let mut arch: String = target_arch_from_text(s);
  let mut abi: String = target_abi_from_text(s);
  if os == "" {
    return cli_target_spec_err(raw, "invalid --target: unknown os in '".concat(raw).concat("'"));
  }
  if arch == "" {
    if os == "wasm" { arch = "wasm32"; } else { arch = host_arch; }
  }
  if os == "windows" && abi == "" { abi = "gnu"; }
  if os == "wasm" && abi == "" { abi = "unknown"; }
  if os != "windows" && os != "wasm" { abi = ""; }

  if !target_os_supported(os) {
    return cli_target_spec_err(raw, "invalid --target: unsupported os '".concat(os).concat("'"));
  }
  if !target_arch_supported(arch) {
    return cli_target_spec_err(raw, "invalid --target: unsupported arch '".concat(arch).concat("'"));
  }
  if !target_pair_supported(os, arch) {
    return cli_target_spec_err(raw, "invalid --target: unsupported platform '".concat(os).concat("-").concat(arch).concat("'"));
  }
  return cli_target_spec_ok(raw, os, arch, abi);
}

struct CliArtifactSpec {
  ok: bool,
  err: String,
  kind: String, // exe | static | shared
}

fn cli_artifact_spec_ok(kind: String) -> CliArtifactSpec {
  return CliArtifactSpec { ok: true, err: "", kind: kind };
}

fn cli_artifact_spec_err(msg: String) -> CliArtifactSpec {
  return CliArtifactSpec { ok: false, err: msg, kind: "" };
}

fn parse_cli_artifact(raw0: String) -> CliArtifactSpec {
  let s: String = tc_ascii_lower(txt.trim_space(raw0));
  if s == "" || s == "exe" {
    return cli_artifact_spec_ok("exe");
  }
  if s == "static" || s == "staticlib" {
    return cli_artifact_spec_ok("static");
  }
  if s == "shared" || s == "sharedlib" || s == "dylib" || s == "cdylib" {
    return cli_artifact_spec_ok("shared");
  }
  return cli_artifact_spec_err("invalid --artifact: expected exe|static|shared, got '".concat(raw0).concat("'"));
}

fn env_key_suffix(s: String) -> String {
  let mut out: String = "";
  let up: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    if ch >= 97 && ch <= 122 {
      out = out.concat(up.slice(ch - 97, ch - 96));
      i = i + 1;
      continue;
    }
    if (ch >= 65 && ch <= 90) || (ch >= 48 && ch <= 57) {
      out = out.concat(s.slice(i, i + 1));
      i = i + 1;
      continue;
    }
    out = out.concat("_");
    i = i + 1;
  }
  return out;
}

fn cc_is_msvc_cmd(cmd0: String) -> bool {
  let cmd: String = tc_ascii_lower(txt.trim_space(cmd0));
  return cmd == "cl" || cmd == "cl.exe" || text_contains(cmd, "\\cl.exe") || text_contains(cmd, "/cl.exe");
}

fn cc_cmd_for_target(host_os: String, host_arch: String, target_os: String, target_arch: String, target_triple: String, target_abi: String) -> String {
  let cc_env: String = txt.trim_space(proc.getenv("CC"));
  if cc_env != "" { return cc_env; }

  let cc_canon: String = txt.trim_space(proc.getenv("CC_".concat(env_key_suffix(target_os.concat("_").concat(target_arch)))));
  if cc_canon != "" { return cc_canon; }

  let cc_triple: String = txt.trim_space(proc.getenv("CC_".concat(env_key_suffix(target_triple))));
  if cc_triple != "" { return cc_triple; }

  if host_os == target_os && host_arch == target_arch {
    if target_os == "windows" {
      if target_abi == "msvc" { return "cl"; }
      return "gcc";
    }
    return "cc";
  }

  if target_os == "windows" {
    if target_abi == "msvc" {
      if host_os == "windows" { return "cl"; }
      return "clang";
    }
    if target_arch == "amd64" { return "x86_64-w64-mingw32-gcc"; }
    if target_arch == "x86" { return "i686-w64-mingw32-gcc"; }
    return "aarch64-w64-mingw32-gcc";
  }
  if target_os == "linux" {
    if target_arch == "amd64" { return "x86_64-linux-gnu-gcc"; }
    if target_arch == "x86" { return "i686-linux-gnu-gcc"; }
    return "aarch64-linux-gnu-gcc";
  }
  if target_os == "darwin" { return "clang"; }
  if target_os == "wasm" {
    if target_abi == "wasi" { return "clang"; }
    if target_abi == "emscripten" { return "emcc"; }
    return "emcc";
  }
  return "cc";
}

fn cc_target_flags_for_target(cmd: String, host_os: String, host_arch: String, target_os: String, target_arch: String, target_triple: String) -> String {
  if host_os == target_os && host_arch == target_arch { return ""; }
  if cc_is_msvc_cmd(cmd) { return ""; }
  if text_contains(cmd, "clang") || cmd == "cc" {
    return " --target=".concat(target_triple);
  }
  return "";
}

fn cc_link_flags_for_target(target_os: String, target_abi: String, use_msvc: bool, artifact: String) -> String {
  if artifact == "static" { return ""; }
  if target_os == "wasm" {
    if target_abi == "wasi" { return ""; }
    return " -Wl,--no-entry -Wl,--export-all";
  }
  if target_os != "windows" { return ""; }
  if use_msvc {
    if artifact == "shared" { return " /link ws2_32.lib"; }
    return " /link ws2_32.lib /STACK:67108864";
  }
  if artifact == "shared" { return " -lws2_32"; }
  return " -lws2_32 -static -Wl,--stack,67108864";
}

fn cc_common_flags_for_target(target_os: String, use_msvc: bool) -> String {
  if use_msvc { return ""; }
  if target_os == "windows" || target_os == "wasm" { return ""; }
  return " -D_POSIX_C_SOURCE=200809L -D_DEFAULT_SOURCE -D_FILE_OFFSET_BITS=64";
}

fn cc_debug_flags(use_msvc: bool) -> String {
  let raw: String = txt.trim_space(proc.getenv("VOX_CC_DEBUG"));
  let on: bool = raw == "1" || raw == "true" || raw == "yes" || raw == "on";
  if use_msvc {
    return if on { " /Zi" } else { "" };
  }
  return if on { " -g" } else { " -g0" };
}

fn ar_cmd_for_target(host_os: String, target_os: String, target_arch: String, target_triple: String, target_abi: String) -> String {
  let ar_env: String = txt.trim_space(proc.getenv("AR"));
  if ar_env != "" { return ar_env; }

  let ar_canon: String = txt.trim_space(proc.getenv("AR_".concat(env_key_suffix(target_os.concat("_").concat(target_arch)))));
  if ar_canon != "" { return ar_canon; }

  let ar_triple: String = txt.trim_space(proc.getenv("AR_".concat(env_key_suffix(target_triple))));
  if ar_triple != "" { return ar_triple; }

  if target_abi == "msvc" {
    if host_os == "windows" { return "lib"; }
    return "llvm-lib";
  }

  if target_os == "windows" {
    if target_arch == "amd64" { return "x86_64-w64-mingw32-ar"; }
    if target_arch == "x86" { return "i686-w64-mingw32-ar"; }
    return "aarch64-w64-mingw32-ar";
  }
  if target_os == "linux" {
    if target_arch == "amd64" { return "x86_64-linux-gnu-ar"; }
    if target_arch == "x86" { return "i686-linux-gnu-ar"; }
    return "aarch64-linux-gnu-ar";
  }
  return "ar";
}

fn cc_shared_flag_for_target(target_os: String, use_msvc: bool) -> String {
  if use_msvc { return " /LD"; }
  if target_os == "darwin" { return " -dynamiclib"; }
  return " -shared";
}

fn cc_cmdline_static_msvc(cc: String, cpath: String, out: String, ar: String) -> String {
  let obj: String = out.concat(".obj");
  let mut cmd: String = cc;
  cmd = cmd.concat(" /nologo /TC /std:c11 /Od");
  cmd = cmd.concat(cc_debug_flags(true));
  cmd = cmd.concat(" /c ");
  cmd = cmd.concat(cpath);
  cmd = cmd.concat(" /Fo:");
  cmd = cmd.concat(obj);
  cmd = cmd.concat(" && ");
  cmd = cmd.concat(ar);
  cmd = cmd.concat(" /nologo /OUT:");
  cmd = cmd.concat(out);
  cmd = cmd.concat(" ");
  cmd = cmd.concat(obj);
  return cmd;
}

fn cc_cmdline_static_gnu(cc: String, tflags: String, target_os: String, cpath: String, out: String, ar: String) -> String {
  let obj: String = out.concat(".o");
  let mut cmd: String = cc;
  cmd = cmd.concat(tflags);
  cmd = cmd.concat(" -std=c11 -O0");
  cmd = cmd.concat(cc_debug_flags(false));
  cmd = cmd.concat(cc_common_flags_for_target(target_os, false));
  cmd = cmd.concat(" -c ");
  cmd = cmd.concat(cpath);
  cmd = cmd.concat(" -o ");
  cmd = cmd.concat(obj);
  cmd = cmd.concat(" && ");
  cmd = cmd.concat(ar);
  cmd = cmd.concat(" rcs ");
  cmd = cmd.concat(out);
  cmd = cmd.concat(" ");
  cmd = cmd.concat(obj);
  return cmd;
}

fn cc_cmdline_non_static_msvc(cc: String, target_os: String, target_abi: String, artifact: String, cpath: String, out: String) -> String {
  let shared_flag: String = if artifact == "shared" { cc_shared_flag_for_target(target_os, true) } else { "" };
  let mut cmd: String = cc;
  cmd = cmd.concat(" /nologo /TC /std:c11 /Od");
  cmd = cmd.concat(cc_debug_flags(true));
  cmd = cmd.concat(shared_flag);
  cmd = cmd.concat(" ");
  cmd = cmd.concat(cpath);
  cmd = cmd.concat(" /Fe:");
  cmd = cmd.concat(out);
  cmd = cmd.concat(cc_link_flags_for_target(target_os, target_abi, true, artifact));
  return cmd;
}

fn cc_cmdline_non_static_gnu(cc: String, tflags: String, target_os: String, target_abi: String, artifact: String, cpath: String, out: String) -> String {
  let shared_flag: String = if artifact == "shared" { cc_shared_flag_for_target(target_os, false) } else { "" };
  let mut cmd: String = cc;
  cmd = cmd.concat(tflags);
  cmd = cmd.concat(" -std=c11 -O0");
  cmd = cmd.concat(cc_debug_flags(false));
  cmd = cmd.concat(cc_common_flags_for_target(target_os, false));
  cmd = cmd.concat(shared_flag);
  cmd = cmd.concat(" ");
  cmd = cmd.concat(cpath);
  cmd = cmd.concat(" -o ");
  cmd = cmd.concat(out);
  cmd = cmd.concat(cc_link_flags_for_target(target_os, target_abi, false, artifact));
  return cmd;
}

fn cc_object_ext(use_msvc: bool) -> String {
  if use_msvc { return ".obj"; }
  return ".o";
}

fn cc_compile_obj_cmdline_msvc(cc: String, cpath: String, obj: String) -> String {
  let mut cmd: String = cc;
  cmd = cmd.concat(" /nologo /TC /std:c11 /Od");
  cmd = cmd.concat(cc_debug_flags(true));
  cmd = cmd.concat(" /c ");
  cmd = cmd.concat(cpath);
  cmd = cmd.concat(" /Fo:");
  cmd = cmd.concat(obj);
  return cmd;
}

fn cc_compile_obj_cmdline_gnu(cc: String, tflags: String, target_os: String, cpath: String, obj: String) -> String {
  let mut cmd: String = cc;
  cmd = cmd.concat(tflags);
  cmd = cmd.concat(" -std=c11 -O0");
  cmd = cmd.concat(cc_debug_flags(false));
  cmd = cmd.concat(cc_common_flags_for_target(target_os, false));
  cmd = cmd.concat(" -c ");
  cmd = cmd.concat(cpath);
  cmd = cmd.concat(" -o ");
  cmd = cmd.concat(obj);
  return cmd;
}

fn cc_link_obj_cmdline_static_msvc(ar: String, obj: String, out: String) -> String {
  return ar.concat(" /nologo /OUT:").concat(out).concat(" ").concat(obj);
}

fn cc_link_obj_cmdline_static_gnu(ar: String, obj: String, out: String) -> String {
  return ar.concat(" rcs ").concat(out).concat(" ").concat(obj);
}

fn cc_link_obj_cmdline_non_static_msvc(cc: String, target_os: String, target_abi: String, artifact: String, obj: String, out: String) -> String {
  let shared_flag: String = if artifact == "shared" { cc_shared_flag_for_target(target_os, true) } else { "" };
  let mut cmd: String = cc;
  cmd = cmd.concat(" /nologo");
  cmd = cmd.concat(shared_flag);
  cmd = cmd.concat(" ");
  cmd = cmd.concat(obj);
  cmd = cmd.concat(" /Fe:");
  cmd = cmd.concat(out);
  cmd = cmd.concat(cc_link_flags_for_target(target_os, target_abi, true, artifact));
  return cmd;
}

fn cc_link_obj_cmdline_non_static_gnu(cc: String, tflags: String, target_os: String, target_abi: String, artifact: String, obj: String, out: String) -> String {
  let shared_flag: String = if artifact == "shared" { cc_shared_flag_for_target(target_os, false) } else { "" };
  let mut cmd: String = cc;
  cmd = cmd.concat(tflags);
  cmd = cmd.concat(shared_flag);
  cmd = cmd.concat(" ");
  cmd = cmd.concat(obj);
  cmd = cmd.concat(" -o ");
  cmd = cmd.concat(out);
  cmd = cmd.concat(cc_link_flags_for_target(target_os, target_abi, false, artifact));
  return cmd;
}

fn cc_compile_obj_cmdline_for_target_artifact(host_os: String, host_arch: String, target_os: String, target_arch: String, target_triple: String, target_abi: String, cpath: String, obj: String) -> String {
  let cc: String = cc_cmd_for_target(host_os, host_arch, target_os, target_arch, target_triple, target_abi);
  let use_msvc: bool = cc_is_msvc_cmd(cc);
  let tflags: String = cc_target_flags_for_target(cc, host_os, host_arch, target_os, target_arch, target_triple);
  if use_msvc { return cc_compile_obj_cmdline_msvc(cc, cpath, obj); }
  return cc_compile_obj_cmdline_gnu(cc, tflags, target_os, cpath, obj);
}

fn cc_link_obj_cmdline_for_target_artifact(host_os: String, host_arch: String, target_os: String, target_arch: String, target_triple: String, target_abi: String, artifact: String, obj: String, out: String) -> String {
  let cc: String = cc_cmd_for_target(host_os, host_arch, target_os, target_arch, target_triple, target_abi);
  let use_msvc: bool = cc_is_msvc_cmd(cc);
  let tflags: String = cc_target_flags_for_target(cc, host_os, host_arch, target_os, target_arch, target_triple);
  if artifact == "static" {
    let ar: String = ar_cmd_for_target(host_os, target_os, target_arch, target_triple, target_abi);
    if use_msvc { return cc_link_obj_cmdline_static_msvc(ar, obj, out); }
    return cc_link_obj_cmdline_static_gnu(ar, obj, out);
  }
  if use_msvc { return cc_link_obj_cmdline_non_static_msvc(cc, target_os, target_abi, artifact, obj, out); }
  return cc_link_obj_cmdline_non_static_gnu(cc, tflags, target_os, target_abi, artifact, obj, out);
}

fn append_build_mode_line(out0: String, key: String, value: String) -> String {
  let mut out: String = out0;
  out = out.concat(key);
  out = out.concat(value);
  out = out.concat("\n");
  return out;
}

fn build_toolchain_fingerprint(host_os: String, host_arch: String, target_os: String, target_arch: String, target_triple: String, target_abi: String, artifact: String) -> String {
  let cc: String = cc_cmd_for_target(host_os, host_arch, target_os, target_arch, target_triple, target_abi);
  let use_msvc: bool = cc_is_msvc_cmd(cc);
  let tflags: String = cc_target_flags_for_target(cc, host_os, host_arch, target_os, target_arch, target_triple);
  let cflags: String = cc_common_flags_for_target(target_os, use_msvc);
  let dflags: String = cc_debug_flags(use_msvc);
  let lflags: String = cc_link_flags_for_target(target_os, target_abi, use_msvc, artifact);
  let mut out: String = "";
  out = append_build_mode_line(out, "cc=", cc);
  out = append_build_mode_line(out, "cc_target_flags=", tflags);
  out = append_build_mode_line(out, "cc_common_flags=", cflags);
  out = append_build_mode_line(out, "cc_debug_flags=", dflags);
  out = append_build_mode_line(out, "cc_link_flags=", lflags);
  if artifact == "static" {
    let ar: String = ar_cmd_for_target(host_os, target_os, target_arch, target_triple, target_abi);
    out = append_build_mode_line(out, "ar=", ar);
  }
  return out;
}

fn build_compile_toolchain_fingerprint(host_os: String, host_arch: String, target_os: String, target_arch: String, target_triple: String, target_abi: String) -> String {
  let cc: String = cc_cmd_for_target(host_os, host_arch, target_os, target_arch, target_triple, target_abi);
  let use_msvc: bool = cc_is_msvc_cmd(cc);
  let tflags: String = cc_target_flags_for_target(cc, host_os, host_arch, target_os, target_arch, target_triple);
  let cflags: String = cc_common_flags_for_target(target_os, use_msvc);
  let dflags: String = cc_debug_flags(use_msvc);
  let mut out: String = "";
  out = append_build_mode_line(out, "cc=", cc);
  out = append_build_mode_line(out, "cc_target_flags=", tflags);
  out = append_build_mode_line(out, "cc_common_flags=", cflags);
  out = append_build_mode_line(out, "cc_debug_flags=", dflags);
  return out;
}

fn build_compile_mode_text(cmd0: String, driver_key: String, emit_driver_key: String, host_os: String, host_arch: String, target_os: String, target_arch: String, target_triple: String, target_abi: String) -> String {
  let mut out: String = "";
  out = append_build_mode_line(out, "cmd=", cmd0);
  out = append_build_mode_line(out, "driver=", driver_key);
  out = append_build_mode_line(out, "emit_driver_main=", emit_driver_key);
  out = append_build_mode_line(out, "host=", host_os.concat("-").concat(host_arch));
  out = append_build_mode_line(out, "target=", target_os.concat("-").concat(target_arch));
  out = append_build_mode_line(out, "triple=", target_triple);
  out = append_build_mode_line(out, "abi=", target_abi);
  out = append_build_mode_line(out, "toolchain=", build_compile_toolchain_fingerprint(host_os, host_arch, target_os, target_arch, target_triple, target_abi));
  return out;
}

fn build_mode_text(cmd0: String, driver_key: String, emit_driver_key: String, host_os: String, host_arch: String, target_os: String, target_arch: String, target_triple: String, target_abi: String, artifact: String) -> String {
  let mut out: String = "";
  out = append_build_mode_line(out, "cmd=", cmd0);
  out = append_build_mode_line(out, "driver=", driver_key);
  out = append_build_mode_line(out, "emit_driver_main=", emit_driver_key);
  out = append_build_mode_line(out, "host=", host_os.concat("-").concat(host_arch));
  out = append_build_mode_line(out, "target=", target_os.concat("-").concat(target_arch));
  out = append_build_mode_line(out, "triple=", target_triple);
  out = append_build_mode_line(out, "abi=", target_abi);
  out = append_build_mode_line(out, "artifact=", artifact);
  out = append_build_mode_line(out, "toolchain=", build_toolchain_fingerprint(host_os, host_arch, target_os, target_arch, target_triple, target_abi, artifact));
  return out;
}

fn cc_cmdline_for_target_artifact(host_os: String, host_arch: String, target_os: String, target_arch: String, target_triple: String, target_abi: String, artifact: String, cpath: String, out: String) -> String {
  let cc: String = cc_cmd_for_target(host_os, host_arch, target_os, target_arch, target_triple, target_abi);
  let use_msvc: bool = cc_is_msvc_cmd(cc);
  let tflags: String = cc_target_flags_for_target(cc, host_os, host_arch, target_os, target_arch, target_triple);

  if artifact == "static" {
    let ar: String = ar_cmd_for_target(host_os, target_os, target_arch, target_triple, target_abi);
    if use_msvc { return cc_cmdline_static_msvc(cc, cpath, out, ar); }
    return cc_cmdline_static_gnu(cc, tflags, target_os, cpath, out, ar);
  }

  if use_msvc { return cc_cmdline_non_static_msvc(cc, target_os, target_abi, artifact, cpath, out); }
  return cc_cmdline_non_static_gnu(cc, tflags, target_os, target_abi, artifact, cpath, out);
}

fn cc_cmdline_for_target(host_os: String, host_arch: String, target_os: String, target_arch: String, target_triple: String, target_abi: String, cpath: String, out: String) -> String {
  return cc_cmdline_for_target_artifact(host_os, host_arch, target_os, target_arch, target_triple, target_abi, "exe", cpath, out);
}

fn cmd_supports_target(cmd: String) -> bool {
  return cmd == "build" || cmd == "test" || cmd == "run" || cmd == "install" || cmd == "list";
}

fn cmd_supports_artifact(cmd: String) -> bool {
  return cmd == "build" || cmd == "run" || cmd == "install";
}

fn cmd_supports_emit_c(cmd: String) -> bool {
  return cmd == "build" || cmd == "test" || cmd == "run";
}

fn usage() -> () {
  let bin: String = pth.base_name(proc.exe_path());
  print(bin.concat(" usage:\n"));
  print("  ".concat(bin).concat(" build [--driver=user|tool] [--artifact=exe|static|shared] [--target=<value>] [out.bin]\n"));
  print("  ".concat(bin).concat(" test  [--module=<glob>] [--run=<glob>] [--filter=<text>] [--jobs=N|-j N] [--fail-fast] [--list] [--rerun-failed] [--json] [out.bin]\n"));
  print("  ".concat(bin).concat(" run   [--driver=user|tool] [--artifact=exe] [--target=<value>] [out.bin]\n"));
  print("  ".concat(bin).concat(" run fmt [--check] [path...] # alias of `vox fmt` in compiler repo\n"));
  print("  ".concat(bin).concat(" install [--target=<value>] [out.bin]   # build local pkg and install to ~/.vox/bin\n"));
  print("  ".concat(bin).concat(" list [--json] [--target=<value>] [--tests|--no-tests]  # print package module dependency graph\n"));
  print("  ".concat(bin).concat(" fmt [--check] [path...]\n"));
  print("  ".concat(bin).concat(" lsp                   # start language server (stdio)\n"));
  print("  ".concat(bin).concat(" toolchain <subcmd>    # install/use/pin/current/list\n"));
  print("  ".concat(bin).concat(" version               # print embedded compiler version\n"));
  print("\n");
  print("flags:\n");
  print("  --driver=user|tool  driver main mode for emitted binaries (default: user)\n");
  print("  --module=<glob>     test: keep tests by module glob (e.g. typecheck, parse, root)\n");
  print("  --run=<glob>        test: run tests by glob on qualified/short name (*, ?)\n");
  print("  --filter=<text>     test: keep tests whose name contains text\n");
  print("  --jobs=N, -j N      test: module-level parallelism; module-internal remains serial\n");
  print("  --fail-fast         test: stop scheduling new tests after first failure\n");
  print("  --list              test: list selected tests and exit\n");
  print("  --rerun-failed      test: run only previously failed tests\n");
  print("  --json              test/list: print JSON report\n");
  print("  --target=<value>    build/test/run/install/list: target os/arch or triple (e.g. darwin-arm64, x86_64-w64-mingw32, x86_64-pc-windows-msvc, i686-w64-mingw32, wasm32-unknown-unknown)\n");
  print("  --tests             list: include tests/** and *_test.vox in graph input\n");
  print("  --no-tests          list: exclude tests/** and *_test.vox (default)\n");
  print("  --artifact=<kind>   build/run/install: artifact kind (exe|static|shared)\n");
  print("  --emit-c[=<path>]   build/test/run: write generated C (default keeps compiler C output path)\n");
  print("  -x                  print external commands before execution\n");
  print("  --version, -V       print embedded compiler version\n");
  print("\n");
  print("env:\n");
  print("  VOX_CC_DEBUG=1      enable C compiler debug symbols (-g / /Zi)\n");
  print("  VOX_PROFILE=1       print compile/cc phase timings for build commands\n");
  print("  VOX_BUILD_CACHE_DISABLE=1  disable build/test cache key/hash and always rebuild\n");
  print("  VOX_ROOT=<path>     source root override for loading src/std and src/vox\n");
  print("  VOX_STDLIB=<path>   stdlib root override (highest priority; supports root, root/src, root/src/std)\n");
  print("  VOX_NODE=<path>     node executable for `vox lsp` (default: node)\n");
  print("  VOX_DEV_SELFHOST_DISABLE=1  disable local repo selfhost reroute for fmt/install\n");
}

fn print_invalid_lock_error(msg: String) -> () {
  print("invalid vox.lock: ".concat(msg).concat("\n"));
  print("hint: refresh lockfile after dependency changes: remove vox.lock then rerun build/test.\n");
}

fn has_suffix(s: String, suf: String) -> bool {
  return txt.has_suffix(s, suf);
}

fn is_test_path(p: String) -> bool {
  if txt.has_prefix(p, "tests/") { return true; }
  if has_suffix(p, "_test.vox") { return true; }
  return false;
}

fn is_test_file_for_discovery(p: String) -> bool {
  if txt.has_prefix(p, "tests/") { return true; }
  if txt.has_prefix(p, "src/") && has_suffix(p, "_test.vox") { return true; }
  return false;
}

fn has_std_under_src(paths: Vec[String]) -> bool {
  let mut i: i32 = 0;
  while i < paths.len() {
    if txt.has_prefix(paths.get(i), "src/std/") { return true; }
    i = i + 1;
  }
  return false;
}

fn has_vox_under_src(paths: Vec[String]) -> bool {
  let mut i: i32 = 0;
  while i < paths.len() {
    if txt.has_prefix(paths.get(i), "src/vox/") { return true; }
    i = i + 1;
  }
  return false;
}

fn filter_pkg_sources(paths: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let p: String = paths.get(i);
    if txt.has_prefix(p, "src/") && !is_test_path(p) {
      out.push(p);
    }
    i = i + 1;
  }
  return out;
}

fn filter_pkg_test_sources(paths: Vec[String]) -> Vec[String] {
  // For tests, include src/** (including _test.vox) and tests/**.
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let p: String = paths.get(i);
    if txt.has_prefix(p, "src/") || txt.has_prefix(p, "tests/") {
      out.push(p);
    }
    i = i + 1;
  }
  return out;
}

fn is_hidden_source_path(p: String) -> bool {
  let n: i32 = p.len();
  let mut start: i32 = 0;
  let mut i: i32 = 0;
  while i <= n {
    let at_end: bool = i == n;
    let is_sep: bool = if at_end { false } else { p.byte_at(i) == 47 };
    if at_end || is_sep {
      if start < i {
        let comp: String = p.slice(start, i);
        if comp.byte_at(0) == 46 && comp != "." && comp != ".." {
          return true;
        }
      }
      start = i + 1;
    }
    i = i + 1;
  }
  return false;
}

fn legacy_runtime_c_enabled() -> bool {
  let v: String = txt.trim_space(proc.getenv("VOX_LEGACY_C_RUNTIME"));
  if v == "1" || v == "true" || v == "yes" { return true; }
  return false;
}

fn is_legacy_runtime_c_path(p: String) -> bool {
  return
    p == "src/vox/bootstrap/legacy_runtime/_preamble.c" ||
    p == "src/vox/bootstrap/legacy_runtime/rt_core.c" ||
    p == "src/vox/bootstrap/legacy_runtime/rt_atomic.c";
}

fn filter_pkg_c_sources(paths: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let include_legacy_runtime_c: bool = legacy_runtime_c_enabled();
  let mut i: i32 = 0;
  while i < paths.len() {
    let p: String = paths.get(i);
    if txt.has_prefix(p, "src/") && !is_hidden_source_path(p) {
      if is_legacy_runtime_c_path(p) && !include_legacy_runtime_c {
        i = i + 1;
        continue;
      }
      out.push(p);
    }
    i = i + 1;
  }
  return out;
}

fn dir_name(p: String) -> String {
  return pth.dirname(p);
}

fn build_rerun_hint(out: String, jobs: i32, fail_fast: bool) -> String {
  let exe_name: String = pth.base_name(proc.exe_path());
  let mut cmd: String = exe_name.concat(" test --rerun-failed");
  if jobs > 1 {
    cmd = cmd.concat(" --jobs=").concat(jobs.to_string());
  }
  if fail_fast {
    cmd = cmd.concat(" --fail-fast");
  }
  return cmd.concat(" ").concat(out);
}

fn exec_cmd(cmd: String, trace: bool) -> i32 {
  if trace {
    print("+ ".concat(cmd).concat("\n"));
  }
  return proc.exec(cmd);
}

fn write_emit_c_text(enabled: bool, emit_path: String, default_cpath: String, c_text: String) -> () {
  if !enabled { return; }
  if emit_path == "" || emit_path == default_cpath { return; }
  fs.mkdir_p(dir_name(emit_path));
  fs.write_string(emit_path, c_text);
}

fn copy_emit_c_from_file(enabled: bool, emit_path: String, default_cpath: String) -> () {
  if !enabled { return; }
  if emit_path == "" || emit_path == default_cpath { return; }
  if !fs.exists(default_cpath) { return; }
  fs.mkdir_p(dir_name(emit_path));
  fs.write_string(emit_path, fs.read_to_string(default_cpath));
}

fn path_join(a: String, b: String) -> String {
  return pth.join(a, b);
}

fn path_with_forward_slashes(p0: String) -> String {
  return pth.to_forward_slashes(p0);
}

fn stage1_root() -> String {
  // stage0 places binaries at: <pkg>/target/debug/<name>
  let exe: String = normalize_host_fs_path(proc.exe_path());
  let d1: String = dir_name(exe);
  let d2: String = dir_name(d1);
  let d3: String = dir_name(d2);
  return d3;
}

fn qname(mod_path: String, name: String) -> String {
  if mod_path == "" || mod_path == "main" { return name; }
  let mut s: String = mod_path;
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 47 { // '/'
      s = s.slice(0, i).concat(".").concat(s.slice(i + 1, s.len()));
    }
    i = i + 1;
  }
  return s.concat("::").concat(name);
}

fn string_insert_sorted(xs0: Vec[String], x: String) -> Vec[String] {
  return ss.insert_sorted(xs0, x);
}

fn sort_strings(xs0: Vec[String]) -> Vec[String] {
  return ss.sort(xs0);
}

fn discover_tests(paths: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let pth: String = paths.get(i);
    if is_test_file_for_discovery(pth) {
      let txt: String = fs.read_to_string(pth);
      let r: p.ParseResult = p.parse_text_with_path(pth, txt);
      if r.err != p.ParseError.None {
        // Fail fast: discovery should not ignore syntax errors.
        panic(p.parse_error_to_string_with_source(pth, txt, r.err));
      }
      let mp: String = ld.mod_path_from_file_path(pth);
      let mut fi: i32 = 0;
      while fi < r.prog.funcs.len() {
        let fd: ast.FuncDecl = r.prog.funcs.get(fi);
        if txt.has_prefix(fd.name, "test_") {
          out.push(qname(mp, fd.name));
        }
        fi = fi + 1;
      }
    }
    i = i + 1;
  }
  return sort_strings(out);
}

fn text_contains(s: String, part: String) -> bool {
  if part.len() == 0 { return true; }
  if s.len() < part.len() { return false; }
  let mut i: i32 = 0;
  while i + part.len() <= s.len() {
    if s.slice(i, i + part.len()) == part { return true; }
    i = i + 1;
  }
  return false;
}

fn filter_tests_contains(tests: Vec[String], part: String) -> Vec[String] {
  if part == "" { return tests; }
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < tests.len() {
    let name: String = tests.get(i);
    if text_contains(name, part) { out.push(name); }
    i = i + 1;
  }
  return out;
}

fn short_test_name(name: String) -> String {
  let mut i: i32 = name.len() - 1;
  while i >= 1 {
    if name.byte_at(i - 1) == 58 && name.byte_at(i) == 58 {
      return name.slice(i + 1, name.len());
    }
    i = i - 1;
  }
  return name;
}

fn glob_match(text: String, pat: String) -> bool {
  let mut ti: i32 = 0;
  let mut pi: i32 = 0;
  let mut star: i32 = -1;
  let mut star_ti: i32 = 0;
  while ti < text.len() {
    if pi < pat.len() {
      let pc: i32 = pat.byte_at(pi);
      if pc == 63 || pc == text.byte_at(ti) { // '?'
        ti = ti + 1;
        pi = pi + 1;
        continue;
      }
      if pc == 42 { // '*'
        star = pi;
        pi = pi + 1;
        star_ti = ti;
        continue;
      }
    }
    if star >= 0 {
      pi = star + 1;
      star_ti = star_ti + 1;
      ti = star_ti;
      continue;
    }
    return false;
  }
  while pi < pat.len() && pat.byte_at(pi) == 42 { pi = pi + 1; }
  return pi == pat.len();
}

fn filter_tests_run_pattern(tests: Vec[String], pat: String) -> Vec[String] {
  if pat == "" { return tests; }
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < tests.len() {
    let name: String = tests.get(i);
    let short: String = short_test_name(name);
    if glob_match(name, pat) || glob_match(short, pat) {
      out.push(name);
    }
    i = i + 1;
  }
  return out;
}

fn filter_tests_module_pattern(tests: Vec[String], pat: String) -> Vec[String] {
  if pat == "" { return tests; }
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < tests.len() {
    let name: String = tests.get(i);
    let module: String = test_module_name(name);
    if glob_match(module, pat) {
      out.push(name);
    }
    i = i + 1;
  }
  return out;
}

struct ParseI32Result { ok: bool, v: i32 }

fn parse_i32_decimal(s0: String) -> ParseI32Result {
  let s: String = txt.trim_space(s0);
  if s.len() == 0 { return ParseI32Result { ok: false, v: 0 }; }
  let mut i: i32 = 0;
  let mut neg: bool = false;
  if s.byte_at(0) == 45 { // '-'
    neg = true;
    i = 1;
  }
  if i >= s.len() { return ParseI32Result { ok: false, v: 0 }; }
  let mut v: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    if ch < 48 || ch > 57 { return ParseI32Result { ok: false, v: 0 }; }
    v = v * 10 + (ch - 48);
    i = i + 1;
  }
  if neg { v = 0 - v; }
  return ParseI32Result { ok: true, v: v };
}

fn unique_sorted_modules_from_tests(tests: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < tests.len() {
    let module: String = test_module_name(tests.get(i));
    let mut seen: bool = false;
    let mut j: i32 = 0;
    while j < out.len() {
      if out.get(j) == module {
        seen = true;
        j = out.len();
      } else {
        j = j + 1;
      }
    }
    if !seen { out = string_insert_sorted(out, module); }
    i = i + 1;
  }
  return out;
}

fn tests_in_module_sorted(tests: Vec[String], module: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < tests.len() {
    let n: String = tests.get(i);
    if test_module_name(n) == module {
      out = string_insert_sorted(out, n);
    }
    i = i + 1;
  }
  return out;
}

fn print_test_selection(discovered: i32, selected: i32, module_pat: String, run_pat: String, filter: String, jobs: i32, fail_fast: bool, rerun_failed_count: i32) -> () {
  print("[select] discovered: ".concat(discovered.to_string()).concat(", selected: ").concat(selected.to_string()).concat("\n"));
  if jobs > 0 {
    print("[select] --jobs: ".concat(jobs.to_string()).concat("\n"));
  }
  if fail_fast {
    print("[select] --fail-fast: true\n");
  }
  if module_pat != "" {
    print("[select] --module: \"".concat(module_pat).concat("\"\n"));
  }
  if run_pat != "" {
    print("[select] --run: \"".concat(run_pat).concat("\"\n"));
  }
  if filter != "" {
    print("[select] --filter: \"".concat(filter).concat("\"\n"));
  }
  if rerun_failed_count >= 0 {
    print("[select] --rerun-failed: ".concat(rerun_failed_count.to_string()).concat(" cached\n"));
  }
}

fn print_test_list(tests: Vec[String]) -> () {
  let mut tests_for_mods: Vec[String] = Vec();
  let mut tmi: i32 = 0;
  while tmi < tests.len() {
    tests_for_mods.push(tests.get(tmi));
    tmi = tmi + 1;
  }
  let mods: Vec[String] = unique_sorted_modules_from_tests(tests_for_mods);
  let mut i: i32 = 0;
  while i < mods.len() {
    let module: String = mods.get(i);
    let mut tests_copy: Vec[String] = Vec();
    let mut ti: i32 = 0;
    while ti < tests.len() {
      tests_copy.push(tests.get(ti));
      ti = ti + 1;
    }
    let names: Vec[String] = tests_in_module_sorted(tests_copy, module);
    print("[list] ".concat(module).concat(" (").concat(names.len().to_string()).concat(")\n"));
    let mut j: i32 = 0;
    while j < names.len() {
      print("[test] ".concat(names.get(j)).concat("\n"));
      j = j + 1;
    }
    i = i + 1;
  }
  print("[list] total: ".concat(tests.len().to_string()).concat("\n"));
}

struct ModuleSummary {
  module: String,
  passed: i32,
  failed: i32,
  dur_ns: i64,
}

struct ModuleDetail {
  module: String,
  tests: Vec[String],
  failed_tests: Vec[String],
  passed: i32,
  failed: i32,
  dur_ns: i64,
}

struct TestRunResult {
  name: String,
  module: String,
  ok: bool,
  dur_ns: i64,
  err: String,
  log_file: String,
}

struct NamedDuration {
  name: String,
  module: String,
  dur_ns: i64,
}

fn dur_nonneg_ns(start: i64, end: i64) -> i64 {
  if end <= start { return 0; }
  return end - start;
}

fn two_digits(v0: i64) -> String {
  let mut v: i64 = v0;
  if v < 0 { v = 0; }
  if v > 99 { v = v % 100; }
  if v < 10 { return "0".concat(v.to_string()); }
  return v.to_string();
}

fn format_duration_ns(ns0: i64) -> String {
  let mut ns: i64 = ns0;
  if ns < 0 { ns = 0; }
  if ns < 1000 { return ns.to_string().concat("ns"); }
  if ns < 1000000 {
    let whole: i64 = ns / 1000;
    let frac: i64 = (ns % 1000) / 10;
    return whole.to_string().concat(".").concat(two_digits(frac)).concat("us");
  }
  if ns < 1000000000 {
    let whole: i64 = ns / 1000000;
    let frac: i64 = (ns % 1000000) / 10000;
    return whole.to_string().concat(".").concat(two_digits(frac)).concat("ms");
  }
  let whole: i64 = ns / 1000000000;
  let frac: i64 = (ns % 1000000000) / 10000000;
  return whole.to_string().concat(".").concat(two_digits(frac)).concat("s");
}

fn env_truthy(raw0: String) -> bool {
  let raw: String = txt.trim_space(raw0);
  if raw == "" { return false; }
  let s: String = tc_ascii_lower(raw);
  return s == "1" || s == "true" || s == "yes" || s == "on";
}

fn compile_profile_enabled() -> bool {
  return env_truthy(proc.getenv("VOX_PROFILE"));
}

fn build_cache_enabled_from_env(raw: String) -> bool {
  return !env_truthy(raw);
}

fn build_cache_enabled() -> bool {
  return build_cache_enabled_from_env(proc.getenv("VOX_BUILD_CACHE_DISABLE"));
}

fn print_compile_profile(label: String, p: c.CompilePhaseProfile) -> () {
  let total_ns: i64 = c.compile_profile_total_ns(p);
  let load_ns: i64 = c.compile_profile_load_ns(p);
  let macroexpand_ns: i64 = c.compile_profile_macroexpand_ns(p);
  let rewrite_async_ns: i64 = c.compile_profile_rewrite_async_ns(p);
  let typecheck_ns: i64 = c.compile_profile_typecheck_ns(p);
  let irgen_ns: i64 = c.compile_profile_irgen_ns(p);
  let ir_verify_ns: i64 = c.compile_profile_ir_verify_ns(p);
  let codegen_ns: i64 = c.compile_profile_codegen_ns(p);
  print("[profile] ".concat(label).concat(" total: ").concat(format_duration_ns(total_ns)).concat("\n"));
  print("[profile] ".concat(label).concat(" load: ").concat(format_duration_ns(load_ns)).concat("\n"));
  print("[profile] ".concat(label).concat(" macroexpand: ").concat(format_duration_ns(macroexpand_ns)).concat("\n"));
  print("[profile] ".concat(label).concat(" rewrite-async: ").concat(format_duration_ns(rewrite_async_ns)).concat("\n"));
  print("[profile] ".concat(label).concat(" typecheck: ").concat(format_duration_ns(typecheck_ns)).concat("\n"));
  print("[profile] ".concat(label).concat(" irgen: ").concat(format_duration_ns(irgen_ns)).concat("\n"));
  print("[profile] ".concat(label).concat(" ir-verify: ").concat(format_duration_ns(ir_verify_ns)).concat("\n"));
  print("[profile] ".concat(label).concat(" codegen: ").concat(format_duration_ns(codegen_ns)).concat("\n"));
}

fn print_compile_warnings(ws: Vec[String]) -> () {
  let mut i: i32 = 0;
  while i < ws.len() {
    print("[warn] ".concat(ws.get(i)).concat("\n"));
    i = i + 1;
  }
}

fn duration_us(ns0: i64) -> i64 {
  let mut ns: i64 = ns0;
  if ns < 0 { ns = 0; }
  return (ns + 500) / 1000;
}

fn test_module_name(name: String) -> String {
  let mut i: i32 = 0;
  while i + 1 < name.len() {
    if name.byte_at(i) == 58 && name.byte_at(i + 1) == 58 {
      return name.slice(0, i);
    }
    i = i + 1;
  }
  return "(root)";
}

fn find_module_summary(mods: Vec[ModuleSummary], module: String) -> i32 {
  let mut i: i32 = 0;
  while i < mods.len() {
    if mods.get(i).module == module { return i; }
    i = i + 1;
  }
  return -1;
}

fn update_module_summary(mods0: Vec[ModuleSummary], name: String, ok: bool, dur_ns: i64) -> Vec[ModuleSummary] {
  let mut mods: Vec[ModuleSummary] = mods0;
  let module: String = test_module_name(name);
  let mut mods_for_find: Vec[ModuleSummary] = Vec();
  let mut mfi: i32 = 0;
  while mfi < mods.len() {
    mods_for_find.push(mods.get(mfi));
    mfi = mfi + 1;
  }
  let module_for_find: String = module.slice(0, module.len());
  let idx: i32 = find_module_summary(mods_for_find, module_for_find);
  if idx < 0 {
    let mut s: ModuleSummary = ModuleSummary { module: module, passed: 0, failed: 0, dur_ns: 0 };
    if ok { s.passed = 1; } else { s.failed = 1; }
    s.dur_ns = dur_ns;
    mods.push(s);
    return mods;
  }
  let mut s0: ModuleSummary = mods.get(idx);
  if ok { s0.passed = s0.passed + 1; } else { s0.failed = s0.failed + 1; }
  s0.dur_ns = s0.dur_ns + dur_ns;
  let mut out: Vec[ModuleSummary] = Vec();
  let mut i: i32 = 0;
  while i < mods.len() {
    if i == idx {
      out.push(s0);
    } else {
      out.push(mods.get(i));
    }
    i = i + 1;
  }
  return out;
}

fn module_summary_insert_sorted(xs0: Vec[ModuleSummary], x: ModuleSummary) -> Vec[ModuleSummary] {
  let mut out: Vec[ModuleSummary] = Vec();
  let mut inserted: bool = false;
  let mut i: i32 = 0;
  while i < xs0.len() {
    let cur: ModuleSummary = xs0.get(i);
    if !inserted && x.module < cur.module {
      out.push(x);
      inserted = true;
    }
    out.push(cur);
    i = i + 1;
  }
  if !inserted { out.push(x); }
  return out;
}

fn sort_module_summaries(xs0: Vec[ModuleSummary]) -> Vec[ModuleSummary] {
  let mut out: Vec[ModuleSummary] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    out = module_summary_insert_sorted(out, xs0.get(i));
    i = i + 1;
  }
  return out;
}

fn print_module_summaries(mods: Vec[ModuleSummary]) -> () {
  let mut i: i32 = 0;
  while i < mods.len() {
    let s: ModuleSummary = mods.get(i);
    print("[module] ".concat(s.module).concat(": ").concat(s.passed.to_string()).concat(" passed, ").concat(s.failed.to_string()).concat(" failed (").concat(format_duration_ns(s.dur_ns)).concat(")\n"));
    i = i + 1;
  }
}

fn find_module_detail(ds: Vec[ModuleDetail], module: String) -> i32 {
  let mut i: i32 = 0;
  while i < ds.len() {
    if ds.get(i).module == module { return i; }
    i = i + 1;
  }
  return -1;
}

fn update_module_detail(ds0: Vec[ModuleDetail], name: String, ok: bool, dur_ns: i64) -> Vec[ModuleDetail] {
  let module: String = test_module_name(name);
  let mut ds: Vec[ModuleDetail] = ds0;
  let mut ds_for_find: Vec[ModuleDetail] = Vec();
  let mut dfi: i32 = 0;
  while dfi < ds.len() {
    ds_for_find.push(ds.get(dfi));
    dfi = dfi + 1;
  }
  let module_for_find: String = module.slice(0, module.len());
  let idx: i32 = find_module_detail(ds_for_find, module_for_find);
  if idx < 0 {
    let mut tests: Vec[String] = Vec();
    tests.push(name);
    let mut failed_tests: Vec[String] = Vec();
    if !ok { failed_tests.push(name); }
    ds.push(ModuleDetail {
      module: module,
      tests: tests,
      failed_tests: failed_tests,
      passed: if ok { 1 } else { 0 },
      failed: if ok { 0 } else { 1 },
      dur_ns: dur_ns,
    });
    return ds;
  }

  let d0: ModuleDetail = ds.get(idx);
  let mut tests1: Vec[String] = d0.tests;
  tests1.push(name);
  let mut failed_tests1: Vec[String] = d0.failed_tests;
  if !ok { failed_tests1.push(name); }
  let d1: ModuleDetail = ModuleDetail {
    module: d0.module,
    tests: tests1,
    failed_tests: failed_tests1,
    passed: d0.passed + if ok { 1 } else { 0 },
    failed: d0.failed + if ok { 0 } else { 1 },
    dur_ns: d0.dur_ns + dur_ns,
  };
  let mut out: Vec[ModuleDetail] = Vec();
  let mut i: i32 = 0;
  while i < ds.len() {
    if i == idx {
      out.push(d1);
    } else {
      out.push(ds.get(i));
    }
    i = i + 1;
  }
  return out;
}

fn module_detail_insert_sorted(xs0: Vec[ModuleDetail], x: ModuleDetail) -> Vec[ModuleDetail] {
  let mut out: Vec[ModuleDetail] = Vec();
  let mut inserted: bool = false;
  let mut i: i32 = 0;
  while i < xs0.len() {
    let cur: ModuleDetail = xs0.get(i);
    if !inserted && x.module < cur.module {
      out.push(x);
      inserted = true;
    }
    out.push(cur);
    i = i + 1;
  }
  if !inserted { out.push(x); }
  return out;
}

fn sort_module_details(xs0: Vec[ModuleDetail]) -> Vec[ModuleDetail] {
  let mut out: Vec[ModuleDetail] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    let d0: ModuleDetail = xs0.get(i);
    let d1: ModuleDetail = ModuleDetail {
      module: d0.module,
      tests: sort_strings(d0.tests),
      failed_tests: sort_strings(d0.failed_tests),
      passed: d0.passed,
      failed: d0.failed,
      dur_ns: d0.dur_ns,
    };
    out = module_detail_insert_sorted(out, d1);
    i = i + 1;
  }
  return out;
}

fn test_result_insert_sorted(xs0: Vec[TestRunResult], x: TestRunResult) -> Vec[TestRunResult] {
  let mut out: Vec[TestRunResult] = Vec();
  let mut inserted: bool = false;
  let mut i: i32 = 0;
  while i < xs0.len() {
    let cur: TestRunResult = xs0.get(i);
    if !inserted && x.name < cur.name {
      out.push(x);
      inserted = true;
    }
    out.push(cur);
    i = i + 1;
  }
  if !inserted { out.push(x); }
  return out;
}

fn sort_test_results(xs0: Vec[TestRunResult]) -> Vec[TestRunResult] {
  let mut out: Vec[TestRunResult] = Vec();
  let mut i: i32 = 0;
  while i < xs0.len() {
    out = test_result_insert_sorted(out, xs0.get(i));
    i = i + 1;
  }
  return out;
}

fn module_details_from_tests(tests: Vec[String]) -> Vec[ModuleDetail] {
  let mut out: Vec[ModuleDetail] = Vec();
  let mut i: i32 = 0;
  while i < tests.len() {
    out = update_module_detail(out, tests.get(i), true, 0);
    i = i + 1;
  }
  return sort_module_details(out);
}

fn slowest_insert(xs0: Vec[NamedDuration], x: NamedDuration) -> Vec[NamedDuration] {
  let mut out: Vec[NamedDuration] = Vec();
  let mut inserted: bool = false;
  let mut i: i32 = 0;
  while i < xs0.len() {
    let cur: NamedDuration = xs0.get(i);
    if !inserted && (x.dur_ns > cur.dur_ns || (x.dur_ns == cur.dur_ns && x.name < cur.name)) {
      out.push(x);
      inserted = true;
    }
    out.push(cur);
    i = i + 1;
  }
  if !inserted { out.push(x); }
  if out.len() <= 5 { return out; }
  let mut top: Vec[NamedDuration] = Vec();
  let mut ti: i32 = 0;
  while ti < 5 {
    top.push(out.get(ti));
    ti = ti + 1;
  }
  return top;
}

fn build_slowest(rs: Vec[TestRunResult]) -> Vec[NamedDuration] {
  let mut out: Vec[NamedDuration] = Vec();
  let mut i: i32 = 0;
  while i < rs.len() {
    let r: TestRunResult = rs.get(i);
    out = slowest_insert(out, NamedDuration { name: r.name, module: r.module, dur_ns: r.dur_ns });
    i = i + 1;
  }
  return out;
}

fn print_slowest(xs: Vec[NamedDuration]) -> () {
  let mut i: i32 = 0;
  while i < xs.len() {
    let x: NamedDuration = xs.get(i);
    print("[slowest] ".concat(x.name).concat(" (").concat(format_duration_ns(x.dur_ns)).concat(")\n"));
    i = i + 1;
  }
}

struct ModuleQueue {
  module: String,
  tests: Vec[String],
  next: i32,
}

struct RunningJob {
  module_idx: i32,
  name: String,
  rc_file: String,
  log_file: String,
  start_ns: i64,
}

fn find_module_queue_idx(qs: Vec[ModuleQueue], module: String) -> i32 {
  let mut i: i32 = 0;
  while i < qs.len() {
    if qs.get(i).module == module { return i; }
    i = i + 1;
  }
  return -1;
}

fn build_module_queues(tests: Vec[String]) -> Vec[ModuleQueue] {
  let mut out: Vec[ModuleQueue] = Vec();
  let mut i: i32 = 0;
  while i < tests.len() {
    let name: String = tests.get(i);
    let module: String = test_module_name(name);
    let mut out_for_find: Vec[ModuleQueue] = Vec();
    let mut ofi: i32 = 0;
    while ofi < out.len() {
      out_for_find.push(out.get(ofi));
      ofi = ofi + 1;
    }
    let module_for_find: String = module.slice(0, module.len());
    let qi: i32 = find_module_queue_idx(out_for_find, module_for_find);
    if qi < 0 {
      let mut ts: Vec[String] = Vec();
      ts.push(name);
      out.push(ModuleQueue { module: module, tests: ts, next: 0 });
    } else {
      let q0: ModuleQueue = out.get(qi);
      let mut ts1: Vec[String] = q0.tests;
      ts1.push(name);
      let q1: ModuleQueue = ModuleQueue { module: q0.module, tests: ts1, next: q0.next };
      let mut out2: Vec[ModuleQueue] = Vec();
      let mut j: i32 = 0;
      while j < out.len() {
        if j == qi { out2.push(q1); } else { out2.push(out.get(j)); }
        j = j + 1;
      }
      out = out2;
    }
    i = i + 1;
  }
  return out;
}

fn has_running_module(rs: Vec[RunningJob], module_idx: i32) -> bool {
  let mut i: i32 = 0;
  while i < rs.len() {
    if rs.get(i).module_idx == module_idx { return true; }
    i = i + 1;
  }
  return false;
}

fn set_module_queue_next(qs: Vec[ModuleQueue], idx: i32, next: i32) -> Vec[ModuleQueue] {
  let mut out: Vec[ModuleQueue] = Vec();
  let mut i: i32 = 0;
  while i < qs.len() {
    let q: ModuleQueue = qs.get(i);
    if i == idx {
      out.push(ModuleQueue { module: q.module, tests: q.tests, next: next });
    } else {
      out.push(q);
    }
    i = i + 1;
  }
  return out;
}

fn has_pending_queues(qs: Vec[ModuleQueue]) -> bool {
  let mut i: i32 = 0;
  while i < qs.len() {
    let q: ModuleQueue = qs.get(i);
    if q.next < q.tests.len() { return true; }
    i = i + 1;
  }
  return false;
}

fn pick_runnable_queue_idx(qs: Vec[ModuleQueue], rs: Vec[RunningJob]) -> i32 {
  let mut i: i32 = 0;
  while i < qs.len() {
    let q: ModuleQueue = qs.get(i);
    if q.next < q.tests.len() && !has_running_module(rs, i) { return i; }
    i = i + 1;
  }
  return -1;
}

fn launch_test_job(bin: String, run_dir: String, module_idx: i32, seq: i32, test_name: String, runner_cmd: String, trace: bool) -> RunningJob {
  let tag: String = module_idx.to_string().concat("_").concat(seq.to_string());
  let rc_file: String = path_join(run_dir, "job_".concat(tag).concat(".rc"));
  let log_file: String = path_join(run_dir, "job_".concat(tag).concat(".log"));
  let bin_exec: String = shell_exec_path(bin);

  let mut cmd_head: String = shell_quote(bin_exec).concat(" ").concat(shell_quote(test_name));
  let mut cmd_head_win: String = bin_exec.concat(" ").concat(test_name);
  let trimmed_runner_cmd: String = txt.trim_space(runner_cmd);
  if trimmed_runner_cmd != "" {
    let re: String = shell_exec_path(trimmed_runner_cmd);
    cmd_head = shell_quote(re).concat(" ").concat(shell_quote(bin_exec)).concat(" ").concat(shell_quote(test_name));
    cmd_head_win = re.concat(" ").concat(bin_exec).concat(" ").concat(test_name);
  }

  let log_redir: String = " > ".concat(shell_quote(shell_exec_path(log_file))).concat(" 2>&1");
  if host_is_windows() {
    let run_cmd_win: String = cmd_head_win.concat(" > ").concat(shell_exec_path(log_file)).concat(" 2>&1");
    let rc: i32 = exec_cmd(run_cmd_win, trace);
    fs.write_string(rc_file, if rc == 0 { "0" } else { "1" });
    return RunningJob {
      module_idx: module_idx,
      name: test_name,
      rc_file: rc_file,
      log_file: log_file,
      start_ns: tm.now_ns(),
    };
  }
  let run_cmd: String =
    cmd_head.concat(log_redir)
      .concat(" && echo 0 > ").concat(shell_quote(shell_exec_path(rc_file)))
      .concat(" || echo 1 > ").concat(shell_quote(shell_exec_path(rc_file)));
  let bg_cmd: String = "( ".concat(run_cmd).concat(" ) &");
  let _rc: i32 = exec_cmd(bg_cmd, trace);
  return RunningJob {
    module_idx: module_idx,
    name: test_name,
    rc_file: rc_file,
    log_file: log_file,
    start_ns: tm.now_ns(),
  };
}

fn parse_exit_code_file(s0: String) -> ParseI32Result {
  return parse_i32_decimal(s0);
}

fn print_failed_test_log(name: String, log_file: String) -> () {
  if !fs.exists(log_file) { return; }
  let log_text: String = fs.read_to_string(log_file);
  if txt.trim_space(log_text) == "" { return; }
  print("[log] ".concat(name).concat(":\n"));
  print(log_text);
  if !has_suffix(log_text, "\n") {
    print("\n");
  }
}

fn json_quote(s: String) -> String {
  let mut out: String = "\"";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    if ch == 34 { out = out.concat("\\\""); i = i + 1; continue; } // "
    if ch == 92 { out = out.concat("\\\\"); i = i + 1; continue; } // \
    if ch == 10 { out = out.concat("\\n"); i = i + 1; continue; } // \n
    if ch == 13 { out = out.concat("\\r"); i = i + 1; continue; } // \r
    if ch == 9 { out = out.concat("\\t"); i = i + 1; continue; } // \t
    out = out.concat(s.slice(i, i + 1));
    i = i + 1;
  }
  return out.concat("\"");
}

fn json_bool(v: bool) -> String { return if v { "true" } else { "false" }; }

fn json_of_tests(tests: Vec[String]) -> String {
  let mut out: String = "[";
  let mut i: i32 = 0;
  while i < tests.len() {
    if i > 0 { out = out.concat(","); }
    out = out.concat(json_quote(tests.get(i)));
    i = i + 1;
  }
  return out.concat("]");
}

fn json_of_results(rs: Vec[TestRunResult]) -> String {
  let mut out: String = "[";
  let mut i: i32 = 0;
  while i < rs.len() {
    if i > 0 { out = out.concat(","); }
    let r: TestRunResult = rs.get(i);
    out = out
      .concat("{\"name\":").concat(json_quote(r.name))
      .concat(",\"module\":").concat(json_quote(r.module))
      .concat(",\"status\":").concat(json_quote(if r.ok { "ok" } else { "fail" }))
      .concat(",\"duration_us\":").concat(duration_us(r.dur_ns).to_string());
    if r.err != "" {
      out = out.concat(",\"error\":").concat(json_quote(r.err));
    }
    if r.log_file != "" {
      out = out.concat(",\"log_file\":").concat(json_quote(r.log_file));
    }
    out = out.concat("}");
    i = i + 1;
  }
  return out.concat("]");
}

fn json_of_modules(ms: Vec[ModuleSummary]) -> String {
  let mut out: String = "[";
  let mut i: i32 = 0;
  while i < ms.len() {
    if i > 0 { out = out.concat(","); }
    let m: ModuleSummary = ms.get(i);
    out = out
      .concat("{\"module\":").concat(json_quote(m.module))
      .concat(",\"passed\":").concat(m.passed.to_string())
      .concat(",\"failed\":").concat(m.failed.to_string())
      .concat(",\"duration_us\":").concat(duration_us(m.dur_ns).to_string())
      .concat("}");
    i = i + 1;
  }
  return out.concat("]");
}

fn json_of_module_details(ds: Vec[ModuleDetail]) -> String {
  let mut out: String = "[";
  let mut i: i32 = 0;
  while i < ds.len() {
    if i > 0 { out = out.concat(","); }
    let d: ModuleDetail = ds.get(i);
    out = out
      .concat("{\"module\":").concat(json_quote(d.module))
      .concat(",\"tests\":").concat(json_of_tests(d.tests))
      .concat(",\"failed_tests\":").concat(json_of_tests(d.failed_tests))
      .concat(",\"passed\":").concat(d.passed.to_string())
      .concat(",\"failed\":").concat(d.failed.to_string())
      .concat(",\"duration_us\":").concat(duration_us(d.dur_ns).to_string())
      .concat("}");
    i = i + 1;
  }
  return out.concat("]");
}

fn json_of_slowest(xs: Vec[NamedDuration]) -> String {
  let mut out: String = "[";
  let mut i: i32 = 0;
  while i < xs.len() {
    if i > 0 { out = out.concat(","); }
    let x: NamedDuration = xs.get(i);
    out = out
      .concat("{\"name\":").concat(json_quote(x.name))
      .concat(",\"module\":").concat(json_quote(x.module))
      .concat(",\"duration_us\":").concat(duration_us(x.dur_ns).to_string())
      .concat("}");
    i = i + 1;
  }
  return out.concat("]");
}

fn print_json_report(
  discovered: i32,
  selected: i32,
  module_pat: String,
  run_pat: String,
  filter: String,
  jobs: i32,
  fail_fast: bool,
  rerun_failed: bool,
  rerun_failed_count: i32,
  list_only: bool,
  selected_tests: Vec[String],
  results: Vec[TestRunResult],
  modules: Vec[ModuleSummary],
  module_details: Vec[ModuleDetail],
  slowest: Vec[NamedDuration],
  failed_tests: Vec[String],
  hint: String,
  message: String,
  passed: i32,
  failed: i32,
  skipped: i32,
  total_ns: i64,
) -> () {
  let mut selected_tests_for_modules: Vec[String] = Vec();
  let mut stmi: i32 = 0;
  while stmi < selected_tests.len() {
    selected_tests_for_modules.push(selected_tests.get(stmi));
    stmi = stmi + 1;
  }
  let list_module_details: Vec[ModuleDetail] = if list_only { module_details_from_tests(selected_tests_for_modules) } else { module_details };
  let mut out: String = "{";
  out = out.concat("\"report_version\":1");
  out = out.concat(",\"rerun_cache_path\":").concat(json_quote(failed_tests_path()));
  out = out.concat(",\"rerun_cache_version\":1");
  out = out.concat(",\"selection\":{");
  out = out.concat("\"discovered\":").concat(discovered.to_string());
  out = out.concat(",\"selected\":").concat(selected.to_string());
  if jobs > 0 { out = out.concat(",\"jobs\":").concat(jobs.to_string()); }
  if fail_fast { out = out.concat(",\"fail_fast\":").concat(json_bool(true)); }
  if module_pat != "" {
    out = out.concat(",\"module\":").concat(json_quote(module_pat));
    out = out.concat(",\"module_pattern\":").concat(json_quote(module_pat));
  }
  if run_pat != "" {
    out = out.concat(",\"run\":").concat(json_quote(run_pat));
    out = out.concat(",\"run_pattern\":").concat(json_quote(run_pat));
  }
  if filter != "" { out = out.concat(",\"filter\":").concat(json_quote(filter)); }
  if rerun_failed {
    out = out.concat(",\"rerun_failed\":").concat(json_bool(true));
    out = out.concat(",\"prev_failed_count\":").concat(rerun_failed_count.to_string());
    out = out.concat(",\"rerun_cache_path\":").concat(json_quote(failed_tests_path()));
  }
  out = out.concat("}");
  out = out.concat(",\"list_only\":").concat(json_bool(list_only));
  out = out.concat(",\"selected_tests\":").concat(json_of_tests(selected_tests));
  out = out.concat(",\"module_details\":").concat(json_of_module_details(list_module_details));
  if message != "" { out = out.concat(",\"message\":").concat(json_quote(message)); }
  if !list_only {
    out = out.concat(",\"results\":").concat(json_of_results(results));
    out = out.concat(",\"modules\":").concat(json_of_modules(modules));
    out = out.concat(",\"slowest\":").concat(json_of_slowest(slowest));
    out = out.concat(",\"failed_tests\":").concat(json_of_tests(failed_tests));
    if hint != "" { out = out.concat(",\"hint\":").concat(json_quote(hint)); }
    out = out.concat(",\"summary\":{");
    out = out.concat("\"passed\":").concat(passed.to_string());
    out = out.concat(",\"failed\":").concat(failed.to_string());
    out = out.concat(",\"skipped\":").concat(skipped.to_string());
    out = out.concat(",\"duration_us\":").concat(duration_us(total_ns).to_string());
    out = out.concat("}");
  }
  out = out.concat("}");
  print(out.concat("\n"));
}

fn failed_tests_path() -> String {
  return "target/debug/.vox_last_failed_tests";
}

fn normalize_failed_tests(names: Vec[String]) -> Vec[String] {
  let sorted: Vec[String] = sort_strings(names);
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < sorted.len() {
    let name: String = txt.trim_space(sorted.get(i));
    if name != "" {
      if out.len() == 0 || out.get(out.len() - 1) != name {
        out.push(name);
      }
    }
    i = i + 1;
  }
  return out;
}

fn split_lines(s: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut cur: String = "";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    if ch == 13 { i = i + 1; continue; } // '\r'
    if ch == 10 { // '\n'
      if cur.len() > 0 { out.push(cur); }
      cur = "";
      i = i + 1;
      continue;
    }
    cur = cur.concat(s.slice(i, i + 1));
    i = i + 1;
  }
  if cur.len() > 0 { out.push(cur); }
  return out;
}

fn index_of_from(s: String, needle: String, start: i32) -> i32 {
  if needle.len() == 0 { return start; }
  let mut i: i32 = if start < 0 { 0 } else { start };
  while i + needle.len() <= s.len() {
    if s.slice(i, i + needle.len()) == needle { return i; }
    i = i + 1;
  }
  return -1;
}

fn parse_json_string_array_field(txt: String, key: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let k: i32 = index_of_from(txt, "\"".concat(key).concat("\""), 0);
  if k < 0 { return out; }
  let lb: i32 = index_of_from(txt, "[", k);
  if lb < 0 { return out; }
  let rb: i32 = index_of_from(txt, "]", lb + 1);
  if rb < 0 { return out; }
  let arr: String = txt.slice(lb + 1, rb);
  let mut i: i32 = 0;
  while i < arr.len() {
    let q0: i32 = index_of_from(arr, "\"", i);
    if q0 < 0 { break; }
    let q1: i32 = index_of_from(arr, "\"", q0 + 1);
    if q1 < 0 { break; }
    out.push(arr.slice(q0 + 1, q1));
    i = q1 + 1;
  }
  return out;
}

fn parse_failed_tests_json(txt: String) -> Vec[String] {
  let t0: Vec[String] = parse_json_string_array_field(txt, "tests");
  if t0.len() > 0 { return t0; }
  return parse_json_string_array_field(txt, "failed_tests");
}

fn read_failed_tests() -> Vec[String] {
  let p: String = failed_tests_path();
  if !fs.exists(p) { return Vec(); }
  let file_text: String = fs.read_to_string(p);
  let t: String = txt.trim_space(file_text);
  if t.len() > 0 && t.byte_at(0) == 123 { // '{'
    return normalize_failed_tests(parse_failed_tests_json(t));
  }
  return normalize_failed_tests(split_lines(file_text));
}

fn write_failed_tests(names: Vec[String]) -> () {
  fs.mkdir_p("target/debug");
  let canon: Vec[String] = normalize_failed_tests(names);
  let mut canon_for_failed: Vec[String] = Vec();
  let mut cfi: i32 = 0;
  while cfi < canon.len() {
    canon_for_failed.push(canon.get(cfi));
    cfi = cfi + 1;
  }
  let updated_us: i64 = tm.now_ns() / 1000;
  let mut out: String = "{";
  out = out.concat("\"version\":1");
  out = out.concat(",\"updated_unix_us\":").concat(updated_us.to_string());
  out = out.concat(",\"tests\":").concat(json_of_tests(canon));
  out = out.concat(",\"failed_tests\":").concat(json_of_tests(canon_for_failed));
  out = out.concat("}\n");
  fs.write_string(failed_tests_path(), out);
}

fn intersect_tests(a: Vec[String], b: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < a.len() {
    let n: String = a.get(i);
    if txt.contains_str(b, n) { out.push(n); }
    i = i + 1;
  }
  return out;
}

fn load_deps_from_manifest() -> DepsResult {
  return load_deps_from_manifest_at(".", Vec(), Vec(), Vec());
}

struct DepsResult { ok: bool, err: String, files: Vec[ld.SourceFile], seen: Vec[String], resolved: Vec[mf.Dependency] }

fn deps_ok(files: Vec[ld.SourceFile], seen: Vec[String], resolved: Vec[mf.Dependency]) -> DepsResult {
  return DepsResult { ok: true, err: "", files: files, seen: seen, resolved: resolved };
}

fn deps_err(msg: String) -> DepsResult {
  return DepsResult { ok: false, err: msg, files: Vec(), seen: Vec(), resolved: Vec() };
}

fn is_abs_path(p: String) -> bool {
  return pth.is_abs_path(p);
}

fn resolve_dep_root(base: String, p: String) -> String {
  if is_abs_path(p) { return p; }
  return path_join(base, p);
}

fn is_alnum(ch: i32) -> bool {
  if ch >= 48 && ch <= 57 { return true; } // 0..9
  if ch >= 65 && ch <= 90 { return true; } // A..Z
  if ch >= 97 && ch <= 122 { return true; } // a..z
  return false;
}

fn sanitize_path_part(s: String) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    if is_alnum(ch) || ch == 45 || ch == 95 || ch == 46 { // - _ .
      out = out.concat(s.slice(i, i + 1));
    } else {
      out = out.concat("_");
    }
    i = i + 1;
  }
  if out == "" { return "_"; }
  return out;
}

fn shell_quote(s: String) -> String {
  if host_is_windows() { return "\"".concat(s).concat("\""); }
  let mut out: String = "'";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    if ch == 39 { // '\''
      out = out.concat("'\"'\"'");
    } else {
      out = out.concat(s.slice(i, i + 1));
    }
    i = i + 1;
  }
  return out.concat("'");
}

fn dep_cache_root(base: String) -> String {
  return path_join(base, ".vox/deps");
}

fn load_dep_sources(dep_name: String, dep_root: String) -> Vec[ld.SourceFile] {
  let rels: Vec[String] = srcw.walk_vox_files(dep_root);
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut j: i32 = 0;
  while j < rels.len() {
    let rel: String = rels.get(j);
    // Dependencies: include src/** only, ignore tests/**.
    if txt.has_prefix(rel, "src/") && !is_test_path(rel) {
      let full: String = path_join(dep_root, rel);
      let virt: String = dep_name.concat("/").concat(rel);
      out.push(ld.SourceFile { path: virt, text: fs.read_to_string(full) });
    }
    j = j + 1;
  }
  let c_rels: Vec[String] = srcw.walk_c_files(dep_root);
  let include_legacy_runtime_c: bool = legacy_runtime_c_enabled();
  let mut ci: i32 = 0;
  while ci < c_rels.len() {
    let c_rel: String = c_rels.get(ci);
    if txt.has_prefix(c_rel, "src/") && !is_hidden_source_path(c_rel) {
      if is_legacy_runtime_c_path(c_rel) && !include_legacy_runtime_c {
        ci = ci + 1;
        continue;
      }
      let c_full: String = path_join(dep_root, c_rel);
      let c_virt: String = dep_name.concat("/").concat(c_rel);
      out.push(ld.SourceFile { path: c_virt, text: fs.read_to_string(c_full) });
    }
    ci = ci + 1;
  }
  return out;
}

struct ResolveDepResult { ok: bool, err: String, dep_root: String, dep: mf.Dependency }

fn dep_res_ok(dep_root: String, dep: mf.Dependency) -> ResolveDepResult {
  return ResolveDepResult { ok: true, err: "", dep_root: dep_root, dep: dep };
}

fn dep_res_err(msg: String) -> ResolveDepResult {
  return ResolveDepResult {
    ok: false,
    err: msg,
    dep_root: "",
    dep: mf.Dependency {
      name: "",
      path: "",
      has_path: false,
      git: "",
      has_git: false,
      rev: "",
      has_rev: false,
      registry: "",
      has_registry: false,
      version: "",
      has_version: false,
    },
  };
}

struct ResolveRegistryRootResult { ok: bool, err: String, root: String }

fn reg_root_ok(root: String) -> ResolveRegistryRootResult {
  return ResolveRegistryRootResult { ok: true, err: "", root: root };
}

fn reg_root_err(msg: String) -> ResolveRegistryRootResult {
  return ResolveRegistryRootResult { ok: false, err: msg, root: "" };
}

fn is_git_like_remote_src(src: String) -> bool {
  if txt.has_prefix(src, "http://") || txt.has_prefix(src, "https://") || txt.has_prefix(src, "ssh://") || txt.has_prefix(src, "git@") || txt.has_prefix(src, "file://") {
    return true;
  }
  return has_suffix(src, ".git");
}

fn strip_git_plus_prefix(src: String) -> String {
  if txt.has_prefix(src, "git+") && src.len() > 4 { return src.slice(4, src.len()); }
  return src;
}

fn resolve_registry_root(base: String, has_registry: bool, registry: String) -> ResolveRegistryRootResult {
  if !has_registry {
    return reg_root_ok(path_join(dep_cache_root(base), "registry"));
  }

  let raw: String = registry;
  let mut git_src: String = strip_git_plus_prefix(raw);
  let as_git: bool = txt.has_prefix(raw, "git+") || is_git_like_remote_src(git_src);
  if !as_git {
    return reg_root_ok(resolve_dep_root(base, raw));
  }

  if !is_abs_path(git_src) && !is_git_like_remote_src(git_src) {
    git_src = resolve_dep_root(base, git_src);
  }

  let cache_base: String = path_join(path_join(dep_cache_root(base), "registry_remote"), sanitize_path_part(git_src));
  fs.mkdir_p(path_join(dep_cache_root(base), "registry_remote"));
  if !fs.exists(path_join(cache_base, ".git")) {
    let clone_cmd: String = "git clone ".concat(shell_quote(git_src)).concat(" ").concat(shell_quote(cache_base));
    if proc.exec(clone_cmd) != 0 {
      return reg_root_err("registry git clone failed: ".concat(raw));
    }
  } else {
    let fetch_cmd: String = "git -C ".concat(shell_quote(cache_base)).concat(" fetch --all --tags --prune");
    proc.exec(fetch_cmd);
  }
  return reg_root_ok(cache_base);
}

fn resolve_dep_source(base: String, d: mf.Dependency) -> ResolveDepResult {
  if d.has_path {
    let dep_root: String = resolve_dep_root(base, d.path);
    if !fs.exists(path_join(dep_root, "vox.toml")) {
      return dep_res_err("dependency missing vox.toml: ".concat(d.name));
    }
    return dep_res_ok(dep_root, mf.Dependency {
      name: d.name,
      path: dep_root,
      has_path: true,
      git: d.git,
      has_git: d.has_git,
      rev: d.rev,
      has_rev: d.has_rev,
      registry: d.registry,
      has_registry: d.has_registry,
      version: d.version,
      has_version: d.has_version,
    });
  }

  if d.has_git {
    let mut git_src: String = d.git;
    if !is_abs_path(git_src) && !txt.has_prefix(git_src, "http://") && !txt.has_prefix(git_src, "https://") && !txt.has_prefix(git_src, "ssh://") && !txt.has_prefix(git_src, "git@") {
      git_src = resolve_dep_root(base, git_src);
    }
    let cache_base: String = path_join(path_join(dep_cache_root(base), "git"), sanitize_path_part(d.name).concat("-").concat(sanitize_path_part(git_src)));
    fs.mkdir_p(path_join(dep_cache_root(base), "git"));
    if !fs.exists(path_join(cache_base, ".git")) {
      let clone_cmd: String = "git clone ".concat(shell_quote(git_src)).concat(" ").concat(shell_quote(cache_base));
      if proc.exec(clone_cmd) != 0 {
        return dep_res_err("git clone failed: ".concat(d.name));
      }
    } else {
      let fetch_cmd: String = "git -C ".concat(shell_quote(cache_base)).concat(" fetch --all --tags --prune");
      proc.exec(fetch_cmd);
    }
    let mut target: String = "";
    if d.has_rev { target = d.rev; } else if d.has_version { target = d.version; }
    if target != "" {
      let checkout_cmd: String = "git -C ".concat(shell_quote(cache_base)).concat(" checkout ").concat(shell_quote(target));
      if proc.exec(checkout_cmd) != 0 {
        return dep_res_err("git checkout failed: ".concat(d.name));
      }
    }
    let rev_file: String = path_join(cache_base, ".vox_resolved_rev");
    let rev_cmd: String = "git -C ".concat(shell_quote(cache_base)).concat(" rev-parse HEAD > ").concat(shell_quote(rev_file));
    let mut resolved_rev: String = d.rev;
    let mut has_resolved_rev: bool = d.has_rev;
    if proc.exec(rev_cmd) == 0 {
      resolved_rev = txt.trim_space(fs.read_to_string(rev_file));
      has_resolved_rev = resolved_rev != "";
    }
    if !fs.exists(path_join(cache_base, "vox.toml")) {
      return dep_res_err("dependency missing vox.toml: ".concat(d.name));
    }
    return dep_res_ok(cache_base, mf.Dependency {
      name: d.name,
      path: cache_base,
      has_path: true,
      git: git_src,
      has_git: true,
      rev: resolved_rev,
      has_rev: has_resolved_rev,
      registry: d.registry,
      has_registry: d.has_registry,
      version: d.version,
      has_version: d.has_version,
    });
  }

  if !d.has_version {
    return dep_res_err("dependency requires path/git/version: ".concat(d.name));
  }
  let reg_rr: ResolveRegistryRootResult = resolve_registry_root(base, d.has_registry, d.registry);
  if !reg_rr.ok {
    return dep_res_err(reg_rr.err);
  }
  let dep_root: String = path_join(path_join(reg_rr.root, d.name), d.version);
  if !fs.exists(path_join(dep_root, "vox.toml")) {
    return dep_res_err("registry dependency not found: ".concat(d.name).concat("@").concat(d.version));
  }
  return dep_res_ok(dep_root, mf.Dependency {
    name: d.name,
    path: dep_root,
    has_path: true,
    git: d.git,
    has_git: d.has_git,
    rev: d.rev,
    has_rev: d.has_rev,
    registry: d.registry,
    has_registry: d.has_registry,
    version: d.version,
    has_version: d.has_version,
  });
}

fn load_deps_from_manifest_at(base: String, files0: Vec[ld.SourceFile], seen0: Vec[String], resolved0: Vec[mf.Dependency]) -> DepsResult {
  let mani_path: String = path_join(base, "vox.toml");
  let mt: String = fs.read_to_string(mani_path);
  let mr: mf.ParseResult = mf.parse(mt);
  if !mr.ok { return deps_err(mr.err); }

  let mut files: Vec[ld.SourceFile] = files0;
  let mut seen: Vec[String] = seen0;
  let mut resolved: Vec[mf.Dependency] = resolved0;
  let mut local_seen: Vec[String] = Vec();

  let mut i: i32 = 0;
  while i < mr.m.deps.len() {
    let d: mf.Dependency = mr.m.deps.get(i);
    if txt.contains_str(local_seen, d.name) {
      return deps_err("duplicate dependency: ".concat(d.name));
    }
    local_seen.push(d.name);
    if txt.contains_str(seen, d.name) { i = i + 1; continue; }
    seen.push(d.name);

    let dep_name: String = d.name.slice(0, d.name.len());
    let rr0: ResolveDepResult = resolve_dep_source(base, d);
    if !rr0.ok { return deps_err(rr0.err); }
    resolved.push(rr0.dep);
    let dep_files: Vec[ld.SourceFile] = load_dep_sources(dep_name, rr0.dep_root);
    let mut di: i32 = 0;
    while di < dep_files.len() { files.push(dep_files.get(di)); di = di + 1; }

    let rr: DepsResult = load_deps_from_manifest_at(rr0.dep_root, files, seen, resolved);
    if !rr.ok { return rr; }
    files = rr.files;
    seen = rr.seen;
    resolved = rr.resolved;

    i = i + 1;
  }

  return deps_ok(files, seen, resolved);
}

fn toml_quote(s: String) -> String {
  return "\"".concat(s.escape_c()).concat("\"");
}

fn dep_source_kind(has_path: bool, has_version: bool, has_git: bool, has_registry: bool) -> String {
  if has_git { return "git"; }
  if has_registry { return "registry"; }
  if has_path && !has_version { return "path"; }
  if has_path && has_version && !has_git { return "path"; }
  if has_version { return "registry"; }
  return "path";
}

fn write_lockfile(deps: Vec[mf.Dependency]) -> () {
  let mut out: String = "# generated by vox stage1\nversion = 1\n";
  let mut i: i32 = 0;
  while i < deps.len() {
    let d: mf.Dependency = deps.get(i);
    let digest: String = lock_dep_digest(d.path);
    out = out.concat("\n[[dependency]]\n");
    out = out.concat("name = ").concat(toml_quote(d.name)).concat("\n");
    out = out.concat("source = ").concat(toml_quote(dep_source_kind(d.has_path, d.has_version, d.has_git, d.has_registry))).concat("\n");
    if d.has_path {
      out = out.concat("path = ").concat(toml_quote(d.path)).concat("\n");
    }
    if d.path != "" {
      out = out.concat("resolved_path = ").concat(toml_quote(d.path)).concat("\n");
    }
    if d.has_git {
      out = out.concat("git = ").concat(toml_quote(d.git)).concat("\n");
    }
    if d.has_rev {
      out = out.concat("rev = ").concat(toml_quote(d.rev)).concat("\n");
    }
    if d.has_registry {
      out = out.concat("registry = ").concat(toml_quote(d.registry)).concat("\n");
    }
    if d.has_version {
      out = out.concat("version = ").concat(toml_quote(d.version)).concat("\n");
    }
    out = out.concat("digest = ").concat(toml_quote(digest)).concat("\n");
    i = i + 1;
  }
  fs.write_string("vox.lock", out);
}

fn load_files(paths: Vec[String]) -> Vec[ld.SourceFile] {
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let p: String = paths.get(i);
    out.push(ld.SourceFile { path: p, text: fs.read_to_string(p) });
    i = i + 1;
  }
  return out;
}

fn load_stage1_std_from_repo_root(root: String) -> Vec[ld.SourceFile] {
  let rels: Vec[String] = srcw.walk_vox_files(root);
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut i: i32 = 0;
  while i < rels.len() {
    let rel: String = rels.get(i);
    if txt.has_prefix(rel, "src/std/") && !is_test_path(rel) {
      let full: String = path_join(root, rel);
      out.push(ld.SourceFile { path: rel, text: fs.read_to_string(full) });
    }
    i = i + 1;
  }
  let c_rels: Vec[String] = srcw.walk_c_files(root);
  let mut ci: i32 = 0;
  while ci < c_rels.len() {
    let c_rel: String = c_rels.get(ci);
    if txt.has_prefix(c_rel, "src/std/") && !is_hidden_source_path(c_rel) {
      let c_full: String = path_join(root, c_rel);
      out.push(ld.SourceFile { path: c_rel, text: fs.read_to_string(c_full) });
    }
    ci = ci + 1;
  }
  return out;
}

fn load_stage1_vox_from_repo_root(root: String) -> Vec[ld.SourceFile] {
  let rels: Vec[String] = srcw.walk_vox_files(root);
  let mut out: Vec[ld.SourceFile] = Vec();
  let mut i: i32 = 0;
  while i < rels.len() {
    let rel: String = rels.get(i);
    if txt.has_prefix(rel, "src/vox/") && !is_test_path(rel) {
      let full: String = path_join(root, rel);
      out.push(ld.SourceFile { path: rel, text: fs.read_to_string(full) });
    }
    i = i + 1;
  }
  return out;
}

fn normalize_std_search_root(root0: String) -> String {
  let root: String = path_with_forward_slashes(root0);
  if has_suffix(root, "/src/std") {
    return dir_name(dir_name(root));
  }
  if has_suffix(root, "/src") {
    return dir_name(root);
  }
  return root;
}

fn load_stage1_std_from_root(root0: String) -> Vec[ld.SourceFile] {
  let root: String = normalize_std_search_root(root0);
  return load_stage1_std_from_repo_root(root);
}

fn load_stage1_vox_from_root(root0: String) -> Vec[ld.SourceFile] {
  let root: String = normalize_std_search_root(root0);
  return load_stage1_vox_from_repo_root(root);
}

fn load_stage1_std() -> Vec[ld.SourceFile] {
  let env_vox_root: String = txt.trim_space(proc.getenv("VOX_ROOT"));
  if env_vox_root != "" {
    let from_root_env: Vec[ld.SourceFile] = load_stage1_std_from_root(env_vox_root);
    if from_root_env.len() > 0 { return from_root_env; }
  }

  let env_root: String = txt.trim_space(proc.getenv("VOX_STDLIB"));
  if env_root != "" {
    let from_env: Vec[ld.SourceFile] = load_stage1_std_from_root(env_root);
    if from_env.len() > 0 { return from_env; }
  }

  // Prefer bundled std layout next to installed binary: <bin>/../src/std.
  let exe: String = normalize_host_fs_path(proc.exe_path());
  let bin_dir: String = dir_name(exe);
  let from_bin_near: Vec[ld.SourceFile] = load_stage1_std_from_root(path_join(bin_dir, "../src/std"));
  if from_bin_near.len() > 0 { return from_bin_near; }

  // Then fallback to build-time embedded source root.
  let embed_root: String = txt.trim_space(path_with_forward_slashes(bi.build_source_root()));
  if embed_root != "" {
    let from_embed: Vec[ld.SourceFile] = load_stage1_std_from_root(embed_root);
    if from_embed.len() > 0 { return from_embed; }
  }

  // Finally use runtime-derived repo roots for local developer builds.
  let root: String = stage1_root();
  let from_root: Vec[ld.SourceFile] = load_stage1_std_from_root(root);
  if from_root.len() > 0 { return from_root; }
  let from_src: Vec[ld.SourceFile] = load_stage1_std_from_root(path_join(root, "src"));
  if from_src.len() > 0 { return from_src; }
  let from_lib: Vec[ld.SourceFile] = load_stage1_std_from_root(path_join(root, "lib"));
  if from_lib.len() > 0 { return from_lib; }
  return Vec();
}

fn load_stage1_vox() -> Vec[ld.SourceFile] {
  let env_vox_root: String = txt.trim_space(proc.getenv("VOX_ROOT"));
  if env_vox_root != "" {
    let from_env_root: Vec[ld.SourceFile] = load_stage1_vox_from_root(env_vox_root);
    if from_env_root.len() > 0 { return from_env_root; }
  }
  return Vec();
}

fn slice_vec(xs: Vec[String], start: i32) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = start;
  while i < xs.len() { out.push(xs.get(i)); i = i + 1; }
  return out;
}

fn is_version_cmd(cmd: String) -> bool {
  return cmd == "version" || cmd == "--version" || cmd == "-V";
}

fn rewrite_run_alias(args0: Vec[String]) -> Vec[String] {
  if args0.len() < 2 { return args0; }
  if !local_dev_repo_has_selfhost() { return args0; }
  if args0.get(0) != "run" { return args0; }
  if args0.get(1) != "fmt" { return args0; }
  let mut out: Vec[String] = Vec();
  out.push("fmt");
  let mut i: i32 = 2;
  while i < args0.len() {
    out.push(args0.get(i));
    i = i + 1;
  }
  return out;
}

fn normalize_cli_version(v0: String) -> String {
  let v: String = txt.trim_space(v0);
  if v == "" { return ""; }
  if v.len() > 1 && v.byte_at(0) == 118 { return v.slice(1, v.len()); } // 'v'
  return v;
}

fn embedded_version() -> String {
  return normalize_cli_version(bi.version());
}

fn embedded_channel() -> String {
  return txt.trim_space(bi.channel());
}

fn build_version_override() -> String {
  return normalize_cli_version(proc.getenv("VOX_BUILD_VERSION"));
}

fn run_git_capture(root: String, suffix: String, subcmd: String) -> String {
  if !fs.exists(path_join(root, ".git")) { return ""; }
  fs.mkdir_p("target/debug");
  let out: String = path_join("target/debug", ".vox_git_".concat(suffix));
  let cmd: String = "git -C ".concat(shell_quote(root)).concat(" ").concat(subcmd).concat(" > ").concat(shell_quote(out)).concat(" 2>&1");
  if proc.exec(cmd) != 0 { return ""; }
  return txt.trim_space(fs.read_to_string(out));
}

fn git_head_short(root: String) -> String {
  return run_git_capture(root, "head_short", "rev-parse --short=12 HEAD");
}

fn git_dirty(root: String) -> bool {
  let s: String = run_git_capture(root, "status_porcelain", "status --porcelain");
  return s != "";
}

fn git_count_since_base_tag(root: String, base: String) -> String {
  if base == "" { return ""; }
  let tag: String = "v".concat(base);
  return run_git_capture(root, "count_since_tag", "rev-list --count ".concat(shell_quote(tag).concat("..HEAD")));
}

fn git_count_total(root: String) -> String {
  return run_git_capture(root, "count_total", "rev-list --count HEAD");
}

fn git_exact_base_tag(root: String, base: String) -> bool {
  if base == "" { return false; }
  let tag: String = "v".concat(base);
  let got: String = run_git_capture(root, "exact_tag", "describe --tags --exact-match --match ".concat(shell_quote(tag)));
  return got == tag;
}

struct LocalSelfhostPrintBinResult { ok: bool, err: String, bin: String }

fn local_dev_repo_has_selfhost() -> bool {
  if !fs.exists("vox.toml") { return false; }
  if !fs.exists("src/main.vox") { return false; }
  if !fs.exists("scripts/ci/rolling-selfhost.sh") { return false; }
  return true;
}

fn local_dev_selfhost_cmd(cmd: String) -> bool {
  return cmd == "fmt" || cmd == "install";
}

fn is_local_selfhost_bin(exe0: String) -> bool {
  let exe: String = path_with_forward_slashes(normalize_host_fs_path(exe0));
  if has_suffix(exe, "/target/debug/vox_rolling") { return true; }
  if has_suffix(exe, "/target/debug/vox_rolling.exe") { return true; }
  if has_suffix(exe, "target/debug/vox_rolling") { return true; }
  if has_suffix(exe, "target/debug/vox_rolling.exe") { return true; }
  return false;
}

fn last_non_empty_line(text: String) -> String {
  let lines: Vec[String] = split_lines(text);
  if lines.len() == 0 { return ""; }
  let mut i: i32 = lines.len() - 1;
  while i >= 0 {
    let s: String = txt.trim_space(lines.get(i));
    if s != "" { return s; }
    i = i - 1;
  }
  return "";
}

fn exec_cmd_with_env_once(cmdline: String, key: String, value: String, trace: bool) -> i32 {
  if host_is_windows() {
    let wrapped: String = "set ".concat(key).concat("=").concat(value).concat("&& ").concat(cmdline);
    return exec_cmd("cmd /C ".concat(shell_quote(wrapped)), trace);
  }
  let wrapped: String = key.concat("=").concat(shell_quote(value)).concat(" ").concat(cmdline);
  return exec_cmd(wrapped, trace);
}

fn local_selfhost_print_bin(trace_exec: bool) -> LocalSelfhostPrintBinResult {
  if !local_dev_repo_has_selfhost() {
    return LocalSelfhostPrintBinResult { ok: false, err: "not in vox-lang repo root", bin: "" };
  }
  fs.mkdir_p("target/debug");
  let out: String = "target/debug/.vox_local_selfhost_print_bin.log";
  let script: String = shell_exec_path("scripts/ci/rolling-selfhost.sh");
  let cmd: String =
    "bash "
      .concat(shell_quote(script))
      .concat(" print-bin > ")
      .concat(shell_quote(shell_exec_path(out)))
      .concat(" 2>&1");
  let rc: i32 = exec_cmd(cmd, trace_exec);
  let txt: String = if fs.exists(out) { fs.read_to_string(out) } else { "" };
  if rc != 0 {
    if txt != "" {
      return LocalSelfhostPrintBinResult { ok: false, err: txt, bin: "" };
    }
    return LocalSelfhostPrintBinResult { ok: false, err: "rolling selfhost build failed", bin: "" };
  }
  let bin: String = last_non_empty_line(txt);
  if bin == "" {
    return LocalSelfhostPrintBinResult { ok: false, err: "rolling selfhost did not print compiler path", bin: "" };
  }
  if !fs.exists(bin) {
    return LocalSelfhostPrintBinResult { ok: false, err: "rolling selfhost binary missing: ".concat(bin), bin: "" };
  }
  return LocalSelfhostPrintBinResult { ok: true, err: "", bin: bin };
}

fn maybe_handle_local_dev_selfhost(args: Vec[String], trace_exec: bool) -> ToolchainRouteResult {
  if args.len() == 0 { return tc_route_no(); }
  if txt.trim_space(proc.getenv("VOX_DEV_SELFHOST_DISABLE")) == "1" {
    return tc_route_no();
  }
  let cmd: String = args.get(0);
  if !local_dev_selfhost_cmd(cmd) { return tc_route_no(); }
  if !local_dev_repo_has_selfhost() { return tc_route_no(); }
  if is_local_selfhost_bin(proc.exe_path()) {
    return tc_route_no();
  }

  let pr: LocalSelfhostPrintBinResult = local_selfhost_print_bin(trace_exec);
  if !pr.ok {
    print("local selfhost failed\n");
    if pr.err != "" { print(pr.err.concat("\n")); }
    return tc_route_yes(1);
  }
  let cmdline: String = tc_build_exec_cmd(pr.bin, args);
  let rc: i32 = exec_cmd_with_env_once(cmdline, "VOX_DEV_SELFHOST_DISABLE", "1", trace_exec);
  return tc_route_yes(rc);
}

fn resolve_cli_version() -> String {
  let override: String = build_version_override();
  if override != "" { return override; }

  let base0: String = embedded_version();
  let base: String = if base0 != "" { base0 } else { "0.0.0" };
  let root: String = stage1_root();
  let sha: String = git_head_short(root);
  if sha != "" {
    let dirty: bool = git_dirty(root);
    if !dirty && git_exact_base_tag(root, base) { return base; }

    let mut n: String = git_count_since_base_tag(root, base);
    if n == "" { n = git_count_total(root); }
    if n == "" { n = "0"; }

    if dirty { return base.concat("-dirty-").concat(n).concat("+g").concat(sha); }
    return base.concat("-").concat(n).concat("+g").concat(sha);
  }

  if embedded_channel() == "release" { return base; }
  if base != "" { return base.concat("+src"); }
  return "unknown";
}

fn print_version() -> () {
  print("vox ".concat(resolve_cli_version()).concat("\n"));
}

fn home_dir_main() -> String {
  let h: String = proc.getenv("HOME");
  if h != "" { return h; }
  let up: String = proc.getenv("USERPROFILE");
  if up != "" { return up; }
  let d: String = proc.getenv("HOMEDRIVE");
  let p: String = proc.getenv("HOMEPATH");
  if d != "" && p != "" { return d.concat(p); }
  return ".";
}

fn default_pkg_name() -> String {
  if !fs.exists("vox.toml") { return "app"; }
  let mr: mf.ParseResult = mf.parse(fs.read_to_string("vox.toml"));
  if !mr.ok || mr.m.pkg_name == "" { return "app"; }
  return sanitize_path_part(mr.m.pkg_name);
}

fn default_pkg_out_base() -> String {
  return path_join("target/debug", default_pkg_name());
}

fn default_install_bin_dir() -> String {
  return path_join(path_join(home_dir_main(), ".vox"), "bin");
}

fn copy_file_host(src: String, dst: String, trace: bool) -> bool {
  let mut cmd: String = "";
  if host_is_windows() {
    cmd =
      "copy /Y "
        .concat(shell_quote(shell_exec_path(src)))
        .concat(" ")
        .concat(shell_quote(shell_exec_path(dst)));
  } else {
    cmd =
      "cp "
        .concat(shell_quote(shell_exec_path(src)))
        .concat(" ")
        .concat(shell_quote(shell_exec_path(dst)));
  }
  return exec_cmd(cmd, trace) == 0;
}

fn fmt_args_paths(args: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < args.len() {
    if args.get(i) != "" {
      out.push(args.get(i));
    }
    i = i + 1;
  }
  if out.len() == 0 {
    out.push("src");
    if fs.exists("tests") { out.push("tests"); }
    if fs.exists("examples") { out.push("examples"); }
  }
  return out;
}

fn cmd_fmt(args: Vec[String]) -> i32 {
  let mut check_only: bool = false;
  let mut raw_paths: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < args.len() {
    let a: String = args.get(i);
    if a == "--check" {
      check_only = true;
      i = i + 1;
      continue;
    }
    if txt.has_prefix(a, "-") {
      usage();
      print("unknown fmt flag: ".concat(a).concat("\n"));
      return 1;
    }
    raw_paths.push(a);
    i = i + 1;
  }

  let files: Vec[String] = vf.discover_files(fmt_args_paths(raw_paths));
  if files.len() == 0 {
    print("[fmt] no .vox files found\n");
    return 1;
  }

  let mut checked: i32 = 0;
  let mut changed: i32 = 0;
  let mut fi: i32 = 0;
  while fi < files.len() {
    let path: String = files.get(fi);
    let src: String = fs.read_to_string(path);
    let got: String = vf.format_text(src);
    checked = checked + 1;
    if got != src {
      changed = changed + 1;
      if check_only {
        print("[fmt] would format ".concat(path).concat("\n"));
      } else {
        fs.write_string(path, got);
        print("[fmt] formatted ".concat(path).concat("\n"));
      }
    }
    fi = fi + 1;
  }
  if check_only {
    if changed == 0 {
      print("[fmt] ok: ".concat(checked.to_string()).concat(" file(s) clean\n"));
      return 0;
    }
    print("[fmt] failed: ".concat(changed.to_string()).concat(" file(s) need formatting\n"));
    return 1;
  }
  print("[fmt] done: ".concat(checked.to_string()).concat(" file(s), ").concat(changed.to_string()).concat(" changed\n"));
  return 0;
}

fn lsp_server_script() -> String {
  let root: String = stage1_root();
  let p0: String = path_join(path_join(root, "tools"), "lsp/server.mjs");
  if fs.exists(p0) { return p0; }
  let p1: String = path_join(path_join(path_join(path_join(root, "tools"), "vscode"), "vox-lang"), "server/server.mjs");
  if fs.exists(p1) { return p1; }
  return "";
}

fn cmd_lsp(trace: bool) -> i32 {
  let script: String = lsp_server_script();
  if script == "" {
    print("lsp server script not found under tools/lsp or tools/vscode/vox-lang/server\n");
    return 1;
  }
  let mut node: String = txt.trim_space(proc.getenv("VOX_NODE"));
  if node == "" { node = "node"; }
  let cmd: String =
    shell_quote(node)
      .concat(" ")
      .concat(shell_quote(shell_exec_path(script)));
  let rc: i32 = exec_cmd(cmd, trace);
  if rc != 0 {
    print("lsp server exited with code ".concat(rc.to_string()).concat("\n"));
  }
  return rc;
}

fn main() -> i32 {
  let raw_args: Vec[String] = proc.args();
  let mut trace_exec: bool = false;
  let mut args: Vec[String] = raw_args;
  if args.len() > 0 && args.get(0) == "-x" {
    trace_exec = true;
    args = slice_vec(args, 1);
  }
  args = rewrite_run_alias(args);
  let mut args_for_route: Vec[String] = Vec();
  let mut ari: i32 = 0;
  while ari < args.len() {
    args_for_route.push(args.get(ari));
    ari = ari + 1;
  }
  let mut args_for_local_route: Vec[String] = Vec();
  let mut arl: i32 = 0;
  while arl < args_for_route.len() {
    args_for_local_route.push(args_for_route.get(arl));
    arl = arl + 1;
  }
  if trace_exec {
    args_for_route.push("-x");
    args_for_local_route.push("-x");
  }
  let routed: ToolchainRouteResult = maybe_handle_toolchain_or_reroute(args_for_route);
  if routed.handled { return routed.code; }
  let local_routed: ToolchainRouteResult = maybe_handle_local_dev_selfhost(args_for_local_route, trace_exec);
  if local_routed.handled { return local_routed.code; }
  if args.len() < 1 {
    usage();
    print("invalid args\n");
    return 1;
  }
  let cmd_in: String = args.get(0);
  if is_version_cmd(cmd_in) {
    print_version();
    return 0;
  }
  let mut cmd: String = cmd_in;
  if cmd == "fmt" {
    let mut fmt_args: Vec[String] = Vec();
    let mut i_fmt: i32 = 1;
    while i_fmt < args.len() {
      if args.get(i_fmt) == "-x" {
        trace_exec = true;
      } else {
        fmt_args.push(args.get(i_fmt));
      }
      i_fmt = i_fmt + 1;
    }
    return cmd_fmt(fmt_args);
  }
  if cmd == "lsp" {
    if args.len() == 2 && args.get(1) == "-x" {
      trace_exec = true;
      return cmd_lsp(trace_exec);
    }
    if args.len() != 1 {
      usage();
      print("unexpected args for lsp\n");
      return 1;
    }
    return cmd_lsp(trace_exec);
  }
  if cmd != "build" && cmd != "test" && cmd != "run" && cmd != "install" && cmd != "list" {
    usage();
    print("unknown command\n");
    return 1;
  }

  let mut driver: cg.DriverMainKind = cg.DriverMainKind.User;
  let mut test_module_pat: String = "";
  let mut test_run_pat: String = "";
  let mut test_filter: String = "";
  let mut test_jobs: i32 = 1;
  let mut test_fail_fast: bool = false;
  let mut test_list_only: bool = false;
  let mut test_rerun_failed: bool = false;
  let mut list_include_tests: bool = false;
  let mut test_json: bool = false;
  let mut target_flag: String = "";
  let mut artifact_flag: String = "";
  let mut emit_c_enabled: bool = false;
  let mut emit_c_path: String = "";
  let mut out: String = "";
  let mut i: i32 = 1;
  while i < args.len() {
    let a: String = args.get(i);
    if a == "-x" {
      trace_exec = true;
      i = i + 1;
      continue;
    }
    if txt.has_prefix(a, "--driver=") {
      let v: String = a.slice(9, a.len());
      if v == "user" { driver = cg.DriverMainKind.User; i = i + 1; continue; }
      if v == "tool" { driver = cg.DriverMainKind.Tool; i = i + 1; continue; }
      usage();
      print("unknown driver: ".concat(v).concat("\n"));
      return 1;
    }
    if txt.has_prefix(a, "--run=") {
      if cmd != "test" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      test_run_pat = a.slice(6, a.len());
      i = i + 1;
      continue;
    }
    if a == "--run" {
      if cmd != "test" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      if i + 1 >= args.len() {
        usage();
        print("missing value for --run\n");
        return 1;
      }
      test_run_pat = args.get(i + 1);
      i = i + 2;
      continue;
    }
    if txt.has_prefix(a, "--module=") {
      if cmd != "test" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      test_module_pat = a.slice(9, a.len());
      i = i + 1;
      continue;
    }
    if a == "--module" {
      if cmd != "test" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      if i + 1 >= args.len() {
        usage();
        print("missing value for --module\n");
        return 1;
      }
      test_module_pat = args.get(i + 1);
      i = i + 2;
      continue;
    }
    if a == "-j" || a == "--jobs" {
      if cmd != "test" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      if i + 1 >= args.len() {
        usage();
        print("missing value for --jobs\n");
        return 1;
      }
      let pj: ParseI32Result = parse_i32_decimal(args.get(i + 1));
      if !pj.ok || pj.v <= 0 {
        usage();
        print("invalid --jobs value: ".concat(args.get(i + 1)).concat("\n"));
        return 1;
      }
      test_jobs = pj.v;
      i = i + 2;
      continue;
    }
    if txt.has_prefix(a, "--jobs=") {
      if cmd != "test" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      let pj: ParseI32Result = parse_i32_decimal(a.slice(7, a.len()));
      if !pj.ok || pj.v <= 0 {
        usage();
        print("invalid --jobs value: ".concat(a.slice(7, a.len())).concat("\n"));
        return 1;
      }
      test_jobs = pj.v;
      i = i + 1;
      continue;
    }
    if txt.has_prefix(a, "--filter=") {
      if cmd != "test" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      test_filter = a.slice(9, a.len());
      i = i + 1;
      continue;
    }
    if a == "--filter" {
      if cmd != "test" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      if i + 1 >= args.len() {
        usage();
        print("missing value for --filter\n");
        return 1;
      }
      test_filter = args.get(i + 1);
      i = i + 2;
      continue;
    }
    if a == "--fail-fast" {
      if cmd != "test" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      test_fail_fast = true;
      i = i + 1;
      continue;
    }
    if a == "--list" {
      if cmd != "test" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      test_list_only = true;
      i = i + 1;
      continue;
    }
    if a == "--rerun-failed" {
      if cmd != "test" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      test_rerun_failed = true;
      i = i + 1;
      continue;
    }
    if a == "--json" {
      if cmd != "test" && cmd != "list" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      test_json = true;
      i = i + 1;
      continue;
    }
    if a == "--tests" {
      if cmd != "list" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      list_include_tests = true;
      i = i + 1;
      continue;
    }
    if a == "--no-tests" {
      if cmd != "list" {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      list_include_tests = false;
      i = i + 1;
      continue;
    }
    if txt.has_prefix(a, "--target=") {
      if !cmd_supports_target(cmd.slice(0, cmd.len())) {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      target_flag = a.slice(9, a.len());
      i = i + 1;
      continue;
    }
    if a == "--target" {
      if !cmd_supports_target(cmd.slice(0, cmd.len())) {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      if i + 1 >= args.len() {
        usage();
        print("missing value for --target\n");
        return 1;
      }
      target_flag = args.get(i + 1);
      i = i + 2;
      continue;
    }
    if txt.has_prefix(a, "--artifact=") {
      if !cmd_supports_artifact(cmd.slice(0, cmd.len())) {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      artifact_flag = a.slice(11, a.len());
      i = i + 1;
      continue;
    }
    if a == "--artifact" {
      if !cmd_supports_artifact(cmd.slice(0, cmd.len())) {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      if i + 1 >= args.len() {
        usage();
        print("missing value for --artifact\n");
        return 1;
      }
      artifact_flag = args.get(i + 1);
      i = i + 2;
      continue;
    }
    if txt.has_prefix(a, "--emit-c=") {
      if !cmd_supports_emit_c(cmd.slice(0, cmd.len())) {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      emit_c_enabled = true;
      emit_c_path = a.slice(9, a.len());
      i = i + 1;
      continue;
    }
    if a == "--emit-c" {
      if !cmd_supports_emit_c(cmd.slice(0, cmd.len())) {
        usage();
        print("unknown flag: ".concat(a).concat("\n"));
        return 1;
      }
      emit_c_enabled = true;
      i = i + 1;
      continue;
    }
    if txt.has_prefix(a, "-") {
      usage();
      print("unknown flag: ".concat(a).concat("\n"));
      return 1;
    }
    if cmd == "list" {
      usage();
      print("unexpected positional arg for list: ".concat(a).concat("\n"));
      return 1;
    }
    if out != "" {
      usage();
      print("unexpected positional arg for ".concat(cmd).concat(": ").concat(a).concat("\n"));
      return 1;
    }
    out = a;
    i = i + 1;
  }
  if out == "" {
    if cmd == "build" || cmd == "test" || cmd == "run" || cmd == "install" {
      out = default_pkg_out_base();
    } else if cmd != "list" {
      usage();
      print("missing out path\n");
      return 1;
    }
  }

  let host_platform: String = tc_detect_platform();
  let host_os: String = platform_os_part(host_platform);
  let host_arch: String = platform_arch_part(host_platform);
  let tr: CliTargetSpec = parse_cli_target_spec(target_flag, host_os.slice(0, host_os.len()), host_arch.slice(0, host_arch.len()));
  if !tr.ok {
    usage();
    print(tr.err.concat("\n"));
    return 1;
  }
  let target_os: String = tr.os;
  let target_arch: String = tr.arch;
  let target_ptr: i32 = target_ptr_bits(target_arch);
  let target_triple: String = tr.triple;
  let target_abi: String = tr.abi;

  let ar: CliArtifactSpec = parse_cli_artifact(artifact_flag);
  if !ar.ok {
    usage();
    print(ar.err.concat("\n"));
    return 1;
  }
  let artifact: String = ar.kind;
  let profile_on: bool = compile_profile_enabled();

  if target_os == "wasm" {
    if cmd == "test" && target_abi != "wasi" {
      usage();
      print("invalid --target for test: wasm target requires wasm32-wasi runner mode\n");
      return 1;
    }
    if cmd == "run" && target_abi != "wasi" {
      usage();
      print("invalid --target for run: wasm run requires wasm32-wasi\n");
      return 1;
    }
    if cmd_supports_artifact(cmd) && artifact != "exe" {
      usage();
      print("invalid --artifact for wasm target: expected exe\n");
      return 1;
    }
  }
  if cmd == "run" && target_os != "wasm" && (target_os != host_os || target_arch != host_arch) {
    usage();
    print("invalid --target for run: only host target is supported\n");
    return 1;
  }

  if cmd == "list" {
    let all: Vec[String] = srcw.walk_vox_files(".");
    let paths: Vec[String] = if list_include_tests { filter_pkg_test_sources(all) } else { filter_pkg_sources(all) };
    let mut paths_for_std: Vec[String] = Vec();
    let mut psi: i32 = 0;
    while psi < paths.len() {
      paths_for_std.push(paths.get(psi));
      psi = psi + 1;
    }
    let mut paths_for_vox: Vec[String] = Vec();
    let mut psv: i32 = 0;
    while psv < paths_for_std.len() {
      paths_for_vox.push(paths_for_std.get(psv));
      psv = psv + 1;
    }
    let mut files: Vec[ld.SourceFile] = if has_std_under_src(paths_for_std) { Vec() } else { load_stage1_std() };
    if !has_vox_under_src(paths_for_vox) {
      let preload_vox: Vec[ld.SourceFile] = load_stage1_vox();
      let mut pvi: i32 = 0;
      while pvi < preload_vox.len() {
        files.push(preload_vox.get(pvi));
        pvi = pvi + 1;
      }
    }
    let dr: DepsResult = load_deps_from_manifest();
    if !dr.ok {
      print("invalid vox.toml: ".concat(dr.err).concat("\n"));
      return 1;
    }
    let mut di: i32 = 0;
    while di < dr.files.len() { files.push(dr.files.get(di)); di = di + 1; }
    let user: Vec[ld.SourceFile] = load_files(paths);
    let mut ui: i32 = 0;
    while ui < user.len() { files.push(user.get(ui)); ui = ui + 1; }
    let c_all: Vec[String] = filter_pkg_c_sources(srcw.walk_c_files("."));
    let c_user: Vec[ld.SourceFile] = load_files(c_all);
    let mut cui: i32 = 0;
    while cui < c_user.len() { files.push(c_user.get(cui)); cui = cui + 1; }

    let opts: lst.GraphOptions = lst.GraphOptions {
      include_tests: list_include_tests,
      target_os: target_os,
      target_arch: target_arch,
      target_ptr_bits: target_ptr,
    };
    let lr: lst.BuildResult = lst.graph_from_files_with_options(files, opts);
    if !lr.ok {
      print("list failed: ".concat(lr.err).concat("\n"));
      return 1;
    }
    if test_json {
      print(lst.graph_to_json(lr.graph).concat("\n"));
    } else {
      print(lst.graph_to_text(lr.graph));
    }
    return 0;
  }

  if cmd == "build" {
    let all: Vec[String] = srcw.walk_vox_files(".");
    let paths: Vec[String] = filter_pkg_sources(all);
    let mut paths_for_std: Vec[String] = Vec();
    let mut psi: i32 = 0;
    while psi < paths.len() {
      paths_for_std.push(paths.get(psi));
      psi = psi + 1;
    }
    let mut paths_for_vox: Vec[String] = Vec();
    let mut psv: i32 = 0;
    while psv < paths_for_std.len() {
      paths_for_vox.push(paths_for_std.get(psv));
      psv = psv + 1;
    }
    let is_self_std: bool = has_std_under_src(paths_for_std);
    let mut files: Vec[ld.SourceFile] = if is_self_std { Vec() } else { load_stage1_std() };
    if !has_vox_under_src(paths_for_vox) {
      let preload_vox: Vec[ld.SourceFile] = load_stage1_vox();
      let mut pvi: i32 = 0;
      while pvi < preload_vox.len() {
        files.push(preload_vox.get(pvi));
        pvi = pvi + 1;
      }
    }
    let dr: DepsResult = load_deps_from_manifest();
    if !dr.ok {
      print("invalid vox.toml: ".concat(dr.err).concat("\n"));
      return 1;
    }
    let vr: LockVerifyResult = verify_lockfile_or_ok(dr.resolved);
    if !vr.ok {
      print_invalid_lock_error(vr.err);
      return 1;
    }
    write_lockfile(dr.resolved);
    let mut di: i32 = 0;
    while di < dr.files.len() { files.push(dr.files.get(di)); di = di + 1; }
    let user: Vec[ld.SourceFile] = load_files(paths);
    let mut ui: i32 = 0;
    while ui < user.len() { files.push(user.get(ui)); ui = ui + 1; }
    let c_all_build: Vec[String] = filter_pkg_c_sources(srcw.walk_c_files("."));
    let c_user_build: Vec[ld.SourceFile] = load_files(c_all_build);
    let mut cubi: i32 = 0;
    while cubi < c_user_build.len() { files.push(c_user_build.get(cubi)); cubi = cubi + 1; }
    let out_cpath: String = out.concat(".c");
    let mut files_for_cache: Vec[ld.SourceFile] = Vec();
    let mut fci: i32 = 0;
    while fci < files.len() {
      files_for_cache.push(files.get(fci));
      fci = fci + 1;
    }
    let driver_key: String = if driver == cg.DriverMainKind.Tool { "tool" } else { "user" };
    let emit_driver_key: String = if artifact == "exe" { "1" } else { "0" };
    let compile_mode: String = build_compile_mode_text("build", driver_key, emit_driver_key, host_os, host_arch, target_os, target_arch, target_triple, target_abi);
    let link_mode: String = build_mode_text("build", driver_key, emit_driver_key, host_os, host_arch, target_os, target_arch, target_triple, target_abi, artifact);
    let cc_target_cmd: String = cc_cmd_for_target(host_os, host_arch, target_os, target_arch, target_triple, target_abi);
    let obj_ext: String = cc_object_ext(cc_is_msvc_cmd(cc_target_cmd));
    let cache_enabled: bool = build_cache_enabled();
    let mut compile_key: String = "";
    let mut link_key: String = "";
    let mut cache_cpath: String = out_cpath;
    let mut cache_obj: String = out.concat(obj_ext);
    let mut cache_bin: String = out;
    let mut compile_cache_hit: bool = false;
    let mut link_cache_hit: bool = false;
    if cache_enabled {
      let mut files_for_link_key: Vec[ld.SourceFile] = Vec();
      let mut fkl: i32 = 0;
      while fkl < files_for_cache.len() {
        files_for_link_key.push(files_for_cache.get(fkl));
        fkl = fkl + 1;
      }
      compile_key = build_cache_key(files_for_cache, compile_mode);
      link_key = build_cache_key(files_for_link_key, link_mode);
      cache_cpath = build_cache_cpath_for_key(compile_key);
      cache_obj = build_cache_obj_path_for_key(compile_key, obj_ext);
      cache_bin = build_cache_bin_for_key(link_key, target_os);
      compile_cache_hit = build_cache_obj_hit(compile_key, cache_cpath, cache_obj);
      link_cache_hit = build_cache_hit(link_key, cache_cpath, cache_bin);
    }
    if !compile_cache_hit {
      let cp: c.CompileProfileResult =
        c.compile_files_to_c_profile_for_target(
          files,
          cg.EmitOptions { emit_driver_main: artifact == "exe", driver_main_kind: driver, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() },
          target_ptr,
          target_os,
          target_arch,
        );
      let r: c.CompileResult = cp.r;
      if !r.ok {
        print("compile failed: ".concat(r.err).concat("\n"));
        return 1;
      }
      print_compile_warnings(r.warnings);
      if profile_on { print_compile_profile("compile", cp.p); }
      fs.mkdir_p(dir_name(cache_cpath));
      fs.write_string(cache_cpath, r.c);
      write_emit_c_text(emit_c_enabled, emit_c_path, out_cpath, r.c);
      fs.mkdir_p(dir_name(cache_obj));
      let cc_obj_cmdline: String = cc_compile_obj_cmdline_for_target_artifact(host_os.slice(0, host_os.len()), host_arch.slice(0, host_arch.len()), target_os.slice(0, target_os.len()), target_arch.slice(0, target_arch.len()), target_triple.slice(0, target_triple.len()), target_abi.slice(0, target_abi.len()), cache_cpath, cache_obj);
      let cc_obj_t0: i64 = tm.now_ns();
      let code: i32 = exec_cmd(cc_obj_cmdline, trace_exec);
      let cc_obj_ns: i64 = dur_nonneg_ns(cc_obj_t0, tm.now_ns());
      if profile_on { print("[profile] cc-obj: ".concat(format_duration_ns(cc_obj_ns)).concat("\n")); }
      if code != 0 {
        print("cc failed: ".concat(cc_obj_cmdline).concat("\n"));
        print("cc exit: ".concat(code.to_string()).concat("\n"));
        return 1;
      }
      if cache_enabled {
        write_build_obj_cache(compile_key);
      }
    }
    if !link_cache_hit {
      fs.mkdir_p(dir_name(cache_bin));
      let link_cmdline: String = cc_link_obj_cmdline_for_target_artifact(host_os.slice(0, host_os.len()), host_arch.slice(0, host_arch.len()), target_os.slice(0, target_os.len()), target_arch.slice(0, target_arch.len()), target_triple.slice(0, target_triple.len()), target_abi.slice(0, target_abi.len()), artifact, cache_obj, cache_bin);
      let link_t0: i64 = tm.now_ns();
      let link_code: i32 = exec_cmd(link_cmdline, trace_exec);
      let link_ns: i64 = dur_nonneg_ns(link_t0, tm.now_ns());
      if profile_on { print("[profile] link: ".concat(format_duration_ns(link_ns)).concat("\n")); }
      if link_code != 0 {
        print("link failed: ".concat(link_cmdline).concat("\n"));
        print("link exit: ".concat(link_code.to_string()).concat("\n"));
        return 1;
      }
      if cache_enabled {
        write_build_cache(link_key);
      }
    }
    if cache_enabled {
      let mut cache_bin_src: String = cache_bin;
      if !fs.exists(cache_bin_src) && fs.exists(cache_bin.concat(".exe")) {
        cache_bin_src = cache_bin.concat(".exe");
      }
      if !copy_file_host(cache_bin_src, out, trace_exec) {
        print("build cache copy failed: ".concat(cache_bin_src).concat(" -> ").concat(out).concat("\n"));
        return 1;
      }
      if out_cpath != cache_cpath {
        fs.write_string(out_cpath, fs.read_to_string(cache_cpath));
      }
    }
    if compile_cache_hit {
      copy_emit_c_from_file(emit_c_enabled, emit_c_path, out_cpath);
    }
    return 0;
  }
  if cmd == "run" {
    if artifact != "exe" {
      usage();
      print("invalid --artifact for run: expected exe\n");
      return 1;
    }

    let self_bin: String = normalize_host_fs_path(proc.exe_path());
    let mut cmdline: String =
      shell_quote(shell_exec_path(self_bin))
        .concat(" build ")
        .concat(shell_quote(out));
    if driver == cg.DriverMainKind.Tool {
      cmdline = cmdline.concat(" --driver=tool");
    }
    if target_flag != "" {
      cmdline = cmdline.concat(" --target=").concat(shell_quote(target_flag));
    }
    if artifact_flag != "" {
      cmdline = cmdline.concat(" --artifact=").concat(shell_quote(artifact_flag));
    }
    if emit_c_enabled {
      if emit_c_path != "" {
        cmdline = cmdline.concat(" --emit-c=").concat(shell_quote(emit_c_path));
      } else {
        cmdline = cmdline.concat(" --emit-c");
      }
    }
    if trace_exec {
      cmdline = cmdline.concat(" -x");
    }
    let rc_build: i32 = exec_cmd(cmdline, trace_exec);
    if rc_build != 0 {
      print("run build failed\n");
      return rc_build;
    }

    let mut built: String = out;
    if !fs.exists(built) {
      let out_exe: String = out.concat(".exe");
      if fs.exists(out_exe) { built = out_exe; }
    }
    if !fs.exists(built) {
      print("run failed: built binary not found: ".concat(built).concat("\n"));
      return 1;
    }

    let mut run_cmd: String = shell_quote(shell_exec_path(built));
    if target_os == "wasm" && target_abi == "wasi" {
      let mut runner: String = txt.trim_space(proc.getenv("WASM_RUNNER"));
      if runner == "" { runner = "wasmtime"; }
      run_cmd = shell_quote(shell_exec_path(runner)).concat(" ").concat(shell_quote(shell_exec_path(built)));
    }
    return exec_cmd(run_cmd, trace_exec);
  }
  if cmd == "install" {
    if artifact != "exe" {
      usage();
      print("invalid --artifact for install: expected exe\n");
      return 1;
    }
    if target_os != host_os || target_arch != host_arch {
      usage();
      print("invalid --target for install: only host target is supported\n");
      return 1;
    }

    let self_bin: String = normalize_host_fs_path(proc.exe_path());
    let mut cmdline: String =
      shell_quote(shell_exec_path(self_bin))
        .concat(" build ")
        .concat(shell_quote(out));
    if driver == cg.DriverMainKind.Tool {
      cmdline = cmdline.concat(" --driver=tool");
    }
    if target_flag != "" {
      cmdline = cmdline.concat(" --target=").concat(shell_quote(target_flag));
    }
    if trace_exec {
      cmdline = cmdline.concat(" -x");
    }
    let rc_build: i32 = exec_cmd(cmdline, trace_exec);
    if rc_build != 0 {
      print("install build failed\n");
      return rc_build;
    }

    let mut built: String = out;
    if !fs.exists(built) {
      let out_exe: String = out.concat(".exe");
      if fs.exists(out_exe) { built = out_exe; }
    }
    if !fs.exists(built) {
      print("install failed: built binary not found: ".concat(built).concat("\n"));
      return 1;
    }

    let install_dir: String = default_install_bin_dir();
    fs.mkdir_p(install_dir);
    let mut dst_name: String = default_pkg_name();
    if dst_name == "" || dst_name == "_" { dst_name = "app"; }
    if host_is_windows() && !has_suffix(dst_name, ".exe") {
      dst_name = dst_name.concat(".exe");
    }
    let dst: String = path_join(install_dir, dst_name);
    if !copy_file_host(built, dst, trace_exec) {
      print("install failed: copy error\n");
      return 1;
    }
    print("[install] ".concat(dst).concat("\n"));
    return 0;
  }
  if cmd == "test" {
    let all: Vec[String] = srcw.walk_vox_files(".");
    let paths: Vec[String] = filter_pkg_test_sources(all);
    let mut paths_for_std_test: Vec[String] = Vec();
    let mut pst: i32 = 0;
    while pst < paths.len() {
      paths_for_std_test.push(paths.get(pst));
      pst = pst + 1;
    }
    let mut paths_for_vox_test: Vec[String] = Vec();
    let mut pvt: i32 = 0;
    while pvt < paths_for_std_test.len() {
      paths_for_vox_test.push(paths_for_std_test.get(pvt));
      pvt = pvt + 1;
    }

    let prev_failed: Vec[String] = if test_rerun_failed { read_failed_tests() } else { Vec() };
    if test_rerun_failed && prev_failed.len() == 0 {
      if test_json {
        print_json_report(0, 0, test_module_pat, test_run_pat, test_filter, test_jobs, test_fail_fast, true, 0, false, Vec(), Vec(), Vec(), Vec(), Vec(), Vec(), "", "no previous failed tests", 0, 0, 0, 0);
      } else {
        print("[test] no previous failed tests\n");
      }
      return 0;
    }
    let mut paths_fast: Vec[String] = Vec();
    let mut pfi: i32 = 0;
    while pfi < paths.len() {
      paths_fast.push(paths.get(pfi));
      pfi = pfi + 1;
    }
    let mut paths_full: Vec[String] = Vec();
    let mut pni: i32 = 0;
    while pni < paths.len() {
      paths_full.push(paths.get(pni));
      pni = pni + 1;
    }
    let discovered: Vec[String] = if test_list_only { discover_tests_cached_fast(paths_fast) } else { discover_tests_cached(paths_full) };
    let mut discovered_for_base: Vec[String] = Vec();
    let mut dbi: i32 = 0;
    while dbi < discovered.len() {
      discovered_for_base.push(discovered.get(dbi));
      dbi = dbi + 1;
    }
    let mut prev_failed_for_base: Vec[String] = Vec();
    let mut pbi: i32 = 0;
    while pbi < prev_failed.len() {
      prev_failed_for_base.push(prev_failed.get(pbi));
      pbi = pbi + 1;
    }
    let base: Vec[String] = if test_rerun_failed { intersect_tests(discovered_for_base, prev_failed_for_base) } else { discovered_for_base };
    let by_module: Vec[String] = filter_tests_module_pattern(base, test_module_pat);
    let by_run: Vec[String] = filter_tests_run_pattern(by_module, test_run_pat);
    let tests: Vec[String] = filter_tests_contains(by_run, test_filter);
    if !test_json {
      print_test_selection(discovered.len(), tests.len(), test_module_pat, test_run_pat, test_filter, test_jobs, test_fail_fast, if test_rerun_failed { prev_failed.len() } else { -1 });
    }
    if test_list_only {
      let mut tests_for_list_json: Vec[String] = Vec();
      let mut tli: i32 = 0;
      while tli < tests.len() {
        tests_for_list_json.push(tests.get(tli));
        tli = tli + 1;
      }
      let mut tests_for_list_text: Vec[String] = Vec();
      let mut tlt: i32 = 0;
      while tlt < tests.len() {
        tests_for_list_text.push(tests.get(tlt));
        tlt = tlt + 1;
      }
      if test_json {
        print_json_report(discovered.len(), tests.len(), test_module_pat, test_run_pat, test_filter, test_jobs, test_fail_fast, test_rerun_failed, if test_rerun_failed { prev_failed.len() } else { 0 }, true, tests_for_list_json, Vec(), Vec(), Vec(), Vec(), Vec(), "", "", 0, 0, 0, 0);
      } else {
        print_test_list(tests_for_list_text);
      }
      return 0;
    }
    if tests.len() == 0 {
      if test_json {
        print_json_report(discovered.len(), 0, test_module_pat, test_run_pat, test_filter, test_jobs, test_fail_fast, test_rerun_failed, if test_rerun_failed { prev_failed.len() } else { 0 }, false, Vec(), Vec(), Vec(), Vec(), Vec(), Vec(), "", "no tests found", 0, 0, 0, 0);
      } else {
        print("[test] no tests found\n");
      }
      write_failed_tests(Vec());
      return 0;
    }

    let is_self_std_test: bool = has_std_under_src(paths_for_std_test);
    let mut files: Vec[ld.SourceFile] = if is_self_std_test { Vec() } else { load_stage1_std() };
    if !has_vox_under_src(paths_for_vox_test) {
      let preload_vox: Vec[ld.SourceFile] = load_stage1_vox();
      let mut pvi: i32 = 0;
      while pvi < preload_vox.len() {
        files.push(preload_vox.get(pvi));
        pvi = pvi + 1;
      }
    }
    let dr: DepsResult = load_deps_from_manifest();
    if !dr.ok {
      print("invalid vox.toml: ".concat(dr.err).concat("\n"));
      return 1;
    }
    let vr: LockVerifyResult = verify_lockfile_or_ok(dr.resolved);
    if !vr.ok {
      print_invalid_lock_error(vr.err);
      return 1;
    }
    write_lockfile(dr.resolved);
    let mut di: i32 = 0;
    while di < dr.files.len() { files.push(dr.files.get(di)); di = di + 1; }
    let user: Vec[ld.SourceFile] = load_files(paths);
    let mut ui: i32 = 0;
    while ui < user.len() { files.push(user.get(ui)); ui = ui + 1; }
    let c_all_test: Vec[String] = filter_pkg_c_sources(srcw.walk_c_files("."));
    let c_user_test: Vec[ld.SourceFile] = load_files(c_all_test);
    let mut cuti: i32 = 0;
    while cuti < c_user_test.len() { files.push(c_user_test.get(cuti)); cuti = cuti + 1; }

    let mut files_for_test_cache: Vec[ld.SourceFile] = Vec();
    let mut ftc: i32 = 0;
    while ftc < files.len() {
      files_for_test_cache.push(files.get(ftc));
      ftc = ftc + 1;
    }
    let test_mode: String = build_mode_text("test", "user", "0", host_os, host_arch, target_os, target_arch, target_triple, target_abi, "exe");
    let test_build_key: String = test_build_cache_key(files_for_test_cache, test_mode);
    let test_cache_out: String = test_build_cache_out_for_key(test_build_key);
    let cpath: String = test_build_cache_cpath_for_key(test_build_key);
    let bin: String = test_cache_out;
    let mut tests_for_selected: Vec[String] = Vec();
    let mut tci: i32 = 0;
    while tci < tests.len() {
      tests_for_selected.push(tests.get(tci));
      tci = tci + 1;
    }
    let mut tests_for_queues: Vec[String] = Vec();
    let mut tqu: i32 = 0;
    while tqu < tests.len() {
      tests_for_queues.push(tests.get(tqu));
      tqu = tqu + 1;
    }
    let mut tests_for_cache_lookup: Vec[String] = Vec();
    let mut tcl: i32 = 0;
    while tcl < tests_for_selected.len() {
      tests_for_cache_lookup.push(tests_for_selected.get(tcl));
      tcl = tcl + 1;
    }
    let total_tests: i32 = tests.len();
    let cache_enabled: bool = build_cache_enabled();
    let mut cache_hit: bool = false;
    if cache_enabled {
      cache_hit = test_build_cache_hit(test_cache_out, test_build_key, cpath, bin, tests_for_cache_lookup);
    }
    if !cache_hit {
      let mut tests_for_compile: Vec[String] = Vec();
      let mut tco: i32 = 0;
      while tco < tests_for_selected.len() {
        tests_for_compile.push(tests_for_selected.get(tco));
        tco = tco + 1;
      }
      let cp: c.CompileProfileResult =
        c.compile_files_to_c_profile_for_target(
          files,
          cg.EmitOptions { emit_driver_main: false, driver_main_kind: cg.DriverMainKind.User, emit_test_main: true, test_funcs: tests_for_compile, c_sources: Vec() },
          target_ptr,
          target_os,
          target_arch,
        );
      let r: c.CompileResult = cp.r;
      if !r.ok {
        print("compile failed: ".concat(r.err).concat("\n"));
        return 1;
      }
      print_compile_warnings(r.warnings);
      if profile_on { print_compile_profile("test-compile", cp.p); }

      fs.mkdir_p(dir_name(cpath));
      fs.mkdir_p(dir_name(bin));
      fs.write_string(cpath, r.c);
      write_emit_c_text(emit_c_enabled, emit_c_path, cpath, r.c);
      let cmdline: String = cc_cmdline_for_target(host_os.slice(0, host_os.len()), host_arch.slice(0, host_arch.len()), target_os.slice(0, target_os.len()), target_arch.slice(0, target_arch.len()), target_triple.slice(0, target_triple.len()), target_abi.slice(0, target_abi.len()), cpath, bin);
      let cc_t0: i64 = tm.now_ns();
      let code: i32 = exec_cmd(cmdline, trace_exec);
      let cc_ns: i64 = dur_nonneg_ns(cc_t0, tm.now_ns());
      if profile_on { print("[profile] test-cc: ".concat(format_duration_ns(cc_ns)).concat("\n")); }
      if code != 0 {
        print("cc failed: ".concat(cmdline).concat("\n"));
        print("cc exit: ".concat(code.to_string()).concat("\n"));
        return 1;
      }
      if cache_enabled {
        write_test_build_cache(test_cache_out, test_build_key, tests_for_selected);
      }
    } else {
      copy_emit_c_from_file(emit_c_enabled, emit_c_path, cpath);
    }

    // Run tests by module-level parallel queues, keeping module-internal order.
    let mut test_runner_cmd: String = "";
    if target_os == "wasm" && target_abi == "wasi" {
      test_runner_cmd = txt.trim_space(proc.getenv("WASM_RUNNER"));
      if test_runner_cmd == "" { test_runner_cmd = "wasmtime"; }
    }
    let run_start_ns: i64 = tm.now_ns();
    let mut passed: i32 = 0;
    let mut failed: i32 = 0;
    let mut failed_names: Vec[String] = Vec();
    let mut module_summaries: Vec[ModuleSummary] = Vec();
    let mut module_details: Vec[ModuleDetail] = Vec();
    let mut results: Vec[TestRunResult] = Vec();
    let mut queues: Vec[ModuleQueue] = build_module_queues(tests_for_queues);
    let mut running: Vec[RunningJob] = Vec();
    let mut launch_seq: i32 = 0;
    let mut stop_launch: bool = false;
    let mut fail_fast_announced: bool = false;
    let run_dir: String = path_join("target/debug", ".vox_test_jobs_".concat(run_start_ns.to_string()));
    fs.mkdir_p(run_dir);
    while passed + failed < total_tests {
      while !stop_launch && running.len() < test_jobs {
        let mut queues_for_pick: Vec[ModuleQueue] = Vec();
        let mut qpi: i32 = 0;
        while qpi < queues.len() {
          queues_for_pick.push(queues.get(qpi));
          qpi = qpi + 1;
        }
        let mut running_for_pick: Vec[RunningJob] = Vec();
        let mut rpi: i32 = 0;
        while rpi < running.len() {
          running_for_pick.push(running.get(rpi));
          rpi = rpi + 1;
        }
        let qi: i32 = pick_runnable_queue_idx(queues_for_pick, running_for_pick);
        if qi < 0 { break; }
        let q: ModuleQueue = queues.get(qi);
        let name: String = q.tests.get(q.next);
        queues = set_module_queue_next(queues, qi, q.next + 1);
        let job: RunningJob = launch_test_job(bin, run_dir, qi, launch_seq, name, test_runner_cmd, trace_exec);
        running.push(job);
        launch_seq = launch_seq + 1;
      }

      let mut queues_for_pending: Vec[ModuleQueue] = Vec();
      let mut qpn: i32 = 0;
      while qpn < queues.len() {
        queues_for_pending.push(queues.get(qpn));
        qpn = qpn + 1;
      }
      if running.len() == 0 && (!has_pending_queues(queues_for_pending) || stop_launch) { break; }

      let mut next_running: Vec[RunningJob] = Vec();
      let mut completed: bool = false;
      let mut i: i32 = 0;
      while i < running.len() {
        let job: RunningJob = running.get(i);
        if fs.exists(job.rc_file) {
          let rc_text: String = fs.read_to_string(job.rc_file);
          let prc: ParseI32Result = parse_exit_code_file(rc_text);
          if !prc.ok {
            // File may exist before shell write is fully visible; poll again.
            next_running.push(job);
            i = i + 1;
            continue;
          }
          completed = true;
          let rc: i32 = prc.v;
          let dur_ns: i64 = dur_nonneg_ns(job.start_ns, tm.now_ns());
          if rc != 0 {
            failed = failed + 1;
            failed_names.push(job.name);
            if test_fail_fast && !stop_launch {
              stop_launch = true;
            }
            module_summaries = update_module_summary(module_summaries, job.name, false, dur_ns);
            module_details = update_module_detail(module_details, job.name, false, dur_ns);
            results.push(TestRunResult { name: job.name, module: test_module_name(job.name), ok: false, dur_ns: dur_ns, err: "test failed", log_file: job.log_file });
            if !test_json {
              print("[FAIL] ".concat(job.name).concat(" (").concat(format_duration_ns(dur_ns)).concat(")\n"));
              print_failed_test_log(job.name, job.log_file);
              if test_fail_fast && !fail_fast_announced {
                print("[test] fail-fast: stop scheduling remaining tests\n");
                fail_fast_announced = true;
              }
            }
          } else {
            passed = passed + 1;
            module_summaries = update_module_summary(module_summaries, job.name, true, dur_ns);
            module_details = update_module_detail(module_details, job.name, true, dur_ns);
            results.push(TestRunResult { name: job.name, module: test_module_name(job.name), ok: true, dur_ns: dur_ns, err: "", log_file: "" });
            if !test_json { print("[OK] ".concat(job.name).concat(" (").concat(format_duration_ns(dur_ns)).concat(")\n")); }
          }
        } else {
          next_running.push(job);
        }
        i = i + 1;
      }
      running = next_running;

      if !completed {
        // Keep polling overhead bounded without relying on shell `sleep`.
        let spin0: i64 = tm.now_ns();
        while dur_nonneg_ns(spin0, tm.now_ns()) < 2000000 {
          // ~2ms spin wait
        }
      }
    }
    let total_ns: i64 = dur_nonneg_ns(run_start_ns, tm.now_ns());
    let skipped: i32 = total_tests - (passed + failed);
    let results_sorted: Vec[TestRunResult] = sort_test_results(results);
    let module_summaries_sorted: Vec[ModuleSummary] = sort_module_summaries(module_summaries);
    let module_details_sorted: Vec[ModuleDetail] = sort_module_details(module_details);
    let failed_names_sorted: Vec[String] = sort_strings(failed_names);
    let mut results_for_slowest: Vec[TestRunResult] = Vec();
    let mut rsi: i32 = 0;
    while rsi < results_sorted.len() {
      results_for_slowest.push(results_sorted.get(rsi));
      rsi = rsi + 1;
    }
    let slowest: Vec[NamedDuration] = build_slowest(results_for_slowest);
    let mut failed_names_for_write: Vec[String] = Vec();
    let mut fwi: i32 = 0;
    while fwi < failed_names_sorted.len() {
      failed_names_for_write.push(failed_names_sorted.get(fwi));
      fwi = fwi + 1;
    }
    write_failed_tests(failed_names_for_write);
    let hint: String = if failed != 0 { build_rerun_hint(out, test_jobs, test_fail_fast) } else { "" };
    if test_json {
      print_json_report(discovered.len(), tests.len(), test_module_pat, test_run_pat, test_filter, test_jobs, test_fail_fast, test_rerun_failed, if test_rerun_failed { prev_failed.len() } else { 0 }, false, tests, results_sorted, module_summaries_sorted, module_details_sorted, slowest, failed_names_sorted, hint, "", passed, failed, skipped, total_ns);
    } else {
      print_module_summaries(module_summaries_sorted);
      print_slowest(slowest);
      let mut summary: String = "[test] ".concat(passed.to_string()).concat(" passed, ").concat(failed.to_string()).concat(" failed");
      if skipped > 0 {
        summary = summary.concat(", ").concat(skipped.to_string()).concat(" skipped");
        if test_fail_fast {
          summary = summary.concat(" (fail-fast)");
        }
      }
      print(summary.concat("\n"));
      print("[time] total: ".concat(format_duration_ns(total_ns)).concat("\n"));
      if failed != 0 {
        print("[hint] rerun failed: ".concat(hint).concat("\n"));
      }
    }
    if failed != 0 { return 1; }
    return 0;
  }

  usage();
  print("unknown command\n");
  return 1;
}
