import "std/testing" as t

fn test_target_matrix_cli_parse_windows_mingw_triple_smoke() -> () {
  let tr: CliTargetSpec = parse_cli_target_spec("x86_64-w64-mingw32", "darwin", "arm64");
  t.assert(tr.ok);
  t.assert(tr.os == "windows");
  t.assert(tr.arch == "amd64");
  t.assert(tr.abi == "gnu");
  t.assert(tr.triple == "x86_64-w64-mingw32");
}

fn test_target_matrix_cli_parse_windows_msvc_triple_smoke() -> () {
  let tr: CliTargetSpec = parse_cli_target_spec("x86_64-pc-windows-msvc", "darwin", "arm64");
  t.assert(tr.ok);
  t.assert(tr.os == "windows");
  t.assert(tr.arch == "amd64");
  t.assert(tr.abi == "msvc");
  t.assert(tr.triple == "x86_64-pc-windows-msvc");
}

fn test_target_matrix_cli_parse_linux_x86_triple_smoke() -> () {
  let tr: CliTargetSpec = parse_cli_target_spec("i686-unknown-linux-gnu", "darwin", "arm64");
  t.assert(tr.ok);
  t.assert(tr.os == "linux");
  t.assert(tr.arch == "x86");
  t.assert(tr.triple == "i686-unknown-linux-gnu");
}

fn test_target_matrix_cli_parse_windows_x86_msvc_triple_smoke() -> () {
  let tr: CliTargetSpec = parse_cli_target_spec("i686-pc-windows-msvc", "darwin", "arm64");
  t.assert(tr.ok);
  t.assert(tr.os == "windows");
  t.assert(tr.arch == "x86");
  t.assert(tr.abi == "msvc");
  t.assert(tr.triple == "i686-pc-windows-msvc");
}

fn test_target_matrix_cli_reject_darwin_x86() -> () {
  let tr: CliTargetSpec = parse_cli_target_spec("darwin-x86", "darwin", "arm64");
  t.assert(!tr.ok);
}

fn test_target_matrix_cc_cmdline_windows_msvc_smoke() -> () {
  let cmd: String = cc_cmdline_for_target("windows", "amd64", "windows", "amd64", "x86_64-pc-windows-msvc", "msvc", "out.c", "out.exe");
  t.assert(text_contains(cmd, " /TC "));
  t.assert(text_contains(cmd, " /Fe:out.exe"));
  t.assert(text_contains(cmd, "ws2_32.lib"));
  t.assert(!text_contains(cmd, " /Zi"));
}

fn test_target_matrix_cc_cmdline_windows_mingw_smoke() -> () {
  let cmd: String = cc_cmdline_for_target("linux", "amd64", "windows", "amd64", "x86_64-w64-mingw32", "gnu", "out.c", "out.exe");
  t.assert(text_contains(cmd, "x86_64-w64-mingw32-gcc"));
  t.assert(text_contains(cmd, " -lws2_32"));
  t.assert(text_contains(cmd, " -g0"));
}

fn test_target_matrix_cc_cmdline_windows_x86_mingw_smoke() -> () {
  let cmd: String = cc_cmdline_for_target("linux", "amd64", "windows", "x86", "i686-w64-mingw32", "gnu", "out.c", "out.exe");
  t.assert(text_contains(cmd, "i686-w64-mingw32-gcc"));
  t.assert(text_contains(cmd, " -lws2_32"));
}

fn test_target_matrix_cli_parse_artifact_static_alias_smoke() -> () {
  let ar: CliArtifactSpec = parse_cli_artifact("staticlib");
  t.assert(ar.ok);
  t.assert(ar.kind == "static");
}

fn test_target_matrix_cli_parse_artifact_reject_smoke() -> () {
  let ar: CliArtifactSpec = parse_cli_artifact("fatbin");
  t.assert(!ar.ok);
}

fn test_target_matrix_cc_cmdline_shared_linux_smoke() -> () {
  let cmd: String = cc_cmdline_for_target_artifact("linux", "amd64", "linux", "amd64", "x86_64-unknown-linux-gnu", "", "shared", "out.c", "libvox.so");
  t.assert(text_contains(cmd, " -shared"));
  t.assert(text_contains(cmd, " -o libvox.so"));
  t.assert(!text_contains(cmd, " -static"));
}

fn test_target_matrix_cc_cmdline_shared_darwin_smoke() -> () {
  let cmd: String = cc_cmdline_for_target_artifact("darwin", "arm64", "darwin", "arm64", "aarch64-apple-darwin", "", "shared", "out.c", "libvox.dylib");
  t.assert(text_contains(cmd, " -dynamiclib"));
  t.assert(text_contains(cmd, " -o libvox.dylib"));
}

fn test_target_matrix_cc_cmdline_static_mingw_smoke() -> () {
  let cmd: String = cc_cmdline_for_target_artifact("linux", "amd64", "windows", "amd64", "x86_64-w64-mingw32", "gnu", "static", "out.c", "libvox.a");
  t.assert(text_contains(cmd, " -c out.c -o libvox.a.o"));
  t.assert(text_contains(cmd, "x86_64-w64-mingw32-ar rcs libvox.a libvox.a.o"));
}

fn test_target_matrix_cc_cmdline_static_msvc_smoke() -> () {
  let cmd: String = cc_cmdline_for_target_artifact("windows", "amd64", "windows", "amd64", "x86_64-pc-windows-msvc", "msvc", "static", "out.c", "vox.lib");
  t.assert(text_contains(cmd, " /c out.c /Fo:vox.lib.obj"));
  t.assert(text_contains(cmd, "lib /nologo /OUT:vox.lib vox.lib.obj"));
}

fn test_target_matrix_cli_parse_wasm32_unknown_unknown_smoke() -> () {
  let tr: CliTargetSpec = parse_cli_target_spec("wasm32-unknown-unknown", "darwin", "arm64");
  t.assert(tr.ok);
  t.assert(tr.os == "wasm");
  t.assert(tr.arch == "wasm32");
  t.assert(tr.abi == "unknown");
  t.assert(tr.triple == "wasm32-unknown-unknown");
}

fn test_target_matrix_cli_parse_wasm32_wasi_smoke() -> () {
  let tr: CliTargetSpec = parse_cli_target_spec("wasm32-wasi", "darwin", "arm64");
  t.assert(tr.ok);
  t.assert(tr.os == "wasm");
  t.assert(tr.arch == "wasm32");
  t.assert(tr.abi == "wasi");
  t.assert(tr.triple == "wasm32-wasi");
}

fn test_target_matrix_cli_reject_wasm_non_wasm32_arch() -> () {
  let tr: CliTargetSpec = parse_cli_target_spec("wasm-amd64", "darwin", "arm64");
  t.assert(!tr.ok);
}

fn test_target_matrix_cc_cmdline_wasm_smoke() -> () {
  let cmd: String = cc_cmdline_for_target_artifact("darwin", "arm64", "wasm", "wasm32", "wasm32-unknown-unknown", "unknown", "exe", "out.c", "out.wasm");
  t.assert(text_contains(cmd, "emcc"));
  t.assert(text_contains(cmd, " -Wl,--no-entry -Wl,--export-all"));
  t.assert(text_contains(cmd, " -o out.wasm"));
}

fn test_target_matrix_cli_parse_wasm32_emscripten_smoke() -> () {
  let tr: CliTargetSpec = parse_cli_target_spec("wasm32-unknown-emscripten", "darwin", "arm64");
  t.assert(tr.ok);
  t.assert(tr.os == "wasm");
  t.assert(tr.arch == "wasm32");
  t.assert(tr.abi == "emscripten");
  t.assert(tr.triple == "wasm32-unknown-emscripten");
}

fn test_target_matrix_cc_cmdline_wasm_wasi_smoke() -> () {
  let cmd: String = cc_cmdline_for_target_artifact("darwin", "arm64", "wasm", "wasm32", "wasm32-wasi", "wasi", "exe", "out.c", "out.wasm");
  t.assert(text_contains(cmd, "clang"));
  t.assert(text_contains(cmd, " --target=wasm32-wasi"));
  t.assert(!text_contains(cmd, "--no-entry"));
}
