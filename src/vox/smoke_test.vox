import "std/testing" as t
import "std/sync" as s

struct CompoundS { x: i32 }

const CONST_I8_A: i8 = 120;

const CONST_I8_B: i8 = CONST_I8_A + CONST_I8_A;

const CONST_U64_MAX: u64 = 18446744073709551615;

const CONST_U64_WRAP: u64 = CONST_U64_MAX + 1;

fn test_std_testing_smoke() -> () {
  t.assert(true);
  t.assert_eq(1 + 1, 2);
  t.assert_ne(1 + 1, 3);
  t.assert_eq(true, true);
  t.assert_ne(true, false);
  t.assert_eq("a", "a");
  t.assert_ne("a", "b");
  t.assert_lt(1, 2);
  t.assert_le(2, 2);
  t.assert_gt(3, 2);
  t.assert_ge(3, 3);
  t.assert_lt("a", "b");
  t.assert_ge("b", "a");
}

fn test_prelude_fallback_smoke() -> () {
  // Unqualified names fall back to std/prelude.
  assert(true);
}

fn test_bitwise_and_shift_smoke() -> () {
  let a: i32 = 6 & 3;
  let b: i32 = 1 << 4;
  let c: i32 = b >> 2;
  t.assert_eq((a | c) ^ 1, 7);
}

fn test_compound_assign_smoke() -> () {
  let mut x: i32 = 32;
  x += 10;
  x -= 2;
  x *= 3;
  x /= 5;
  x %= 7;
  x <<= 4;
  x >>= 3;
  x &= 3;
  x |= 8;
  x ^= 15;

  let mut s: CompoundS = CompoundS { x: 32 };
  s.x += 10;
  s.x -= 2;
  s.x *= 3;
  s.x /= 5;
  s.x %= 7;
  s.x <<= 4;
  s.x >>= 3;
  s.x &= 3;
  s.x |= 8;
  s.x ^= 15;
  t.assert_eq(x + s.x, 10);
}

fn test_const_i8_wrapping_add_smoke() -> () {
  let ok: bool = (CONST_I8_B as i32) == ((-16) as i32);
  t.assert(ok);
}

fn test_const_u64_wrapping_add_smoke() -> () {
  t.assert(CONST_U64_WRAP == 0);
}

fn test_expr_cast_u64_max_literal_smoke() -> () {
  let x: u64 = CONST_U64_MAX;
  t.assert(x > 1);
}

fn test_std_sync_runtime_shared_handle_smoke() -> () {
  let mut m: s.Mutex[i32] = s.mutex[i32](7);
  let m2: s.Mutex[i32] = m;
  m = s.mutex_store[i32](m, 3);
  t.assert_eq(s.mutex_load[i32](m2), 3);

  let a: Atomic[i32] = Atomic(10);
  let old_add: i32 = a.fetch_add(2);
  t.assert_eq(old_add, 10);
  t.assert_eq(a.load(), 12);
  let old_swap: i32 = a.swap(5);
  t.assert_eq(old_swap, 12);
  t.assert_eq(a.load(), 5);

  s.mutex_drop[i32](m);
  a.drop();
}

fn test_std_sync_runtime_generic_handle_smoke() -> () {
  let mut m: s.Mutex[i64] = s.mutex[i64](7 as i64);
  let m2: s.Mutex[i64] = m;
  m = s.mutex_store[i64](m, 11 as i64);
  t.assert_eq(s.mutex_load[i64](m2), 11 as i64);

  let a: Atomic[i64] = Atomic(1 as i64);
  let old_add: i64 = a.fetch_add(4 as i64);
  t.assert_eq(old_add, 1 as i64);
  t.assert_eq(a.load(), 5 as i64);
  let old_swap: i64 = a.swap(9 as i64);
  t.assert_eq(old_swap, 5 as i64);
  t.assert_eq(a.load(), 9 as i64);

  s.mutex_drop[i64](m);
  a.drop();
}

fn test_std_sync_runtime_generic_api_smoke() -> () {
  let mut m: s.Mutex[i32] = s.mutex[i32](8);
  let m2: s.Mutex[i32] = m;
  m = s.mutex_store[i32](m, 13);
  t.assert_eq(s.mutex_load[i32](m2), 13);
  t.assert_eq(s.mutex_into_inner[i32](m), 13);

  let a: Atomic[i64] = Atomic(2 as i64);
  let old1: i64 = a.fetch_add(5 as i64);
  t.assert_eq(old1, 2 as i64);
  t.assert_eq(a.load(), 7 as i64);
  let old2: i64 = a.fetch_add(1 as i64);
  t.assert_eq(old2, 7 as i64);
  let old3: i64 = a.swap(9 as i64);
  t.assert_eq(old3, 8 as i64);
  t.assert_eq(a.load(), 9 as i64);
  let ok: bool = a.cas(9 as i64, 11 as i64);
  t.assert(ok);
  t.assert_eq(a.load(), 11 as i64);

  s.mutex_drop[i32](m);
  a.drop();
}

fn test_std_sync_runtime_drop_idempotent_smoke() -> () {
  // Mutex handles are value-copied today; explicit drop should tolerate duplicate drops.
  let m: s.Mutex[i32] = s.mutex[i32](1);
  let m2: s.Mutex[i32] = m;

  s.mutex_drop[i32](m);
  s.mutex_drop[i32](m2);

  // Built-in Atomic[T] basic drop test.
  let a: Atomic[i64] = Atomic(2 as i64);
  a.drop();

  t.assert(true);
}
