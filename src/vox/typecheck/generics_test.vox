import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc

fn add_mod2(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn test_typecheck_allows_generic_fn_sig() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", "fn id[T](x: T) -> T { return x; }\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(r.ok);
}

fn test_typecheck_generic_call_infers_vec_return() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", "fn mk[T](x: T) -> Vec[T] { return Vec(); }\nfn main() -> i32 { let v = mk(1); return v.len(); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(r.ok);
}

fn test_typecheck_generic_call_returning_nominal_with_expected_type_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", "struct Boxed[T] { v: T }\nfn mk[T](x: T) -> Boxed[T] { return Boxed[T] { v: x }; }\nfn main() -> i32 { let b: Boxed[i32] = mk[i32](7); return b.v; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
  t.assert(r.ok);
}

fn test_typecheck_imported_generic_nominal_bound_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "dep", """
    pub trait Bound { fn id(v: Self) -> Self; }
    impl Bound for i32 { fn id(v: i32) -> i32 { return v; } }
    pub struct Wrap[T: Bound] { pub v: T }
    pub fn make[T: Bound](v: T) -> Wrap[T] { return Wrap { v: Bound.id(v) }; }
  """);
  w = add_mod2(w, "main", """
    import "dep" as d
    fn main() -> i32 {
      let w: d.Wrap[i32] = d.make[i32](7);
      return w.v;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
  t.assert(r.ok);
}

fn test_typecheck_generic_trait_bound_satisfied() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    fn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }
    fn main() -> i32 { return if same(1, 1) { 1 } else { 0 }; }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(r.ok);
}

fn test_typecheck_generic_trait_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    fn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }
    fn main() -> i32 { return if same("a", "b") { 1 } else { 0 }; }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.len() > 0);
}

fn test_typecheck_generic_where_trait_bound_satisfied() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    fn same[T](a: T, b: T) -> bool where T: Eq { return Eq.eq(a, b); }
    fn main() -> i32 { return if same(1, 1) { 1 } else { 0 }; }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(r.ok);
}

fn test_typecheck_generic_where_trait_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    fn same[T](a: T, b: T) -> bool where T: Eq { return Eq.eq(a, b); }
    fn main() -> i32 { return if same("a", "b") { 1 } else { 0 }; }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!r.ok);
}

fn test_typecheck_impl_specialization_prefers_more_specific_impl() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Tag { fn tag(x: Self) -> i32; }
    impl[T] Tag for Vec[T] { fn tag(x: Vec[T]) -> i32 { return 1; } }
    impl Tag for Vec[i32] { fn tag(x: Vec[i32]) -> i32 { return 2; } }
    fn main() -> i32 {
      let mut vi: Vec[i32] = Vec();
      let mut vs: Vec[String] = Vec();
      vi.push(7);
      vs.push("x");
      return Tag.tag(vi) + Tag.tag(vs);
    }
  """;
  w = add_mod2(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
  t.assert(r.ok);
}

fn test_typecheck_bound_method_call_autoborrows_mut_self_on_type_param() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", """
    trait Bump { fn bump(x: &mut Self) -> i32; }
    struct I { v: i32 }
    impl Bump for I { fn bump(x: &mut I) -> i32 { x.v = x.v + 1; return x.v; } }
    fn inc[T: Bump](x0: T) -> i32 { let mut x: T = x0; return x.bump(); }
    fn main() -> i32 { let i: I = I { v: 0 }; return inc[I](i); }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
  t.assert(r.ok);
}

fn test_typecheck_impl_specialization_requires_strict_order() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Tag { fn tag(x: Self) -> i32; }
    impl[T] Tag for Vec[T] { fn tag(x: Vec[T]) -> i32 { return 1; } }
    impl[U] Tag for Vec[U] { fn tag(x: Vec[U]) -> i32 { return 2; } }
    fn main() -> i32 { let mut v: Vec[i32] = Vec(); return Tag.tag(v); }
  """;
  w = add_mod2(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "overlapping impl without strict specialization"));
  t.assert(contains(msg, "rank_trace:"));
}

fn test_typecheck_impl_unconstrained_head_type_param_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    trait Tag { fn tag(x: Self) -> i32; }
    impl[T, U: Eq] Tag for T { fn tag(x: T) -> i32 { return 1; } }
    fn main() -> i32 { return Tag.tag(7); }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl type param is unconstrained by impl target type: U"));
}

fn test_typecheck_impl_specialization_prefers_stronger_bounds_and_filters_non_matching_bounds() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    trait Tag { fn tag(x: Self) -> i32; }
    impl[T] Tag for T { fn tag(x: T) -> i32 { return 1; } }
    impl[T: Eq] Tag for T { fn tag(x: T) -> i32 { return 2; } }
    fn main() -> i32 { return Tag.tag(7) + Tag.tag("x"); }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
  t.assert(r.ok);
}

fn test_typecheck_impl_specialization_incomparable_bounds_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod2(w, "main", """
    trait A { fn a(x: Self) -> i32; }
    trait B { fn b(x: Self) -> i32; }
    impl A for i32 { fn a(x: i32) -> i32 { return x; } }
    impl B for i32 { fn b(x: i32) -> i32 { return x; } }
    trait Tag { fn tag(x: Self) -> i32; }
    impl[T: A] Tag for T { fn tag(x: T) -> i32 { return 1; } }
    impl[T: B] Tag for T { fn tag(x: T) -> i32 { return 2; } }
    fn main() -> i32 { return Tag.tag(1); }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "overlapping impl without strict specialization"));
  t.assert(contains(msg, "rank_trace:"));
}
