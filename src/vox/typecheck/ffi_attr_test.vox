import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc

fn ffi_tc_add_mod(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn ffi_tc_run_main(src: String) -> tc.TcResult {
  let mut w: tc.World = tc.world();
  w = ffi_tc_add_mod(w, "main", src);
  return tc.typecheck_world(w);
}

fn test_typecheck_ffi_import_export_conflict_rejected() -> () {
  let src: String = "@ffi_import(\"c\", \"puts\")\n@ffi_export(\"c\", \"puts\")\npub fn puts(msg: String) -> i32;\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "cannot coexist on one function"), msg);
}

fn test_typecheck_ffi_export_must_be_pub() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_add\")\nfn add(a: i32, b: i32) -> i32 { return a + b; }\nfn main() -> i32 { return add(1, 2); }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi export function must be pub"));
}

fn test_typecheck_ffi_import_generic_rejected() -> () {
  let src: String = "@ffi_import(\"c\", \"id\")\nfn id[T](x: T) -> T;\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi import function cannot be generic"));
}

fn test_typecheck_ffi_import_variadic_accepted() -> () {
  let src: String = "@ffi_import(\"c\", \"printf\")\nfn printf(fmt: String, xs: i32...) -> i32;\nfn main() -> i32 { return printf(\"hello %d\", 42); }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_ffi_export_variadic_rejected() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_sum\")\npub fn sum(head: i32, tail: i32...) -> i32 { return head + tail.len(); }\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi export variadic function is not supported yet"));
}

fn test_typecheck_ffi_import_non_ffi_param_rejected() -> () {
  let src: String = "@ffi_import(\"c\", \"take_vec\")\nfn take_vec(xs: Vec[i32]) -> i32;\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi parameter type not supported"));
}

fn test_typecheck_ffi_export_duplicate_target_rejected() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_add\")\n@ffi_export(\"c\", \"vox_add_2\")\npub fn add(a: i32, b: i32) -> i32 { return a + b; }\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "duplicate ffi export target on one function"));
}

fn test_typecheck_ffi_import_c_smoke() -> () {
  let src: String = "@ffi_import(\"c\", \"puts\")\nfn puts(msg: String) -> i32;\nfn main() -> i32 { return puts(\"ok\"); }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(r.ok);
}

fn test_typecheck_ffi_import_vec_string_param_and_return_smoke() -> () {
  // Note: symbols here are deliberately fake; this test only checks type rules.
  let src: String = """
    @ffi_import("c", "ffi_fake_vec_string_source")
    fn args_raw() -> Vec[String];
    @ffi_import("c", "ffi_fake_consume_vec_string")
    fn consume_raw(xs: Vec[String]) -> i32;
    @ffi_import("c", "ffi_fake_vec_string_walk")
    fn walk_raw(root: String) -> Vec[String];
    fn main() -> i32 {
      let _a: Vec[String] = args_raw();
      let _w: Vec[String] = walk_raw(".");
      let mut xs: Vec[String] = Vec();
      xs.push("x");
      let _c: i32 = consume_raw(xs);
      return 0;
    }
  """;
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_ffi_import_rawptr_param_and_return_smoke() -> () {
  let src: String = """
    @ffi_import("c", "malloc")
    fn c_malloc(n: usize) -> rawptr;
    @ffi_import("c", "free")
    fn c_free(p: rawptr) -> ();
    fn main() -> i32 {
      let p: rawptr = c_malloc(16);
      c_free(p);
      return 0;
    }
  """;
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_ffi_import_const_rawptr_and_string_bridge_smoke() -> () {
  let src: String = """
    @ffi_import("c", "write")
    fn c_write(fd: i32, p: const rawptr, n: usize) -> isize;
    fn main() -> i32 {
      let n: isize = c_write(1, "ok" as const rawptr, 2 as usize);
      return n as i32;
    }
  """;
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_ffi_import_mut_ref_param_smoke() -> () {
  let src: String = """
    @ffi_import("c", "_sopen_s")
    fn c_sopen_s(fd_out: &mut i32, path: String, flags: i32, shflag: i32, mode: i32) -> i32;
    fn main() -> i32 {
      let mut fd: i32 = -1;
      let rc: i32 = c_sopen_s(fd, "x", 0, 64, 0);
      if rc != 0 { return -1; }
      return fd;
    }
  """;
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_ffi_import_ref_param_rejected() -> () {
  let src: String = """
    @ffi_import("c", "bad")
    fn bad(x: &i32) -> i32;
    fn main() -> i32 {
      let v: i32 = 1;
      return bad(v);
    }
  """;
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi parameter type not supported"));
}

fn test_typecheck_const_rawptr_to_rawptr_cast_rejected() -> () {
  let src: String = """
    @ffi_import("c", "malloc")
    fn c_malloc(n: usize) -> rawptr;
    fn main() -> i32 {
      let p: const rawptr = c_malloc(8) as const rawptr;
      let _q: rawptr = p as rawptr;
      return 0;
    }
  """;
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
}

fn test_typecheck_ffi_import_struct_param_smoke() -> () {
  let src: String = """
    struct Point { x: i32, y: i32 }
    @ffi_import("c", "take_point")
    fn take_point(p: Point) -> i32;
    fn main() -> i32 {
      let p: Point = Point { x: 1, y: 2 };
      return take_point(p);
    }
  """;
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_ffi_import_struct_return_smoke() -> () {
  let src: String = """
    struct Point { x: i32, y: i32 }
    @ffi_import("c", "make_point")
    fn make_point(x: i32, y: i32) -> Point;
    fn main() -> i32 {
      let p: Point = make_point(3, 4);
      return p.x + p.y;
    }
  """;
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_ffi_import_mut_ref_struct_param_smoke() -> () {
  let src: String = """
    struct Info { family: i32, proto: i32 }
    @ffi_import("c", "fill_info")
    fn fill_info(out: &mut Info) -> i32;
    fn main() -> i32 {
      let mut info: Info = Info { family: 0, proto: 0 };
      return fill_info(info);
    }
  """;
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_ffi_export_symbol_collision_rejected() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_dup\")\npub fn a() -> i32 { return 1; }\n@ffi_export(\"c\", \"vox_dup\")\npub fn b() -> i32 { return 2; }\nfn main() -> i32 { return a() + b(); }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "duplicate ffi export symbol for target"));
}
