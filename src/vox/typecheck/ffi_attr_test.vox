import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc

fn ffi_tc_add_mod(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn ffi_tc_run_main(src: String) -> tc.TcResult {
  let mut w: tc.World = tc.world();
  w = ffi_tc_add_mod(w, "main", src);
  return tc.typecheck_world(w);
}

fn test_typecheck_ffi_import_export_conflict_rejected() -> () {
  let src: String = "@ffi_import(\"c\", \"puts\")\n@ffi_export(\"c\", \"puts\")\npub fn puts(msg: String) -> i32;\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "cannot coexist on one function"), msg);
}

fn test_typecheck_ffi_export_must_be_pub() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_add\")\nfn add(a: i32, b: i32) -> i32 { return a + b; }\nfn main() -> i32 { return add(1, 2); }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi export function must be pub"));
}

fn test_typecheck_ffi_import_generic_rejected() -> () {
  let src: String = "@ffi_import(\"c\", \"id\")\nfn id[T](x: T) -> T;\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi import function cannot be generic/variadic"));
}

fn test_typecheck_ffi_import_non_ffi_param_rejected() -> () {
  let src: String = "@ffi_import(\"c\", \"take_vec\")\nfn take_vec(xs: Vec[i32]) -> i32;\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi parameter type not supported"));
}

fn test_typecheck_ffi_export_duplicate_target_rejected() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_add\")\n@ffi_export(\"c\", \"vox_add_2\")\npub fn add(a: i32, b: i32) -> i32 { return a + b; }\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "duplicate ffi export target on one function"));
}

fn test_typecheck_ffi_import_c_smoke() -> () {
  let src: String = "@ffi_import(\"c\", \"puts\")\nfn puts(msg: String) -> i32;\nfn main() -> i32 { return puts(\"ok\"); }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(r.ok);
}
