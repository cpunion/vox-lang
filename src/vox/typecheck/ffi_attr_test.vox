import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc

fn ffi_tc_add_mod(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn ffi_tc_run_main(src: String) -> tc.TcResult {
  let mut w: tc.World = tc.world();
  w = ffi_tc_add_mod(w, "main", src);
  return tc.typecheck_world(w);
}

fn test_typecheck_ffi_import_export_conflict_rejected() -> () {
  let src: String = "@ffi_import(\"c\", \"puts\")\n@ffi_export(\"c\", \"puts\")\npub fn puts(msg: String) -> i32;\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "cannot coexist on one function"), msg);
}

fn test_typecheck_ffi_export_must_be_pub() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_add\")\nfn add(a: i32, b: i32) -> i32 { return a + b; }\nfn main() -> i32 { return add(1, 2); }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi export function must be pub"));
}

fn test_typecheck_ffi_import_generic_rejected() -> () {
  let src: String = "@ffi_import(\"c\", \"id\")\nfn id[T](x: T) -> T;\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi import function cannot be generic"));
}

fn test_typecheck_ffi_import_variadic_rejected() -> () {
  let src: String = "@ffi_import(\"c\", \"printf\")\nfn printf(fmt: String, xs: i32...) -> i32;\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi import variadic function is not supported yet"));
}

fn test_typecheck_ffi_export_variadic_rejected() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_sum\")\npub fn sum(head: i32, tail: i32...) -> i32 { return head + tail.len(); }\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi export variadic function is not supported yet"));
}

fn test_typecheck_ffi_import_non_ffi_param_rejected() -> () {
  let src: String = "@ffi_import(\"c\", \"take_vec\")\nfn take_vec(xs: Vec[i32]) -> i32;\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "ffi parameter type not supported"));
}

fn test_typecheck_ffi_export_duplicate_target_rejected() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_add\")\n@ffi_export(\"c\", \"vox_add_2\")\npub fn add(a: i32, b: i32) -> i32 { return a + b; }\nfn main() -> i32 { return 0; }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "duplicate ffi export target on one function"));
}

fn test_typecheck_ffi_import_c_smoke() -> () {
  let src: String = "@ffi_import(\"c\", \"puts\")\nfn puts(msg: String) -> i32;\nfn main() -> i32 { return puts(\"ok\"); }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(r.ok);
}

fn test_typecheck_ffi_import_vec_string_param_and_return_smoke() -> () {
  let src: String = """
    @ffi_import("c", "vox_rt_args")
    fn args_raw() -> Vec[String];
    @ffi_import("c", "vox_fake_consume_vec_string")
    fn consume_raw(xs: Vec[String]) -> i32;
    @ffi_import("c", "vox_rt_walk_vox_files")
    fn walk_raw(root: String) -> Vec[String];
    fn main() -> i32 {
      let _a: Vec[String] = args_raw();
      let _w: Vec[String] = walk_raw(".");
      let mut xs: Vec[String] = Vec();
      xs.push("x");
      let _c: i32 = consume_raw(xs);
      return 0;
    }
  """;
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_ffi_import_rawptr_param_and_return_smoke() -> () {
  let src: String = """
    @ffi_import("c", "malloc")
    fn c_malloc(n: usize) -> rawptr;
    @ffi_import("c", "free")
    fn c_free(p: rawptr) -> ();
    fn main() -> i32 {
      let p: rawptr = c_malloc(16);
      c_free(p);
      return 0;
    }
  """;
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_ffi_export_symbol_collision_rejected() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_dup\")\npub fn a() -> i32 { return 1; }\n@ffi_export(\"c\", \"vox_dup\")\npub fn b() -> i32 { return 2; }\nfn main() -> i32 { return a() + b(); }";
  let r: tc.TcResult = ffi_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "duplicate ffi export symbol for target"));
}
