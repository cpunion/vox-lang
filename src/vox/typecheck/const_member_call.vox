import "vox/ast" as ast
import "vox/ir" as ir

struct ConstMemberCallResult {
  matched: bool,
  ev: EvalConstExprResult,
}

fn const_member_no_match(ctx: Ctx, sigs: Vec[ConstSig], states: Vec[i32]) -> ConstMemberCallResult {
  return ConstMemberCallResult {
    matched: false,
    ev: EvalConstExprResult {
      ok: false, err: TcError.None,
      kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "",
      sigs: sigs, states: states,
    },
  };
}

fn const_member_match(ev: EvalConstExprResult) -> ConstMemberCallResult {
  return ConstMemberCallResult { matched: true, ev: ev };
}

fn const_member_err(
  ctx: Ctx, file: String, exprs: ast.ExprPool, call_id: i32, msg: String,
  sigs: Vec[ConstSig], states: Vec[i32],
) -> ConstMemberCallResult {
  return const_member_match(EvalConstExprResult {
    ok: false, err: const_expr_error(file, exprs, call_id, msg),
    kind: 0, ty: ctx.ty_bad, iv: 0, bv: false, sv: "",
    sigs: sigs, states: states,
  });
}

fn const_member_expect_ok(ctx: Ctx, expected: i32, out_ty: i32) -> bool {
  return expected == -1 || assignable_to(ctx, expected, out_ty);
}

fn const_member_root_is_value(
  items: Vec[ConstItem], cur_mod: String, imps: Imports, locals: Vec[ConstLocal], root: String,
) -> bool {
  if const_find_local(locals, root) != -1 { return true; }
  let nc: NamedConstImport = find_named_const(imps.named_consts, root);
  if nc.local != "" { return true; }
  if const_find_item(items, cur_mod, root) != -1 { return true; }
  if const_find_item(items, "std/prelude", root) != -1 { return true; }
  return false;
}

fn const_member_recv_maybe_value(
  items: Vec[ConstItem], cur_mod: String, imps: Imports, exprs: ast.ExprPool, recv_id: i32, locals: Vec[ConstLocal],
) -> bool {
  let pr: ExprPartsResult = expr_parts(exprs, recv_id);
  if !pr.ok || pr.parts.len() == 0 { return true; }
  return const_member_root_is_value(items, cur_mod, imps, locals, pr.parts.get(0));
}

fn const_int_to_string_text(ctx: Ctx, ty: i32, iv: i64) -> String {
  let k: ir.TyKind = int_kind(ctx, ty);
  if is_unsigned_int_kind(k) {
    return u64_bits_to_dec_text(iv);
  }
  return iv.to_string();
}

fn const_float_to_string_text(s0: String) -> String {
  let n: String = float_norm_text(s0);
  if n.len() >= 2 && n.slice(n.len() - 2, n.len()) == ".0" {
    return n.slice(0, n.len() - 2);
  }
  return n;
}

fn str_starts_with_text(s: String, pre: String) -> bool {
  if pre.len() == 0 { return true; }
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

fn str_ends_with_text(s: String, suf: String) -> bool {
  if suf.len() == 0 { return true; }
  if s.len() < suf.len() { return false; }
  return s.slice(s.len() - suf.len(), s.len()) == suf;
}

fn str_contains_text(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn str_index_of_text(hay: String, needle: String) -> i32 {
  if needle.len() == 0 { return 0; }
  if hay.len() < needle.len() { return -1; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return i; }
    i = i + 1;
  }
  return -1;
}

fn str_last_index_of_text(hay: String, needle: String) -> i32 {
  if needle.len() == 0 { return hay.len(); }
  if hay.len() < needle.len() { return -1; }
  let mut i: i32 = hay.len() - needle.len();
  while i >= 0 {
    if hay.slice(i, i + needle.len()) == needle { return i; }
    i = i - 1;
  }
  return -1;
}

// Evaluate pure member-call subset in const context, e.g. String methods and
// primitive to_string(). Non-value path-like receivers are ignored so module/
// enum path calls keep existing resolution flow.
fn eval_const_member_call(
  ctx: Ctx, w: World, items: Vec[ConstItem],
  sigs0: Vec[ConstSig], states0: Vec[i32],
  cur_mod: String, imps: Imports, exprs: ast.ExprPool,
  file: String, call_id: i32, recv_id: i32, mname: String, args: Vec[i32], expected: i32, locals: Vec[ConstLocal],
) -> ConstMemberCallResult {
  if !const_member_recv_maybe_value(items, cur_mod, imps, exprs, recv_id, locals) {
    return const_member_no_match(ctx, sigs0, states0);
  }

  let rr: EvalConstExprResult = eval_const_expr_in_mod_locals(
    ctx, w, items, sigs0, states0, cur_mod, imps, exprs, file, recv_id, -1, locals,
  );
  if !rr.ok { return const_member_match(rr); }

  if rr.kind == const_kind_str() {
    if mname == "len" {
      if args.len() != 0 {
        return const_member_err(ctx, file, exprs, call_id, "String.len expects 0 args", rr.sigs, rr.states);
      }
      if !const_member_expect_ok(ctx, expected, ctx.ty_i32) {
        return const_member_err(ctx, file, exprs, call_id, "const method result type mismatch", rr.sigs, rr.states);
      }
      return const_member_match(EvalConstExprResult {
        ok: true, err: TcError.None,
        kind: const_kind_int(), ty: ctx.ty_i32, iv: rr.sv.len() as i64, bv: false, sv: "",
        sigs: rr.sigs, states: rr.states,
      });
    }

    if mname == "is_empty" {
      if args.len() != 0 {
        return const_member_err(ctx, file, exprs, call_id, "String.is_empty expects 0 args", rr.sigs, rr.states);
      }
      if !const_member_expect_ok(ctx, expected, ctx.ty_bool) {
        return const_member_err(ctx, file, exprs, call_id, "const method result type mismatch", rr.sigs, rr.states);
      }
      return const_member_match(EvalConstExprResult {
        ok: true, err: TcError.None,
        kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: rr.sv.len() == 0, sv: "",
        sigs: rr.sigs, states: rr.states,
      });
    }

    if mname == "byte_at" {
      if args.len() != 1 {
        return const_member_err(ctx, file, exprs, call_id, "String.byte_at expects 1 arg", rr.sigs, rr.states);
      }
      let ar0: EvalConstExprResult = eval_const_expr_in_mod_locals(
        ctx, w, items, rr.sigs, rr.states, cur_mod, imps, exprs, file, args.get(0), ctx.ty_i32, locals,
      );
      if !ar0.ok { return const_member_match(ar0); }
      if ar0.kind != const_kind_int() {
        return const_member_err(ctx, file, exprs, call_id, "String.byte_at index must be int", ar0.sigs, ar0.states);
      }
      let n0: i64 = rr.sv.len() as i64;
      if ar0.iv < 0 || ar0.iv >= n0 {
        return const_member_err(ctx, file, exprs, call_id, "string index out of bounds", ar0.sigs, ar0.states);
      }
      let idx0: i32 = ar0.iv as i32;
      if !const_member_expect_ok(ctx, expected, ctx.ty_i32) {
        return const_member_err(ctx, file, exprs, call_id, "const method result type mismatch", ar0.sigs, ar0.states);
      }
      return const_member_match(EvalConstExprResult {
        ok: true, err: TcError.None,
        kind: const_kind_int(), ty: ctx.ty_i32, iv: rr.sv.byte_at(idx0) as i64, bv: false, sv: "",
        sigs: ar0.sigs, states: ar0.states,
      });
    }

    if mname == "slice" {
      if args.len() != 2 {
        return const_member_err(ctx, file, exprs, call_id, "String.slice expects 2 args", rr.sigs, rr.states);
      }
      let sr: EvalConstExprResult = eval_const_expr_in_mod_locals(
        ctx, w, items, rr.sigs, rr.states, cur_mod, imps, exprs, file, args.get(0), ctx.ty_i32, locals,
      );
      if !sr.ok { return const_member_match(sr); }
      let er: EvalConstExprResult = eval_const_expr_in_mod_locals(
        ctx, w, items, sr.sigs, sr.states, cur_mod, imps, exprs, file, args.get(1), ctx.ty_i32, locals,
      );
      if !er.ok { return const_member_match(er); }
      if sr.kind != const_kind_int() || er.kind != const_kind_int() {
        return const_member_err(ctx, file, exprs, call_id, "String.slice indices must be int", er.sigs, er.states);
      }
      let start: i64 = sr.iv;
      let end: i64 = er.iv;
      let n: i64 = rr.sv.len() as i64;
      if start < 0 || end < start || end > n {
        return const_member_err(ctx, file, exprs, call_id, "string slice out of bounds", er.sigs, er.states);
      }
      let start_i32: i32 = start as i32;
      let end_i32: i32 = end as i32;
      if !const_member_expect_ok(ctx, expected, ctx.ty_string) {
        return const_member_err(ctx, file, exprs, call_id, "const method result type mismatch", er.sigs, er.states);
      }
      return const_member_match(EvalConstExprResult {
        ok: true, err: TcError.None,
        kind: const_kind_str(), ty: ctx.ty_string, iv: 0, bv: false, sv: rr.sv.slice(start_i32, end_i32),
        sigs: er.sigs, states: er.states,
      });
    }

    if mname == "concat" {
      if args.len() != 1 {
        return const_member_err(ctx, file, exprs, call_id, "String.concat expects 1 arg", rr.sigs, rr.states);
      }
      let ar1: EvalConstExprResult = eval_const_expr_in_mod_locals(
        ctx, w, items, rr.sigs, rr.states, cur_mod, imps, exprs, file, args.get(0), ctx.ty_string, locals,
      );
      if !ar1.ok { return const_member_match(ar1); }
      if ar1.kind != const_kind_str() {
        return const_member_err(ctx, file, exprs, call_id, "String.concat arg must be string", ar1.sigs, ar1.states);
      }
      if !const_member_expect_ok(ctx, expected, ctx.ty_string) {
        return const_member_err(ctx, file, exprs, call_id, "const method result type mismatch", ar1.sigs, ar1.states);
      }
      return const_member_match(EvalConstExprResult {
        ok: true, err: TcError.None,
        kind: const_kind_str(), ty: ctx.ty_string, iv: 0, bv: false, sv: rr.sv.concat(ar1.sv),
        sigs: ar1.sigs, states: ar1.states,
      });
    }

    if mname == "escape_c" {
      if args.len() != 0 {
        return const_member_err(ctx, file, exprs, call_id, "String.escape_c expects 0 args", rr.sigs, rr.states);
      }
      if !const_member_expect_ok(ctx, expected, ctx.ty_string) {
        return const_member_err(ctx, file, exprs, call_id, "const method result type mismatch", rr.sigs, rr.states);
      }
      return const_member_match(EvalConstExprResult {
        ok: true, err: TcError.None,
        kind: const_kind_str(), ty: ctx.ty_string, iv: 0, bv: false, sv: rr.sv.escape_c(),
        sigs: rr.sigs, states: rr.states,
      });
    }

    if mname == "to_string" {
      if args.len() != 0 {
        return const_member_err(ctx, file, exprs, call_id, "String.to_string expects 0 args", rr.sigs, rr.states);
      }
      if !const_member_expect_ok(ctx, expected, ctx.ty_string) {
        return const_member_err(ctx, file, exprs, call_id, "const method result type mismatch", rr.sigs, rr.states);
      }
      return const_member_match(EvalConstExprResult {
        ok: true, err: TcError.None,
        kind: const_kind_str(), ty: ctx.ty_string, iv: 0, bv: false, sv: rr.sv,
        sigs: rr.sigs, states: rr.states,
      });
    }

    if mname == "starts_with" || mname == "ends_with" || mname == "contains" {
      if args.len() != 1 {
        return const_member_err(
          ctx, file, exprs, call_id, "String.".concat(mname).concat(" expects 1 arg"), rr.sigs, rr.states,
        );
      }
      let ar2: EvalConstExprResult = eval_const_expr_in_mod_locals(
        ctx, w, items, rr.sigs, rr.states, cur_mod, imps, exprs, file, args.get(0), ctx.ty_string, locals,
      );
      if !ar2.ok { return const_member_match(ar2); }
      if ar2.kind != const_kind_str() {
        return const_member_err(
          ctx, file, exprs, call_id, "String.".concat(mname).concat(" arg must be string"), ar2.sigs, ar2.states,
        );
      }
      if !const_member_expect_ok(ctx, expected, ctx.ty_bool) {
        return const_member_err(ctx, file, exprs, call_id, "const method result type mismatch", ar2.sigs, ar2.states);
      }
      let out: bool =
        if mname == "starts_with" {
          str_starts_with_text(rr.sv, ar2.sv)
        } else if mname == "ends_with" {
          str_ends_with_text(rr.sv, ar2.sv)
        } else {
          str_contains_text(rr.sv, ar2.sv)
        };
      return const_member_match(EvalConstExprResult {
        ok: true, err: TcError.None,
        kind: const_kind_bool(), ty: ctx.ty_bool, iv: 0, bv: out, sv: "",
        sigs: ar2.sigs, states: ar2.states,
      });
    }

    if mname == "index_of" || mname == "last_index_of" {
      if args.len() != 1 {
        return const_member_err(
          ctx, file, exprs, call_id, "String.".concat(mname).concat(" expects 1 arg"), rr.sigs, rr.states,
        );
      }
      let ar3: EvalConstExprResult = eval_const_expr_in_mod_locals(
        ctx, w, items, rr.sigs, rr.states, cur_mod, imps, exprs, file, args.get(0), ctx.ty_string, locals,
      );
      if !ar3.ok { return const_member_match(ar3); }
      if ar3.kind != const_kind_str() {
        return const_member_err(
          ctx, file, exprs, call_id, "String.".concat(mname).concat(" arg must be string"), ar3.sigs, ar3.states,
        );
      }
      if !const_member_expect_ok(ctx, expected, ctx.ty_i32) {
        return const_member_err(ctx, file, exprs, call_id, "const method result type mismatch", ar3.sigs, ar3.states);
      }
      let out: i32 =
        if mname == "index_of" {
          str_index_of_text(rr.sv, ar3.sv)
        } else {
          str_last_index_of_text(rr.sv, ar3.sv)
        };
      return const_member_match(EvalConstExprResult {
        ok: true, err: TcError.None,
        kind: const_kind_int(), ty: ctx.ty_i32, iv: out as i64, bv: false, sv: "",
        sigs: ar3.sigs, states: ar3.states,
      });
    }

    return const_member_err(ctx, file, exprs, call_id, "const method call not supported", rr.sigs, rr.states);
  }

  if rr.kind == const_kind_bool() {
    if mname != "to_string" {
      return const_member_err(ctx, file, exprs, call_id, "const method call not supported", rr.sigs, rr.states);
    }
    if args.len() != 0 {
      return const_member_err(ctx, file, exprs, call_id, "bool.to_string expects 0 args", rr.sigs, rr.states);
    }
    if !const_member_expect_ok(ctx, expected, ctx.ty_string) {
      return const_member_err(ctx, file, exprs, call_id, "const method result type mismatch", rr.sigs, rr.states);
    }
    return const_member_match(EvalConstExprResult {
      ok: true, err: TcError.None,
      kind: const_kind_str(), ty: ctx.ty_string, iv: 0, bv: false, sv: if rr.bv { "true" } else { "false" },
      sigs: rr.sigs, states: rr.states,
    });
  }

  if rr.kind == const_kind_int() {
    if mname != "to_string" {
      return const_member_err(ctx, file, exprs, call_id, "const method call not supported", rr.sigs, rr.states);
    }
    if args.len() != 0 {
      return const_member_err(ctx, file, exprs, call_id, "int.to_string expects 0 args", rr.sigs, rr.states);
    }
    if !const_member_expect_ok(ctx, expected, ctx.ty_string) {
      return const_member_err(ctx, file, exprs, call_id, "const method result type mismatch", rr.sigs, rr.states);
    }
    return const_member_match(EvalConstExprResult {
      ok: true, err: TcError.None,
      kind: const_kind_str(), ty: ctx.ty_string, iv: 0, bv: false, sv: const_int_to_string_text(ctx, rr.ty, rr.iv),
      sigs: rr.sigs, states: rr.states,
    });
  }

  if rr.kind == const_kind_float() {
    if mname != "to_string" {
      return const_member_err(ctx, file, exprs, call_id, "const method call not supported", rr.sigs, rr.states);
    }
    if args.len() != 0 {
      return const_member_err(ctx, file, exprs, call_id, "float.to_string expects 0 args", rr.sigs, rr.states);
    }
    if !const_member_expect_ok(ctx, expected, ctx.ty_string) {
      return const_member_err(ctx, file, exprs, call_id, "const method result type mismatch", rr.sigs, rr.states);
    }
    return const_member_match(EvalConstExprResult {
      ok: true, err: TcError.None,
      kind: const_kind_str(), ty: ctx.ty_string, iv: 0, bv: false, sv: const_float_to_string_text(rr.sv),
      sigs: rr.sigs, states: rr.states,
    });
  }

  return const_member_err(ctx, file, exprs, call_id, "const method call not supported", rr.sigs, rr.states);
}
