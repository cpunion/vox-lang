import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc

fn tc_src_generic_poll(src: String) -> tc.TcResult {
  let pr: p.ParseResult = p.parse_text(src);
  t.assert(pr.err == p.ParseError.None);

  let std_async_src: String = """
    pub enum Poll[T] { Pending, Ready(T) }
    pub struct Waker { pub token: i64 }
    pub struct Context { pub waker: Waker }
    pub trait Future { type Output; fn poll[Ctx](x: &mut Self, cx: Ctx) -> Poll[Self.Output]; }
  """;
  let pr_std: p.ParseResult = p.parse_text(std_async_src);
  t.assert(pr_std.err == p.ParseError.None);

  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "std/async", pr_std.prog);
  w = tc.world_add(w, "main", pr.prog);
  return tc.typecheck_world(w);
}

fn test_typecheck_async_fn_with_await_future_impl_generic_poll_smoke() -> () {
  let src: String = """
    import "std/async" as a
    struct C { n: i32 }
    impl a.Future for C {
      type Output = i32;
      fn poll[Ctx](x: &mut C, _cx: Ctx) -> a.Poll[i32] { return .Ready(x.n); }
    }
    async fn main() -> i32 {
      let c: C = C { n: 1 };
      let x: i32 = c.await;
      return x + 1;
    }
  """;
  let r: tc.TcResult = tc_src_generic_poll(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}
