import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc

fn effect_tc_add_mod(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn effect_tc_run_main(src: String) -> tc.TcResult {
  let mut w: tc.World = tc.world();
  w = effect_tc_add_mod(w, "main", src);
  return tc.typecheck_world(w);
}

fn test_typecheck_effect_missing_rejected() -> () {
  let src: String =
    "@effect(FsRead)\n"
    .concat("fn read() -> i32 { return 1; }\n")
    .concat("fn caller() -> i32 { return read(); }\n")
    .concat("fn main() -> i32 { return 0; }\n");
  let r: tc.TcResult = effect_tc_run_main(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "effect check failed"), msg);
  t.assert_with(contains(msg, "FsRead"), msg);
}

fn test_typecheck_effect_declared_ok() -> () {
  let src: String =
    "@effect(FsRead)\n"
    .concat("fn read() -> i32 { return 1; }\n")
    .concat("@effect(FsRead)\n")
    .concat("fn caller() -> i32 { return read(); }\n")
    .concat("@effect(FsRead)\n")
    .concat("fn main() -> i32 { return caller(); }\n");
  let r: tc.TcResult = effect_tc_run_main(src);
  t.assert(r.ok);
}

fn test_typecheck_effect_duplicate_rejected() -> () {
  let src: String =
    "@effect(FsRead)\n"
    .concat("@effect(FsRead)\n")
    .concat("fn read() -> i32 { return 1; }\n")
    .concat("fn main() -> i32 { return 0; }\n");
  let r: tc.TcResult = effect_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "duplicate effect on function"));
}

fn test_typecheck_effect_empty_rejected() -> () {
  let src: String = "@effect(\"\")\nfn read() -> i32 { return 1; }\nfn main() -> i32 { return 0; }\n";
  let pr: p.ParseResult = p.parse_text(src);
  if pr.err != p.ParseError.None {
    t.assert(contains(p.parse_error_to_string(pr.err), "bad effect attribute arguments"));
    return;
  }
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "main", pr.prog);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "effect name must not be empty"));
}
