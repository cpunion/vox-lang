import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc

fn tc_src(src: String) -> tc.TcResult {
  let pr: p.ParseResult = p.parse_text(src);
  t.assert(pr.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "main", pr.prog);
  return tc.typecheck_world(w);
}

fn test_typecheck_async_fn_without_await_smoke() -> () {
  let src: String = "async fn main() -> i32 { return 0; }";
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_with_await_poll_ready_smoke() -> () {
  let src: String = "enum Poll[T] { Pending, Ready(T) }\nasync fn main() -> i32 { let p: Poll[i32] = .Ready(1); let x: i32 = await p; return x + 1; }";
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_impl_method_without_await_smoke() -> () {
  let src: String = "struct S { x: i32 }\nimpl S { async fn f(x: S) -> i32 { return x.x + 1; } }\nfn main() -> i32 { let s: S = S { x: 0 }; return s.f(); }";
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_impl_method_with_await_poll_ready_smoke() -> () {
  let src: String = "enum Poll[T] { Pending, Ready(T) }\nstruct S { x: i32 }\nimpl S { async fn f(x: S) -> i32 { let p: Poll[i32] = .Ready(x.x); let y: i32 = await p; return y + 1; } }\nfn main() -> i32 { let s: S = S { x: 0 }; return s.f(); }";
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_await_expr_requires_async_fn_error() -> () {
  let src: String = "enum Poll[T] { Pending, Ready(T) }\nfn main() -> i32 { let p: Poll[i32] = .Ready(1); let x: i32 = await p; return x; }";
  let r: tc.TcResult = tc_src(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "await can only be used in async fn (D03)"));
}

fn test_typecheck_await_expr_requires_poll_operand_error() -> () {
  let src: String = "async fn main() -> i32 { let x: i32 = await 1; return x; }";
  let r: tc.TcResult = tc_src(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "`await` requires Poll-like enum { Pending, Ready(T) } in current D03 scaffold"));
}
