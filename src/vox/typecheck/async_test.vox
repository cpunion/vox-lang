import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc

fn tc_src(src: String) -> tc.TcResult {
  let pr: p.ParseResult = p.parse_text(src);
  t.assert(pr.err == p.ParseError.None);

  let std_async_src: String = """
    pub enum Poll[T] { Pending, Ready(T) }
    pub struct Waker { pub token: i64 }
    pub struct Context { pub waker: Waker }
    pub trait Future { type Output; fn poll(x: Self, cx: Context) -> Poll[Self.Output]; }
  """;
  let pr_std: p.ParseResult = p.parse_text(std_async_src);
  t.assert(pr_std.err == p.ParseError.None);

  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "std/async", pr_std.prog);
  w = tc.world_add(w, "main", pr.prog);
  return tc.typecheck_world(w);
}

fn test_typecheck_async_fn_without_await_smoke() -> () {
  let src: String = "async fn main() -> i32 { return 0; }";
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_with_await_poll_ready_smoke() -> () {
  let src: String = "enum Poll[T] { Pending, Ready(T) }\nasync fn main() -> i32 { let p: Poll[i32] = .Ready(1); let x: i32 = p.await; return x + 1; }";
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_with_await_future_impl_smoke() -> () {
  let src: String = """
    import "std/async" as a
    struct C { n: i32 }
    impl a.Future for C {
      type Output = i32;
      fn poll(x: C, _cx: a.Context) -> a.Poll[i32] { return .Ready(x.n); }
    }
    async fn main() -> i32 {
      let c: C = C { n: 1 };
      let x: i32 = c.await;
      return x + 1;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_impl_method_without_await_smoke() -> () {
  let src: String = "struct S { x: i32 }\nimpl S { async fn f(x: S) -> i32 { return x.x + 1; } }\nfn main() -> i32 { let s: S = S { x: 0 }; return s.f(); }";
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_impl_method_with_await_poll_ready_smoke() -> () {
  let src: String = "enum Poll[T] { Pending, Ready(T) }\nstruct S { x: i32 }\nimpl S { async fn f(x: S) -> i32 { let p: Poll[i32] = .Ready(x.x); let y: i32 = p.await; return y + 1; } }\nfn main() -> i32 { let s: S = S { x: 0 }; return s.f(); }";
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_await_expr_requires_async_fn_error() -> () {
  let src: String = "enum Poll[T] { Pending, Ready(T) }\nfn main() -> i32 { let p: Poll[i32] = .Ready(1); let x: i32 = p.await; return x; }";
  let r: tc.TcResult = tc_src(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "await can only be used in async fn (D03)"));
}

fn test_typecheck_await_expr_requires_poll_or_future_operand_error() -> () {
  let src: String = "async fn main() -> i32 { let x: i32 = await 1; return x; }";
  let r: tc.TcResult = tc_src(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "`await` requires Poll-like enum { Pending, Ready(T) } or std/async::Future impl (D03 scaffold)"));
}
