import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc
import "vox/macroexpand" as mx
import "vox/loader" as ld

fn tc_src(src: String) -> tc.TcResult {
  let pr: p.ParseResult = p.parse_text(src);
  t.assert(pr.err == p.ParseError.None);

  let std_async_src: String = """
    pub enum Poll[T] { Pending, Ready(T) }
    pub struct Waker { pub token: i64 }
    pub struct Context { pub waker: Waker }
    pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
  """;
  let pr_std: p.ParseResult = p.parse_text(std_async_src);
  t.assert(pr_std.err == p.ParseError.None);

  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "std/async", pr_std.prog);
  w = tc.world_add(w, "main", pr.prog);
  return tc.typecheck_world(w);
}

fn test_typecheck_async_fn_without_await_smoke() -> () {
  let src: String = "async fn main() -> i32 { return 0; }";
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_with_await_poll_ready_smoke() -> () {
  let src: String = "enum Poll[T] { Pending, Ready(T) }\nasync fn main() -> i32 { let p: Poll[i32] = .Ready(1); let x: i32 = p.await; return x + 1; }";
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_with_nested_await_smoke() -> () {
  let src: String = """
    enum Poll[T] { Pending, Ready(T) }
    async fn main() -> i32 {
      let pp: Poll[Poll[i32]] = .Ready(.Ready(7));
      let x: i32 = pp.await.await;
      return x;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_with_await_future_impl_smoke() -> () {
  let src: String = """
    import "std/async" as a
    struct C { n: i32 }
    impl a.Future for C {
      type Output = i32;
      fn poll(x: &mut C, _cx: &a.Context) -> a.Poll[i32] { return .Ready(x.n); }
    }
    async fn main() -> i32 {
      let c: C = C { n: 1 };
      let x: i32 = c.await;
      return x + 1;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_generic_fn_with_explicit_type_arg_is_supported() -> () {
  let src: String = """
    async fn id[T](x: T) -> T { return x; }
    async fn main() -> i32 {
      let x: i32 = id[i32](1).await;
      return x;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_generic_fn_with_inferred_type_arg_is_supported() -> () {
  let src: String = """
    async fn id[T](x: T) -> T { return x; }
    async fn main() -> i32 {
      let x: i32 = id(1).await;
      return x;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_trait_method_default_body_is_supported() -> () {
  let src: String = """
    trait AddOne { async fn add_one(x: Self, v: i32) -> i32 { return v + 1; } }
    struct S { n: i32 }
    impl AddOne for S {}

    async fn main() -> i32 {
      let s: S = S { n: 0 };
      let x: i32 = s.add_one(1).await;
      return x;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_allows_postfix_await_then_try_smoke() -> () {
  let src: String = """
    enum Result[T, E] { Ok(T), Err(E) }
    enum Poll[T] { Pending, Ready(T) }
    async fn main() -> Result[i32, i32] {
      let p: Poll[Result[i32, i32]] = .Ready(.Ok(1));
      let x: i32 = p.await?;
      return .Ok(x + 1);
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_allows_await_inside_try_block_smoke() -> () {
  let src: String = """
    import "std/async" as a
    enum Result[T, E] { Ok(T), Err(E) }
    async fn main() -> Result[i32, i32] {
      let r: Result[i32, i32] = try {
        let p: a.Poll[Result[i32, i32]] = .Ready(.Ok(1));
        let v: i32 = p.await?;
        v + 1
      };
      return r;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_allows_await_in_macro_arg_smoke() -> () {
  let src: String = """
    import "std/async" as a
    fn assert(cond: bool) -> () { if !cond { panic("bad"); } }
    async fn main() -> i32 {
      let p: a.Poll[i32] = .Ready(1);
      assert!(p.await == 1);
      return 0;
    }
  """;
  let pr: p.ParseResult = p.parse_text(src);
  t.assert(pr.err == p.ParseError.None);

  let std_async_src: String = """
    pub enum Poll[T] { Pending, Ready(T) }
    pub struct Waker { pub token: i64 }
    pub struct Context { pub waker: Waker }
    pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
  """;
  let pr_std: p.ParseResult = p.parse_text(std_async_src);
  t.assert(pr_std.err == p.ParseError.None);

  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "std/async", pr_std.prog);
  w = tc.world_add(w, "main", pr.prog);
  let xr: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(xr.ok, tc.tc_error_to_string(xr.err));
  let r: tc.TcResult = tc.typecheck_world(xr.world);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_allows_await_in_nested_if_expr_smoke() -> () {
  let src: String = """
    import "std/async" as a
    async fn main() -> i32 {
      let p: a.Poll[i32] = .Ready(1);
      let x: i32 = 10 + (if true { p.await } else { 0 });
      return x;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_allows_await_in_nested_match_expr_smoke() -> () {
  let src: String = """
    import "std/async" as a
    async fn main() -> i32 {
      let p: a.Poll[i32] = .Ready(1);
      let x: i32 = 20 + (match p {
        a.Poll.Ready(v) => {
          let q: a.Poll[i32] = a.Poll.Ready(v + 1);
          q.await
        },
        a.Poll.Pending => 0,
      });
      return x;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_allows_multiple_await_linear_smoke() -> () {
  let src: String = """
    enum Poll[T] { Pending, Ready(T) }
    async fn main() -> i32 {
      let p0: Poll[i32] = .Ready(1);
      let x: i32 = p0.await;
      let p1: Poll[i32] = .Ready(x + 1);
      let y: i32 = p1.await;
      return y + 1;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_allows_let_shadowing_across_await_smoke() -> () {
  let src: String = """
    import "std/async" as a
    async fn main() -> i32 {
      let x: i32 = 1;
      let p0: a.Poll[i32] = .Ready(x);
      let y: i32 = p0.await;
      if true {
        let x: i32 = y + 1;
        let p1: a.Poll[i32] = .Ready(x);
        let z: i32 = p1.await;
        return z;
      }
      return x + y;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_captures_immutable_local_across_await_smoke() -> () {
  let src: String = """
    enum Poll[T] { Pending, Ready(T) }
    async fn main() -> i32 {
      let x: i32 = 3;
      let p0: Poll[i32] = .Ready(x);
      let y: i32 = p0.await;
      let p1: Poll[i32] = .Ready(x + 1);
      let z: i32 = p1.await;
      return y + z;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_allows_mut_local_across_await_smoke() -> () {
  let src: String = """
    enum Poll[T] { Pending, Ready(T) }
    async fn main() -> i32 {
      let mut x: i32 = 1;
      let p0: Poll[i32] = .Ready(0);
      let _y: i32 = p0.await;
      let z: i32 = x;
      return z;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_allows_static_ref_across_await_smoke() -> () {
  let src: String = """
    enum Poll[T] { Pending, Ready(T) }
    async fn main() -> i32 {
      let s: &'static str = "hello";
      let p0: Poll[i32] = .Ready(0);
      let _y: i32 = p0.await;
      return s.len();
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_rejects_nonstatic_ref_local_across_await_error() -> () {
  let src: String = """
    enum Poll[T] { Pending, Ready(T) }
    fn use_ref(_x: &i32) -> i32 { return 0; }
    async fn main() -> i32 {
      let x: i32 = 1;
      let r: &i32 = x;
      let p0: Poll[i32] = .Ready(0);
      let _y: i32 = p0.await;
      return use_ref(r);
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "borrowed local cannot live across await"));
}

fn test_typecheck_async_fn_rejects_await_operand_with_nonstatic_borrow_error() -> () {
  let src: String = """
    enum Poll[T] { Pending, Ready(T) }
    async fn main() -> i32 {
      let x: i32 = 1;
      let p0: Poll[&i32] = .Ready(x);
      let _r: &i32 = p0.await;
      return 0;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "await operand cannot contain non-static borrow"));
}

fn test_typecheck_async_fn_allows_postfix_await_then_try_smoke_after_macroexpand() -> () {
  let src: String = """
    enum Result[T, E] { Ok(T), Err(E) }
    enum Poll[T] { Pending, Ready(T) }
    async fn main() -> Result[i32, i32] {
      let p: Poll[Result[i32, i32]] = .Ready(.Ok(1));
      let x: i32 = p.await?;
      return .Ok(x + 1);
    }
  """;
  let pr: p.ParseResult = p.parse_text(src);
  t.assert(pr.err == p.ParseError.None);

  let std_async_src: String = """
    pub enum Poll[T] { Pending, Ready(T) }
    pub struct Waker { pub token: i64 }
    pub struct Context { pub waker: Waker }
    pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
  """;
  let pr_std: p.ParseResult = p.parse_text(std_async_src);
  t.assert(pr_std.err == p.ParseError.None);

  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "std/async", pr_std.prog);
  w = tc.world_add(w, "main", pr.prog);
  let xr: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(xr.ok, tc.tc_error_to_string(xr.err));
  let r: tc.TcResult = tc.typecheck_world(xr.world);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_fn_allows_postfix_await_then_try_smoke_via_loader_pipeline() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/async/async.vox",
    text: """
      pub enum Poll[T] { Pending, Ready(T) }
      pub struct Waker { pub token: i64 }
      pub struct Context { pub waker: Waker }
      pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Result[T, E] { Ok(T), Err(E) }
      enum Poll[T] { Pending, Ready(T) }
      async fn main() -> Result[i32, i32] {
        let p: Poll[Result[i32, i32]] = .Ready(.Ok(1));
        let x: i32 = p.await?;
        return .Ok(x + 1);
      }
    """,
  });
  let lr: ld.LoadWorldResult = ld.world_from_files(fs);
  t.assert_with(lr.ok, lr.err);
  let xr: mx.ExpandResult = mx.expand_world(lr.world, mx.default_config());
  t.assert_with(xr.ok, tc.tc_error_to_string(xr.err));
  let r: tc.TcResult = tc.typecheck_world(xr.world);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_impl_method_without_await_smoke() -> () {
  let src: String = """
    struct S { x: i32 }
    impl S { async fn f(x: S) -> i32 { return x.x + 1; } }
    async fn main() -> i32 {
      let s: S = S { x: 0 };
      return s.f().await;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_impl_method_with_await_poll_ready_smoke() -> () {
  let src: String = """
    enum Poll[T] { Pending, Ready(T) }
    struct S { x: i32 }
    impl S {
      async fn f(x: S) -> i32 {
        let p: Poll[i32] = .Ready(x.x);
        let y: i32 = p.await;
        return y + 1;
      }
    }
    async fn main() -> i32 {
      let s: S = S { x: 0 };
      return s.f().await;
    }
  """;
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_await_expr_requires_async_fn_error() -> () {
  let src: String = "enum Poll[T] { Pending, Ready(T) }\nfn main() -> i32 { let p: Poll[i32] = .Ready(1); let x: i32 = p.await; return x; }";
  let r: tc.TcResult = tc_src(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "await can only be used in async fn"));
}

fn test_typecheck_await_expr_requires_poll_or_future_operand_error() -> () {
  let src: String = "async fn main() -> i32 { let x: i32 = await 1; return x; }";
  let r: tc.TcResult = tc_src(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "`await` requires Poll-like enum { Pending, Ready(T) } or std/async::Future impl"));
}
