import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc

fn tc_src(src: String) -> tc.TcResult {
  let pr: p.ParseResult = p.parse_text(src);
  t.assert(pr.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "main", pr.prog);
  return tc.typecheck_world(w);
}

fn test_typecheck_async_fn_without_await_smoke() -> () {
  let src: String = "async fn main() -> i32 { return 0; }";
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_async_impl_method_without_await_smoke() -> () {
  let src: String = "struct S { x: i32 }\nimpl S { async fn f(x: S) -> i32 { return x.x + 1; } }\nfn main() -> i32 { let s: S = S { x: 0 }; return s.f(); }";
  let r: tc.TcResult = tc_src(src);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
}

fn test_typecheck_await_expr_is_deferred_error() -> () {
  let src: String = "fn main() -> i32 { let x: i32 = await 1; return x; }";
  let r: tc.TcResult = tc_src(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "await expression is deferred (D03)"));
}
