import "vox/ast" as ast

// Async await scanning helpers (D03).
// This is intentionally conservative: it only supports top-level await in
// let/expr/return statements, and rejects await under complex expressions.

struct TopAwaitResult { ok: bool, err: String, found: bool, await_expr: i32, operand_expr: i32 }

fn stmt_span(st: ast.Stmt) -> ast.Span {
  return match st {
    ast.Stmt.Let(sp, _m, _n, _ha, _ann, _e) => sp,
    ast.Stmt.Assign(sp, _n, _e) => sp,
    ast.Stmt.AssignField(sp, _r, _f, _e) => sp,
    ast.Stmt.ExprStmt(sp, _e) => sp,
    ast.Stmt.IfStmt(sp, _c, _t, _h, _e) => sp,
    ast.Stmt.WhileStmt(sp, _c, _b) => sp,
    ast.Stmt.Break(sp) => sp,
    ast.Stmt.Continue(sp) => sp,
    ast.Stmt.ReturnStmt(sp, _h, _e) => sp,
  };
}

fn expr_contains_await(exprs: ast.ExprPool, eid: i32) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);
  if match n { ast.ExprNode.Await(_x) => true, _ => false } { return true; }
  if match n { ast.ExprNode.Try(x) => true, _ => false } {
    let x: i32 = match n { ast.ExprNode.Try(y) => y, _ => -1 };
    return expr_contains_await(exprs, x);
  }
  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Unary(_op, x) => x, _ => -1 };
    return expr_contains_await(exprs, a);
  }
  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(x, _tn) => x, _ => -1 };
    return expr_contains_await(exprs, a);
  }
  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let l: i32 = match n { ast.ExprNode.Binary(_op, x, _r) => x, _ => -1 };
    let r: i32 = match n { ast.ExprNode.Binary(_op, _l, x) => x, _ => -1 };
    return expr_contains_await(exprs, l) || expr_contains_await(exprs, r);
  }
  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } {
    let c: i32 = match n { ast.ExprNode.If(x, _t, _e) => x, _ => -1 };
    let t: i32 = match n { ast.ExprNode.If(_c, x, _e) => x, _ => -1 };
    let e: i32 = match n { ast.ExprNode.If(_c, _t, x) => x, _ => -1 };
    return expr_contains_await(exprs, c) || expr_contains_await(exprs, t) || expr_contains_await(exprs, e);
  }
  if match n { ast.ExprNode.Member(_r, _f) => true, _ => false } {
    let r: i32 = match n { ast.ExprNode.Member(x, _f) => x, _ => -1 };
    return expr_contains_await(exprs, r);
  }
  if match n { ast.ExprNode.Call(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(x, _t, _a) => x, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _t, x) => x, _ => Vec() };
    if expr_contains_await(exprs, callee) { return true; }
    let mut i: i32 = 0;
    while i < args.len() {
      if expr_contains_await(exprs, args.get(i)) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.StructLit(_t, _fs) => true, _ => false } {
    let fs: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_t, x) => x, _ => Vec() };
    let mut i: i32 = 0;
    while i < fs.len() {
      if expr_contains_await(exprs, fs.get(i).expr) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.Block(_b) => true, _ => false } {
    let b: ast.ExprBlock = match n { ast.ExprNode.Block(x) => x, _ => ast.ExprBlock { stmts: Vec(), has_tail: false, tail: -1 } };
    let mut i: i32 = 0;
    while i < b.stmts.len() {
      if stmt_contains_await(exprs, b.stmts.get(i)) { return true; }
      i = i + 1;
    }
    if b.has_tail && b.tail != -1 { return expr_contains_await(exprs, b.tail); }
    return false;
  }
  if match n { ast.ExprNode.Match(_s, _as) => true, _ => false } {
    let scrut: i32 = match n { ast.ExprNode.Match(x, _as) => x, _ => -1 };
    let arms: Vec[ast.MatchArm] = match n { ast.ExprNode.Match(_s, x) => x, _ => Vec() };
    if expr_contains_await(exprs, scrut) { return true; }
    let mut i: i32 = 0;
    while i < arms.len() {
      if expr_contains_await(exprs, arms.get(i).expr) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.TryBlock(_bid) => true, _ => false } {
    let bid: i32 = match n { ast.ExprNode.TryBlock(x) => x, _ => -1 };
    if bid == -1 { return false; }
    return expr_contains_await(exprs, bid);
  }
  return false;
}

fn stmt_contains_await(exprs: ast.ExprPool, st: ast.Stmt) -> bool {
  return match st {
    ast.Stmt.Let(_sp, _m, _n, _ha, _ann, e) => expr_contains_await(exprs, e),
    ast.Stmt.Assign(_sp, _n, e) => expr_contains_await(exprs, e),
    ast.Stmt.AssignField(_sp, _r, _f, e) => expr_contains_await(exprs, e),
    ast.Stmt.ExprStmt(_sp, e) => expr_contains_await(exprs, e),
    ast.Stmt.IfStmt(_sp, c, t, has, e) => {
      if expr_contains_await(exprs, c) { true } else {
        let mut i: i32 = 0;
        while i < t.stmts.len() {
          if stmt_contains_await(exprs, t.stmts.get(i)) { return true; }
          i = i + 1;
        }
        if has {
          i = 0;
          while i < e.stmts.len() {
            if stmt_contains_await(exprs, e.stmts.get(i)) { return true; }
            i = i + 1;
          }
        }
        false
      }
    },
    ast.Stmt.WhileStmt(_sp, c, b) => {
      if expr_contains_await(exprs, c) { true } else {
        let mut i: i32 = 0;
        while i < b.stmts.len() {
          if stmt_contains_await(exprs, b.stmts.get(i)) { return true; }
          i = i + 1;
        }
        false
      }
    },
    ast.Stmt.ReturnStmt(_sp, has, e) => if has { expr_contains_await(exprs, e) } else { false },
    _ => false,
  };
}

fn expr_top_level_await(exprs: ast.ExprPool, eid: i32) -> TopAwaitResult {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);
  if match n { ast.ExprNode.Await(_x) => true, _ => false } {
    let op: i32 = match n { ast.ExprNode.Await(x) => x, _ => -1 };
    if expr_contains_await(exprs, op) {
      return TopAwaitResult { ok: false, err: "await operand contains await (deferred D03)", found: false, await_expr: -1, operand_expr: -1 };
    }
    return TopAwaitResult { ok: true, err: "", found: true, await_expr: eid, operand_expr: op };
  }
  if match n { ast.ExprNode.Try(_x) => true, _ => false } {
    let x: i32 = match n { ast.ExprNode.Try(y) => y, _ => -1 };
    let nx: ast.ExprNode = ast.expr_pool_get(exprs, x);
    if match nx { ast.ExprNode.Await(_y) => true, _ => false } {
      let op2: i32 = match nx { ast.ExprNode.Await(y) => y, _ => -1 };
      if expr_contains_await(exprs, op2) {
        return TopAwaitResult { ok: false, err: "await operand contains await (deferred D03)", found: false, await_expr: -1, operand_expr: -1 };
      }
      return TopAwaitResult { ok: true, err: "", found: true, await_expr: x, operand_expr: op2 };
    }
    if expr_contains_await(exprs, x) {
      return TopAwaitResult { ok: false, err: "await in complex try expression is deferred (D03)", found: false, await_expr: -1, operand_expr: -1 };
    }
    return TopAwaitResult { ok: true, err: "", found: false, await_expr: -1, operand_expr: -1 };
  }
  if expr_contains_await(exprs, eid) {
    return TopAwaitResult { ok: false, err: "await in complex expression is deferred (D03)", found: false, await_expr: -1, operand_expr: -1 };
  }
  return TopAwaitResult { ok: true, err: "", found: false, await_expr: -1, operand_expr: -1 };
}

fn stmt_top_level_await(exprs: ast.ExprPool, st: ast.Stmt) -> TopAwaitResult {
  return match st {
    ast.Stmt.Let(_sp, _m, _n, _ha, _ann, e) => expr_top_level_await(exprs, e),
    ast.Stmt.ExprStmt(_sp, e) => expr_top_level_await(exprs, e),
    ast.Stmt.ReturnStmt(_sp, has, e) => if has { expr_top_level_await(exprs, e) } else { TopAwaitResult { ok: true, err: "", found: false, await_expr: -1, operand_expr: -1 } },
    _ => {
      if stmt_contains_await(exprs, st) {
        TopAwaitResult { ok: false, err: "await is only supported in let/expr/return statements (D03)", found: false, await_expr: -1, operand_expr: -1 }
      } else {
        TopAwaitResult { ok: true, err: "", found: false, await_expr: -1, operand_expr: -1 }
      }
    }
  };
}

fn expr_uses_name(exprs: ast.ExprPool, eid: i32, name: String) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);
  if match n { ast.ExprNode.Ident(_x) => true, _ => false } {
    let s: String = match n { ast.ExprNode.Ident(x) => x, _ => "" };
    return s == name;
  }
  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Unary(_op, x) => x, _ => -1 };
    return expr_uses_name(exprs, a, name);
  }
  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(x, _tn) => x, _ => -1 };
    return expr_uses_name(exprs, a, name);
  }
  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let l: i32 = match n { ast.ExprNode.Binary(_op, x, _r) => x, _ => -1 };
    let r: i32 = match n { ast.ExprNode.Binary(_op, _l, x) => x, _ => -1 };
    return expr_uses_name(exprs, l, name) || expr_uses_name(exprs, r, name);
  }
  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } {
    let c: i32 = match n { ast.ExprNode.If(x, _t, _e) => x, _ => -1 };
    let t: i32 = match n { ast.ExprNode.If(_c, x, _e) => x, _ => -1 };
    let e: i32 = match n { ast.ExprNode.If(_c, _t, x) => x, _ => -1 };
    return expr_uses_name(exprs, c, name) || expr_uses_name(exprs, t, name) || expr_uses_name(exprs, e, name);
  }
  if match n { ast.ExprNode.Member(_r, _f) => true, _ => false } {
    let r: i32 = match n { ast.ExprNode.Member(x, _f) => x, _ => -1 };
    return expr_uses_name(exprs, r, name);
  }
  if match n { ast.ExprNode.Call(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(x, _t, _a) => x, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _t, x) => x, _ => Vec() };
    if expr_uses_name(exprs, callee, name) { return true; }
    let mut i: i32 = 0;
    while i < args.len() {
      if expr_uses_name(exprs, args.get(i), name) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.Block(_b) => true, _ => false } {
    let b: ast.ExprBlock = match n { ast.ExprNode.Block(x) => x, _ => ast.ExprBlock { stmts: Vec(), has_tail: false, tail: -1 } };
    let mut i: i32 = 0;
    while i < b.stmts.len() {
      if stmt_uses_name(exprs, b.stmts.get(i), name) { return true; }
      i = i + 1;
    }
    if b.has_tail && b.tail != -1 { return expr_uses_name(exprs, b.tail, name); }
    return false;
  }
  if match n { ast.ExprNode.Try(x) => true, _ => false } {
    let x: i32 = match n { ast.ExprNode.Try(y) => y, _ => -1 };
    return expr_uses_name(exprs, x, name);
  }
  if match n { ast.ExprNode.Await(x) => true, _ => false } {
    let x: i32 = match n { ast.ExprNode.Await(y) => y, _ => -1 };
    return expr_uses_name(exprs, x, name);
  }
  if match n { ast.ExprNode.StructLit(_t, _fs) => true, _ => false } {
    let fs: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_t, x) => x, _ => Vec() };
    let mut i: i32 = 0;
    while i < fs.len() {
      if expr_uses_name(exprs, fs.get(i).expr, name) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.Match(_s, _as) => true, _ => false } {
    let scrut: i32 = match n { ast.ExprNode.Match(x, _as) => x, _ => -1 };
    let arms: Vec[ast.MatchArm] = match n { ast.ExprNode.Match(_s, x) => x, _ => Vec() };
    if expr_uses_name(exprs, scrut, name) { return true; }
    let mut i: i32 = 0;
    while i < arms.len() {
      if expr_uses_name(exprs, arms.get(i).expr, name) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.TryBlock(_bid) => true, _ => false } {
    let bid: i32 = match n { ast.ExprNode.TryBlock(x) => x, _ => -1 };
    if bid == -1 { return false; }
    return expr_uses_name(exprs, bid, name);
  }
  return false;
}

fn stmt_uses_name(exprs: ast.ExprPool, st: ast.Stmt, name: String) -> bool {
  return match st {
    ast.Stmt.Let(_sp, _m, _n, _ha, _ann, e) => expr_uses_name(exprs, e, name),
    ast.Stmt.Assign(_sp, _n, e) => expr_uses_name(exprs, e, name),
    ast.Stmt.AssignField(_sp, _r, _f, e) => expr_uses_name(exprs, e, name),
    ast.Stmt.ExprStmt(_sp, e) => expr_uses_name(exprs, e, name),
    ast.Stmt.IfStmt(_sp, c, t, has, e) => {
      if expr_uses_name(exprs, c, name) { true } else {
        let mut i: i32 = 0;
        while i < t.stmts.len() {
          if stmt_uses_name(exprs, t.stmts.get(i), name) { return true; }
          i = i + 1;
        }
        if has {
          i = 0;
          while i < e.stmts.len() {
            if stmt_uses_name(exprs, e.stmts.get(i), name) { return true; }
            i = i + 1;
          }
        }
        false
      }
    },
    ast.Stmt.WhileStmt(_sp, c, b) => {
      if expr_uses_name(exprs, c, name) { true } else {
        let mut i: i32 = 0;
        while i < b.stmts.len() {
          if stmt_uses_name(exprs, b.stmts.get(i), name) { return true; }
          i = i + 1;
        }
        false
      }
    },
    ast.Stmt.ReturnStmt(_sp, has, e) => if has { expr_uses_name(exprs, e, name) } else { false },
    _ => false,
  };
}

