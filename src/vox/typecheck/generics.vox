import "vox/ast" as ast
import "vox/ir" as ir

pub struct TySub { pub name: String, pub ty: i32 }

pub struct ConstSub { pub name: String, pub ty: i32, pub iv: i64, pub text: String }

pub struct ConstWhereCheckResult { pub ok: bool, pub err: String }

pub struct UnifyResult { pub ok: bool, pub subs: Vec[TySub] }

pub struct ParseConstGenericArgResult { pub ok: bool, pub iv: i64, pub text: String }

pub struct ParseConstGenericArgWithLocalsResult { pub ok: bool, pub unresolved: bool, pub iv: i64, pub text: String }

pub fn is_const_generic_arg_tn(tn: ast.TypeName) -> bool {
  return tn.parts.len() == 2 && tn.parts.get(0) == "@const" && tn.args.len() == 0;
}

fn is_bare_ident_tn(tn: ast.TypeName) -> bool {
  return tn.parts.len() == 1 && tn.args.len() == 0;
}

pub fn is_const_generic_arg_tn_or_local(l0: Locals, tn: ast.TypeName) -> bool {
  if is_const_generic_arg_tn(tn) { return true; }
  if !is_bare_ident_tn(tn) { return false; }
  let lr: LookupConstResult = locals_lookup_const(l0, tn.parts.get(0));
  return lr.found;
}

pub fn const_generic_arg_text(tn: ast.TypeName) -> String {
  if !is_const_generic_arg_tn(tn) { return ""; }
  return tn.parts.get(1);
}

fn is_unsigned_int_kind_gen(k: ir.TyKind) -> bool {
  return match k {
    ir.TyKind.U8 => true,
    ir.TyKind.U16 => true,
    ir.TyKind.U32 => true,
    ir.TyKind.U64 => true,
    ir.TyKind.USize => true,
    _ => false,
  };
}

fn const_i64_in_range_for_kind(iv: i64, k: ir.TyKind) -> bool {
  if k == ir.TyKind.I8 { return iv >= -128 && iv <= 127; }
  if k == ir.TyKind.U8 { return iv >= 0 && iv <= 255; }
  if k == ir.TyKind.I16 { return iv >= -32768 && iv <= 32767; }
  if k == ir.TyKind.U16 { return iv >= 0 && iv <= 65535; }
  if k == ir.TyKind.I32 { return iv >= -2147483648 && iv <= 2147483647; }
  if k == ir.TyKind.U32 { return iv >= 0 && iv <= 4294967295; }
  if k == ir.TyKind.I64 { return true; }
  if k == ir.TyKind.ISize { return true; }
  if k == ir.TyKind.U64 { return true; }
  if k == ir.TyKind.USize { return true; }
  return false;
}

pub fn parse_const_generic_arg(ctx: Ctx, tn: ast.TypeName, want_ty: i32) -> ParseConstGenericArgResult {
  let text: String = const_generic_arg_text(tn);
  if text == "" { return ParseConstGenericArgResult { ok: false, iv: 0, text: "" }; }
  let bty: i32 = strip_range(ctx, want_ty);
  let bt: ir.Ty = ir.ty_pool_get(ctx.pool, bty);
  let kind: ir.TyKind = bt.kind;
  if !is_int_like_ty(ctx, bty) { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }

  if is_unsigned_int_kind_gen(kind) {
    if text.len() > 0 && text.byte_at(0) == 45 { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
    let pu: ParseU64DecResult = parse_u64_dec(text);
    if !pu.ok { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
    if !const_i64_in_range_for_kind(pu.val, kind) { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
    return ParseConstGenericArgResult { ok: true, iv: pu.val, text: text };
  }

  let ps: ParseI64DecResult = parse_i64_dec(text);
  if !ps.ok { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
  if !const_i64_in_range_for_kind(ps.val, kind) { return ParseConstGenericArgResult { ok: false, iv: 0, text: text }; }
  return ParseConstGenericArgResult { ok: true, iv: ps.val, text: text };
}

pub fn parse_const_generic_arg_with_locals(
  ctx: Ctx,
  l0: Locals,
  tn: ast.TypeName,
  want_ty: i32,
) -> ParseConstGenericArgWithLocalsResult {
  let pr: ParseConstGenericArgResult = parse_const_generic_arg(ctx, tn, want_ty);
  if pr.ok {
    return ParseConstGenericArgWithLocalsResult { ok: true, unresolved: false, iv: pr.iv, text: pr.text };
  }

  if !is_bare_ident_tn(tn) {
    return ParseConstGenericArgWithLocalsResult { ok: false, unresolved: false, iv: 0, text: "" };
  }
  let name: String = tn.parts.get(0);
  let lr: LookupConstResult = locals_lookup_const(l0, name);
  if !lr.found {
    return ParseConstGenericArgWithLocalsResult { ok: false, unresolved: false, iv: 0, text: name };
  }
  let bty: i32 = strip_range(ctx, want_ty);
  if !is_int_like_ty(ctx, bty) {
    return ParseConstGenericArgWithLocalsResult { ok: false, unresolved: false, iv: 0, text: name };
  }
  if !assignable_to(ctx, want_ty, lr.ty) {
    return ParseConstGenericArgWithLocalsResult { ok: false, unresolved: false, iv: 0, text: name };
  }
  if !lr.has_val {
    return ParseConstGenericArgWithLocalsResult { ok: true, unresolved: true, iv: 0, text: name };
  }
  let kind: ir.TyKind = ir.ty_pool_get(ctx.pool, bty).kind;
  if !const_i64_in_range_for_kind(lr.iv, kind) {
    return ParseConstGenericArgWithLocalsResult { ok: false, unresolved: false, iv: 0, text: name };
  }
  return ParseConstGenericArgWithLocalsResult { ok: true, unresolved: false, iv: lr.iv, text: lr.iv.to_string() };
}

fn subs_lookup(subs: Vec[TySub], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < subs.len() {
    let s: TySub = subs.get(i);
    if s.name == name { return s.ty; }
    i = i + 1;
  }
  return -1;
}

fn subs_add(subs0: Vec[TySub], name: String, ty: i32) -> Vec[TySub] {
  let mut subs: Vec[TySub] = subs0;
  subs.push(TySub { name: name, ty: ty });
  return subs;
}

fn is_param_ty(t: ir.Ty) -> bool { return match t.kind { ir.TyKind.Param => true, _ => false }; }

fn is_vec_ty2(t: ir.Ty) -> bool { return match t.kind { ir.TyKind.Vec => true, _ => false }; }

fn is_atomic_ty2(t: ir.Ty) -> bool { return match t.kind { ir.TyKind.Atomic => true, _ => false }; }

fn is_struct_ty2(t: ir.Ty) -> bool { return match t.kind { ir.TyKind.Struct => true, _ => false }; }

fn is_enum_ty2(t: ir.Ty) -> bool { return match t.kind { ir.TyKind.Enum => true, _ => false }; }

fn find_nominal_ty_idx_subst(ctx: Ctx, kind: ir.TyKind, mod_path: String, name: String) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    let kind_ok: bool =
      match kind {
        ir.TyKind.Struct => t.kind == ir.TyKind.Struct,
        ir.TyKind.Enum => t.kind == ir.TyKind.Enum,
        _ => false,
      };
    if kind_ok && t.mod_path == mod_path && t.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn subst_struct_nominal_ty(ctx: Ctx, ty_idx: i32, subs: Vec[TySub]) -> i32 {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  let fs: FindStructResult = find_struct(ctx, t.mod_path, t.name);
  if !fs.found { return ty_idx; }

  let mut changed: bool = false;
  let mut want_tys: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < fs.sig.fields.len() {
    let f: StructFieldSig = fs.sig.fields.get(i);
    let st: i32 = subst_ty(ctx, f.ty, subs);
    if st == ctx.ty_bad { return ctx.ty_bad; }
    if st != f.ty { changed = true; }
    want_tys.push(st);
    i = i + 1;
  }
  if !changed { return ty_idx; }

  let mut si: i32 = 0;
  while si < ctx.structs.len() {
    let s: StructSig = ctx.structs.get(si);
    if s.mod_path == fs.sig.mod_path && s.base_name == fs.sig.base_name && s.fields.len() == fs.sig.fields.len() {
      let mut ok: bool = true;
      let mut fi: i32 = 0;
      while fi < s.fields.len() {
        let sf: StructFieldSig = s.fields.get(fi);
        let pf: StructFieldSig = fs.sig.fields.get(fi);
        if sf.name != pf.name || sf.ty != want_tys.get(fi) {
          ok = false;
          fi = s.fields.len();
        } else {
          fi = fi + 1;
        }
      }
      if ok {
        let idx: i32 = find_nominal_ty_idx_subst(ctx, ir.TyKind.Struct, s.mod_path, s.name);
        if idx != -1 { return idx; }
      }
    }
    si = si + 1;
  }
  // Partial substitution is expected during inference (for example when only
  // one generic parameter is constrained by expected return type). Keep the
  // original nominal generic and defer until remaining params are resolved.
  let mut wi: i32 = 0;
  while wi < want_tys.len() {
    if ty_has_param(ctx, want_tys.get(wi)) { return ty_idx; }
    wi = wi + 1;
  }
  return ctx.ty_bad;
}

fn subst_enum_nominal_ty(ctx: Ctx, ty_idx: i32, subs: Vec[TySub]) -> i32 {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  let fe: FindEnumResult = find_enum(ctx, t.mod_path, t.name);
  if !fe.found { return ty_idx; }

  let mut changed: bool = false;
  let mut want_vars: Vec[EnumVariantSig] = Vec();
  let mut vi: i32 = 0;
  while vi < fe.sig.vars.len() {
    let v: EnumVariantSig = fe.sig.vars.get(vi);
    let mut ftys: Vec[i32] = Vec();
    let mut fi: i32 = 0;
    while fi < v.fields.len() {
      let st: i32 = subst_ty(ctx, v.fields.get(fi), subs);
      if st == ctx.ty_bad { return ctx.ty_bad; }
      if st != v.fields.get(fi) { changed = true; }
      ftys.push(st);
      fi = fi + 1;
    }
    want_vars.push(EnumVariantSig { name: v.name, fields: ftys });
    vi = vi + 1;
  }
  if !changed { return ty_idx; }

  let mut ei: i32 = 0;
  while ei < ctx.enums.len() {
    let e: EnumSig = ctx.enums.get(ei);
    if e.mod_path == fe.sig.mod_path && e.base_name == fe.sig.base_name && e.vars.len() == fe.sig.vars.len() {
      let mut ok: bool = true;
      let mut i2: i32 = 0;
      while i2 < e.vars.len() {
        let ev: EnumVariantSig = e.vars.get(i2);
        let wv: EnumVariantSig = want_vars.get(i2);
        if ev.name != wv.name || ev.fields.len() != wv.fields.len() {
          ok = false;
          i2 = e.vars.len();
        } else {
          let mut j: i32 = 0;
          while j < ev.fields.len() {
            if ev.fields.get(j) != wv.fields.get(j) {
              ok = false;
              j = ev.fields.len();
            } else {
              j = j + 1;
            }
          }
          i2 = i2 + 1;
        }
      }
      if ok {
        let idx: i32 = find_nominal_ty_idx_subst(ctx, ir.TyKind.Enum, e.mod_path, e.name);
        if idx != -1 { return idx; }
      }
    }
    ei = ei + 1;
  }
  // Same defer rule for enums with partially substituted variant fields.
  let mut vi2: i32 = 0;
  while vi2 < want_vars.len() {
    let wv2: EnumVariantSig = want_vars.get(vi2);
    let mut fi2: i32 = 0;
    while fi2 < wv2.fields.len() {
      if ty_has_param(ctx, wv2.fields.get(fi2)) { return ty_idx; }
      fi2 = fi2 + 1;
    }
    vi2 = vi2 + 1;
  }
  return ctx.ty_bad;
}

pub fn ty_has_param(ctx: Ctx, ty_idx: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  if t.kind == ir.TyKind.Param { return true; }
  if t.kind == ir.TyKind.Vec || t.kind == ir.TyKind.Atomic { return ty_has_param(ctx, t.elem); }
  if t.kind == ir.TyKind.Range || t.kind == ir.TyKind.Verified { return ty_has_param(ctx, t.elem); }
  if t.kind == ir.TyKind.Struct {
    let fs: FindStructResult = find_struct(ctx, t.mod_path, t.name);
    if !fs.found { return false; }
    let mut i: i32 = 0;
    while i < fs.sig.fields.len() {
      if ty_has_param(ctx, fs.sig.fields.get(i).ty) { return true; }
      i = i + 1;
    }
    return false;
  }
  if t.kind == ir.TyKind.Enum {
    let fe: FindEnumResult = find_enum(ctx, t.mod_path, t.name);
    if !fe.found { return false; }
    let mut vi: i32 = 0;
    while vi < fe.sig.vars.len() {
      let v: EnumVariantSig = fe.sig.vars.get(vi);
      let mut fi: i32 = 0;
      while fi < v.fields.len() {
        if ty_has_param(ctx, v.fields.get(fi)) { return true; }
        fi = fi + 1;
      }
      vi = vi + 1;
    }
    return false;
  }
  return false;
}

pub fn unify_ty(ctx: Ctx, pattern: i32, got: i32, subs0: Vec[TySub]) -> UnifyResult {
  let pt: ir.Ty = ir.ty_pool_get(ctx.pool, pattern);
  if is_param_ty(pt) {
    let cur: i32 = subs_lookup(subs0, pt.name);
    if cur == -1 { return UnifyResult { ok: true, subs: subs_add(subs0, pt.name, got) }; }
    if cur == got { return UnifyResult { ok: true, subs: subs0 }; }
    // Allow a refined int type to satisfy an already-bound base int param (widening).
    if assignable_to(ctx, cur, got) { return UnifyResult { ok: true, subs: subs0 }; }
    return UnifyResult { ok: false, subs: subs0 };
  }

  if is_vec_ty2(pt) {
    let gt: ir.Ty = ir.ty_pool_get(ctx.pool, got);
    if !is_vec_ty2(gt) { return UnifyResult { ok: false, subs: subs0 }; }
    return unify_ty(ctx, pt.elem, gt.elem, subs0);
  }

  if is_atomic_ty2(pt) {
    let gt: ir.Ty = ir.ty_pool_get(ctx.pool, got);
    if !is_atomic_ty2(gt) { return UnifyResult { ok: false, subs: subs0 }; }
    return unify_ty(ctx, pt.elem, gt.elem, subs0);
  }

  if pattern == got { return UnifyResult { ok: true, subs: subs0 }; }

  if is_struct_ty2(pt) {
    let gt: ir.Ty = ir.ty_pool_get(ctx.pool, got);
    if !is_struct_ty2(gt) { return UnifyResult { ok: false, subs: subs0 }; }
    if pt.mod_path != gt.mod_path { return UnifyResult { ok: false, subs: subs0 }; }

    let fs0: FindStructResult = find_struct(ctx, pt.mod_path, pt.name);
    let fs1: FindStructResult = find_struct(ctx, gt.mod_path, gt.name);
    if !fs0.found || !fs1.found { return UnifyResult { ok: false, subs: subs0 }; }
    if fs0.sig.base_name != fs1.sig.base_name { return UnifyResult { ok: false, subs: subs0 }; }
    if fs0.sig.fields.len() != fs1.sig.fields.len() { return UnifyResult { ok: false, subs: subs0 }; }

    let mut subs: Vec[TySub] = subs0;
    let mut i: i32 = 0;
    while i < fs0.sig.fields.len() {
      let f0: StructFieldSig = fs0.sig.fields.get(i);
      let f1: StructFieldSig = fs1.sig.fields.get(i);
      if f0.name != f1.name { return UnifyResult { ok: false, subs: subs0 }; }
      let ur: UnifyResult = unify_ty(ctx, f0.ty, f1.ty, subs);
      if !ur.ok { return UnifyResult { ok: false, subs: subs0 }; }
      subs = ur.subs;
      i = i + 1;
    }
    return UnifyResult { ok: true, subs: subs };
  }

  if is_enum_ty2(pt) {
    let gt: ir.Ty = ir.ty_pool_get(ctx.pool, got);
    if !is_enum_ty2(gt) { return UnifyResult { ok: false, subs: subs0 }; }
    if pt.mod_path != gt.mod_path { return UnifyResult { ok: false, subs: subs0 }; }

    let fe0: FindEnumResult = find_enum(ctx, pt.mod_path, pt.name);
    let fe1: FindEnumResult = find_enum(ctx, gt.mod_path, gt.name);
    if !fe0.found || !fe1.found { return UnifyResult { ok: false, subs: subs0 }; }
    if fe0.sig.base_name != fe1.sig.base_name { return UnifyResult { ok: false, subs: subs0 }; }
    if fe0.sig.vars.len() != fe1.sig.vars.len() { return UnifyResult { ok: false, subs: subs0 }; }

    let mut subs2: Vec[TySub] = subs0;
    let mut vi: i32 = 0;
    while vi < fe0.sig.vars.len() {
      let v0: EnumVariantSig = fe0.sig.vars.get(vi);
      let v1: EnumVariantSig = fe1.sig.vars.get(vi);
      if v0.name != v1.name || v0.fields.len() != v1.fields.len() {
        return UnifyResult { ok: false, subs: subs0 };
      }
      let mut fi: i32 = 0;
      while fi < v0.fields.len() {
        let ur2: UnifyResult = unify_ty(ctx, v0.fields.get(fi), v1.fields.get(fi), subs2);
        if !ur2.ok { return UnifyResult { ok: false, subs: subs0 }; }
        subs2 = ur2.subs;
        fi = fi + 1;
      }
      vi = vi + 1;
    }
    return UnifyResult { ok: true, subs: subs2 };
  }

  return UnifyResult { ok: false, subs: subs0 };
}

fn find_vec_ty_idx(ctx: Ctx, elem: i32) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    if t.kind == ir.TyKind.Vec && t.elem == elem { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_atomic_ty_idx(ctx: Ctx, elem: i32) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    if t.kind == ir.TyKind.Atomic && t.elem == elem { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_range_ty_idx_subst(ctx: Ctx, elem: i32, lo: i64, hi: i64) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    if t.kind == ir.TyKind.Range && t.elem == elem && t.lo == lo && t.hi == hi { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_verified_ty_idx_subst(ctx: Ctx, elem: i32, mod_path: String, name: String) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    if t.kind == ir.TyKind.Verified && t.elem == elem && t.mod_path == mod_path && t.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_ref_ty_idx(ctx: Ctx, elem: i32, mut0: bool, static0: bool) -> i32 {
  let mv: i64 = if mut0 { 1 } else { 0 };
  let sv: i64 = if static0 { 1 } else { 0 };
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    if t.kind == ir.TyKind.Ref && t.elem == elem && t.lo == mv && t.hi == sv { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_dot_pos_subst(s: String) -> i32 {
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 46 { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_param_ty_idx_subst(ctx: Ctx, name: String) -> i32 {
  let tys: Vec[ir.Ty] = ctx.pool.tys;
  let mut i: i32 = 0;
  while i < tys.len() {
    let t: ir.Ty = tys.get(i);
    if t.kind == ir.TyKind.Param && t.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn subst_proj_param(ctx: Ctx, name: String, subs: Vec[TySub]) -> i32 {
  // Projection-like type parameter names are represented as flat params:
  //   "U.Item", "U.Item.Sub", ...
  // If base `U` is substituted to param `T`, rewrite to `T.Item...`.
  let dot: i32 = find_dot_pos_subst(name);
  if dot <= 0 { return -1; }
  let base: String = name.slice(0, dot);
  let suffix: String = name.slice(dot, name.len());

  let bty: i32 = subs_lookup(subs, base);
  if bty == -1 { return -1; }
  let bt: ir.Ty = ir.ty_pool_get(ctx.pool, bty);
  if bt.kind != ir.TyKind.Param { return -1; }

  let want: String = bt.name.concat(suffix);
  let sub2: i32 = subs_lookup(subs, want);
  if sub2 != -1 { return sub2; }

  return find_param_ty_idx_subst(ctx, want);
}

pub fn subst_ty(ctx: Ctx, ty_idx: i32, subs: Vec[TySub]) -> i32 {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  if t.kind == ir.TyKind.Param {
    let r: i32 = subs_lookup(subs, t.name);
    if r != -1 { return r; }
    let rp: i32 = subst_proj_param(ctx, t.name, subs);
    if rp != -1 { return rp; }
    return ty_idx;
  }
  if t.kind == ir.TyKind.Ref {
    let e0: i32 = subst_ty(ctx, t.elem, subs);
    if e0 == t.elem { return ty_idx; }
    let ridx: i32 = find_ref_ty_idx(ctx, e0, ir.ty_ref_is_mut(t), ir.ty_ref_is_static(t));
    if ridx == -1 { return ctx.ty_bad; }
    return ridx;
  }
  if t.kind == ir.TyKind.Vec {
    let e: i32 = subst_ty(ctx, t.elem, subs);
    if e == t.elem { return ty_idx; }
    let vidx: i32 = find_vec_ty_idx(ctx, e);
    if vidx == -1 { return ctx.ty_bad; }
    return vidx;
  }
  if t.kind == ir.TyKind.Atomic {
    let e: i32 = subst_ty(ctx, t.elem, subs);
    if e == t.elem { return ty_idx; }
    let aidx: i32 = find_atomic_ty_idx(ctx, e);
    if aidx == -1 { return ctx.ty_bad; }
    return aidx;
  }
  if t.kind == ir.TyKind.Range {
    let e2: i32 = subst_ty(ctx, t.elem, subs);
    if e2 == t.elem { return ty_idx; }
    let ridx: i32 = find_range_ty_idx_subst(ctx, e2, t.lo, t.hi);
    if ridx == -1 { return ctx.ty_bad; }
    return ridx;
  }
  if t.kind == ir.TyKind.Verified {
    let e2: i32 = subst_ty(ctx, t.elem, subs);
    if e2 == t.elem { return ty_idx; }
    let vidx: i32 = find_verified_ty_idx_subst(ctx, e2, t.mod_path, t.name);
    if vidx == -1 { return ctx.ty_bad; }
    return vidx;
  }
  if t.kind == ir.TyKind.Struct {
    return subst_struct_nominal_ty(ctx, ty_idx, subs);
  }
  if t.kind == ir.TyKind.Enum {
    return subst_enum_nominal_ty(ctx, ty_idx, subs);
  }
  return ty_idx;
}

pub fn ty_inst_str(ctx: Ctx, ty_idx: i32) -> String {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  if t.kind == ir.TyKind.Unit { return "()"; }
  if t.kind == ir.TyKind.Bool { return "bool"; }
  if t.kind == ir.TyKind.I8 { return "i8"; }
  if t.kind == ir.TyKind.U8 { return "u8"; }
  if t.kind == ir.TyKind.I16 { return "i16"; }
  if t.kind == ir.TyKind.U16 { return "u16"; }
  if t.kind == ir.TyKind.I32 { return "i32"; }
  if t.kind == ir.TyKind.U32 { return "u32"; }
  if t.kind == ir.TyKind.I64 { return "i64"; }
  if t.kind == ir.TyKind.U64 { return "u64"; }
  if t.kind == ir.TyKind.ISize { return "isize"; }
  if t.kind == ir.TyKind.USize { return "usize"; }
  if t.kind == ir.TyKind.RawPtr { return if ir.ty_rawptr_is_const(t) { "const rawptr" } else { "rawptr" }; }
  if t.kind == ir.TyKind.F32 { return "f32"; }
  if t.kind == ir.TyKind.F64 { return "f64"; }
  if t.kind == ir.TyKind.String { return "String"; }
  if t.kind == ir.TyKind.Ref {
    let et: ir.Ty = ir.ty_pool_get(ctx.pool, t.elem);
    let base: String = if et.kind == ir.TyKind.String && !ir.ty_ref_is_mut(t) { "str" } else { ty_inst_str(ctx, t.elem) };
    if ir.ty_ref_is_mut(t) && ir.ty_ref_is_static(t) { return "&'static mut ".concat(base); }
    if ir.ty_ref_is_mut(t) { return "&mut ".concat(base); }
    if ir.ty_ref_is_static(t) { return "&'static ".concat(base); }
    return "&".concat(base);
  }
  if t.kind == ir.TyKind.Param { return t.name; }
  if t.kind == ir.TyKind.Vec { return "Vec[".concat(ty_inst_str(ctx, t.elem)).concat("]"); }
  if t.kind == ir.TyKind.Atomic { return "Atomic[".concat(ty_inst_str(ctx, t.elem)).concat("]"); }
  if t.kind == ir.TyKind.Range {
    return "@range(".
      concat(t.lo.to_string()).
      concat("..=").
      concat(t.hi.to_string()).
      concat(") ").
      concat(ty_inst_str(ctx, t.elem));
  }
  if t.kind == ir.TyKind.Verified {
    let mut p: String = t.mod_path;
    let mut i: i32 = 0;
    while i < p.len() {
      if p.byte_at(i) == 47 { p = p.slice(0, i).concat(".").concat(p.slice(i + 1, p.len())); }
      i = i + 1;
    }
    let qn: String = if p == "" || p == "main" { t.name } else { p.concat(".").concat(t.name) };
    return "@verified(".concat(qn).concat(") ").concat(ty_inst_str(ctx, t.elem));
  }
  if t.kind == ir.TyKind.Struct || t.kind == ir.TyKind.Enum {
    // Use `mod::Name` with '/' normalized to '.' for readability.
    if t.mod_path == "" || t.mod_path == "main" { return t.name; }
    let mut s: String = t.mod_path;
    let mut i: i32 = 0;
    while i < s.len() {
      if s.byte_at(i) == 47 { s = s.slice(0, i).concat(".").concat(s.slice(i + 1, s.len())); }
      i = i + 1;
    }
    return s.concat("::").concat(t.name);
  }
  return "<bad>";
}

fn hex_val(c: i32) -> i32 {
  if c >= 48 && c <= 57 { return c - 48; } // 0-9
  if c >= 97 && c <= 102 { return 10 + (c - 97); } // a-f
  return -1;
}

fn is_hex_escape_byte(s: String, i: i32, want: i32) -> bool {
  if s.byte_at(i) != 95 { return false; } // '_'
  if (i + 2) >= s.len() { return false; }
  let hi: i32 = hex_val(s.byte_at(i + 1));
  let lo: i32 = hex_val(s.byte_at(i + 2));
  if hi == -1 || lo == -1 { return false; }
  return (hi * 16 + lo) == want;
}

fn inst_text_pretty(s0: String) -> String {
  // Convert `Name$gT_3di32` -> `Name[i32]` for diagnostics.
  let mut i: i32 = 0;
  while i < s0.len() {
    if s0.byte_at(i) == 36 { // '$'
      let base: String = s0.slice(0, i);
      let mut suf: String = s0.slice(i + 1, s0.len());
      if suf.len() > 0 && suf.byte_at(0) == 103 { // 'g'
        suf = suf.slice(1, suf.len());
      }
      // Parse mangled raw `A_3dTy_2cB_3d3_3ai32` => values [Ty, 3].
      let mut vals: Vec[String] = Vec();
      let mut j: i32 = 0;
      while j < suf.len() {
        // Scan to '=' escape.
        let mut eq_at: i32 = -1;
        let mut k: i32 = j;
        while k < suf.len() {
          if is_hex_escape_byte(suf, k, 61) { // '='
            eq_at = k;
            k = suf.len();
          } else if is_hex_escape_byte(suf, k, 44) { // ',' (malformed segment)
            k = suf.len();
          } else if suf.byte_at(k) == 95 && (k + 2) < suf.len() {
            k = k + 3;
          } else {
            k = k + 1;
          }
        }
        if eq_at == -1 { j = suf.len(); continue; }
        let rhs_start: i32 = eq_at + 3;

        // rhs ends at ',' or ':' escape or end.
        let mut rhs_end: i32 = rhs_start;
        while rhs_end < suf.len() {
          if is_hex_escape_byte(suf, rhs_end, 44) { break; } // ','
          if is_hex_escape_byte(suf, rhs_end, 58) { break; } // ':'
          if suf.byte_at(rhs_end) == 95 && (rhs_end + 2) < suf.len() {
            rhs_end = rhs_end + 3;
          } else {
            rhs_end = rhs_end + 1;
          }
        }
        if rhs_start <= rhs_end && rhs_end <= suf.len() {
          let rhs: String = suf.slice(rhs_start, rhs_end);
          vals.push(inst_text_pretty(rhs));
        }

        // Advance to next segment: skip until ',' escape (if any), then consume it.
        let mut next: i32 = rhs_end;
        while next < suf.len() && !is_hex_escape_byte(suf, next, 44) {
          if suf.byte_at(next) == 95 && (next + 2) < suf.len() { next = next + 3; } else { next = next + 1; }
        }
        if next < suf.len() && is_hex_escape_byte(suf, next, 44) { next = next + 3; }
        j = next;
      }
      if vals.len() == 0 { return base; }
      let mut args: String = "";
      let mut vi: i32 = 0;
      while vi < vals.len() {
        if vi != 0 { args = args.concat(", "); }
        args = args.concat(vals.get(vi));
        vi = vi + 1;
      }
      return base.concat("[").concat(args).concat("]");
    }
    i = i + 1;
  }
  return s0;
}

pub fn ty_user_str(ctx: Ctx, ty_idx: i32) -> String {
  // User-facing type text for diagnostics: demangles generic instantiation
  // suffixes produced by inst_name_ex().
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty_idx);
  if t.kind == ir.TyKind.Unit { return "()"; }
  if t.kind == ir.TyKind.Bool { return "bool"; }
  if t.kind == ir.TyKind.I8 { return "i8"; }
  if t.kind == ir.TyKind.U8 { return "u8"; }
  if t.kind == ir.TyKind.I16 { return "i16"; }
  if t.kind == ir.TyKind.U16 { return "u16"; }
  if t.kind == ir.TyKind.I32 { return "i32"; }
  if t.kind == ir.TyKind.U32 { return "u32"; }
  if t.kind == ir.TyKind.I64 { return "i64"; }
  if t.kind == ir.TyKind.U64 { return "u64"; }
  if t.kind == ir.TyKind.ISize { return "isize"; }
  if t.kind == ir.TyKind.USize { return "usize"; }
  if t.kind == ir.TyKind.F32 { return "f32"; }
  if t.kind == ir.TyKind.F64 { return "f64"; }
  if t.kind == ir.TyKind.String { return "String"; }
  if t.kind == ir.TyKind.Ref {
    let et: ir.Ty = ir.ty_pool_get(ctx.pool, t.elem);
    let base: String = if et.kind == ir.TyKind.String && !ir.ty_ref_is_mut(t) { "str" } else { ty_user_str(ctx, t.elem) };
    if ir.ty_ref_is_mut(t) && ir.ty_ref_is_static(t) { return "&'static mut ".concat(base); }
    if ir.ty_ref_is_mut(t) { return "&mut ".concat(base); }
    if ir.ty_ref_is_static(t) { return "&'static ".concat(base); }
    return "&".concat(base);
  }
  if t.kind == ir.TyKind.Param { return t.name; }
  if t.kind == ir.TyKind.Vec { return "Vec[".concat(ty_user_str(ctx, t.elem)).concat("]"); }
  if t.kind == ir.TyKind.Atomic { return "Atomic[".concat(ty_user_str(ctx, t.elem)).concat("]"); }
  if t.kind == ir.TyKind.Range {
    return "@range(".
      concat(t.lo.to_string()).
      concat("..=").
      concat(t.hi.to_string()).
      concat(") ").
      concat(ty_user_str(ctx, t.elem));
  }
  if t.kind == ir.TyKind.Verified {
    let mut p: String = t.mod_path;
    let mut i: i32 = 0;
    while i < p.len() {
      if p.byte_at(i) == 47 { p = p.slice(0, i).concat(".").concat(p.slice(i + 1, p.len())); }
      i = i + 1;
    }
    let qn: String = if p == "" || p == "main" { t.name } else { p.concat(".").concat(t.name) };
    return "@verified(".concat(qn).concat(") ").concat(ty_user_str(ctx, t.elem));
  }
  if t.kind == ir.TyKind.Struct || t.kind == ir.TyKind.Enum {
    // Use `mod::Name` with '/' normalized to '.' for readability.
    let mut base: String = "";
    if t.mod_path == "" || t.mod_path == "main" { base = t.name; } else {
      let mut s: String = t.mod_path;
      let mut i: i32 = 0;
      while i < s.len() {
        if s.byte_at(i) == 47 { s = s.slice(0, i).concat(".").concat(s.slice(i + 1, s.len())); }
        i = i + 1;
      }
      base = s.concat("::").concat(t.name);
    }
    return inst_text_pretty(base);
  }
  return "<bad>";
}

fn hex2(b: i32) -> String {
  let hex: String = "0123456789abcdef";
  let hi: i32 = b / 16;
  let lo: i32 = b % 16;
  return hex.slice(hi, hi + 1).concat(hex.slice(lo, lo + 1));
}

pub fn mangle_ident(s: String) -> String {
  // Keep [A-Za-z0-9], hex-escape everything else. Prefix with 'g'.
  let mut out: String = "g";
  let mut i: i32 = 0;
  while i < s.len() {
    let ch: i32 = s.byte_at(i);
    let ok: bool = (ch >= 97 && ch <= 122) || (ch >= 65 && ch <= 90) || (ch >= 48 && ch <= 57);
    if ok {
      out = out.concat(s.slice(i, i + 1));
    } else {
      out = out.concat("_").concat(hex2(ch));
    }
    i = i + 1;
  }
  return out;
}

pub fn inst_suffix(ctx: Ctx, type_params: Vec[String], subs: Vec[TySub]) -> String {
  return inst_suffix_ex(ctx, type_params, Vec(), subs, Vec());
}

fn const_sub_lookup(csubs: Vec[ConstSub], name: String) -> ConstSub {
  let mut i: i32 = 0;
  while i < csubs.len() {
    let cs: ConstSub = csubs.get(i);
    if cs.name == name { return cs; }
    i = i + 1;
  }
  return ConstSub { name: "", ty: -1, iv: 0, text: "" };
}

fn const_where_ty_lookup(subs: Vec[TySub], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < subs.len() {
    let s: TySub = subs.get(i);
    if s.name == name { return s.ty; }
    i = i + 1;
  }
  return -1;
}

fn const_where_op_text(op: ast.BinaryOp) -> String {
  if match op { ast.BinaryOp.Eq => true, _ => false } { return "=="; }
  if match op { ast.BinaryOp.Ne => true, _ => false } { return "!="; }
  if match op { ast.BinaryOp.Lt => true, _ => false } { return "<"; }
  if match op { ast.BinaryOp.Le => true, _ => false } { return "<="; }
  if match op { ast.BinaryOp.Gt => true, _ => false } { return ">"; }
  if match op { ast.BinaryOp.Ge => true, _ => false } { return ">="; }
  return "?";
}

fn const_where_eval_i64(op: ast.BinaryOp, a: i64, b: i64) -> bool {
  if match op { ast.BinaryOp.Eq => true, _ => false } { return a == b; }
  if match op { ast.BinaryOp.Ne => true, _ => false } { return a != b; }
  if match op { ast.BinaryOp.Lt => true, _ => false } { return a < b; }
  if match op { ast.BinaryOp.Le => true, _ => false } { return a <= b; }
  if match op { ast.BinaryOp.Gt => true, _ => false } { return a > b; }
  if match op { ast.BinaryOp.Ge => true, _ => false } { return a >= b; }
  return false;
}

struct GenericsRhsReflectDecode {
  ok: bool,
  kind: i32,
  name: String,
}

fn generics_rhs_reflect_decode(s: String) -> GenericsRhsReflectDecode {
  let pfx: String = "__cwref__:";
  if s.len() <= pfx.len() || s.slice(0, pfx.len()) != pfx {
    return GenericsRhsReflectDecode { ok: false, kind: ast.comptime_where_lhs_const_param(), name: "" };
  }
  let rest: String = s.slice(pfx.len(), s.len());
  let mut cut: i32 = -1;
  let mut i: i32 = 0;
  while i < rest.len() {
    if rest.byte_at(i) == 58 {
      cut = i;
      i = rest.len();
    } else {
      i = i + 1;
    }
  }
  if cut <= 0 || cut + 1 >= rest.len() {
    return GenericsRhsReflectDecode { ok: false, kind: ast.comptime_where_lhs_const_param(), name: "" };
  }
  let tag: String = rest.slice(0, cut);
  let name: String = rest.slice(cut + 1, rest.len());
  let kind: i32 =
    if tag == "size_of" {
      ast.comptime_where_lhs_size_of()
    } else if tag == "align_of" {
      ast.comptime_where_lhs_align_of()
    } else if tag == "field_count" {
      ast.comptime_where_lhs_field_count()
    } else if tag == "type" {
      ast.comptime_where_lhs_type()
    } else {
      ast.comptime_where_lhs_const_param()
    };
  if kind == ast.comptime_where_lhs_const_param() {
    return GenericsRhsReflectDecode { ok: false, kind: kind, name: "" };
  }
  return GenericsRhsReflectDecode { ok: true, kind: kind, name: name };
}

fn const_where_lhs_text(b: ConstWhereBoundSig) -> String {
  if b.lhs_kind == ast.comptime_where_lhs_const_param() { return b.name; }
  if b.lhs_kind == ast.comptime_where_lhs_size_of() { return "@size_of(".concat(b.name).concat(")"); }
  if b.lhs_kind == ast.comptime_where_lhs_align_of() { return "@align_of(".concat(b.name).concat(")"); }
  if b.lhs_kind == ast.comptime_where_lhs_field_count() { return "@field_count(".concat(b.name).concat(")"); }
  if b.lhs_kind == ast.comptime_where_lhs_type() { return "@type(".concat(b.name).concat(")"); }
  return b.name;
}

struct ConstWhereReflectEvalResult {
  ok: bool,
  err: String,
  iv: i64,
}

fn const_where_eval_reflect_i64(ctx: Ctx, kind: i32, name: String, subs: Vec[TySub]) -> ConstWhereReflectEvalResult {
  let ty0: i32 = const_where_ty_lookup(subs, name);
  if ty0 == -1 {
    return ConstWhereReflectEvalResult { ok: false, err: "missing type generic arg for constraint: ".concat(name), iv: 0 };
  }
  let ty: i32 = strip_range(ctx, ty0);
  if kind == ast.comptime_where_lhs_size_of() {
    let sr: ReflectIntResult = intrinsic_size_of(ctx, ty);
    if !sr.ok { return ConstWhereReflectEvalResult { ok: false, err: "comptime where size_of failed: ".concat(sr.err), iv: 0 }; }
    return ConstWhereReflectEvalResult { ok: true, err: "", iv: sr.iv };
  }
  if kind == ast.comptime_where_lhs_align_of() {
    let ar: ReflectIntResult = intrinsic_align_of(ctx, ty);
    if !ar.ok { return ConstWhereReflectEvalResult { ok: false, err: "comptime where align_of failed: ".concat(ar.err), iv: 0 }; }
    return ConstWhereReflectEvalResult { ok: true, err: "", iv: ar.iv };
  }
  if kind == ast.comptime_where_lhs_field_count() {
    let fr: ReflectIntResult = intrinsic_field_count_of(ctx, ty);
    if !fr.ok { return ConstWhereReflectEvalResult { ok: false, err: "comptime where field_count failed: ".concat(fr.err), iv: 0 }; }
    return ConstWhereReflectEvalResult { ok: true, err: "", iv: fr.iv };
  }
  if kind == ast.comptime_where_lhs_type() {
    let tr: ReflectIntResult = intrinsic_type_id_of(ctx, ty);
    if !tr.ok { return ConstWhereReflectEvalResult { ok: false, err: "comptime where type failed: ".concat(tr.err), iv: 0 }; }
    return ConstWhereReflectEvalResult { ok: true, err: "", iv: tr.iv };
  }
  return ConstWhereReflectEvalResult { ok: false, err: "unsupported comptime where lhs", iv: 0 };
}

pub fn check_const_where_bounds(ctx: Ctx, bounds: Vec[ConstWhereBoundSig], subs: Vec[TySub], csubs: Vec[ConstSub]) -> ConstWhereCheckResult {
  let mut i: i32 = 0;
  while i < bounds.len() {
    let b: ConstWhereBoundSig = bounds.get(i);
    let mut lhs_iv: i64 = 0;
    let mut lhs_text: String = const_where_lhs_text(b);
    if b.lhs_kind == ast.comptime_where_lhs_const_param() {
      let cs: ConstSub = const_sub_lookup(csubs, b.name);
      if cs.name == "" {
        return ConstWhereCheckResult { ok: false, err: "missing const generic arg for constraint: ".concat(b.name) };
      }
      lhs_iv = cs.iv;
      lhs_text = b.name;
    } else if
      b.lhs_kind == ast.comptime_where_lhs_size_of() ||
      b.lhs_kind == ast.comptime_where_lhs_align_of() ||
      b.lhs_kind == ast.comptime_where_lhs_field_count() ||
      b.lhs_kind == ast.comptime_where_lhs_type()
    {
      let lv: ConstWhereReflectEvalResult = const_where_eval_reflect_i64(ctx, b.lhs_kind, b.name, subs);
      if !lv.ok { return ConstWhereCheckResult { ok: false, err: lv.err }; }
      lhs_iv = lv.iv;
    } else {
      return ConstWhereCheckResult { ok: false, err: "unsupported comptime where lhs" };
    }
    let mut rhs_iv: i64 = b.rhs_iv;
    if b.rhs_is_param {
      let rhs_cs: ConstSub = const_sub_lookup(csubs, b.rhs_param);
      if rhs_cs.name != "" {
        rhs_iv = rhs_cs.iv;
      } else {
        let rr: GenericsRhsReflectDecode = generics_rhs_reflect_decode(b.rhs_param);
        if !rr.ok {
          return ConstWhereCheckResult { ok: false, err: "missing const generic arg for constraint rhs: ".concat(b.rhs_param) };
        }
        let rv: ConstWhereReflectEvalResult = const_where_eval_reflect_i64(ctx, rr.kind, rr.name, subs);
        if !rv.ok { return ConstWhereCheckResult { ok: false, err: rv.err }; }
        rhs_iv = rv.iv;
      }
    }
    if !const_where_eval_i64(b.op, lhs_iv, rhs_iv) {
      let msg: String =
        "comptime generic constraint failed: "
          .concat(lhs_text).concat(" ")
          .concat(const_where_op_text(b.op)).concat(" ")
          .concat(b.rhs_text).concat(" (got ").concat(lhs_iv.to_string()).concat(")");
      return ConstWhereCheckResult { ok: false, err: msg };
    }
    i = i + 1;
  }
  return ConstWhereCheckResult { ok: true, err: "" };
}

pub fn inst_suffix_ex(ctx: Ctx, type_params: Vec[String], const_params: Vec[ConstParamSig], subs: Vec[TySub], csubs: Vec[ConstSub]) -> String {
  let mut raw: String = "";
  let mut i: i32 = 0;
  while i < type_params.len() {
    let tp: String = type_params.get(i);
    let ty: i32 = subs_lookup(subs, tp);
    raw = raw.concat(tp).concat("=").concat(ty_inst_str(ctx, ty));
    if i + 1 < type_params.len() { raw = raw.concat(","); }
    i = i + 1;
  }
  let mut j: i32 = 0;
  while j < const_params.len() {
    if raw != "" { raw = raw.concat(","); }
    let cp: ConstParamSig = const_params.get(j);
    let cs: ConstSub = const_sub_lookup(csubs, cp.name);
    if cs.name == "" {
      raw = raw.concat(cp.name).concat("=<missing>");
    } else {
      raw = raw.concat(cp.name)
        .concat("=").concat(cs.text)
        .concat(":").concat(ty_inst_str(ctx, cp.ty));
    }
    j = j + 1;
  }
  return mangle_ident(raw);
}

pub fn inst_name(ctx: Ctx, base: String, type_params: Vec[String], subs: Vec[TySub]) -> String {
  return inst_name_ex(ctx, base, type_params, Vec(), subs, Vec());
}

pub fn inst_name_ex(ctx: Ctx, base: String, type_params: Vec[String], const_params: Vec[ConstParamSig], subs: Vec[TySub], csubs: Vec[ConstSub]) -> String {
  return base.concat("$").concat(inst_suffix_ex(ctx, type_params, const_params, subs, csubs));
}
