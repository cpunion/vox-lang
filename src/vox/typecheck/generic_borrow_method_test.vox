import "std/testing" as t
import "vox/typecheck" as tc

fn test_typecheck_generic_inherent_ref_receiver_method_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Q[T] { data: Vec[T], head: i32 }
    struct Front[T] { ok: bool, value: T }
    impl[T] Q[T] {
      fn try_front_or(q: &Q[T], fallback: T) -> Front[T] {
        if q.data.len() == q.head {
          return Front[T] { ok: false, value: fallback };
        }
        return Front[T] { ok: true, value: q.data.get(q.head) };
      }
    }
    fn main() -> i32 {
      let mut xs: Vec[i32] = Vec();
      xs.push(7);
      let q: Q[i32] = Q[i32] { data: xs, head: 0 };
      let r: Front[i32] = q.try_front_or(-1);
      return if r.ok { r.value } else { -1 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_generic_inherent_ref_mut_receiver_method_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Q[T] { data: Vec[T], head: i32 }
    impl[T] Q[T] {
      fn advance(q: &mut Q[T]) -> i32 {
        q.head = q.head + 1;
        return q.head;
      }
    }
    fn main() -> i32 {
      let mut xs: Vec[i32] = Vec();
      xs.push(7);
      xs.push(9);
      let mut q: Q[i32] = Q[i32] { data: xs, head: 0 };
      let n: i32 = q.advance();
      return n;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}
