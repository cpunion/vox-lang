import "std/testing" as t
import "vox/typecheck" as tc

fn test_typecheck_bool_bitwise_or_xor_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let a: bool = true;
      let b: bool = false;
      let x: bool = a | b;
      let y: bool = a ^ b;
      if x && y { return 1; }
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_bool_shift_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let _x: bool = true << false;
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_call_ref_arg_requires_place_diag() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn take_ref(x: &i32) -> i32 { return 0; }
    fn main() -> i32 { return take_ref(1 + 2); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), "expected non-place borrow call to fail");
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "for & parameter must be place"), msg);
}

fn test_typecheck_call_mut_arg_immutable_place_diag() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn take_mut(x: &mut i32) -> i32 { return 0; }
    fn main() -> i32 {
      let x: i32 = 1;
      return take_mut(x);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), "expected immutable mut-borrow arg to fail");
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "for &mut parameter is immutable"), msg);
}

fn test_typecheck_vec_ctor_requires_expected_type_diag() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let _x = Vec();
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), "expected Vec() without expected type to fail");
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "Vec() requires expected type Vec[T]"), msg);
}
