import "std/testing" as t
import "vox/typecheck" as tc

fn tc_expect_fail_msg(src: String) -> String {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), "expected typecheck failure");
  return tc.tc_error_to_string(r.err);
}

fn test_typecheck_bool_bitwise_or_xor_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let a: bool = true;
      let b: bool = false;
      let x: bool = a | b;
      let y: bool = a ^ b;
      if x && y { return 1; }
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_bool_shift_rejected() -> () {
  let msg: String = tc_expect_fail_msg("""
    fn main() -> i32 {
      let _x: bool = true << false;
      return 0;
    }
  """);
  t.assert(msg.len() > 0);
}

fn test_typecheck_call_ref_arg_requires_place_diag() -> () {
  let msg: String = tc_expect_fail_msg("""
    fn take_ref(x: &i32) -> i32 { return 0; }
    fn main() -> i32 { return take_ref(1 + 2); }
  """);
  t.assert_with(contains(msg, "for & parameter must be place"), msg);
}

fn test_typecheck_call_mut_arg_immutable_place_diag() -> () {
  let msg: String = tc_expect_fail_msg("""
    fn take_mut(x: &mut i32) -> i32 { return 0; }
    fn main() -> i32 {
      let x: i32 = 1;
      return take_mut(x);
    }
  """);
  t.assert_with(contains(msg, "for &mut parameter is immutable"), msg);
}

fn test_typecheck_vec_ctor_requires_expected_type_diag() -> () {
  let msg: String = tc_expect_fail_msg("""
    fn main() -> i32 {
      let _x = Vec();
      return 0;
    }
  """);
  t.assert_with(contains(msg, "Vec() requires expected type Vec[T]"), msg);
}
