import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc

fn parse_prog(src: String) -> p.ParseResult { return p.parse_text(src); }

fn add_mod(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = parse_prog(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn ok(r: tc.TcResult) -> bool { return r.ok; }

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn starts_with(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

fn test_typecheck_prelude_fallback() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub fn assert(cond: bool) -> () { return; }");
  w = add_mod(w, "main", "fn main() -> i32 { assert(true); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_prelude_trait_static_call_fallback() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
  """);
  w = add_mod(w, "main", "fn main() -> i32 { if Eq.eq(1, 1) { return 1; } return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_impl_uses_prelude_trait_without_import() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Show { fn show(x: Self) -> String; }");
  w = add_mod(w, "main", """
    struct I { v: i32 }
    impl Show for I { fn show(x: I) -> String { return "ok"; } }
    fn main() -> i32 { let s: String = Show.show(I { v: 1 }); return s.len(); }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_impl_uses_prelude_trait_default_method_without_import() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    fn tag() -> String { return "pre"; }
    pub trait Show { fn show(x: Self) -> String { return tag(); } }
  """);
  w = add_mod(w, "main", """
    struct I { v: i32 }
    impl Show for I {}
    fn main() -> i32 { let s: String = I { v: 1 }.show(); return s.len(); }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_import_alias_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub fn assert(cond: bool) -> () { return; }");
  w = add_mod(w, "std/testing", "import \"std/prelude\" as prelude\npub fn assert(cond: bool) -> () { prelude.assert(cond); return; }");
  w = add_mod(w, "main", "import \"std/testing\" as t\nfn main() -> i32 { t.assert(true); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_testing_assert_ne_wrapper_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
    pub fn assert_ne[T: Eq](a: T, b: T) -> () { if a == b { panic("assertion failed"); } }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
  """);
  w = add_mod(w, "std/testing", """
    import "std/prelude" as prelude
    pub fn assert_ne[T: prelude.Eq](a: T, b: T) -> () { prelude.assert_ne(a, b); }
  """);
  w = add_mod(w, "main", "import \"std/testing\" as t\nfn main() -> i32 { t.assert_ne(1, 2); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_testing_assert_lt_wrapper_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Ord { fn lt(a: Self, b: Self) -> bool; }
    pub fn assert_lt[T: Ord](a: T, b: T) -> () { if a < b { return; } panic("assertion failed"); }
    impl Ord for i32 { fn lt(a: i32, b: i32) -> bool { return a < b; } }
  """);
  w = add_mod(w, "std/testing", """
    import "std/prelude" as prelude
    pub fn assert_lt[T: prelude.Ord](a: T, b: T) -> () { prelude.assert_lt(a, b); }
  """);
  w = add_mod(w, "main", "import \"std/testing\" as t\nfn main() -> i32 { t.assert_lt(1, 2); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_io_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/io", """
    @ffi_import("c", "access")
    fn rt_access_raw(path: String, mode: i32) -> i32;
    @ffi_import("c", "vox_impl_read_file")
    fn rt_read_file_raw(path: String) -> String;
    @ffi_import("c", "creat")
    fn rt_creat_raw(path: String, mode: u32) -> i32;
    @ffi_import("c", "write")
    fn rt_write_raw(fd: i32, buf: const rawptr, n: usize) -> isize;
    @ffi_import("c", "close")
    fn rt_close_raw(fd: i32) -> i32;
    @ffi_import("c", "mkdir")
    fn rt_mkdir_raw(path: String, mode: u32) -> i32;
    @ffi_import("c", "vox_impl_tcp_connect")
    fn rt_tcp_connect_raw(host: String, port: i32) -> isize;
    @ffi_import("c", "send")
    fn rt_send_raw(fd: i32, buf: const rawptr, n: usize, flags: i32) -> isize;
    @ffi_import("c", "vox_impl_tcp_recv")
    fn rt_tcp_recv_raw(handle: isize, max_n: i32) -> String;
    @ffi_import("c", "vox_impl_tcp_close")
    fn rt_tcp_close_raw(handle: isize) -> ();
    @ffi_import("c", "vox_impl_tcp_wait_read")
    fn rt_tcp_wait_read_raw(handle: isize, timeout_ms: i32) -> bool;
    @ffi_import("c", "vox_impl_tcp_wait_write")
    fn rt_tcp_wait_write_raw(handle: isize, timeout_ms: i32) -> bool;
    @ffi_import("c", "vox_impl_walk_vox_files")
    fn rt_walk_files_raw(path: String) -> Vec[String];
    fn handle_to_fd(handle: isize) -> i32 {
      if handle < -2147483648 as isize || handle > 2147483647 as isize {
        panic("tcp handle out of i32 range");
      }
      return handle as i32;
    }
    fn rt_path_exists_raw(path: String) -> bool { return rt_access_raw(path, 0) == 0; }
    fn rt_write_file_raw(path: String, text: String) -> () {
      let fd: i32 = rt_creat_raw(path, 438 as u32);
      if fd < 0 { panic("write_file failed"); }
      let _nw: isize = rt_write_raw(fd, text as const rawptr, text.len() as usize);
      let _rc: i32 = rt_close_raw(fd);
      _nw;
      _rc;
      return;
    }
    fn rt_mkdir_p_raw(path: String) -> () {
      let _rc: i32 = rt_mkdir_raw(path, 511 as u32);
      _rc;
      return;
    }
    fn rt_tcp_send_raw(handle: isize, text: String) -> i32 {
      let fd: i32 = handle_to_fd(handle);
      let sent: isize = rt_send_raw(fd, text as const rawptr, text.len() as usize, 0);
      if sent < 0 { panic("tcp send failed"); }
      if sent > 2147483647 as isize { panic("tcp send count too large"); }
      return sent as i32;
    }
    pub fn out(msg: String) -> () { msg; return; }
    pub fn out_ln(msg: String) -> () { msg; return; }
    pub fn fail(msg: String) -> () { panic(msg); }
    pub struct File { path: String }
    pub fn file(path: String) -> File { return File { path: path }; }
    impl File {
      fn read_all(f: &File) -> String { return rt_read_file_raw(f.path); }
      fn write_all(f: &File, text: String) -> () { rt_write_file_raw(f.path, text); }
      fn exists(f: &File) -> bool { return rt_path_exists_raw(f.path); }
      fn mkdir_p(f: &File) -> () { rt_mkdir_p_raw(f.path); }
    }
    pub fn file_exists(path: String) -> bool { return rt_path_exists_raw(path); }
    pub fn mkdir_p(path: String) -> () { rt_mkdir_p_raw(path); }
  """);
  w = add_mod(w, "main", """
    import "std/io" as io
    fn main() -> i32 {
      io.out("x");
      io.out_ln("y");
      let f: io.File = io.file("a.txt");
      f.write_all("ok");
      let g: io.File = io.file("a.txt");
      let _s: String = g.read_all();
      let _b: bool = io.file_exists("a.txt");
      io.mkdir_p("tmp");
      return 0;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_std_io_method_style_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/io", """
    @ffi_import("c", "access")
    fn rt_access_raw(path: String, mode: i32) -> i32;
    @ffi_import("c", "vox_impl_read_file")
    fn rt_read_file_raw(path: String) -> String;
    @ffi_import("c", "creat")
    fn rt_creat_raw(path: String, mode: u32) -> i32;
    @ffi_import("c", "write")
    fn rt_write_raw(fd: i32, buf: const rawptr, n: usize) -> isize;
    @ffi_import("c", "close")
    fn rt_close_raw(fd: i32) -> i32;
    @ffi_import("c", "mkdir")
    fn rt_mkdir_raw(path: String, mode: u32) -> i32;
    fn rt_path_exists_raw(path: String) -> bool { return rt_access_raw(path, 0) == 0; }
    fn rt_write_file_raw(path: String, text: String) -> () {
      let fd: i32 = rt_creat_raw(path, 438 as u32);
      if fd < 0 { panic("write_file failed"); }
      let _nw: isize = rt_write_raw(fd, text as const rawptr, text.len() as usize);
      let _rc: i32 = rt_close_raw(fd);
      _nw;
      _rc;
      return;
    }
    fn rt_mkdir_p_raw(path: String) -> () {
      let _rc: i32 = rt_mkdir_raw(path, 511 as u32);
      _rc;
      return;
    }
    pub struct File { path: String }
    pub fn file(path: String) -> File { return File { path: path }; }
    impl File {
      fn exists(f: &File) -> bool { return rt_path_exists_raw(f.path); }
      fn read_all(f: &File) -> String { return rt_read_file_raw(f.path); }
      fn write_all(f: &File, text: String) -> () { rt_write_file_raw(f.path, text); }
      fn mkdir_p(f: &File) -> () { rt_mkdir_p_raw(f.path); }
    }
  """);
  w = add_mod(w, "main", """
    import "std/io" as io
    fn main() -> i32 {
      let f: io.File = io.file("a.txt");
      f.write_all("ok");
      let _s: String = f.read_all();
      let _b: bool = f.exists();
      let d: io.File = io.file("tmp");
      d.mkdir_p();
      return 0;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_std_fs_method_style_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/fs", """
    @ffi_import("c", "access")
    fn rt_access_raw(path: String, mode: i32) -> i32;
    @ffi_import("c", "vox_impl_read_file")
    fn rt_read_file_raw(path: String) -> String;
    @ffi_import("c", "creat")
    fn rt_creat_raw(path: String, mode: u32) -> i32;
    @ffi_import("c", "write")
    fn rt_write_raw(fd: i32, buf: const rawptr, n: usize) -> isize;
    @ffi_import("c", "close")
    fn rt_close_raw(fd: i32) -> i32;
    @ffi_import("c", "mkdir")
    fn rt_mkdir_raw(path: String, mode: u32) -> i32;
    @ffi_import("c", "vox_impl_walk_vox_files")
    fn rt_walk_files_raw(path: String) -> Vec[String];
    fn rt_path_exists_raw(path: String) -> bool { return rt_access_raw(path, 0) == 0; }
    fn rt_write_file_raw(path: String, text: String) -> () {
      let fd: i32 = rt_creat_raw(path, 438 as u32);
      if fd < 0 { panic("write_file failed"); }
      let _nw: isize = rt_write_raw(fd, text as const rawptr, text.len() as usize);
      let _rc: i32 = rt_close_raw(fd);
      _nw;
      _rc;
      return;
    }
    fn rt_mkdir_p_raw(path: String) -> () {
      let _rc: i32 = rt_mkdir_raw(path, 511 as u32);
      _rc;
      return;
    }
    pub struct Path { raw: String }
    pub fn path(raw: String) -> Path { return Path { raw: raw }; }
    pub fn clean(raw: String) -> String { return raw; }
    pub fn join(a: String, b: String) -> String { return a.concat("/").concat(b); }
    pub fn base_name(raw: String) -> String { return raw; }
    pub fn dir_name(_raw: String) -> String { return "."; }
    pub fn ext(_raw: String) -> String { return ""; }
    pub fn stem(raw: String) -> String { return raw; }
    pub fn is_abs(raw: String) -> bool { return raw.len() > 0 && raw.byte_at(0) == 47; }
    impl Path {
      fn clean(p: &Path) -> Path { return path(clean(p.raw)); }
      fn join(p: &Path, elem: String) -> Path { return path(join(p.raw, elem)); }
      fn base_name(p: &Path) -> String { return base_name(p.raw); }
      fn dir_name(p: &Path) -> String { return dir_name(p.raw); }
      fn ext(p: &Path) -> String { return ext(p.raw); }
      fn stem(p: &Path) -> String { return stem(p.raw); }
      fn is_abs(p: &Path) -> bool { return is_abs(p.raw); }
      fn read_to_string(p: &Path) -> String { return rt_read_file_raw(p.raw); }
      fn write_string(p: &Path, text: String) -> () { rt_write_file_raw(p.raw, text); }
      fn exists(p: &Path) -> bool { return rt_path_exists_raw(p.raw); }
      fn mkdir_p(p: &Path) -> () { rt_mkdir_p_raw(p.raw); }
      fn walk_files(p: &Path) -> Vec[String] { return rt_walk_files_raw(p.raw); }
    }
    pub fn read_to_string(raw: String) -> String { let p: Path = path(raw); return p.read_to_string(); }
    pub fn write_string(raw: String, text: String) -> () { let p: Path = path(raw); p.write_string(text); return; }
    pub fn exists(raw: String) -> bool { let p: Path = path(raw); return p.exists(); }
    pub fn mkdir_p(raw: String) -> () { let p: Path = path(raw); p.mkdir_p(); return; }
    pub fn walk_files(raw: String) -> Vec[String] { let p: Path = path(raw); return p.walk_files(); }
  """);
  w = add_mod(w, "main", """
    import "std/fs" as fs
    fn main() -> i32 {
      let p: fs.Path = fs.path("a.txt");
      p.write_string("ok");
      let _s: String = p.read_to_string();
      let _b: bool = p.exists();
      let d: fs.Path = fs.path("tmp");
      d.mkdir_p();
      let _xs: Vec[String] = d.walk_files();
      let dc: fs.Path = d.clean();
      let j: fs.Path = dc.join("x.txt");
      let _bn: String = j.base_name();
      let _dn: String = j.dir_name();
      let _ex: String = j.ext();
      let _st: String = j.stem();
      let _ba: bool = j.is_abs();
      let _cj: String = fs.clean("a/./b");
      let _jj: String = fs.join("a", "b");
      fs.write_string("b.txt", "x");
      let _s2: String = fs.read_to_string("b.txt");
      let _b2: bool = fs.exists("b.txt");
      fs.mkdir_p("tmp2");
      let _xs2: Vec[String] = fs.walk_files("tmp2");
      return 0;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_std_process_command_style_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/process", """
    @ffi_import("c", "system")
    fn c_system(cmd: String) -> i32;
    @ffi_import("c", "vox_impl_args")
    fn rt_args_raw() -> Vec[String];
    @ffi_import("c", "vox_impl_exe_path")
    fn rt_exe_path_raw() -> String;
    @ffi_import("c", "vox_impl_getenv")
    fn rt_getenv_raw(key: String) -> String;
    pub struct EnvVar { key: String, value: String }
    pub struct Command { prog: String, argv: Vec[String], envs: Vec[EnvVar], cwd: String }
    pub fn command(prog: String) -> Command { return Command { prog: prog, argv: Vec(), envs: Vec(), cwd: "" }; }
    fn sh_quote(s: String) -> String { return s; }
    impl Command {
      fn arg(c: Command, a: String) -> Command { let mut out: Command = c; out.argv.push(a); return out; }
      fn args(c: Command, xs: Vec[String]) -> Command {
        let mut out: Command = c;
        let mut i: i32 = 0;
        while i < xs.len() { out.argv.push(xs.get(i)); i = i + 1; }
        return out;
      }
      fn env(c: Command, key: String, value: String) -> Command {
        let mut out: Command = c;
        out.envs.push(EnvVar { key: key, value: value });
        return out;
      }
      fn env_remove(c: Command, key: String) -> Command {
        let mut out: Command = c;
        let mut next: Vec[EnvVar] = Vec();
        let mut i: i32 = 0;
        while i < out.envs.len() {
          let e: EnvVar = out.envs.get(i);
          if e.key != key { next.push(e); }
          i = i + 1;
        }
        out.envs = next;
        return out;
      }
      fn clear_env(c: Command) -> Command {
        let mut out: Command = c;
        out.envs = Vec();
        return out;
      }
      fn cwd(c: Command, dir: String) -> Command {
        let mut out: Command = c;
        out.cwd = dir;
        return out;
      }
      fn render(c: &Command) -> String {
        let mut out: String = "";
        if c.cwd != "" {
          out = out.concat("cd ").concat(sh_quote(c.cwd)).concat(" && ");
        }
        let mut i: i32 = 0;
        while i < c.envs.len() {
          let e: EnvVar = c.envs.get(i);
          out = out.concat(e.key).concat("=").concat(sh_quote(e.value)).concat(" ");
          i = i + 1;
        }
        out = out.concat(sh_quote(c.prog));
        i = 0;
        while i < c.argv.len() {
          out = out.concat(" ").concat(sh_quote(c.argv.get(i)));
          i = i + 1;
        }
        return out;
      }
      fn run(c: &Command) -> i32 { return exec(c.render()); }
    }
    pub fn args() -> Vec[String] { return rt_args_raw(); }
    pub fn exec(cmd: String) -> i32 { return c_system(cmd); }
    pub fn exe_path() -> String { return rt_exe_path_raw(); }
    pub fn getenv(key: String) -> String { return rt_getenv_raw(key); }
  """);
  w = add_mod(w, "main", """
    import "std/process" as p
    fn main() -> i32 {
      let exe: String = p.exe_path();
      let cmd: p.Command = p.command(exe)
        .env("VOX_X", "1")
        .env("VOX_Y", "2")
        .env_remove("VOX_Y")
        .cwd("tmp")
        .arg("version")
        .args(Vec());
      let line: String = cmd.render();
      let _rc0: i32 = p.exec(line);
      let _rc1: i32 = cmd.run();
      let clean: p.Command = cmd.clear_env();
      let _line2: String = clean.render();
      let _as: Vec[String] = p.args();
      let _g: String = p.getenv("HOME");
      return 0;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_string_collections_method_style_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/string", """
    pub struct StrView { owner: String, lo: i32, hi: i32 }
    pub fn view_all(owner: String) -> StrView {
      let n: i32 = owner.len();
      return StrView { owner: owner, lo: 0, hi: n };
    }
    impl StrView {
      fn len(v: StrView) -> i32 { return v.hi - v.lo; }
      fn is_empty(v: StrView) -> bool { return v.hi == v.lo; }
      fn to_string(v: StrView) -> String { return v.owner.slice(v.lo, v.hi); }
      fn contains(v: StrView, needle: String) -> bool { return v.to_string().contains(needle); }
    }
  """);
  w = add_mod(w, "std/collections", """
    pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    pub struct Slice[T] { owner: Vec[T], lo: i32, hi: i32 }
    pub fn view_all[T](owner: Vec[T]) -> Slice[T] {
      let n: i32 = owner.len();
      return Slice { owner: owner, lo: 0, hi: n };
    }
    impl[T] Slice[T] {
      fn len(s: Slice[T]) -> i32 { return s.hi - s.lo; }
      fn is_empty(s: Slice[T]) -> bool { return s.hi == s.lo; }
      fn get(s: Slice[T], idx: i32) -> T { return s.owner.get(s.lo + idx); }
      fn to_vec(s: Slice[T]) -> Vec[T] {
        let mut out: Vec[T] = Vec();
        let mut i: i32 = 0;
        let n: i32 = s.hi - s.lo;
        while i < n {
          out.push(s.owner.get(s.lo + i));
          i = i + 1;
        }
        return out;
      }
    }
    impl[T: Eq] Slice[T] {
      fn contains(s: Slice[T], needle: T) -> bool {
        let mut i: i32 = 0;
        let n: i32 = s.hi - s.lo;
        while i < n {
          if s.owner.get(s.lo + i) == needle { return true; }
          i = i + 1;
        }
        return false;
      }
    }
  """);
  w = add_mod(w, "main", """
    import "std/string" as s
    import "std/collections" as c
    fn main() -> i32 {
      let _stok: bool = s.view_all("vox-lang").contains("vox");

      let mut xs0: Vec[i32] = Vec();
      xs0.push(1);
      xs0.push(2);
      xs0.push(3);
      let sl: c.Slice[i32] = c.view_all(xs0);
      return sl.len();
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_std_net_socket_addr_style_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/sys", """
    @ffi_import("c", "vox_impl_tcp_connect")
    fn rt_tcp_connect_raw(host: String, port: i32) -> isize;
    pub fn connect(host: String, port: i32) -> isize { return rt_tcp_connect_raw(host, port); }
    pub fn listen(host: String, port: i32, backlog: i32) -> isize { host; port; backlog; return -1 as isize; }
    pub fn accept(handle: isize) -> isize { handle; return -1 as isize; }
    pub fn send(handle: isize, text: String, n: usize) -> i32 { handle; text; n; return 0; }
    pub fn recv(handle: isize, max_n: i32) -> String { handle; max_n; return ""; }
    pub fn close_socket(handle: isize) -> () { handle; return; }
    pub fn wait_read(handle: isize, timeout_ms: i32) -> bool { handle; timeout_ms; return false; }
    pub fn wait_write(handle: isize, timeout_ms: i32) -> bool { handle; timeout_ms; return false; }
  """);
  w = add_mod(w, "std/net", """
    import "std/sys" as sys
    pub enum NetProto { Tcp, Udp }
    pub struct SocketAddr { pub proto: NetProto, pub host: String, pub port: i32 }
    pub struct SocketAddrParseResult { pub ok: bool, pub err: String, pub addr: SocketAddr }
    pub struct NetConn { handle: isize, closed: bool }
    pub struct NetI32Result { pub ok: bool, pub err: String, pub n: i32 }
    pub struct NetStringResult { pub ok: bool, pub err: String, pub text: String }
    pub struct NetBoolResult { pub ok: bool, pub err: String, pub ready: bool }
    pub struct NetCloseResult { pub ok: bool, pub err: String, pub conn: NetConn, pub closed_now: bool }
    pub struct TcpListener { handle: isize, closed: bool }
    pub struct UdpSocket { local: SocketAddr }
    pub struct HttpRequest { pub method: String, pub host: String, pub path: String, pub headers: Vec[String], pub body: String }
    pub struct Request { pub url: String, pub inner: HttpRequest }
    pub struct RequestResult { pub ok: bool, pub err: String, pub req: Request }
    pub struct HttpResponseHead { pub code: i32, pub reason: String }
    pub struct Response { pub raw: String, pub status: HttpResponseHead, pub body: String }
    pub struct ResponseResult { pub ok: bool, pub err: String, pub resp: Response }
    pub struct RoundtripResult { pub ok: bool, pub err: String, pub raw: String }
    pub struct Client { recv_limit: i32 }
    pub fn socket_addr(proto: NetProto, host: String, port: i32) -> SocketAddr {
      return SocketAddr { proto: proto, host: host, port: port };
    }
    pub fn tcp_addr(host: String, port: i32) -> SocketAddr { return socket_addr(NetProto.Tcp, host, port); }
    pub fn udp_addr(host: String, port: i32) -> SocketAddr { return socket_addr(NetProto.Udp, host, port); }
    impl SocketAddr {
      fn is_tcp(a: &SocketAddr) -> bool { return match a.proto { NetProto.Tcp => true, _ => false }; }
      fn is_udp(a: &SocketAddr) -> bool { return match a.proto { NetProto.Udp => true, _ => false }; }
      fn uri(a: &SocketAddr) -> String {
        let scheme: String = match a.proto { NetProto.Tcp => "tcp", _ => "udp" };
        return scheme.concat("://").concat(a.host).concat(":").concat(a.port.to_string());
      }
      fn tcp_connect(a: &SocketAddr) -> NetConn {
        return NetConn { handle: sys.connect(a.host, a.port), closed: false };
      }
      fn listen(a: &SocketAddr, backlog: i32) -> TcpListener {
        return TcpListener { handle: sys.listen(a.host, a.port, backlog), closed: false };
      }
      fn bind_udp(a: SocketAddr) -> UdpSocket { return UdpSocket { local: a }; }
    }
    impl NetConn {
      fn is_closed(c: &NetConn) -> bool { return c.closed || c.handle < 0; }
      fn try_send(c: &NetConn, text: String) -> NetI32Result {
        if c.is_closed() { return NetI32Result { ok: false, err: "closed", n: 0 }; }
        return NetI32Result { ok: true, err: "", n: sys.send(c.handle, text, text.len() as usize) };
      }
      fn try_recv(c: &NetConn, max_n: i32) -> NetStringResult {
        if c.is_closed() { return NetStringResult { ok: false, err: "closed", text: "" }; }
        return NetStringResult { ok: true, err: "", text: sys.recv(c.handle, max_n) };
      }
      fn try_wait_read(c: &NetConn, timeout_ms: i32) -> NetBoolResult {
        if c.is_closed() { return NetBoolResult { ok: false, err: "closed", ready: false }; }
        return NetBoolResult { ok: true, err: "", ready: sys.wait_read(c.handle, timeout_ms) };
      }
      fn try_wait_write(c: &NetConn, timeout_ms: i32) -> NetBoolResult {
        if c.is_closed() { return NetBoolResult { ok: false, err: "closed", ready: false }; }
        return NetBoolResult { ok: true, err: "", ready: sys.wait_write(c.handle, timeout_ms) };
      }
      fn send(c: &NetConn, text: String) -> i32 { return c.try_send(text).n; }
      fn recv(c: &NetConn, max_n: i32) -> String { return c.try_recv(max_n).text; }
      fn wait_read(c: &NetConn, timeout_ms: i32) -> bool { return c.try_wait_read(timeout_ms).ready; }
      fn wait_write(c: &NetConn, timeout_ms: i32) -> bool { return c.try_wait_write(timeout_ms).ready; }
      fn try_close(c0: NetConn) -> NetCloseResult {
        let mut c: NetConn = c0;
        if c.is_closed() { c.handle = -1 as isize; c.closed = true; return NetCloseResult { ok: true, err: "", conn: c, closed_now: false }; }
        sys.close_socket(c.handle);
        c.handle = -1 as isize;
        c.closed = true;
        return NetCloseResult { ok: true, err: "", conn: c, closed_now: true };
      }
      fn close(c: NetConn) -> NetConn { return c.try_close().conn; }
    }
    impl TcpListener {
      fn is_closed(l: &TcpListener) -> bool { return l.closed || l.handle < 0; }
      fn close(l0: TcpListener) -> TcpListener {
        let mut l: TcpListener = l0;
        if l.is_closed() { l.handle = -1 as isize; l.closed = true; return l; }
        sys.close_socket(l.handle);
        l.handle = -1 as isize;
        l.closed = true;
        return l;
      }
      fn accept(l: &TcpListener) -> NetConn {
        if l.is_closed() { return NetConn { handle: -1 as isize, closed: true }; }
        return NetConn { handle: sys.accept(l.handle), closed: false };
      }
    }
    pub fn parse_socket_uri(_raw: String) -> SocketAddrParseResult {
      return SocketAddrParseResult { ok: true, err: "", addr: tcp_addr("127.0.0.1", 9000) };
    }
    impl UdpSocket {
      fn local_addr(x: &UdpSocket) -> SocketAddr { return x.local; }
      fn send_to(_x: &UdpSocket, _to: SocketAddr, _data: String) -> i32 { return 0; }
      fn recv_from(_x: &UdpSocket, _max_n: i32) -> String { return ""; }
    }
    pub fn new_request(method: String, url: String) -> RequestResult {
      let req: Request = Request { url: url, inner: HttpRequest { method: method, host: "x", path: "/", headers: Vec(), body: "" } };
      return RequestResult { ok: true, err: "", req: req };
    }
    pub fn request(method: String, url: String) -> Request {
      return Request { url: url, inner: HttpRequest { method: method, host: "x", path: "/", headers: Vec(), body: "" } };
    }
    impl Request {
      fn with_header(r: Request, _name: String, _value: String) -> Request { return r; }
      fn with_body(r: Request, _body: String) -> Request { return r; }
      fn render(_r: &Request) -> String { return "GET / HTTP/1.1\\r\\n\\r\\n"; }
    }
    pub fn response_from_raw(raw: String) -> Response {
      return Response { raw: raw, status: HttpResponseHead { code: 200, reason: "OK" }, body: "" };
    }
    impl Response {
      fn status_code(r: &Response) -> i32 { return r.status.code; }
      fn reason(r: &Response) -> String { return r.status.reason; }
      fn header(_r: &Response, _name: String) -> String { return ""; }
    }
    pub fn http_roundtrip_checked(_url: String, _req: HttpRequest, _recv_limit: i32) -> RoundtripResult {
      return RoundtripResult { ok: true, err: "", raw: "HTTP/1.1 200 OK\\r\\n\\r\\n" };
    }
    pub fn http_roundtrip(_url: String, _req: HttpRequest, _recv_limit: i32) -> String {
      return "HTTP/1.1 200 OK\\r\\n\\r\\n";
    }
    pub fn client() -> Client { return Client { recv_limit: 8192 }; }
    impl Client {
      fn with_recv_limit(c: Client, recv_limit: i32) -> Client {
        let mut out: Client = c;
        out.recv_limit = recv_limit;
        return out;
      }
      fn recv_limit(c: &Client) -> i32 { return c.recv_limit; }
      fn try_send(_c: &Client, req: Request) -> ResponseResult {
        return ResponseResult { ok: true, err: "", resp: response_from_raw(req.render()) };
      }
      fn send(c: &Client, req: Request) -> Response {
        return c.try_send(req).resp;
      }
      fn try_get(c: &Client, _url: String) -> ResponseResult {
        return c.try_send(request("GET", "https://x"));
      }
      fn get(c: &Client, _url: String) -> Response {
        return c.try_get("https://x").resp;
      }
    }
    pub fn http_get(_url: String, _recv_limit: i32) -> String { return "HTTP/1.1 200 OK\\r\\n\\r\\n"; }
  """);
  w = add_mod(w, "main", """
    import "std/net" as net
    fn main() -> i32 {
      let a: net.SocketAddr = net.tcp_addr("127.0.0.1", 9000);
      let _u: String = a.uri();
      let _b0: bool = a.is_tcp();
      let _b1: bool = a.is_udp();
      let _c = a.tcp_connect();
      if false {
        let mut l: net.TcpListener = a.listen(8);
        let _a0: net.NetConn = l.accept();
        l = l.close();
        let _lb: bool = l.is_closed();
      }
      let p: net.SocketAddrParseResult = net.parse_socket_uri("tcp://127.0.0.1:9000");
      if p.ok {
        let _u2: String = p.addr.uri();
      }
      let u: net.SocketAddr = net.udp_addr("0.0.0.0", 53);
      let s: net.UdpSocket = u.bind_udp();
      let _lu: net.SocketAddr = s.local_addr();
      let _sn: i32 = s.send_to(net.udp_addr("127.0.0.1", 53), "x");
      let _rx: String = s.recv_from(16);
      let rq: net.RequestResult = net.new_request("GET", "https://x");
      let req: net.Request = rq.req.with_header("K", "V").with_body("b");
      let _req_text: String = req.render();
      let c0: net.Client = net.client();
      let c: net.Client = c0.with_recv_limit(1024);
      let _lim: i32 = c.recv_limit();
      let rr0: net.ResponseResult = c.try_send(req);
      let _resp0: net.Response = rr0.resp;
      let _resp1: net.Response = c.send(net.request("GET", "https://x"));
      let rr1: net.ResponseResult = c.try_get("https://x");
      let _resp2: net.Response = rr1.resp;
      let resp: net.Response = c.get("https://x");
      let _sc: i32 = resp.status_code();
      let _rs: String = resp.reason();
      let _hv: String = resp.header("X");
      let _raw: String = net.http_get("https://x", 1024);
      return 0;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_fs_virtual_fs_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/fs", """
    pub trait FS {
      fn read_to_string(x: &Self, path: String) -> String;
      fn exists(x: &Self, path: String) -> bool;
      fn walk_files(x: &Self, root: String) -> Vec[String];
    }
    pub trait WritableFS {
      fn write_string(x: Self, path: String, text: String) -> Self;
      fn mkdir_p(x: Self, path: String) -> Self;
    }
    pub struct MemFS { files: Vec[String] }
    pub fn mem_fs() -> MemFS { return MemFS { files: Vec() }; }
    impl MemFS {
      fn read_to_string(_x: &MemFS, _p: String) -> String { return "ok"; }
      fn exists(x: &MemFS, p: String) -> bool {
        let mut i: i32 = 0;
        while i < x.files.len() { if x.files.get(i) == p { return true; } i = i + 1; }
        return false;
      }
      fn walk_files(x: &MemFS, _root: String) -> Vec[String] { return x.files; }
      fn write_string(x: MemFS, p: String, _text: String) -> MemFS {
        let mut ys: Vec[String] = x.files;
        ys.push(p);
        return MemFS { files: ys };
      }
      fn mkdir_p(x: MemFS, _p: String) -> MemFS { return x; }
    }
    impl FS for MemFS {
      fn read_to_string(x: &MemFS, p: String) -> String { return x.read_to_string(p); }
      fn exists(x: &MemFS, p: String) -> bool { return x.exists(p); }
      fn walk_files(x: &MemFS, root: String) -> Vec[String] { return x.walk_files(root); }
    }
    impl WritableFS for MemFS {
      fn write_string(x: MemFS, p: String, text: String) -> MemFS { return x.write_string(p, text); }
      fn mkdir_p(x: MemFS, p: String) -> MemFS { return x.mkdir_p(p); }
    }
    pub fn fs_read_to_string[T: FS](x: T, p: String) -> String { return FS.read_to_string(x, p); }
    pub fn fs_exists[T: FS](x: T, p: String) -> bool { return FS.exists(x, p); }
    pub fn fs_walk_files[T: FS](x: T, root: String) -> Vec[String] { return FS.walk_files(x, root); }
    pub fn fs_write_string[T: WritableFS](x: T, p: String, text: String) -> T { return WritableFS.write_string(x, p, text); }
    pub fn fs_mkdir_p[T: WritableFS](x: T, p: String) -> T { return WritableFS.mkdir_p(x, p); }
  """);
  w = add_mod(w, "main", """
    import "std/fs" as fs
    fn main() -> i32 {
      let mut m: fs.MemFS = fs.mem_fs();
      m = m.mkdir_p("/src");
      m = m.write_string("/src/main.vox", "fn main() -> i32 { return 0; }");
      let _b0: bool = m.exists("/src/main.vox");
      let _s: String = m.read_to_string("/src/main.vox");
      let _xs: Vec[String] = m.walk_files("/src");
      m = fs.fs_mkdir_p(m, "/pkg");
      m = fs.fs_write_string(m, "/pkg/lib.vox", "fn lib() -> i32 { return 1; }");
      let _b1: bool = fs.fs_exists(m, "/pkg/lib.vox");
      let _s2: String = fs.fs_read_to_string(m, "/pkg/lib.vox");
      let _ys: Vec[String] = fs.fs_walk_files(m, "/pkg");
      return 0;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_time_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/time", """
    @ffi_import("c", "vox_impl_now_ns")
    fn rt_now_ns_raw() -> i64;
    pub fn now_ns() -> i64 { return rt_now_ns_raw(); }
  """);
  w = add_mod(w, "main", """
    import "std/time" as tm
    fn main() -> i32 {
      let t0: i64 = tm.now_ns();
      if t0 >= 0 { return 1; }
      return 0;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_time_yield_intrinsic_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/time", """
    @ffi_import("c", "sched_yield")
    fn c_sched_yield() -> i32;
    pub fn yield_now() -> () { let _rc: i32 = c_sched_yield(); _rc; return; }
  """);
  w = add_mod(w, "main", """
    import "std/time" as tm
    fn main() -> i32 {
      tm.yield_now();
      return 0;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_runtime_intrinsic_abi_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/runtime", """
    pub fn intrinsic_abi() -> i32 { return 1; }
    pub fn has_intrinsic(name: String) -> bool { return name == "__read_file"; }
  """);
  w = add_mod(w, "main", """
    import "std/runtime" as rt
    fn main() -> i32 {
      if rt.intrinsic_abi() < 1 { return 1; }
      if rt.has_intrinsic("__read_file") { return 0; }
      return 2;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_rejects_reserved_yield_intrinsic_outside_std() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      __yield_now();
      return 0;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_std_async_wake_intrinsics_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/async", """
    @ffi_import("c", "vox_impl_wake_notify")
    fn rt_wake_notify_raw(token: i64) -> ();
    @ffi_import("c", "vox_impl_wake_wait")
    fn rt_wake_wait_raw(token: i64, timeout_ms: i32) -> bool;
    pub struct Waker { pub token: i64 }
    pub struct Context { pub waker: Waker }
    pub fn wake(c: Context) -> () { rt_wake_notify_raw(c.waker.token); return; }
    pub fn park_until_wake(i: i32, c: Context) -> bool { i; return rt_wake_wait_raw(c.waker.token, 1); }
    pub fn park_any(i: i32, cs: Vec[Context]) -> i32 {
      i;
      if cs.len() == 0 { return -1; }
      if rt_wake_wait_raw(cs.get(0).waker.token, 1) { return 0; }
      let mut j: i32 = 1;
      while j < cs.len() {
        if rt_wake_wait_raw(cs.get(j).waker.token, 0) { return j; }
        j = j + 1;
      }
      return -1;
    }
  """);
  w = add_mod(w, "main", """
    import "std/async" as a
    fn main() -> i32 {
      let cx: a.Context = a.Context { waker: a.Waker { token: 1 } };
      let mut cs: Vec[a.Context] = Vec();
      cs.push(cx);
      a.wake(cx);
      let _idx: i32 = a.park_any(0, cs);
      if a.park_until_wake(0, cx) { return 1; }
      return 0;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_sync_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/sync", """
    @ffi_import("c", "vox_impl_atomic_i32_new")
    fn rt_atomic_i32_new(v: i32) -> isize;
    @ffi_import("c", "vox_impl_atomic_i32_load")
    fn rt_atomic_i32_load(handle: isize) -> i32;
    @ffi_import("c", "vox_impl_atomic_i32_store")
    fn rt_atomic_i32_store(handle: isize, v: i32) -> ();
    @ffi_import("c", "vox_impl_atomic_i32_fetch_add")
    fn rt_atomic_i32_fetch_add(handle: isize, delta: i32) -> i32;
    @ffi_import("c", "vox_impl_atomic_i32_swap")
    fn rt_atomic_i32_swap(handle: isize, v: i32) -> i32;
    pub trait SyncScalar {
      fn mutex_new(v: Self) -> isize;
      fn mutex_load(sample: Self, handle: isize) -> Self;
      fn mutex_store(v: Self, handle: isize) -> ();
      fn atomic_new(v: Self) -> isize;
      fn atomic_load(sample: Self, handle: isize) -> Self;
      fn atomic_store(v: Self, handle: isize) -> ();
      fn atomic_fetch_add(delta: Self, handle: isize) -> Self;
      fn atomic_swap(v: Self, handle: isize) -> Self;
    }
    impl SyncScalar for i32 {
      fn mutex_new(v: i32) -> isize { return rt_atomic_i32_new(v); }
      fn mutex_load(sample: i32, handle: isize) -> i32 { return rt_atomic_i32_load(handle); }
      fn mutex_store(v: i32, handle: isize) -> () { rt_atomic_i32_store(handle, v); }
      fn atomic_new(v: i32) -> isize { return rt_atomic_i32_new(v); }
      fn atomic_load(sample: i32, handle: isize) -> i32 { return rt_atomic_i32_load(handle); }
      fn atomic_store(v: i32, handle: isize) -> () { rt_atomic_i32_store(handle, v); }
      fn atomic_fetch_add(delta: i32, handle: isize) -> i32 { return rt_atomic_i32_fetch_add(handle, delta); }
      fn atomic_swap(v: i32, handle: isize) -> i32 { return rt_atomic_i32_swap(handle, v); }
    }
    pub struct Mutex[T: SyncScalar] { handle: isize, sample: T }
    pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] { return Mutex { handle: SyncScalar.mutex_new(v), sample: v }; }
    pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
    pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
      SyncScalar.mutex_store(v, m.handle);
      return Mutex { handle: m.handle, sample: v };
    }
    pub struct Atomic[T: SyncScalar] { handle: isize, sample: T }
    pub fn atomic[T: SyncScalar](v: T) -> Atomic[T] { return Atomic { handle: SyncScalar.atomic_new(v), sample: v }; }
    pub fn atomic_load[T: SyncScalar](a: Atomic[T]) -> T { return SyncScalar.atomic_load(a.sample, a.handle); }
    pub fn atomic_store[T: SyncScalar](a: Atomic[T], v: T) -> Atomic[T] {
      SyncScalar.atomic_store(v, a.handle);
      return Atomic { handle: a.handle, sample: v };
    }
    pub fn atomic_fetch_add[T: SyncScalar](a: Atomic[T], delta: T) -> Atomic[T] {
      let next: T = SyncScalar.atomic_fetch_add(delta, a.handle);
      return Atomic { handle: a.handle, sample: next };
    }
    pub fn atomic_swap[T: SyncScalar](a: Atomic[T], v: T) -> Atomic[T] {
      let next: T = SyncScalar.atomic_swap(v, a.handle);
      return Atomic { handle: a.handle, sample: next };
    }
  """);
  w = add_mod(w, "main", """
    import "std/sync" as s
    fn main() -> i32 {
      let mut m: s.Mutex[i32] = s.mutex[i32](7);
      let m2: s.Mutex[i32] = m;
      m = s.mutex_store[i32](m, 3);
      let x: i32 = s.mutex_load[i32](m2);
      let mut a: s.Atomic[i32] = s.atomic[i32](1);
      let a2: s.Atomic[i32] = a;
      a = s.atomic_fetch_add[i32](a, 2);
      a = s.atomic_swap[i32](a, 4);
      a = s.atomic_store[i32](a, 5);
      return x + s.atomic_load[i32](a2);
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_sync_i64_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/sync", """
    @ffi_import("c", "vox_impl_atomic_i64_new")
    fn rt_atomic_i64_new(v: i64) -> isize;
    @ffi_import("c", "vox_impl_atomic_i64_load")
    fn rt_atomic_i64_load(handle: isize) -> i64;
    @ffi_import("c", "vox_impl_atomic_i64_store")
    fn rt_atomic_i64_store(handle: isize, v: i64) -> ();
    @ffi_import("c", "vox_impl_atomic_i64_fetch_add")
    fn rt_atomic_i64_fetch_add(handle: isize, delta: i64) -> i64;
    pub trait SyncScalar {
      fn mutex_new(v: Self) -> isize;
      fn mutex_load(sample: Self, handle: isize) -> Self;
      fn mutex_store(v: Self, handle: isize) -> ();
      fn atomic_new(v: Self) -> isize;
      fn atomic_load(sample: Self, handle: isize) -> Self;
      fn atomic_fetch_add(delta: Self, handle: isize) -> Self;
    }
    impl SyncScalar for i64 {
      fn mutex_new(v: i64) -> isize { return rt_atomic_i64_new(v); }
      fn mutex_load(sample: i64, handle: isize) -> i64 { return rt_atomic_i64_load(handle); }
      fn mutex_store(v: i64, handle: isize) -> () { rt_atomic_i64_store(handle, v); }
      fn atomic_new(v: i64) -> isize { return rt_atomic_i64_new(v); }
      fn atomic_load(sample: i64, handle: isize) -> i64 { return rt_atomic_i64_load(handle); }
      fn atomic_fetch_add(delta: i64, handle: isize) -> i64 { return rt_atomic_i64_fetch_add(handle, delta); }
    }
    pub struct Mutex[T: SyncScalar] { handle: isize, sample: T }
    pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] { return Mutex { handle: SyncScalar.mutex_new(v), sample: v }; }
    pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
    pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
      SyncScalar.mutex_store(v, m.handle);
      return Mutex { handle: m.handle, sample: v };
    }
    pub struct Atomic[T: SyncScalar] { handle: isize, sample: T }
    pub fn atomic[T: SyncScalar](v: T) -> Atomic[T] { return Atomic { handle: SyncScalar.atomic_new(v), sample: v }; }
    pub fn atomic_load[T: SyncScalar](a: Atomic[T]) -> T { return SyncScalar.atomic_load(a.sample, a.handle); }
    pub fn atomic_fetch_add[T: SyncScalar](a: Atomic[T], d: T) -> Atomic[T] {
      let next: T = SyncScalar.atomic_fetch_add(d, a.handle);
      return Atomic { handle: a.handle, sample: next };
    }
  """);
  w = add_mod(w, "main", """
    import "std/sync" as s
    fn main() -> i32 {
      let mut m: s.Mutex[i64] = s.mutex[i64](7 as i64);
      let m2: s.Mutex[i64] = m;
      m = s.mutex_store[i64](m, 9 as i64);
      let x: i64 = s.mutex_load[i64](m2);
      let mut a: s.Atomic[i64] = s.atomic[i64](3 as i64);
      a = s.atomic_fetch_add[i64](a, 4 as i64);
      let y: i64 = s.atomic_load[i64](a);
      return (x + y) as i32;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_std_io_net_intrinsics_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/sys", """
    @ffi_import("c", "vox_impl_tcp_connect")
    fn rt_tcp_connect_raw(host: String, port: i32) -> isize;
    @ffi_import("c", "send")
    fn rt_send_raw(fd: i32, buf: const rawptr, n: usize, flags: i32) -> isize;
    @ffi_import("c", "vox_impl_tcp_recv")
    fn rt_tcp_recv_raw(handle: isize, max_n: i32) -> String;
    @ffi_import("c", "vox_impl_tcp_close")
    fn rt_tcp_close_raw(handle: isize) -> ();
    @ffi_import("c", "vox_impl_tcp_wait_read")
    fn rt_tcp_wait_read_raw(handle: isize, timeout_ms: i32) -> bool;
    @ffi_import("c", "vox_impl_tcp_wait_write")
    fn rt_tcp_wait_write_raw(handle: isize, timeout_ms: i32) -> bool;
    fn handle_to_fd(handle: isize) -> i32 {
      if handle < -2147483648 as isize || handle > 2147483647 as isize {
        panic("tcp handle out of i32 range");
      }
      return handle as i32;
    }
    pub fn connect(host: String, port: i32) -> isize { return rt_tcp_connect_raw(host, port); }
    pub fn send(handle: isize, text: String, n: usize) -> i32 {
      let fd: i32 = handle_to_fd(handle);
      let sent: isize = rt_send_raw(fd, text as const rawptr, n, 0);
      if sent < 0 { panic("tcp send failed"); }
      if sent > 2147483647 as isize { panic("tcp send count too large"); }
      return sent as i32;
    }
    pub fn recv(handle: isize, max_n: i32) -> String { return rt_tcp_recv_raw(handle, max_n); }
    pub fn close_socket(handle: isize) -> () { rt_tcp_close_raw(handle); return; }
    pub fn wait_read(handle: isize, timeout_ms: i32) -> bool { return rt_tcp_wait_read_raw(handle, timeout_ms); }
    pub fn wait_write(handle: isize, timeout_ms: i32) -> bool { return rt_tcp_wait_write_raw(handle, timeout_ms); }
  """);
  w = add_mod(w, "std/net", """
    import "std/sys" as sys
    pub struct SocketAddr { host: String, port: i32 }
    pub struct NetConn { handle: isize, closed: bool }
    pub struct NetI32Result { pub ok: bool, pub err: String, pub n: i32 }
    pub struct NetStringResult { pub ok: bool, pub err: String, pub text: String }
    pub struct NetBoolResult { pub ok: bool, pub err: String, pub ready: bool }
    pub struct NetCloseResult { pub ok: bool, pub err: String, pub conn: NetConn, pub closed_now: bool }
    pub fn tcp_addr(host: String, port: i32) -> SocketAddr { return SocketAddr { host: host, port: port }; }
    pub fn closed_conn() -> NetConn { return NetConn { handle: -1 as isize, closed: true }; }
    impl SocketAddr {
      fn tcp_connect(a: &SocketAddr) -> NetConn {
        return NetConn { handle: sys.connect(a.host, a.port), closed: false };
      }
    }
    impl NetConn {
      fn is_closed(c: &NetConn) -> bool { return c.closed || c.handle < 0; }
      fn try_send(c: &NetConn, text: String) -> NetI32Result {
        if c.is_closed() { return NetI32Result { ok: false, err: "closed", n: 0 }; }
        return NetI32Result { ok: true, err: "", n: sys.send(c.handle, text, text.len() as usize) };
      }
      fn try_recv(c: &NetConn, max_n: i32) -> NetStringResult {
        if c.is_closed() { return NetStringResult { ok: false, err: "closed", text: "" }; }
        return NetStringResult { ok: true, err: "", text: sys.recv(c.handle, max_n) };
      }
      fn try_wait_read(c: &NetConn, timeout_ms: i32) -> NetBoolResult {
        if c.is_closed() { return NetBoolResult { ok: false, err: "closed", ready: false }; }
        return NetBoolResult { ok: true, err: "", ready: sys.wait_read(c.handle, timeout_ms) };
      }
      fn try_wait_write(c: &NetConn, timeout_ms: i32) -> NetBoolResult {
        if c.is_closed() { return NetBoolResult { ok: false, err: "closed", ready: false }; }
        return NetBoolResult { ok: true, err: "", ready: sys.wait_write(c.handle, timeout_ms) };
      }
      fn send(c: &NetConn, text: String) -> i32 { return c.try_send(text).n; }
      fn recv(c: &NetConn, max_n: i32) -> String { return c.try_recv(max_n).text; }
      fn wait_read(c: &NetConn, timeout_ms: i32) -> bool { return c.try_wait_read(timeout_ms).ready; }
      fn wait_write(c: &NetConn, timeout_ms: i32) -> bool { return c.try_wait_write(timeout_ms).ready; }
      fn try_close(c0: NetConn) -> NetCloseResult {
        let mut c: NetConn = c0;
        if c.is_closed() { c.handle = -1 as isize; c.closed = true; return NetCloseResult { ok: true, err: "", conn: c, closed_now: false }; }
        sys.close_socket(c.handle);
        c.handle = -1 as isize;
        c.closed = true;
        return NetCloseResult { ok: true, err: "", conn: c, closed_now: true };
      }
      fn close(c: NetConn) -> NetConn { return c.try_close().conn; }
    }
  """);
  w = add_mod(w, "main", """
    import "std/net" as net
    fn main() -> i32 {
      let a: net.SocketAddr = net.tcp_addr("127.0.0.1", 7);
      let mut c: net.NetConn = a.tcp_connect();
      let _n: i32 = c.send("ping");
      let _s: String = c.recv(16);
      let _r: bool = c.wait_read(1);
      let _w: bool = c.wait_write(1);
      let _t0: net.NetI32Result = c.try_send("x");
      let _t1: net.NetStringResult = c.try_recv(8);
      let _t2: net.NetBoolResult = c.try_wait_read(1);
      let _t3: net.NetBoolResult = c.try_wait_write(1);
      let cr: net.NetCloseResult = c.try_close();
      c = cr.conn;
      c = c.close();
      let _is_closed: bool = c.is_closed();
      return 0;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_ifexpr_and_field_push() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct S { items: Vec[i32] }
    fn main() -> i32 {
      let mut s: S = S { items: Vec() };
      let x: i32 = if true { 40 } else { 0 };
      s.items.push(x);
      s.items.push(2);
      return s.items.get(0) + s.items.get(1) + s.items.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_nested_field_push_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      o.inner.items.push(40);
      o.inner.items.push(2);
      return o.inner.items.get(0) + o.inner.items.get(1) + o.inner.items.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_insert_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.insert(0, 9);
      return v.get(0) + v.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_is_empty_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      if v.is_empty() { v.push(7); }
      return if !v.is_empty() && v.len() == 1 { 1 } else { 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_set_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.push(2);
      v.set(1, 9);
      return v.get(1);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_clear_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.push(2);
      v.clear();
      return if v.len() == 0 { 1 } else { 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_extend_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let mut a: Vec[i32] = Vec();
      a.push(1);
      let mut b: Vec[i32] = Vec();
      b.push(2);
      b.push(3);
      a.extend(b);
      return if a.len() == 3 { 1 } else { 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_pop_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.push(2);
      let x: i32 = v.pop();
      return x + v.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_remove_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.push(2);
      let x: i32 = v.remove(0);
      return x + v.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_nested_field_clear_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      o.inner.items.push(7);
      o.inner.items.clear();
      return if o.inner.items.len() == 0 { 1 } else { 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_nested_field_extend_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      let mut extra: Vec[i32] = Vec();
      extra.push(7);
      extra.push(8);
      o.inner.items.extend(extra);
      return if o.inner.items.len() == 2 { 1 } else { 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_nested_field_pop_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      o.inner.items.push(7);
      o.inner.items.push(8);
      return o.inner.items.pop();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_nested_field_remove_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      o.inner.items.push(7);
      o.inner.items.push(8);
      return o.inner.items.remove(0);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_nested_field_insert_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      o.inner.items.push(8);
      o.inner.items.insert(0, 7);
      return o.inner.items.get(0);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_nested_field_set_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      o.inner.items.push(8);
      o.inner.items.set(0, 7);
      return o.inner.items.get(0);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_vec_push_rejects_immutable_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      v.push(1);
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.push receiver is immutable"));
}

fn test_typecheck_vec_insert_rejects_immutable_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      v.insert(0, 1);
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.insert receiver is immutable"));
}

fn test_typecheck_vec_set_rejects_immutable_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      v.set(0, 1);
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.set receiver is immutable"));
}

fn test_typecheck_vec_extend_rejects_immutable_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      let w2: Vec[i32] = Vec();
      v.extend(w2);
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.extend receiver is immutable"));
}

fn test_typecheck_vec_clear_rejects_immutable_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      v.clear();
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.clear receiver is immutable"));
}

fn test_typecheck_vec_pop_rejects_immutable_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      let x: i32 = v.pop();
      return x;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.pop receiver is immutable"));
}

fn test_typecheck_vec_remove_rejects_immutable_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      let x: i32 = v.remove(0);
      return x;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.remove receiver is immutable"));
}

fn test_typecheck_vec_push_rejects_non_place_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn mk() -> Vec[i32] {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      return v;
    }
    fn main() -> i32 {
      mk().push(2);
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.push receiver must be mutable place"));
}

fn test_typecheck_vec_insert_rejects_non_place_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn mk() -> Vec[i32] {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      return v;
    }
    fn main() -> i32 {
      mk().insert(0, 2);
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.insert receiver must be mutable place"));
}

fn test_typecheck_vec_set_rejects_non_place_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn mk() -> Vec[i32] {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      return v;
    }
    fn main() -> i32 {
      mk().set(0, 2);
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.set receiver must be mutable place"));
}

fn test_typecheck_vec_extend_rejects_non_place_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn mk() -> Vec[i32] {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      return v;
    }
    fn main() -> i32 {
      let mut extra: Vec[i32] = Vec();
      extra.push(2);
      mk().extend(extra);
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.extend receiver must be mutable place"));
}

fn test_typecheck_vec_clear_rejects_non_place_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn mk() -> Vec[i32] {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      return v;
    }
    fn main() -> i32 {
      mk().clear();
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.clear receiver must be mutable place"));
}

fn test_typecheck_vec_pop_rejects_non_place_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn mk() -> Vec[i32] {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      return v;
    }
    fn main() -> i32 {
      return mk().pop();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.pop receiver must be mutable place"));
}

fn test_typecheck_vec_remove_rejects_non_place_receiver() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn mk() -> Vec[i32] {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      return v;
    }
    fn main() -> i32 {
      return mk().remove(0);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec.remove receiver must be mutable place"));
}

fn test_typecheck_nested_field_assign_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct I { x: i32 }\nstruct O { i: I }\nfn main() -> i32 {\n  let mut o: O = O { i: I { x: 1 } };\n  o.i.x = 2;\n  o.i.x += 3;\n  return o.i.x;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_nested_field_compound_assign_all_ops_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct I { x: i32 }
    struct O { i: I }
    fn main() -> i32 {
      let mut o: O = O { i: I { x: 255 } };
      o.i.x += 1;
      o.i.x -= 2;
      o.i.x *= 3;
      o.i.x /= 4;
      o.i.x %= 5;
      o.i.x &= 6;
      o.i.x |= 7;
      o.i.x ^= 8;
      o.i.x <<= 1;
      o.i.x >>= 2;
      return o.i.x;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_cmp_u32_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: u32 = 1;\n  if x < 2 { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_float_arith_compare_and_to_string_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: f64 = 1.25;\n  let y: f64 = x + 2.75;\n  let s: String = y.to_string();\n  if y > 3.0 && s.len() > 0 { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_float_mod_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: f64 = 5.5 % 2.0;\n  if x > 1.0 { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_string_ordered_compare_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  if \"ab\" < \"ac\" { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_string_to_string_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let s: String = \"vox\";\n  let t2: String = s.to_string();\n  return t2.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_bare_str_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let s: str = "vox";
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "bare str is not allowed"), msg);
}

fn test_typecheck_ref_str_alias_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn len1(s: &str) -> i32 { return s.len(); }
    fn main() -> i32 { return len1("vox"); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_ref_static_str_alias_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn id(s: &'static str) -> &'static str { return s; }
    fn main() -> i32 { let s: &'static str = id("vox"); return s.len(); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_ref_i32_alias_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn add1(x: &i32) -> i32 { return x + 1; }
    fn main() -> i32 {
      let v: i32 = 41;
      return add1(v);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_ref_mut_i32_alias_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn add1(x: &mut i32) -> i32 { return x + 1; }
    fn main() -> i32 {
      let mut v: i32 = 41;
      return add1(v);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_ref_mut_arg_requires_mutable_place() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn add1(x: &mut i32) -> i32 { return x + 1; }
    fn main() -> i32 { return add1(41); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "must be mutable place"), msg);
}

fn test_typecheck_ref_mut_arg_rejects_immutable_place() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn add1(x: &mut i32) -> i32 { return x + 1; }
    fn main() -> i32 {
      let v: i32 = 41;
      return add1(v);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "is immutable"), msg);
}

fn test_typecheck_ref_arg_requires_place() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn add1(x: &i32) -> i32 { return x + 1; }
    fn main() -> i32 { return add1(41); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "for & parameter must be place"), msg);
}

fn test_typecheck_ref_named_lifetime_rejected() -> () {
  let src: String = """
    fn bad(s: &'a str) -> i32 { return s.len(); }
    fn main() -> i32 { return 0; }
  """;
  let r: p.ParseResult = parse_prog(src);
  t.assert(r.err != p.ParseError.None);
  let msg: String = p.parse_error_to_string(r.err);
  t.assert_with(contains(msg, "only 'static is allowed"), msg);
}

fn test_typecheck_ref_mut_named_lifetime_rejected() -> () {
  let src: String = """
    fn bad(s: &'a mut i32) -> i32 { return s; }
    fn main() -> i32 { return 0; }
  """;
  let r: p.ParseResult = parse_prog(src);
  t.assert(r.err != p.ParseError.None);
  let msg: String = p.parse_error_to_string(r.err);
  t.assert_with(contains(msg, "only 'static is allowed"), msg);
}

fn test_typecheck_ref_named_lifetime_in_let_annotation_rejected() -> () {
  let src: String = "fn main() -> i32 { let x: &'a i32 = 1; return x; }";
  let r: p.ParseResult = parse_prog(src);
  t.assert(r.err != p.ParseError.None);
  let msg: String = p.parse_error_to_string(r.err);
  t.assert_with(contains(msg, "only 'static is allowed"), msg);
}

fn test_typecheck_ref_nonstatic_return_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn bad(x: &i32) -> &i32 { return x; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "non-static borrowed type is not allowed in return type"), msg);
}

fn test_typecheck_ref_nonstatic_struct_field_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct S { x: &i32 }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "non-static borrowed type is not allowed in struct field"), msg);
}

fn test_typecheck_ref_nonstatic_enum_variant_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { V(&i32) }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "non-static borrowed type is not allowed in enum variant"), msg);
}

fn test_typecheck_ref_nonstatic_type_alias_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type R = &i32;\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "non-static borrowed type is not allowed in type alias"), msg);
}

fn test_typecheck_ref_nonstatic_container_param_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn bad(xs: Vec[&i32]) -> i32 { return xs.len(); }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "non-static borrowed type in parameter must be top-level &T or &mut T"), msg);
}

fn test_typecheck_ref_nonstatic_container_let_annotation_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 { let xs: Vec[&i32] = Vec(); return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "non-static borrowed type in let annotation must be top-level &T or &mut T"), msg);
}

fn test_typecheck_ref_let_init_requires_place() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 { let r: &i32 = 41; return r; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "let init for & annotation must be place"), msg);
}

fn test_typecheck_ref_let_init_from_place_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 { let v: i32 = 41; let r: &i32 = v; return r; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_ref_mut_let_init_requires_mutable_place() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 { let v: i32 = 41; let r: &mut i32 = v; return r; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "let init for &mut annotation is immutable"), msg);
}

fn test_typecheck_ref_mut_let_init_from_mutable_place_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 { let mut v: i32 = 41; let r: &mut i32 = v; return r; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_string_is_empty_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let s0: String = "";
      let s1: String = "vox";
      return if s0.is_empty() && !s1.is_empty() { 1 } else { 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_string_predicate_methods_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let s: String = "vox-lang";
      if s.starts_with("vox") && s.ends_with("lang") && s.contains("-") { return 1; }
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_string_index_methods_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main() -> i32 {
      let s: String = "vox-lang-vox";
      let i0: i32 = s.index_of("vox");
      let i1: i32 = s.last_index_of("vox");
      let i2: i32 = s.index_of("zzz");
      if i0 == 0 && i1 == 9 && i2 == -1 { return 1; }
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_float_cast_f64_to_f32_and_back_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: f64 = 1.5;\n  let y: f32 = x as f32;\n  let z: f64 = y as f64;\n  if z >= 1.0 { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_int_float_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: i32 = 7;\n  let y: f64 = x as f64;\n  let z: i32 = y as i32;\n  return z;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_float_scientific_and_suffix_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let a: f64 = 1e3;\n  let b: f32 = 2.5e-2f32;\n  let c: f64 = b as f64;\n  if a > c { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_float_suffix_conflict_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: f64 = 1.0f32;\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_i16_u16_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let a: i16 = -5;\n  let b: u16 = 7;\n  let x: i32 = (a as i32) + (b as i32);\n  return x;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_isize_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let a: isize = -5;\n  let x: i64 = a as i64;\n  return x as i32;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_bitwise_shift_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let a: i32 = 6 & 3;\n  let b: i32 = 1 << 4;\n  let c: i32 = b >> 2;\n  return (a | c) ^ 1;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_bitwise_bool_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let a: bool = true;\n  let b: bool = false;\n  let x: bool = a & b;\n  if x { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_unary_not_int_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: i32 = !1;\n  return x;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_unary_not_float_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: f64 = !1.0;\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_unary_plus_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> i32 {\n  let x: i32 = +1;\n  let y: f64 = +1.5;\n  if y > 1.0 { return x; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_compound_assign_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct S { x: i32 }
    fn main() -> i32 {
      let mut x: i32 = 32;
      x += 10;
      x -= 2;
      x *= 3;
      x /= 5;
      x %= 7;
      x <<= 4;
      x >>= 3;
      x &= 3;
      x |= 8;
      x ^= 15;
      let mut s: S = S { x: 32 };
      s.x += 10;
      s.x -= 2;
      s.x *= 3;
      s.x /= 5;
      s.x %= 7;
      s.x <<= 4;
      s.x >>= 3;
      s.x &= 3;
      s.x |= 8;
      s.x ^= 15;
      return x + s.x;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_i64_arith_coerces_int_lit_to_context() -> () {
  let mut w: tc.World = tc.world();
  // Regression: `0 - y` should typecheck under i64 context (self-hosting relies on this).
  let src: String = "fn main() -> i32 {\n  let y: i64 = 1;\n  let x: i64 = 0 - y;\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_i64_arith_coerces_int_lit_to_context_struct_field() -> () {
  let mut w: tc.World = tc.world();
  // Also cover the common `0 - s.iv` form.
  let src: String = "struct S { iv: i64 }\nfn main() -> i32 {\n  let s: S = S { iv: 1 };\n  let x: i64 = 0 - s.iv;\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_enum_ctor_and_match() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let x: E = E.A(1);\n  let y: i32 = match x { E.A(v) => v, E.None => 0, };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_struct_instantiation_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Pair[T] { a: T, b: T }\nfn main() -> i32 {\n  let p: Pair[i32] = Pair { a: 1, b: 2 };\n  return p.a + p.b;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_struct_instantiation_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Pair[T] { a: T, b: T }\nstruct Box[T] { a: T, b: T }\nfn main() -> i32 {\n  let _p: Pair[i32] = Box { a: 1, b: 2 };\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_generic_enum_instantiation_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum Option[T] { Some(T), None }\nfn main() -> i32 {\n  let x: Option[i32] = Option.Some(7);\n  return match x { Option.Some(v) => v, Option.None => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_typed_path_struct_lit_without_expected_type() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Pair[T] { a: T, b: T }\nfn main() -> i32 {\n  let p = Pair[i32] { a: 1, b: 2 };\n  return p.a + p.b;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_typed_path_enum_ctor_and_unit_variant_without_expected_type() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    enum Option[T] { Some(T), None }
    fn main() -> i32 {
      let a = Option[i32].Some(7);
      let b = Option[i32].None;
      let x: i32 = match a { Option.Some(v) => v, Option.None => 0 };
      let y: i32 = match b { Option.Some(v) => v, Option.None => 1 };
      return x + y;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_nominal_requires_type_args() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Pair[T] { a: T, b: T }\nfn main() -> i32 {\n  let p: Pair = Pair { a: 1, b: 2 };\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_u32_patterns_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u32) -> i32 {\n  let y: i32 = match x { 0 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_u8_patterns_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u8) -> i32 {\n  let y: i32 = match x { 0 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_u64_max_pattern_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u64) -> i32 {\n  let y: i32 = match x { 18446744073709551615 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_i8_pat_literal_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i8) -> i32 {\n  let y: i32 = match x { 200 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_u8_pat_literal_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u8) -> i32 {\n  let y: i32 = match x { 300 => 1, _ => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_negative_int_pattern_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  let y: i32 = match x { -1 => 0, _ => 1 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_negative_int_pattern_rejected_for_u8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: u8) -> i32 {\n  let y: i32 = match x { -1 => 0, _ => 1 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_nested_variant_patterns_requires_variant_catchall() -> () {
  // Missing coverage for Ok(O.None).
  let mut w: tc.World = tc.world();
  let src: String = "enum O { Some(i32), None }\nenum R { Ok(O), Err(i32) }\nfn main(x: R) -> i32 {\n  return match x {\n    R.Ok(O.Some(v)) => v,\n    R.Err(_) => -1,\n  };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_nested_variant_patterns_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum O { Some(i32), None }\nenum R { Ok(O), Err(i32) }\nfn main(x: R) -> i32 {\n  return match x {\n    R.Ok(O.Some(v)) => v,\n    R.Ok(O.None) => 0,\n    R.Err(_) => -1,\n  };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_int_requires_wildcard() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  let y: i32 = match x { 0 => 1, 1 => 2 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_bool_patterns_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: bool) -> i32 {\n  return match x { true => 1, false => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_match_bool_non_exhaustive_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: bool) -> i32 {\n  return match x { true => 1 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_rejects_unreachable_after_wildcard() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main(x: i32) -> i32 {\n  let y: i32 = match x { _ => 0, 1 => 1 };\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_match_rejects_unreachable_after_enum_variant_fully_covered() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    enum O { Some(i32), None }
    enum R { Ok(O), Err(i32) }
    fn main(x: R) -> i32 {
      return match x {
        R.Ok(O.Some(v)) => v,
        R.Ok(O.None) => 0,
        R.Ok(_o) => 0,
        R.Err(_) => -1,
      };
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_enum_unit_equality_allows_if_condition() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let x: E = E.A(1);\n  if x == E.None { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_enum_payload_equality_allows_if_condition() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), None }\nfn main() -> i32 {\n  let a: E = E.A(1);\n  let b: E = E.A(1);\n  if a == b { return 1; }\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_enum_payload_equality_rejects_non_eq_field() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(Vec[i32]), None }\nfn main() -> i32 {\n  let mut x: Vec[i32] = Vec();\n  let mut y: Vec[i32] = Vec();\n  let a: E = E.A(x);\n  let b: E = E.A(y);\n  return if a == b { 1 } else { 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_struct_equality_allows_if_condition() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct S { a: i32, b: String }\nfn main() -> i32 {\n  let x: S = S { a: 1, b: \"v\" };\n  let y: S = S { a: 1, b: \"v\" };\n  return if x == y { 1 } else { 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_struct_equality_rejects_non_eq_field() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct S { v: Vec[i32] }
    fn main() -> i32 {
      let mut x: Vec[i32] = Vec();
      let mut y: Vec[i32] = Vec();
      let a: S = S { v: x };
      let b: S = S { v: y };
      return if a == b { 1 } else { 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_prelude_print_and_builtin_panic() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub fn print(msg: String) -> () { panic(msg); }");
  w = add_mod(w, "main", "fn main() -> () { print(\"hi\"); panic(\"bye\"); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_compile_error_rejected_with_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> i32 { @compile_error(\"boom\"); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "compile_error: boom"));
}

fn test_typecheck_const_compile_error_rejected_with_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const X: i32 = @compile_error(\"const-boom\")\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "compile_error: const-boom"));
}

fn test_typecheck_reflect_intrinsics_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    type R = @range(0..=7) i32
    struct S { a: i32, b: i64 }
    enum E { A(i32), B }
    const SZ: usize = @size_of(S)
    const AL: usize = @align_of(S)
    const FC_S: usize = @field_count(S)
    const FC_E: usize = @field_count(E)
    const FN0: String = @field_name(S, 0)
    const VN1: String = @field_name(E, 1)
    const FT1: String = @field_type(S, 1)
    const ET0: String = @field_type(E, 0)
    const ET1: String = @field_type(E, 1)
    const FTY1: TypeId = @field_type_id(S, 1)
    const ETY0: TypeId = @field_type_id(E, 0)
    const ETY1: TypeId = @field_type_id(E, 1)
    const TY_S: TypeId = @type(S)
    const TY_I32: TypeId = @type(i32)
    const TY_I64: TypeId = @type(i64)
    const TN: String = @type_name(S)
    const EQTY: bool = @same_type(i32, i32)
    const NETY: bool = @same_type(i32, i64)
    const A0: bool = @assignable_to(R, i32)
    const A1: bool = @assignable_to(i32, R)
    const A2: bool = @assignable_to(i32, i32)
    const C0: bool = @castable_to(i32, f64)
    const C1: bool = @castable_to(String, i32)
    const E2E0: bool = @eq_comparable_with(S, S)
    const E2E1: bool = @eq_comparable_with(Vec[i32], Vec[i32])
    const O2O0: bool = @ordered_with(String, String)
    const O2O1: bool = @ordered_with(S, S)
    const I0: bool = @is_integer(i32)
    const I1: bool = @is_integer(S)
    const SI: bool = @is_signed_int(i64)
    const SU: bool = @is_unsigned_int(u64)
    const F0: bool = @is_float(f64)
    const B0: bool = @is_bool(bool)
    const S0: bool = @is_string(String)
    const ST: bool = @is_struct(S)
    const EN: bool = @is_enum(E)
    const V0: bool = @is_vec(Vec[i32])
    const R0: bool = @is_range(R)
    const EQC0: bool = @is_eq_comparable(S)
    const EQC1: bool = @is_eq_comparable(Vec[i32])
    const ORD0: bool = @is_ordered(String)
    const ORD1: bool = @is_ordered(S)
    const U0: bool = @is_unit(())
    const U1: bool = @is_unit(i32)
    const N0: bool = @is_numeric(i32)
    const N1: bool = @is_numeric(String)
    fn main() -> i32 {
      return if SZ >= AL && FC_S == 2 && FC_E == 2 && FN0 == "a" && VN1 == "B" &&
          FT1 == "i64" && ET0 == "i32" && ET1 == "()" && FTY1 == TY_I64 && ETY0 == TY_I32 &&
          ETY1 == @type(()) && TY_S == @type(S) && TY_I32 != TY_I64 && EQTY && !NETY &&
          A0 && !A1 && A2 && C0 && !C1 && E2E0 && !E2E1 && O2O0 && !O2O1 &&
          I0 && !I1 && SI && SU && F0 && B0 && S0 && ST && EN && V0 && R0 &&
          EQC0 && !EQC1 && ORD0 && !ORD1 && U0 && !U1 && N0 && !N1 && TN.len() > 0 { 1 } else { 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_reflect_layout_intrinsics_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    const Z0: bool = @is_zero_sized(())
    const Z1: bool = @is_zero_sized(i32)
    const L0: bool = @same_layout(i32, u32)
    const L1: bool = @same_layout(i32, i64)
    const B0: bool = @bitcastable(i32, u32)
    const B1: bool = @bitcastable(i32, i64)
    fn main() -> i32 { return if Z0 && !Z1 && L0 && !L1 && B0 && !B1 { 1 } else { 0 }; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_type_alias_field_type_struct_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct S { a: i32, b: String }
    type B = @field_type(S, 1)
    fn main() -> i32 {
      let x: B = "ok";
      return x.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_type_alias_field_type_enum_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    enum E { A(i64), B }
    type TA = @field_type(E, 0)
    type TB = @field_type(E, 1)
    fn touch(x: TB) -> i32 { return 0; }
    fn main() -> i32 {
      let a: TA = 7;
      return a as i32;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_type_alias_field_type_multi_payload_enum_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    enum E { A(i32, i64), B }
    type T = @field_type(E, 0)
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_type_alias_field_type_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct S { a: i32 }
    type T = @field_type(S, 1)
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_type_alias_field_type_generic_nominal_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Pair[T] { a: T, b: T }
    enum Wrap[T] { One(T), None }
    type PA = @field_type(Pair[i32], 0)
    type WA = @field_type(Wrap[i64], 0)
    type WN = @field_type(Wrap[i64], 1)
    fn touch(x: WN) -> i32 { return 0; }
    fn main() -> i32 {
      let a: PA = 3;
      let b: WA = 4;
      return a + (b as i32);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_reflect_intrinsic_unknown_type_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> usize { return @size_of(UnknownType); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_reflect_intrinsic_field_count_non_nominal_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const N: usize = @field_count(i32)\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_reflect_intrinsic_field_name_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct S { a: i32 }\nconst N: String = @field_name(S, 1)\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_reflect_intrinsic_field_type_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct S { a: i32 }\nconst N: String = @field_type(S, 1)\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_reflect_intrinsic_field_type_id_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct S { a: i32 }\nconst N: TypeId = @field_type_id(S, 1)\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_reflect_intrinsic_field_type_id_multi_payload_enum_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    enum E { A(i32, i64), B(i32, i64), C(i32, i32), D }
    const T0: TypeId = @field_type_id(E, 0)
    const T1: TypeId = @field_type_id(E, 1)
    const T2: TypeId = @field_type_id(E, 2)
    const TD: TypeId = @field_type_id(E, 3)
    const OK0: bool = T0 == T1
    const OK1: bool = T0 != T2
    const OK2: bool = TD == @type(())
    fn main() -> i32 { return if OK0 && OK1 && OK2 { 1 } else { 0 }; }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_rejects_unknown_fn() -> () {
  let mut w: tc.World = tc.world();
  // Put the error at a stable location: line 2, col 1.
  w = add_mod(w, "main", "fn main() -> i32 {\nnope();\nreturn 0;\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.slice(0, "src/main.vox:2:1:".len()) == "src/main.vox:2:1:");
  // We want a specific reason, not just "bad expr".
  t.assert(contains(msg, "unknown fn"));
  t.assert(contains(msg, "nope"));
}

fn test_typecheck_error_has_file_line_col_prefix() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> i32 {\nnope();\nreturn 0;\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.slice(0, "src/main.vox:2:1:".len()) == "src/main.vox:2:1:");
}

fn test_typecheck_const_error_uses_expr_span() -> () {
  let mut w: tc.World = tc.world();
  // Keep leading blank lines so we can assert const diagnostics are not stuck at 1:1.
  let src: String = "\n\nconst N: i32 = 1 / 0\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(starts_with(msg, "src/main.vox:3:"));
  t.assert(contains(msg, "const division by zero"));
}

fn test_typecheck_error_column_uses_rune_index() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> i32 {\n\"\"; nope();\nreturn 0;\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(starts_with(msg, "src/main.vox:2:6:"));
  t.assert(contains(msg, "unknown fn"));
}

fn test_typecheck_duplicate_trait_reports_decl_span() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "trait A {}\ntrait A {}\nfn main() -> i32 { return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.slice(0, "src/main.vox:2:1:".len()) == "src/main.vox:2:1:");
  t.assert(contains(msg, "duplicate trait"));
}

fn test_typecheck_rejects_vec_ctor_without_expected_ty() -> () {
  let mut w: tc.World = tc.world();
  // `Vec()` requires an expected `Vec[T]` type (e.g. from an annotation or struct field).
  w = add_mod(w, "main", "fn main() -> i32 {\nVec();\nreturn 0;\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "Vec()"));
  t.assert(contains(msg, "expected"));
}

fn test_typecheck_wrong_number_of_args_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn f(x: i32) -> i32 { return x; }\nfn main() -> i32 {\n  return f(1, 2);\n}");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "wrong number of args"));
  t.assert(contains(msg, "expected 1"));
  t.assert(contains(msg, "got 2"));
}

fn test_typecheck_call_arg_type_mismatch_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn f(x: i32) -> i32 { return x; }\nfn main() -> i32 { return f(\"x\"); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "call arg #1 type mismatch"), msg);
  t.assert_with(contains(msg, "expected i32"), msg);
  t.assert_with(contains(msg, "got String"), msg);
}

fn test_typecheck_call_arg_type_mismatch_message_shows_ref_expected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn f(x: &i32) -> i32 { return x + 1; }\nfn main() -> i32 { let s: String = \"x\"; return f(s); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "call arg #1 type mismatch"), msg);
  t.assert_with(contains(msg, "expected &i32"), msg);
  t.assert_with(contains(msg, "got String"), msg);
}

fn test_typecheck_call_arg_type_mismatch_message_shows_ref_mut_expected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn f(x: &mut i32) -> i32 { return x + 1; }\nfn main() -> i32 { let mut s: String = \"x\"; return f(s); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "call arg #1 type mismatch"), msg);
  t.assert_with(contains(msg, "expected &mut i32"), msg);
  t.assert_with(contains(msg, "got String"), msg);
}

fn test_typecheck_non_generic_fn_type_args_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn f(x: i32) -> i32 { return x; }\nfn main() -> i32 { return f[i32](1); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "non-generic function does not accept type args"), msg);
}

fn test_typecheck_member_unknown_field_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct S { x: i32 }\nfn main() -> i32 { let s: S = S { x: 1 }; return s.y; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "unknown field: y"), msg);
}

fn test_typecheck_struct_lit_field_type_mismatch_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct S { x: i32 }\nfn main() -> i32 { let s: S = S { x: \"x\" }; return s.x; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "struct field type mismatch: x"), msg);
  t.assert_with(contains(msg, "expected i32"), msg);
  t.assert_with(contains(msg, "got String"), msg);
}

fn test_typecheck_enum_ctor_unknown_variant_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "enum E { A(i32), B }\nfn main() -> i32 { let e: E = E.C(7); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "unknown enum variant: E.C"), msg);
}

fn test_typecheck_enum_ctor_arg_type_mismatch_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "enum E { A(i32) }\nfn main() -> i32 { let e: E = E.A(\"x\"); return 0; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "enum ctor E.A arg #1 type mismatch"), msg);
  t.assert_with(contains(msg, "expected i32"), msg);
  t.assert_with(contains(msg, "got String"), msg);
}

fn test_typecheck_type_alias_resolves() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type I = i32\ntype V = Vec[I]\nfn main() -> i32 {\n  let x: I = 1;\n  let mut v: V = Vec();\n  v.push(x);\n  return v.len();\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_union_type_decl_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Value = I32: i32 | Str: String\nfn main() -> i32 {\n  let x: Value = .I32(1);\n  return match x { .I32(v) => v, .Str(_s) => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_union_ctor_qualified_path_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Value = I32: i32 | Str: String\nfn main() -> i32 {\n  let x: Value = Value.I32(7);\n  return match x { .I32(v) => v, .Str(_s) => 0 };\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_union_match_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Value = I32: i32 | Str: String\nconst X: Value = Value.I32(7)\nconst N: i32 = match X { .I32(v) => v, .Str(_s) => 0 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_decl_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = 1 + 2 * 3\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn add2(x: i32) -> i32 { return x + 2; }\nconst N: i32 = add2(5)\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_named_import_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "pub fn plus(a: i32, b: i32) -> i32 { return a + b; }");
  let src: String = "import { plus } from \"dep\"\nconst N: i32 = plus(3, 4)\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_generic_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn id[T](x: T) -> T { return x; }\nconst N: i32 = id(7)\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_const_generic_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nconst M: i32 = addn[3](4)\nfn main() -> i32 { return M; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_with_pure_member_methods_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn calc() -> i32 {
      let s: String = "abcd";
      let t2: String = s.slice(1, 3).concat("x");
      let n: String = 42.to_string();
      let b: String = true.to_string();
      return t2.len() + t2.byte_at(0) + n.len() + b.len();
    }
    const N: i32 = calc()
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_with_escape_and_float_to_string_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn calc() -> i32 {
      let e: String = "\n".escape_c();
      let f: String = 1.5.to_string();
      let g: String = 2.0.to_string();
      return e.len() + f.len() + g.len();
    }
    const N: i32 = calc()
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_with_string_predicate_methods_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn calc() -> i32 {
      let s: String = "ab_cd";
      let b0: bool = s.starts_with("ab");
      let b1: bool = s.ends_with("cd");
      let b2: bool = s.contains("_");
      return if b0 && b1 && b2 { 1 } else { 0 };
    }
    const N: i32 = calc()
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_with_string_is_empty_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn calc() -> i32 {
      let s0: String = "";
      let s1: String = "x";
      return if s0.is_empty() && !s1.is_empty() { 1 } else { 0 };
    }
    const N: i32 = calc()
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_with_string_index_methods_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn calc() -> i32 {
      let s: String = "ab_cd_ab";
      let i0: i32 = s.index_of("ab");
      let i1: i32 = s.last_index_of("ab");
      let i2: i32 = s.index_of("zz");
      return i0 + i1 + i2;
    }
    const N: i32 = calc()
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_member_method_oob_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn bad() -> i32 {
      let s: String = "ab";
      return s.byte_at(2);
    }
    const N: i32 = bad()
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "string index out of bounds"));
}

fn test_typecheck_const_fn_call_generic_trait_bound_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    fn id[T: Eq](x: T) -> T { return x; }
    const N: i32 = id(7)
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_generic_trait_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    fn id[T: Eq](x: T) -> T { return x; }
    const S: String = id("x")
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  t.assert(!ok(r));
}

fn test_typecheck_const_fn_call_generic_type_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn id[T](x: T) -> T { return x; }\nconst N: i32 = id[String](7)\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  t.assert(!ok(r));
}

fn test_typecheck_const_unary_not_int_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = !0\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_block_expr_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let a: i32 = 2; let b: i32 = a + 3; b * 2 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_shadowing_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let x: i32 = 1; let x: i32 = 2; x }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_if_stmt_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let x: i32 = 1; if true { let y: i32 = 2; } else { let z: i32 = 3; }; x + 4 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_block_let_mut_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let mut a: i32 = 1; a = 2; a }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_assign_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let mut x: i32 = 1; x = 2; x }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_assign_immutable_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { let x: i32 = 1; x = 2; x }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const assign target is immutable"));
}

fn test_typecheck_const_block_assign_field_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct P { x: i32 }
    const N: i32 = { let mut p: P = P { x: 1 }; p.x = 7; p.x }
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_assign_nested_field_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct I { x: i32 }
    struct O { i: I }
    const N: i32 = { let mut o: O = O { i: I { x: 1 } }; o.i.x = 9; o.i.x }
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_block_compound_assign_nested_field_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct I { x: i32 }
    struct O { i: I }
    const N: i32 = { let mut o: O = O { i: I { x: 1 } }; o.i.x += 2; o.i.x }
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_block_compound_assign_nested_field_all_ops_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct I { x: i32 }
    struct O { i: I }
    const N: i32 = {
      let mut o: O = O { i: I { x: 255 } };
      o.i.x += 1;
      o.i.x -= 2;
      o.i.x *= 3;
      o.i.x /= 4;
      o.i.x %= 5;
      o.i.x &= 6;
      o.i.x |= 7;
      o.i.x ^= 8;
      o.i.x <<= 1;
      o.i.x >>= 2;
      o.i.x
    }
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_block_assign_nested_string_field_with_codec_chars_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct I { s: String }
    struct O { i: I }
    const N: i32 = { let mut o: O = O { i: I { s: "a#|b" } }; o.i.s = "q#|w"; o.i.s.len() }
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_struct_member_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct P { x: i32, y: i32 }
    const P0: P = P { x: 3, y: 4 }
    const N: i32 = P0.x + P0.y
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_typed_path_generic_struct_lit_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Pair[T] { a: T, b: T }
    const P0: Pair[i32] = Pair[i32] { a: 3, b: 4 }
    const N: i32 = P0.a + P0.b
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_struct_lit_uses_expected_type_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Pair[T] { a: T, b: T }
    const P0: Pair[i32] = Pair { a: 3, b: 4 }
    const N: i32 = P0.a + P0.b
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_struct_lit_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Pair[T] { a: T, b: T }
    struct Box[T] { a: T, b: T }
    const P0: Pair[i32] = Box { a: 3, b: 4 }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_const_block_branch_assign_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    const N: i32 = { let mut x: i32 = 1; if true { x = 3; } else { x = 4; }; x }
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_while_break_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    const N: i32 = { while true { break; } 7 }
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_block_break_outside_while_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    const N: i32 = {
      break;
      1
    }
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "src/main.vox:2:"));
  t.assert(!contains(msg, "src/main.vox:1:1:"));
  t.assert(contains(msg, "const break outside while"));
}

fn test_typecheck_const_block_continue_outside_while_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    const N: i32 = {
      continue;
      1
    }
    fn main() -> i32 { return N; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "src/main.vox:2:"));
  t.assert(!contains(msg, "src/main.vox:1:1:"));
  t.assert(contains(msg, "const continue outside while"));
}

fn test_typecheck_const_block_return_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = { return 7; 1 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_float_decl_and_ops_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: f64 = 1.5\nconst B: f64 = A\nconst C: bool = B == 1.5\nfn main() -> i32 { return if C { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_float_unary_and_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: f64 = -1.5\nconst B: f32 = A as f32\nconst C: f64 = B as f64\nconst D: bool = C == -1.5\nfn main() -> i32 { return if D { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_float_arith_and_cmp_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    const A: f64 = 3.0 + 2.0
    const B: f64 = A * 4.0
    const C: f64 = B / 2.0
    const D: f64 = C - 3.0
    const LT: bool = D < 8.0
    const LE: bool = D <= 7.0
    const GT: bool = D > 6.0
    const GE: bool = D >= 7.0
    const EQ: bool = D == 7.0
    const NE: bool = D != 8.0
    fn main() -> i32 { return if LT && LE && GT && GE && EQ && NE { 1 } else { 0 }; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_float_scientific_and_suffix_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: f64 = 1e3\nconst B: f32 = 2.5e-2f32\nconst C: f64 = B as f64\nconst D: bool = A > C\nfn main() -> i32 { return if D { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_float_div_by_zero_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: f64 = 1.0 / 0.0\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const division by zero"));
}

fn test_typecheck_const_logic_short_circuit_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: bool = false && (1 / 0 == 0)\nconst B: bool = true || (1 / 0 == 0)\nfn main() -> i32 { return if A || B { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(r.ok, tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_logic_evaluates_rhs_when_needed() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: bool = true && (1 / 0 == 0)\nfn main() -> i32 { return if A { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const division by zero"));
}

fn test_typecheck_const_match_int_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = match 2 { 1 => 10, 2 => 20, _ => 0 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_match_string_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const B: bool = match \"a\" { \"a\" => true, _ => false }\nfn main() -> i32 { return if B { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_match_bool_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = match true { true => 1, false => 0 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_match_no_matching_arm_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = match 1 { 2 => 3 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const match has no matching arm"));
}

fn test_typecheck_const_match_bind_pattern_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = match 1 { x => x + 1 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_enum_unit_match_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A, B }\nconst X: E = .A\nconst N: i32 = match X { .A => 1, .B => 0 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_enum_payload_match_bind_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), B }\nconst X: E = .A(7)\nconst N: i32 = match X { .A(v) => v + 1, .B => 0 }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_enum_payload_multiple_binds_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32, i32) }\nconst X: E = .A(1, 2)\nconst N: i32 = match X { .A(a, b) => a + b }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_enum_payload_duplicate_bind_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32, i32) }\nconst X: E = .A(1, 2)\nconst N: i32 = match X { .A(a, a) => a }\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "duplicate bind"));
}

fn test_typecheck_const_enum_ctor_qualified_path_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32), B }\nconst X: E = E.A(7)\nconst Y: E = E.B\nconst N: i32 = match X { .A(v) => v, .B => 0 }\nfn main() -> i32 { return if Y == E.B { N } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_enum_ctor_alias_path_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "pub enum E { A(i32), B }");
  let src: String = "import \"dep\" as dep\nconst X: dep.E = dep.E.A(7)\nconst Y: dep.E = dep.E.B\nconst N: i32 = match X { .A(v) => v, .B => 0 }\nfn main() -> i32 { return if Y == dep.E.B { N } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_typed_path_generic_enum_ctor_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    enum Option[T] { Some(T), None }
    const A: Option[i32] = Option[i32].Some(7)
    const B: Option[i32] = Option[i32].None
    fn main() -> i32 { let _a: Option[i32] = A; let _b: Option[i32] = B; return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_enum_ctor_uses_expected_type_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum Option[T] { Some(T), None }\nconst A: Option[i32] = Option.Some(7)\nconst B: Option[i32] = Option.None\nfn main() -> i32 { let _a: Option[i32] = A; let _b: Option[i32] = B; return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_enum_ctor_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum Option[T] { Some(T), None }\nenum Maybe[T] { Some(T), None }\nconst A: Option[i32] = Maybe.Some(7)\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "enum ctor result type mismatch"), msg);
  t.assert_with(contains(msg, "expected Option[i32]"), msg);
  t.assert_with(contains(msg, "got Maybe[i32]"), msg);
}

fn test_typecheck_const_int_float_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: f64 = 1 as f64\nconst B: i32 = 1.75 as i32\nconst C: i32 = -1.75 as i32\nconst D: u32 = 9.9 as u32\nfn main() -> i32 { return A as i32 + B + C + D as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_float_to_int_overflow_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: u32 = (-1.0) as u32\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "int cast overflow"));
}

fn test_typecheck_const_i8_wrapping_add_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: i8 = 120\nconst B: i8 = A + A\nfn main() -> i32 { return B as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_u64_max_literal_expected_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> u64 { let x: u64 = 18446744073709551615; return x; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_expr_cast_u64_max_literal_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> u64 { let x: u64 = 18446744073709551615 as u64; return x; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_u64_max_literal_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: u64 = 18446744073709551615\nfn main() -> u64 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_u64_max_add_wrap_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: u64 = 18446744073709551615\nconst B: u64 = A + 1\nfn main() -> u64 { return B; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_named_import_const_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "pub const N: i32 = 7");
  w = add_mod(w, "main", "import { N } from \"dep\"\nfn main() -> i32 { return N; }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = 1 as i32\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_cast_overflow_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = 3000000000 as i32\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "i64 to i32 overflow"));
}

fn test_typecheck_const_u64_to_i64_cast_overflow_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const A: u64 = 18446744073709551615\nconst B: i64 = A as i64\nfn main() -> i64 { return B; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const expression: int cast overflow"));
}

fn test_typecheck_const_division_overflow_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i8 = (-128) / (-1)\nfn main() -> i32 { return N as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const division overflow"));
}

fn test_typecheck_const_shift_count_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const N: i32 = 1 << 32\nfn main() -> i32 { return N; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const shift count out of range"));
}

fn test_typecheck_const_eq_type_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "const B: bool = (1 as i8) == (1 as i16)\nfn main() -> i32 { return if B { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "const ==/!= type mismatch"));
}

fn test_typecheck_const_struct_equality_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct S { a: i32, b: String }\nconst X: S = S { a: 1, b: \"x\" }\nconst Y: S = S { a: 1, b: \"x\" }\nconst B: bool = X == Y\nfn main() -> i32 { return if B { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_enum_payload_equality_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum E { A(i32, String), None }\nconst X: E = E.A(7, \"x\")\nconst Y: E = E.A(7, \"x\")\nconst B: bool = X == Y\nfn main() -> i32 { return if B { 1 } else { 0 }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_char_alias_scalar_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn main() -> u32 {\n  let c0: char = 65;\n  let c1: char = 66 as char;\n  return c0 + c1 - 65;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_char_base_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Ascii = @range(0..=127) char\nfn main() -> u32 {\n  let a: Ascii = 65 as Ascii;\n  let b: char = a;\n  return b;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_char_literal_bounds_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Lower = @range('a'..='z') char\nfn main() -> u32 {\n  let a: Lower = 'm' as Lower;\n  let b: char = a;\n  return b;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i32\nfn main() -> i32 {\n  let x: Tiny = 1 as Tiny;\n  let y: i32 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_i8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i8\nfn main() -> i8 {\n  let x: Tiny = 1 as Tiny;\n  let y: i8 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_u32() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u32\nfn main() -> u32 {\n  let x: Tiny = 1 as Tiny;\n  let y: u32 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_u8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u8\nfn main() -> u8 {\n  let x: Tiny = 1 as Tiny;\n  let y: u8 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_u64() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u64\nfn main() -> u64 {\n  let x: Tiny = 1 as Tiny;\n  let y: u64 = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_widening_allows_range_to_base_usize() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) usize\nfn main() -> usize {\n  let x: Tiny = 1 as Tiny;\n  let y: usize = x;\n  return y;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_range_requires_explicit_cast_from_base() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i32\nfn main() -> i32 { let x: Tiny = 1; return x as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "integer literal requires expected scalar int"));
}

fn test_typecheck_range_requires_explicit_cast_from_base_i8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i8\nfn main() -> i8 { let x: Tiny = 1; return x as i8; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "integer literal requires expected scalar int"));
}

fn test_typecheck_range_requires_explicit_cast_from_base_u8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u8\nfn main() -> u8 { let x: Tiny = 1; return x as u8; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "integer literal requires expected scalar int"));
}

fn test_typecheck_const_range_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i32\nconst N: Tiny = 2 as Tiny\nfn main() -> i32 { return N as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_range_cast_smoke_u32() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u32\nconst N: Tiny = 2 as Tiny\nfn main() -> u32 { return N as u32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_range_cast_smoke_usize() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) usize\nconst N: Tiny = 2 as Tiny\nfn main() -> usize { return N as usize; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_range_cast_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i32\nconst N: Tiny = 5 as Tiny\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "range check failed"));
}

fn test_typecheck_const_range_cast_rejected_i8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) i8\nconst N: Tiny = 5 as Tiny\nfn main() -> i8 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "range check failed"));
}

fn test_typecheck_const_range_cast_rejected_u8() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Tiny = @range(0..=3) u8\nconst N: Tiny = 5 as Tiny\nfn main() -> u8 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "range check failed"));
}

fn test_typecheck_const_range_cast_rejected_char_literal_bounds() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "type Lower = @range('a'..='z') char\nconst C: Lower = 'A' as Lower\nfn main() -> u32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "range check failed"));
}

fn test_typecheck_verified_widening_allows_to_base() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
fn in_small(x: i32) -> bool { return x >= 0 && x <= 3; }
type Small = @verified(in_small) i32
fn main(x: i32) -> i32 {
  let v: Small = x as Small;
  let y: i32 = v;
  return y;
}
""";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_verified_requires_explicit_cast_from_base() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
fn in_small(x: i32) -> bool { return x >= 0 && x <= 3; }
type Small = @verified(in_small) i32
fn main() -> i32 {
  let v: Small = 1;
  return v as i32;
}
""";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "integer literal requires expected scalar int"));
}

fn test_typecheck_verified_predicate_module_alias_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "util", "pub fn nonneg(x: i32) -> bool { return x >= 0; }");
  let src: String = """
import "util" as u
type NonNeg = @verified(u.nonneg) i32
fn main(x: i32) -> i32 {
  let v: NonNeg = x as NonNeg;
  return v as i32;
}
""";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_verified_predicate_bad_signature_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
fn bad(x: i64) -> bool { return x > 0; }
type Small = @verified(bad) i32
fn main() -> i32 { return 0; }
""";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_const_verified_cast_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
fn in_small(x: i32) -> bool { return x >= 0 && x <= 3; }
type Small = @verified(in_small) i32
const N: Small = 2 as Small
fn main() -> i32 { return N as i32; }
""";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_verified_cast_rejected_on_predicate_false() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
fn in_small(x: i32) -> bool { return x >= 0 && x <= 3; }
type Small = @verified(in_small) i32
const N: Small = 5 as Small
fn main() -> i32 { return 0; }
""";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "verified check failed"));
}

fn test_typecheck_verified_char_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
fn is_ascii(x: char) -> bool { return (x as u32) <= (127 as u32); }
type Ascii = @verified(is_ascii) char
const C: Ascii = 65 as Ascii
fn main() -> u32 {
  let v: char = C;
  return v;
}
""";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_verified_char_rejected_on_predicate_false() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
fn is_ascii(x: char) -> bool { return (x as u32) <= (127 as u32); }
type Ascii = @verified(is_ascii) char
const C: Ascii = 255 as Ascii
fn main() -> u32 { return 0; }
""";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "verified check failed"));
}

fn test_typecheck_trait_static_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    pub trait Show {
      fn show(x: Self) -> String;
    }
    struct I { v: i32 }
    impl Show for I {
      fn show(x: I) -> String { return "ok"; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let s: String = Show.show(x);
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_static_call_through_alias_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "pub trait Show { fn show(x: Self) -> String; }");
  let main_src: String = """
    import "dep" as d
    struct I { v: i32 }
    impl d.Show for I {
      fn show(x: I) -> String { return "ok"; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let s: String = d.Show.show(x);
      return s.len();
    }
  """;
  w = add_mod(w, "main", main_src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_impl_local_trait_for_foreign_type_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Tag { fn tag(x: Self) -> i32; }\nimpl Tag for i32 { fn tag(x: i32) -> i32 { return x; } }\nfn main() -> i32 { return Tag.tag(7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_impl_foreign_trait_for_foreign_type_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "pub trait Show { fn show(x: Self) -> String; }");
  let src: String = "import \"dep\" as d\nimpl d.Show for i32 { fn show(x: i32) -> String { return \"x\"; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "orphan impl is not allowed"));
}

fn test_typecheck_trait_method_sugar_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    struct I { v: i32 }
    impl Show for I {
      fn show(x: I) -> String { return "ok"; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let s: String = x.show();
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_method_sugar_mut_receiver_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Bump { fn bump(x: &mut Self) -> i32; }
    struct I { v: i32 }
    impl Bump for I {
      fn bump(x: &mut I) -> i32 { return x.v + 1; }
    }
    fn main() -> i32 {
      let mut x: I = I { v: 1 };
      return x.bump();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_method_sugar_mut_receiver_rejects_immutable_place() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Bump { fn bump(x: &mut Self) -> i32; }
    struct I { v: i32 }
    impl Bump for I {
      fn bump(x: &mut I) -> i32 { return x.v + 1; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return x.bump();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "is immutable"), msg);
}

fn test_typecheck_trait_method_sugar_mut_receiver_rejects_non_place() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Bump { fn bump(x: &mut Self) -> i32; }
    struct I { v: i32 }
    impl Bump for I {
      fn bump(x: &mut I) -> i32 { return x.v + 1; }
    }
    fn main() -> i32 { return I { v: 1 }.bump(); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "must be mutable place"), msg);
}

fn test_typecheck_trait_method_sugar_ref_receiver_rejects_non_place() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Peek { fn peek(x: &Self) -> i32; }
    struct I { v: i32 }
    impl Peek for I {
      fn peek(x: &I) -> i32 { return x.v; }
    }
    fn main() -> i32 { return I { v: 1 }.peek(); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "for & parameter must be place"), msg);
}

fn test_typecheck_generic_impl_trait_static_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    impl[T] Show for Vec[T] {
      fn show(x: Vec[T]) -> String { return x.len().to_string(); }
    }
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(7);
      let s: String = Show.show(v);
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_impl_trait_method_sugar_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    impl[T] Show for Vec[T] {
      fn show(x: Vec[T]) -> String { return x.len().to_string(); }
    }
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(7);
      let s: String = v.show();
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_impl_bound_rejected_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Mark { fn mark(x: Self) -> bool; }
    trait Show { fn show(x: Self) -> String; }
    impl[T: Mark] Show for Vec[T] {
      fn show(x: Vec[T]) -> String { return x.len().to_string(); }
    }
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(7);
      let s: String = Show.show(v);
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  let bound_msg: bool = contains(msg, "does not satisfy trait bound");
  let no_impl_msg: bool = contains(msg, "no impl for trait call");
  t.assert(bound_msg || no_impl_msg);
  if bound_msg {
    t.assert(contains(msg, "Mark"));
  } else {
    t.assert(contains(msg, "Show"));
  }
}

fn test_typecheck_trait_default_method_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String { return \"ok\"; } }\nstruct I { v: i32 }\nimpl Show for I {}\nfn main() -> i32 { let x: I = I { v: 1 }; let s: String = x.show(); return s.len(); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_default_method_external_trait_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", "fn dep_tag() -> String { return \"dep\"; }\npub trait Show { fn show(x: Self) -> String { return dep_tag(); } }");
  w = add_mod(w, "main", "import \"dep\" as d\nstruct I { v: i32 }\nimpl d.Show for I {}\nfn main() -> i32 { let x: I = I { v: 1 }; let s: String = x.show(); return s.len(); }");
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_generic_method_static_and_member_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }");
  let src: String = """
    trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T; }
    struct I { v: i32 }
    impl Wrap for I { fn wrap[T: Eq](x: I, v: T) -> T { return v; } }
    fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = Wrap.wrap[i32](x, 7); let b: i32 = I { v: 2 }.wrap[i32](9); return a + b; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_const_generic_method_static_and_member_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }
    struct I { v: i32 }
    impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let a: i32 = AddN.addn[3](x, 4);
      let b: i32 = I { v: 2 }.addn[5](6);
      return a + b;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_const_generic_method_default_const_arg_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait AddN { fn addn[const N: i32 = 3](x: Self, v: i32) -> i32; }
    struct I { v: i32 }
    impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let a: i32 = AddN.addn(x, 4);
      let b: i32 = I { v: 2 }.addn(6);
      return a + b;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_const_generic_method_comptime_where_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }
    struct I { v: i32 }
    impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N > 0 { return v + N; } }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return AddN.addn[3](x, 4);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_const_generic_method_comptime_where_rhs_param_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait AddNM { fn addnm[const N: i32, const M: i32](x: Self, v: i32) -> i32 where comptime N < M; }
    struct I { v: i32 }
    impl AddNM for I { fn addnm[const N: i32, const M: i32](x: I, v: i32) -> i32 where comptime N < M { return v + N; } }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return AddNM.addnm[3, 5](x, 4);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_const_generic_method_comptime_where_rhs_unknown_reports_method_span() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """

    trait AddN {
      fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N < M;
    }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.slice(0, "src/main.vox:3:3:".len()) == "src/main.vox:3:3:");
  t.assert(contains(msg, "unknown const param in comptime where rhs"));
}

fn test_typecheck_trait_const_generic_method_comptime_where_type_layout_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Fit {
      fn fit[T](x: Self, v: T) -> i32 where comptime @size_of(T) <= 8, comptime @align_of(T) <= 8;
    }
    struct I { v: i32 }
    impl Fit for I {
      fn fit[T](x: I, v: T) -> i32 where comptime @size_of(T) <= 8, comptime @align_of(T) <= 8 { return 1; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return Fit.fit(x, 3);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_const_generic_method_comptime_where_rhs_reflect_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait FitRU {
      fn fit[T, U](x: Self, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U);
    }
    struct I { v: i32 }
    impl FitRU for I {
      fn fit[T, U](x: I, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U) { return 1; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let y: i64 = 0;
      return FitRU.fit(x, 3, y);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_const_generic_method_comptime_where_rhs_reflect_impl_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait FitRU {
      fn fit[T, U](x: Self, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U);
    }
    struct I { v: i32 }
    impl FitRU for I {
      fn fit[T, U](x: I, a: T, b: U) -> i32 where comptime @size_of(T) < @align_of(U) { return 1; }
    }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "@size_of(T) <= @align_of(U)"), msg);
}

fn test_typecheck_trait_const_generic_method_comptime_where_impl_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }
    struct I { v: i32 }
    impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N >= 0 { return v + N; } }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "comptime where"));
}

fn test_typecheck_trait_const_generic_method_comptime_where_rhs_param_impl_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait AddNM { fn addnm[const N: i32, const M: i32](x: Self, v: i32) -> i32 where comptime N < M; }
    struct I { v: i32 }
    impl AddNM for I { fn addnm[const N: i32, const M: i32](x: I, v: i32) -> i32 where comptime N <= M { return v + N; } }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "comptime where"));
}

fn test_typecheck_trait_const_generic_method_comptime_where_type_layout_impl_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Fit { fn fit[T](x: Self, v: T) -> i32 where comptime @size_of(T) <= 8; }
    struct I { v: i32 }
    impl Fit for I { fn fit[T](x: I, v: T) -> i32 where comptime @size_of(T) <= 16 { return 1; } }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "comptime where"));
}

fn test_typecheck_trait_const_generic_method_default_violates_comptime_where_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait AddN { fn addn[const N: i32 = 0](x: Self, v: i32) -> i32 where comptime N > 0; }
    struct I { v: i32 }
    impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N > 0 { return v + N; } }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "default violates comptime where"));
}

fn test_typecheck_trait_const_generic_method_default_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait AddN { fn addn[const N: i32 = 3](x: Self, v: i32) -> i32; }
    struct I { v: i32 }
    impl AddN for I { fn addn[const N: i32 = 4](x: I, v: i32) -> i32 { return v + N; } }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "default mismatch"));
}

fn test_typecheck_trait_const_generic_method_impl_name_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }\nstruct I { v: i32 }\nimpl AddN for I { fn addn[const M: i32](x: I, v: i32) -> i32 { return v + M; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl method const param name mismatch"));
}

fn test_typecheck_trait_generic_method_impl_type_param_rename_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }");
  let src: String = """
    trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T; }
    struct I { v: i32 }
    impl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }
    fn main() -> i32 { let x: I = I { v: 1 }; return Wrap.wrap[i32](x, 7); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_generic_method_impl_type_param_rename_assoc_projection_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Pass { type Item; fn pass[T: Pass](x: Self, v: T.Item) -> T.Item; }
    struct I { v: i32 }
    impl Pass for I { type Item = i32; fn pass[U: Pass](x: I, v: U.Item) -> U.Item { return v; } }
    fn main() -> i32 { let x: I = I { v: 1 }; return Pass.pass[I](x, 7); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_generic_method_impl_type_param_rename_assoc_projection_nested_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Pass { type Item; fn dup[T: Pass](x: Self, v: T.Item) -> Vec[T.Item]; }
    struct I { v: i32 }
    impl Pass for I { type Item = i32; fn dup[U: Pass](x: I, v: U.Item) -> Vec[U.Item] { return Vec(); } }
    fn main() -> i32 { let x: I = I { v: 1 }; let ys: Vec[i32] = Pass.dup[I](x, 7); return ys.len(); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_impl_method_bound_mismatch_reports_missing_bound() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
    pub trait Show { fn show(x: Self) -> String; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
  """);
  let src: String = "trait Wrap { fn wrap[T: Eq + Show](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl method missing type bound"));
  t.assert(contains(msg, "Show"));
}

fn test_typecheck_trait_generic_default_method_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }");
  let src: String = """
    trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T { return v; } }
    struct I { v: i32 }
    impl Wrap for I {}
    fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = Wrap.wrap[i32](x, 7); let b: i32 = I { v: 2 }.wrap[i32](9); return a + b; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_fn_body_checked_without_instantiation() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn bad[T](x: T) -> T { let y: i32 = x; return x; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_const_generic_fn_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn[3](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_default_const_arg_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn(4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_default_const_arg_can_override() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn[9](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_comptime_where_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0, comptime N <= 8 { return x + N; }\nfn main() -> i32 { return addn[3](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_comptime_where_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0, comptime N <= 8 { return x + N; }\nfn main() -> i32 { return addn[0](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "constraint failed"));
}

fn test_typecheck_const_generic_fn_comptime_where_rhs_param_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addnm[const N: i32, const M: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return addnm[3, 5](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_comptime_where_rhs_param_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addnm[const N: i32, const M: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return addnm[5, 3](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "constraint failed"));
}

fn test_typecheck_const_generic_fn_comptime_where_rhs_unknown_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addnm[const N: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "unknown const param in comptime where rhs"));
}

fn test_typecheck_const_generic_fn_comptime_where_rhs_unknown_reports_decl_span() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "\n\nfn addnm[const N: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.slice(0, "src/main.vox:3:1:".len()) == "src/main.vox:3:1:");
  t.assert(contains(msg, "unknown const param in comptime where rhs"));
}

fn test_typecheck_const_generic_fn_comptime_where_type_layout_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn fit[T](x: T) -> i32 where comptime @size_of(T) <= 8, comptime @align_of(T) <= 8 { return 1; }\nfn main() -> i32 { return fit(3); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_comptime_where_type_layout_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Big { a: i64, b: i64 }\nfn fit[T](x: T) -> i32 where comptime @size_of(T) <= 8 { return 1; }\nfn main() -> i32 { let b: Big = Big { a: 1, b: 2 }; return fit(b); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "@size_of(T) <= 8"));
}

fn test_typecheck_const_generic_fn_comptime_where_type_layout_rhs_param_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn fit[T, const LIM: i32](x: T) -> i32 where comptime @size_of(T) <= LIM { return 1; }\nfn main() -> i32 { return fit[8](3); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_comptime_where_type_layout_rhs_param_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn fit[T, const LIM: i32](x: T) -> i32 where comptime @size_of(T) <= LIM { return 1; }\nfn main() -> i32 { return fit[2](3); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "@size_of(T) <= LIM"));
}

fn test_typecheck_const_generic_fn_comptime_where_field_count_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Pair { a: i32, b: i32 }\nfn fit[T](x: T) -> i32 where comptime @field_count(T) <= 2 { return 1; }\nfn main() -> i32 { let p: Pair = Pair { a: 1, b: 2 }; return fit(p); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_comptime_where_field_count_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Triple { a: i32, b: i32, c: i32 }\nfn fit[T](x: T) -> i32 where comptime @field_count(T) <= 2 { return 1; }\nfn main() -> i32 { let x: Triple = Triple { a: 1, b: 2, c: 3 }; return fit(x); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "@field_count(T) <= 2"));
}

fn test_typecheck_const_generic_fn_comptime_where_type_id_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn fit[T](x: T) -> i32 where comptime @type(T) > 0 { return 1; }\nfn main() -> i32 { return fit(3); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_comptime_where_type_id_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn fit[T](x: T) -> i32 where comptime @type(T) < 0 { return 1; }\nfn main() -> i32 { return fit(3); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "@type(T) < 0"));
}

fn test_typecheck_const_generic_fn_comptime_where_rhs_reflect_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn fit[T, U](x: T, y: U) -> i32 where comptime @size_of(T) <= @align_of(U) { return 1; }\nfn main() -> i32 { let y: i64 = 0; return fit(3, y); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_comptime_where_rhs_reflect_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn fit[T, U](x: T, y: U) -> i32 where comptime @size_of(T) <= @align_of(U) { return 1; }\nfn main() -> i32 { let y: u8 = 0; let x: i64 = 1; return fit(x, y); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "@size_of(T) <= @align_of(U)"), msg);
}

fn test_typecheck_const_generic_fn_comptime_where_type_layout_unknown_param_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn fit[T](x: T) -> i32 where comptime @size_of(U) <= 8 { return 1; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "unknown type param in comptime where"));
}

fn test_typecheck_generic_struct_comptime_where_type_layout_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Small[T] where comptime @size_of(T) <= 8, comptime @align_of(T) <= 8 { v: T }\nfn main() -> i32 { let s: Small[i32] = Small[i32] { v: 7 }; return s.v; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_struct_comptime_where_type_layout_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Big { a: i64, b: i64 }\nstruct Small[T] where comptime @size_of(T) <= 8 { v: T }\nfn main() -> i32 { let b: Big = Big { a: 1, b: 2 }; let s: Small[Big] = Small[Big] { v: b }; return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "type resolve failed in let annotation"), msg);
}

fn test_typecheck_generic_enum_comptime_where_type_layout_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "enum Tiny[T] where comptime @size_of(T) <= 8 { V(T) }\nfn main() -> i32 { let x: Tiny[i32] = Tiny.V(7); return match x { Tiny.V(v) => v }; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_enum_comptime_where_type_layout_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "struct Big { a: i64, b: i64 }\nenum Tiny[T] where comptime @size_of(T) <= 8 { V(T) }\nfn main() -> i32 { let b: Big = Big { a: 1, b: 2 }; let x: Tiny[Big] = Tiny[Big].V(b); return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "type resolve failed in let annotation"), msg);
}

fn test_typecheck_generic_struct_trait_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    struct Boxed[T: Eq] { v: T }
    fn main() -> i32 { let b: Boxed[String] = Boxed[String] { v: "x" }; return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "type resolve failed in let annotation"), msg);
}

fn test_typecheck_generic_enum_trait_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    enum MaybeEq[T: Eq] { V(T) }
    fn main() -> i32 { let x: MaybeEq[String] = MaybeEq[String].V("x"); return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "type resolve failed in let annotation"), msg);
}

fn test_typecheck_const_generic_fn_default_violates_comptime_where_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32 = 0](x: i32) -> i32 where comptime N > 0 { return x + N; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "default violates comptime where"));
}

fn test_typecheck_const_generic_fn_infers_type_params_with_const_args() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn idn[T, const N: i32](x: T) -> T { return x; }\nfn main() -> i32 { return idn[3](7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_infers_type_params_with_default_const_arg() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn idn[T, const N: i32 = 3](x: T) -> T { return x; }\nfn main() -> i32 { return idn(7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_missing_const_arg_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn(4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_generic_type_param_pack_decl_accepted() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn id[T...](x: T) -> T { return x; }\nfn main() -> i32 { return id[i32](7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_generic_type_param_pack_must_be_last_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn id[T..., U](x: T) -> T { return x; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "type parameter pack must be the last type parameter"), msg);
}

fn test_typecheck_generic_multiple_type_param_packs_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn id[T..., U...](x: T) -> T { return x; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "only one type parameter pack is currently supported"), msg);
}

fn test_typecheck_generic_type_param_pack_extra_type_args_rejected_with_message() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn id[T...](x: T) -> T { return x; }\nfn main() -> i32 { return id[i32, i64](7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  let ok_msg: bool = contains(msg, "return type mismatch") || contains(msg, "typecheck failed");
  t.assert_with(ok_msg, msg);
}

fn test_typecheck_variadic_param_lowered_to_vec_accepted() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn sum(xs: i32...) -> i32 {
      let mut i: i32 = 0;
      let mut acc: i32 = 0;
      while i < xs.len() {
        acc = acc + xs.get(i);
        i = i + 1;
      }
      return acc;
    }
    fn main() -> i32 {
      let mut xs: Vec[i32] = Vec();
      xs.push(1);
      xs.push(2);
      xs.push(3);
      return sum(xs);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_variadic_call_pack_args_accepted() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn sum(xs: i32...) -> i32 { return xs.len(); }
    fn main() -> i32 { return sum(1, 2, 3); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_variadic_call_empty_pack_accepted() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn sum(xs: i32...) -> i32 { return xs.len(); }
    fn main() -> i32 { return sum(); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_variadic_call_explicit_vec_accepted() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn sum(xs: i32...) -> i32 { return xs.len(); }
    fn main() -> i32 {
      let xs: Vec[i32] = Vec();
      return sum(xs);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_variadic_call_generic_infer_pack_accepted() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn first[T](head: T, tail: T...) -> T { return head; }
    fn main() -> i32 { return first(7, 8, 9); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_variadic_generic_with_explicit_type_and_const_pack_vs_vec_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn take[T, const N: i32](head: T, tail: T...) -> T { return head; }
    fn main() -> i32 {
      let mut xs: Vec[i32] = Vec();
      xs.push(8);
      xs.push(9);
      let a: i32 = take[i32, 3](7, 8, 9);
      let b: i32 = take[i32, 3](7, xs);
      return a + b;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_variadic_call_missing_fixed_args_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn need(x: i32, ys: i32...) -> i32 { return x + ys.len(); }
    fn main() -> i32 { return need(); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "wrong number of args: expected at least 1, got 0"), msg);
}

fn test_typecheck_variadic_param_non_tail_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn bad(xs: i32..., y: i32) -> i32 { return y; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "variadic parameter must be the last parameter"), msg);
}

fn test_typecheck_trait_impl_method_pack_count_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Boxed { fn id[T...](x: Self, v: T) -> T; }
    struct I { v: i32 }
    impl Boxed for I { fn id[T](x: I, v: T) -> T { return v; } }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "impl method type parameter pack count mismatch"), msg);
}

fn test_typecheck_const_generic_fn_const_arg_out_of_range_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn f[const N: u8](x: i32) -> i32 { return x; }\nfn main() -> i32 { return f[300](1); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_const_generic_fn_forwards_const_param_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn wrap[const N: i32](x: i32) -> i32 { return addn[N](x); }\nfn main() -> i32 { return wrap[3](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_fn_call_forwards_const_param_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn twice[const N: i32](x: i32) -> i32 { return addn[N](addn[N](x)); }\nconst K: i32 = twice[3](1)\nfn main() -> i32 { return K; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_const_generic_fn_forwards_const_param_with_comptime_where_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0 { return x + N; }\nfn wrap[const N: i32](x: i32) -> i32 { return addn[N](x); }\nfn main() -> i32 { return wrap[3](4); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_generic_impl_method_body_checked_without_instantiation() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Boxed { fn id[T](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Boxed for I { fn id[T](x: I, v: T) -> T { let y: i32 = v; return v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_generic_default_method_body_checked_without_instantiation() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Boxed { fn id[T](x: Self, v: T) -> T { let y: i32 = v; return v; } }\nstruct I { v: i32 }\nimpl Boxed for I {}\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_generic_bound_trait_static_call_in_body_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    fn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_eq_operator_with_eq_bound_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    fn same[T: Eq](a: T, b: T) -> bool { return a == b; }
    fn main() -> i32 { return if same(1, 1) { 1 } else { 0 }; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_eq_operator_without_eq_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn same[T](a: T, b: T) -> bool { return a == b; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_generic_cmp_operator_with_ord_bound_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Ord { fn lt(a: Self, b: Self) -> bool; }
    impl Ord for i32 { fn lt(a: i32, b: i32) -> bool { return a < b; } }
    fn less[T: Ord](a: T, b: T) -> bool { return a < b; }
    fn main() -> i32 { return if less(1, 2) { 1 } else { 0 }; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_cmp_operator_without_ord_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn less[T](a: T, b: T) -> bool { return a < b; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
}

fn test_typecheck_generic_bound_trait_method_sugar_in_body_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
    fn f[T: Show](x: T) -> String { return x.show(); }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_bound_trait_method_sugar_generic_method_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    trait Wrap { fn wrap[U: Eq](x: Self, v: U) -> U; }
    struct I { v: i32 }
    impl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }
    fn f[T: Wrap](x: T) -> i32 { return x.wrap[i32](7); }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return f(x);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_bound_trait_method_sugar_supertrait_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    trait Wrap: Show { fn id(x: Self) -> Self; }
    struct I { v: i32 }
    impl Show for I { fn show(x: I) -> String { return "ok"; } }
    impl Wrap for I { fn id(x: I) -> I { return x; } }
    fn f[T: Wrap](x: T) -> String { return x.show(); }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let s: String = f(x);
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_generic_bound_trait_method_sugar_missing_bound_method_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    fn f[T: Eq](x: T) -> String { return x.show(); }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "trait method not in bounds"));
  t.assert(contains(msg, "Eq"));
}

fn test_typecheck_generic_bound_trait_method_sugar_ambiguous_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait A { fn show(x: Self) -> String; }
    trait B { fn show(x: Self) -> String; }
    struct I { v: i32 }
    impl A for I { fn show(x: I) -> String { return "a"; } }
    impl B for I { fn show(x: I) -> String { return "b"; } }
    fn f[T: A + B](x: T) -> String { return x.show(); }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "ambiguous trait method call"));
  t.assert(contains(msg, "A.show"));
  t.assert(contains(msg, "B.show"));
}

fn test_typecheck_supertrait_forward_decl_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait B: A { fn b(x: Self) -> i32; }
    trait A { fn a(x: Self) -> i32; }
    struct I { v: i32 }
    impl A for I { fn a(x: I) -> i32 { return 1; } }
    impl B for I { fn b(x: I) -> i32 { return 2; } }
    fn main() -> i32 { let x: I = I { v: 1 }; return B.b(x) + A.a(x); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_supertrait_impl_requires_parent_impl() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait A { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl B for I { fn b(x: I) -> i32 { return 2; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "requires supertrait A"));
}

fn test_typecheck_supertrait_cycle_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait A: B { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "supertrait cycle"));
}

fn test_typecheck_supertrait_cycle_reports_decl_span() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "\ntrait A: B { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.slice(0, "src/main.vox:2:1:".len()) == "src/main.vox:2:1:");
  t.assert(contains(msg, "supertrait cycle"));
}

fn test_typecheck_supertrait_impl_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait A { fn a(x: Self) -> i32; }
    trait B: A { fn b(x: Self) -> i32; }
    struct I { v: i32 }
    impl A for I { fn a(x: I) -> i32 { return 1; } }
    impl B for I { fn b(x: I) -> i32 { return 2; } }
    fn main() -> i32 { let x: I = I { v: 1 }; return B.b(x) + A.a(x); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_assoc_type_impl_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Iter { type Item; fn next(x: Self) -> i32; }
    struct I { v: i32 }
    impl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }
    fn main() -> i32 { let x: I = I { v: 1 }; return Iter.next(x); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_assoc_type_projection_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Iter { type Item; fn next(x: Self) -> Self.Item; }
    struct I { v: i32 }
    impl Iter for I { type Item = i32; fn next(x: I) -> Self.Item { return x.v; } }
    fn id[T: Iter](x: T) -> T.Item { return x.next(); }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let y: i32 = id[I](x);
      return y;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_assoc_type_projection_infer_local_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Iter { type Item; fn next(x: Self) -> Self.Item; }
    struct I { v: i32 }
    impl Iter for I { type Item = i32; fn next(x: I) -> Self.Item { return x.v; } }
    fn id[T: Iter](x: T) -> T.Item { return x.next(); }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let y = id[I](x);
      return y;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_trait_assoc_type_unknown_in_method_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; fn next(x: Self) -> Self.Missing; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "unknown associated type in trait method"));
  t.assert(contains(msg, "Missing"));
}

fn test_typecheck_trait_assoc_type_projection_unknown_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait A { fn a(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl A for I { fn a(x: I) -> i32 { return x.v; } }\nfn bad[T: A](x: T) -> T.Item { return 0; }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "unknown associated type projection"));
  t.assert(contains(msg, "T.Item"));
}

fn test_typecheck_trait_assoc_type_projection_ambiguous_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait A { type Item; fn a(x: Self) -> i32; }
    trait B { type Item; fn b(x: Self) -> i32; }
    struct I { v: i32 }
    impl A for I { type Item = i32; fn a(x: I) -> i32 { return x.v; } }
    impl B for I { type Item = i32; fn b(x: I) -> i32 { return x.v; } }
    fn bad[T: A + B](x: T) -> T.Item { return x.a(); }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "ambiguous associated type projection"));
  t.assert(contains(msg, "T.Item"));
}

fn test_typecheck_trait_assoc_type_impl_missing_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl missing associated type"));
  t.assert(contains(msg, "Item"));
}

fn test_typecheck_trait_assoc_type_impl_extra_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl associated type not in trait"));
  t.assert(contains(msg, "Item"));
}

fn test_typecheck_trait_assoc_type_duplicate_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "duplicate trait associated type"));
  t.assert(contains(msg, "Item"));
}

fn test_typecheck_trait_assoc_type_duplicate_reports_assoc_span() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Iter {
      type Item;
      type Item;
      fn next(x: Self) -> i32;
    }
    struct I { v: i32 }
    impl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.slice(0, "src/main.vox:3:3:".len()) == "src/main.vox:3:3:");
  t.assert(contains(msg, "duplicate trait associated type"));
}

fn test_typecheck_impl_assoc_type_duplicate_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; type Item = i64; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "duplicate impl associated type"));
  t.assert(contains(msg, "Item"));
}

fn test_typecheck_impl_assoc_type_duplicate_reports_assoc_span() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Iter { type Item; fn next(x: Self) -> i32; }
    struct I { v: i32 }
    impl Iter for I {
      type Item = i32;
      type Item = i64;
      fn next(x: I) -> i32 { return x.v; }
    }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(msg.slice(0, "src/main.vox:5:3:".len()) == "src/main.vox:5:3:");
  t.assert(contains(msg, "duplicate impl associated type"));
}

fn test_typecheck_trait_method_name_conflicts_assoc_type_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Iter { type Item; fn Item(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn Item(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "trait method conflicts with associated type"));
  t.assert(contains(msg, "Item"));
}

fn test_typecheck_trait_method_sugar_ambiguous_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait A { fn show(x: Self) -> String; }
    trait B { fn show(x: Self) -> String; }
    struct I { v: i32 }
    impl A for I { fn show(x: I) -> String { return "a"; } }
    impl B for I { fn show(x: I) -> String { return "b"; } }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let _s: String = x.show();
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "ambiguous trait method call"));
  t.assert(contains(msg, "A.show"));
  t.assert(contains(msg, "B.show"));
}

fn test_typecheck_trait_call_missing_impl_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "pub trait Show { fn show(x: Self) -> String; }\nstruct I { v: i32 }\nfn main() -> i32 {\n  let x: I = I { v: 1 };\n  let _s: String = Show.show(x);\n  return 0;\n}";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "no impl for trait call"));
  t.assert(contains(msg, "available impls"));
}

fn test_typecheck_trait_call_unknown_method_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    pub trait Show { fn show(x: Self) -> String; fn debug(x: Self) -> String; }
    struct I { v: i32 }
    impl Show for I {
      fn show(x: I) -> String { return "ok"; }
      fn debug(x: I) -> String { return "dbg"; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let _s: String = Show.missing(x);
      return 0;
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "unknown trait method"));
  t.assert(contains(msg, "available methods"));
  t.assert(contains(msg, "show"));
  t.assert(contains(msg, "debug"));
}

fn test_typecheck_impl_method_sig_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait AddOne { fn add_one(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl AddOne for I {\n  fn add_one(x: i32) -> i32 { return x + 1; }\n}\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl method param type mismatch"));
}

fn test_typecheck_impl_missing_required_method_reports_candidates() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "trait Show { fn show(x: Self) -> String; fn debug(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I { fn show(x: I) -> String { return \"ok\"; } }\nfn main() -> i32 { return 0; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl missing trait method"));
  t.assert(contains(msg, "required methods"));
  t.assert(contains(msg, "show"));
  t.assert(contains(msg, "debug"));
}

fn test_typecheck_impl_extra_method_reports_candidates() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    struct I { v: i32 }
    impl Show for I { fn show(x: I) -> String { return "ok"; } fn debug(x: I) -> String { return "dbg"; } }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "impl method not in trait"));
  t.assert(contains(msg, "available methods"));
  t.assert(contains(msg, "show"));
}

fn test_typecheck_inherent_impl_method_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct I { v: i32 }
    impl I {
      fn inc(x: I) -> i32 { return x.v + 1; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return x.inc();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_inherent_impl_method_mut_receiver_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct I { v: i32 }
    impl I {
      fn inc(x: &mut I) -> i32 { return x.v + 1; }
    }
    fn main() -> i32 {
      let mut x: I = I { v: 1 };
      return x.inc();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(ok(r));
}

fn test_typecheck_inherent_impl_method_mut_receiver_rejects_immutable_place() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct I { v: i32 }
    impl I {
      fn inc(x: &mut I) -> i32 { return x.v + 1; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return x.inc();
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "is immutable"), msg);
}

fn test_typecheck_inherent_impl_method_mut_receiver_rejects_non_place() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct I { v: i32 }
    impl I {
      fn inc(x: &mut I) -> i32 { return x.v + 1; }
    }
    fn main() -> i32 { return I { v: 1 }.inc(); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "must be mutable place"), msg);
}

fn test_typecheck_inherent_impl_assoc_type_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct I { v: i32 }
    impl I {
      type Item = i32;
      fn inc(x: I) -> i32 { return x.v + 1; }
    }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "inherent impl does not support associated types"));
}

fn test_typecheck_inherent_impl_receiver_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct I { v: i32 }
    impl I {
      fn bad(x: i32) -> i32 { return x; }
    }
    fn main() -> i32 { let x: I = I { v: 1 }; return x.bad(); }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert(!ok(r));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert(contains(msg, "inherent impl method receiver type mismatch"));
}

fn test_typecheck_generic_type_param_pack_infer_without_explicit_type_args_accepted() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn id[T...](x: T) -> T { return x; }\nfn main() -> i32 { return id(7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_generic_type_param_pack_type_args_must_precede_const_args_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn f[T..., const N: i32](x: T) -> T { return x; }\nfn main() -> i32 { return f[3, i32](7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "generic arg order error: type args must come before const args"), msg);
}

fn test_typecheck_generic_type_param_pack_extra_type_args_with_const_suffix_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn f[T..., const N: i32](x: T) -> T { return x; }\nfn main() -> i32 { return f[i32, i64, 3](7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  let ok_msg: bool = contains(msg, "return type mismatch") || contains(msg, "typecheck failed");
  t.assert_with(ok_msg, msg);
}

fn test_typecheck_generic_type_param_pack_same_type_args_with_const_suffix_accepted() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn f[T..., const N: i32](x: T) -> T { return x; }\nfn main() -> i32 { return f[i32, i32, 3](7); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_const_fn_call_type_param_pack_same_type_args_with_const_suffix_accepted() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn f[T..., const N: i32](x: T) -> T { return x; }\nconst X: i32 = f[i32, i32, 3](7)\nfn main() -> i32 { return X; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_const_fn_call_type_param_pack_extra_type_args_with_const_suffix_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn f[T..., const N: i32](x: T) -> T { return x; }\nconst X: i32 = f[i32, i64, 3](7)\nfn main() -> i32 { return X; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  let ok_msg: bool = contains(msg, "const fn call type arg mismatch") || contains(msg, "const fn return type mismatch");
  t.assert_with(ok_msg, msg);
}

fn test_typecheck_generic_type_param_pack_unused_allows_heterogeneous_type_args_with_const_suffix() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn keep[T..., const N: i32]() -> i32 { return N; }\nfn main() -> i32 { return keep[i32, String, 7](); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_generic_type_param_pack_materialization_limit_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn keep[T..., const N: i32]() -> i32 { return N; }\nfn main() -> i32 { return keep[i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, 7](); }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "type pack arity exceeds materialization limit: 17 > 16"), msg);
}

fn test_typecheck_const_fn_call_type_param_pack_unused_allows_heterogeneous_type_args_with_const_suffix() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn keep[T..., const N: i32]() -> i32 { return N; }\nconst X: i32 = keep[i32, String, 9]()\nfn main() -> i32 { return X; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_const_fn_call_type_param_pack_materialization_limit_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "fn keep[T..., const N: i32]() -> i32 { return N; }\nconst X: i32 = keep[i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, 7]()\nfn main() -> i32 { return X; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "type pack arity exceeds materialization limit: 17 > 16"), msg);
}

fn test_typecheck_generic_type_param_pack_projection_bounds_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Mark { fn mark(v: Self) -> i32; }
    impl Mark for i32 { fn mark(v: i32) -> i32 { return v; } }
    impl Mark for i64 { fn mark(v: i64) -> i32 { return v as i32; } }
    fn keep[T..., const N: i32](a: T.0, b: T.1) -> i32
      where T.0: Mark, T.1: Mark, comptime @size_of(T.0) < @size_of(T.1) {
      return Mark.mark(a) + Mark.mark(b) + N;
    }
    fn main() -> i32 {
      let b: i64 = 5;
      return keep[i32, i64, 3](4, b);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_generic_type_param_pack_projection_effective_arity_limit_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Mark { fn mark(v: Self) -> i32; }
    impl Mark for i32 { fn mark(v: i32) -> i32 { return v; } }
    impl Mark for i64 { fn mark(v: i64) -> i32 { return v as i32; } }
    fn keep[T..., const N: i32](a: T.0, b: T.1) -> i32
      where T.0: Mark, T.1: Mark, comptime @size_of(T.1) >= 8 {
      return Mark.mark(a) + Mark.mark(b) + N;
    }
    fn main() -> i32 {
      let b: i64 = 5;
      return keep[i32, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, 3](4, b);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_const_fn_call_type_param_pack_projection_effective_arity_limit_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn keep[T..., const N: i32](_a: T.0, _b: T.1) -> i32
      where comptime @size_of(T.1) >= 8 {
      return N;
    }
    const X: i32 = keep[i32, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, 3](4, 5 as i64);
    fn main() -> i32 { return X; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
}

fn test_typecheck_generic_type_param_pack_projection_comptime_where_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Mark { fn mark(v: Self) -> i32; }
    impl Mark for i32 { fn mark(v: i32) -> i32 { return v; } }
    impl Mark for i64 { fn mark(v: i64) -> i32 { return v as i32; } }
    fn keep[T..., const N: i32](a: T.0, b: T.1) -> i32
      where T.0: Mark, T.1: Mark, comptime @size_of(T.0) < @size_of(T.1) {
      return Mark.mark(a) + Mark.mark(b) + N;
    }
    fn main() -> i32 {
      let a: i64 = 4;
      return keep[i64, i32, 3](a, 5);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "comptime generic constraint failed"), msg);
}

fn test_typecheck_const_reflect_intrinsic_error_uses_call_span_and_code() -> () {
  let mut w: tc.World = tc.world();
  let src: String = "\n\nconst BAD: usize = @size_of(UnknownType)\nfn main() -> i32 { return BAD as i32; }";
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(starts_with(msg, "src/main.vox:3:20:"), msg);
  t.assert_with(contains(msg, "const intrinsic type arg resolve failed"), msg);
  t.assert_with(contains(msg, "[E_TYPE_0001]"), msg);
}

fn test_typecheck_send_sync_auto_derive_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Send {}\npub trait Sync {}");
  let src: String = """
    struct Point { x: i32, y: i32 }
    enum Msg { Quit, Move(Point), Data(Vec[i32]) }

    fn need_send[T: Send](x: T) -> i32 { return 1; }
    fn need_sync[T: Sync](x: T) -> i32 { return 1; }

    fn main() -> i32 {
      let p: Point = Point { x: 1, y: 2 };
      let m: Msg = Msg.Move(Point { x: 3, y: 4 });
      let mut xs: Vec[i32] = Vec();
      xs.push(7);
      return need_send(p) + need_send(m) + need_sync(xs);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_send_bound_not_inferred_for_type_param_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Send {}\npub trait Sync {}");
  let src: String = """
    fn need_send[T: Send](x: T) -> i32 { return 0; }
    fn relay[T](x: T) -> i32 { return need_send[T](x); }
    fn main() -> i32 { return 0; }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "does not satisfy trait bound"), msg);
}

fn test_typecheck_negative_send_impl_overrides_auto_derive() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Send {}\npub trait Sync {}");
  let src: String = """
    struct UiHandle { id: i32 }
    impl !Send for UiHandle {}
    fn need_send[T: Send](x: T) -> i32 { return 1; }
    fn main() -> i32 {
      let h: UiHandle = UiHandle { id: 7 };
      return need_send(h);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "does not satisfy trait bound"), msg);
}

fn test_typecheck_negative_sync_impl_overrides_auto_derive() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Send {}\npub trait Sync {}");
  let src: String = """
    struct UiHandle { id: i32 }
    impl !Sync for UiHandle {}
    fn need_sync[T: Sync](x: T) -> i32 { return 1; }
    fn main() -> i32 {
      let h: UiHandle = UiHandle { id: 7 };
      return need_sync(h);
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "does not satisfy trait bound"), msg);
}

fn test_typecheck_negative_impl_non_send_sync_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Send {}\npub trait Sync {}");
  w = add_mod(w, "main", """
    trait Marker {}
    struct UiHandle { id: i32 }
    impl !Marker for UiHandle {}
    fn main() -> i32 { return 0; }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "negative impl is only allowed for std/prelude::Send and std/prelude::Sync"), msg);
}

fn test_typecheck_negative_send_impl_non_empty_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Send {}\npub trait Sync {}");
  w = add_mod(w, "main", """
    struct UiHandle { id: i32 }
    impl !Send for UiHandle {
      fn mark(x: UiHandle) -> i32 { return x.id; }
    }
    fn main() -> i32 { return 0; }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "negative impl must not define methods"), msg);
}

fn test_typecheck_manual_positive_send_impl_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Send {}\npub trait Sync {}");
  w = add_mod(w, "main", """
    struct UiHandle { id: i32 }
    impl Send for UiHandle {}
    fn main() -> i32 { return 0; }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "manual impl of auto marker trait is not allowed"), msg);
}

fn test_typecheck_manual_positive_sync_impl_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", "pub trait Send {}\npub trait Sync {}");
  w = add_mod(w, "main", """
    struct UiHandle { id: i32 }
    impl Sync for UiHandle {}
    fn main() -> i32 { return 0; }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "manual impl of auto marker trait is not allowed"), msg);
}

fn test_typecheck_reflect_type_name_and_type_id_for_borrow_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    const N0: String = @type_name(&i32)
    const N1: String = @type_name(&mut i32)
    const N2: String = @type_name(&'static str)
    const N3: String = @type_name(&'static mut i32)
    const N4: String = @type_name(&str)
    const T0: TypeId = @type(&i32)
    const T1: TypeId = @type(i32)

    fn main() -> i32 {
      return if N0 == "&i32" && N1 == "&mut i32" && N2 == "&'static str" &&
          N3 == "&'static mut i32" && N4 == "&str" && T0 != T1 { 1 } else { 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_release_stmt_requires_rebind() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
    impl[T] Release for Vec[T] { fn release(x: Vec[T]) -> Vec[T] { return Vec(); } }
  """);
  w = add_mod(w, "std/string", "pub fn release(s: String) -> String { return Release.release(s); }");
  w = add_mod(w, "main", """
    import "std/string" as s
    fn main() -> i32 {
      let a: String = "x";
      s.release(a);
      return 0;
    }
  """);
  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(!ok(r), tc.tc_error_to_string(r.err));
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "release call result must be assigned back"), msg);
}

fn test_typecheck_release_move_use_after_release_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "std/string", "pub fn release(s: String) -> String { return Release.release(s); }");
  w = add_mod(w, "main", """
    import "std/string" as s
    fn main() -> i32 {
      let mut a: String = "x";
      let _b: String = s.release(a);
      return a.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_release_move_self_rebind_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "std/string", "pub fn release(s: String) -> String { return Release.release(s); }");
  w = add_mod(w, "main", """
    import "std/string" as s
    fn main() -> i32 {
      let mut a: String = "x";
      a = s.release(a);
      return a.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_release_method_stmt_requires_rebind() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let a: String = "x";
      a.release();
      return 0;
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "release call result must be assigned back"), msg);
}

fn test_typecheck_release_method_move_use_after_release_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let mut a: String = "x";
      let _b: String = a.release();
      return a.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_release_move_if_branch_possible_use_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "std/string", "pub fn release(s: String) -> String { return Release.release(s); }");
  w = add_mod(w, "main", """
    import "std/string" as s
    fn main(flag: bool) -> i32 {
      let mut a: String = "x";
      if flag {
        let _b: String = s.release(a);
      }
      return a.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_release_move_if_both_branches_rebind_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "std/string", "pub fn release(s: String) -> String { return Release.release(s); }");
  w = add_mod(w, "main", """
    import "std/string" as s
    fn main(flag: bool) -> i32 {
      let mut a: String = "x";
      if flag {
        a = s.release(a);
      } else {
        a = s.release(a);
      }
      return a.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_release_move_member_arg_marks_root_moved() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "std/string", "pub fn release(s: String) -> String { return Release.release(s); }");
  w = add_mod(w, "main", """
    import "std/string" as s
    struct S { text: String, n: i32 }
    fn main() -> i32 {
      let mut a: S = S { text: "x", n: 1 };
      let _b: String = s.release(a.text);
      let _c: S = a;
      return 0;
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_release_method_member_marks_root_moved() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "main", """
    struct S { text: String, n: i32 }
    fn main() -> i32 {
      let mut a: S = S { text: "x", n: 1 };
      let _b: String = a.text.release();
      let _c: S = a;
      return 0;
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_release_move_member_chain_use_after_release_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "std/string", "pub fn release(s: String) -> String { return Release.release(s); }");
  w = add_mod(w, "main", """
    import "std/string" as s
    struct S { text: String }
    fn main() -> i32 {
      let mut a: S = S { text: "x" };
      let _b: String = s.release(a.text);
      return a.text.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_release_method_member_chain_use_after_release_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "main", """
    struct S { text: String }
    fn main() -> i32 {
      let mut a: S = S { text: "x" };
      let _b: String = a.text.release();
      return a.text.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_release_move_if_expr_marks_source_moved() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "std/string", "pub fn release(s: String) -> String { return Release.release(s); }");
  w = add_mod(w, "main", """
    import "std/string" as s
    fn main(flag: bool) -> i32 {
      let mut a: String = "x";
      let _b: String = if flag { s.release(a) } else { "y" };
      return a.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_release_move_block_expr_marks_source_moved() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "std/string", "pub fn release(s: String) -> String { return Release.release(s); }");
  w = add_mod(w, "main", """
    import "std/string" as s
    fn main() -> i32 {
      let mut a: String = "x";
      let _b: String = { let t: String = s.release(a); t };
      return a.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_release_trait_ufcs_move_use_after_release_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let mut a: String = "x";
      let _b: String = Release.release(a);
      return a.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_release_trait_ufcs_self_rebind_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let mut a: String = "x";
      a = Release.release(a);
      return a.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_release_move_multi_args_marks_all_sources() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "std/string", "pub fn release(s: String) -> String { return Release.release(s); }");
  w = add_mod(w, "main", """
    import "std/string" as s
    fn pick(a: String, b: String) -> String { return a; }
    fn main() -> i32 {
      let mut a: String = "x";
      let mut b: String = "y";
      let _c: String = pick(s.release(a), s.release(b));
      return b.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: b"), msg);
}

fn test_typecheck_release_move_assign_field_marks_source() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Release { fn release(x: Self) -> Self; }
    impl Release for String { fn release(x: String) -> String { return ""; } }
  """);
  w = add_mod(w, "std/string", "pub fn release(s: String) -> String { return Release.release(s); }");
  w = add_mod(w, "main", """
    import "std/string" as s
    struct Holder { text: String }
    fn main() -> i32 {
      let mut h: Holder = Holder { text: "t" };
      let mut a: String = "x";
      h.text = s.release(a);
      return a.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_move_call_by_value_use_after_call_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct S { text: String }
    fn take(x: S) -> i32 { return x.text.len(); }
    fn main() -> i32 {
      let a: S = S { text: "x" };
      let _n: i32 = take(a);
      return a.text.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_move_call_by_borrow_keeps_value_available() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct S { text: String }
    fn peek(x: &S) -> i32 { return x.text.len(); }
    fn main() -> i32 {
      let a: S = S { text: "x" };
      let _n: i32 = peek(a);
      return a.text.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_move_call_i32_copy_not_moved() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn id(x: i32) -> i32 { return x; }
    fn main() -> i32 {
      let a: i32 = 7;
      let _n: i32 = id(a);
      return a;
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_move_trait_method_by_value_receiver_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait Take { fn take(x: Self) -> i32; }
    struct S { text: String }
    impl Take for S { fn take(x: S) -> i32 { return x.text.len(); } }
    fn main() -> i32 {
      let a: S = S { text: "x" };
      let _n: i32 = a.take();
      return a.text.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(!ok(r), msg);
  t.assert_with(contains(msg, "use of moved value: a"), msg);
}

fn test_typecheck_move_trait_method_by_borrow_receiver_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait Peek { fn peek(x: &Self) -> i32; }
    struct S { n: i32 }
    impl Peek for S { fn peek(x: &S) -> i32 { return x.n; } }
    fn main() -> i32 {
      let a: S = S { n: 7 };
      let _n: i32 = a.peek();
      return a.n;
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  t.assert_with(ok(r), tc.tc_error_to_string(r.err));
  t.assert(ok(r));
}

fn test_typecheck_move_call_member_arg_keeps_root_available() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn take(x: String) -> i32 { return x.len(); }
    struct H { text: String }
    fn main() -> i32 {
      let a: H = H { text: "x" };
      let _n: i32 = take(a.text);
      return a.text.len();
    }
  """);

  let r: tc.TcResult = tc.typecheck_world(w);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(ok(r), msg);
  t.assert(ok(r));
}
