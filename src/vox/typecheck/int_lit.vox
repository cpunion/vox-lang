// Decimal integer literal parsing helpers for stage1 toolchain.
//
// Note: lexer guarantees the token text is digits only, but these helpers are
// defensive and also perform range checks.

pub struct ParseI32DecResult { pub ok: bool, pub val: i32 }

pub struct ParseI64DecResult { pub ok: bool, pub val: i64 }

pub struct ParseU64DecResult { pub ok: bool, pub val: i64 }

pub fn parse_i32_dec(s: String) -> ParseI32DecResult {
  if s.len() == 0 { return ParseI32DecResult { ok: false, val: 0 }; }
  let max: i32 = 2147483647;
  let mut n: i32 = 0;
  let mut i: i32 = 0;
  while i < s.len() {
    let b: i32 = s.byte_at(i);
    if b < 48 || b > 57 { return ParseI32DecResult { ok: false, val: 0 }; }
    let d: i32 = b - 48;
    // overflow check: n*10 + d <= max
    if n > (max - d) / 10 { return ParseI32DecResult { ok: false, val: 0 }; }
    n = n * 10 + d;
    i = i + 1;
  }
  return ParseI32DecResult { ok: true, val: n };
}

pub fn parse_i64_dec(s: String) -> ParseI64DecResult {
  if s.len() == 0 { return ParseI64DecResult { ok: false, val: 0 }; }
  let max: i64 = 9223372036854775807;
  let mut neg: bool = false;
  let mut n: i64 = 0;
  let mut i: i32 = 0;
  if s.byte_at(0) == 45 { // '-'
    neg = true;
    i = 1;
    if s.len() == 1 { return ParseI64DecResult { ok: false, val: 0 }; }
  }
  while i < s.len() {
    let b: i32 = s.byte_at(i);
    if b < 48 || b > 57 { return ParseI64DecResult { ok: false, val: 0 }; }
    // Avoid implicit casts and avoid `match` on i32 (stage0 interp only supports enum match).
    let mut d: i64 = 0;
    if b == 48 { d = 0; }
    else if b == 49 { d = 1; }
    else if b == 50 { d = 2; }
    else if b == 51 { d = 3; }
    else if b == 52 { d = 4; }
    else if b == 53 { d = 5; }
    else if b == 54 { d = 6; }
    else if b == 55 { d = 7; }
    else if b == 56 { d = 8; }
    else { d = 9; }
    // overflow check: n*10 + d <= max
    if n > (max - d) / 10 { return ParseI64DecResult { ok: false, val: 0 }; }
    n = n * 10 + d;
    i = i + 1;
  }
  if neg { return ParseI64DecResult { ok: true, val: -n }; }
  return ParseI64DecResult { ok: true, val: n };
}

fn dec_gt_u64_max(s: String) -> bool {
  // max_u64 = 18446744073709551615
  let maxs: String = "18446744073709551615";
  if s.len() != maxs.len() { return s.len() > maxs.len(); }
  let mut i: i32 = 0;
  while i < s.len() {
    let a: i32 = s.byte_at(i);
    let b: i32 = maxs.byte_at(i);
    if a > b { return true; }
    if a < b { return false; }
    i = i + 1;
  }
  return false;
}

pub fn parse_u64_dec(s: String) -> ParseU64DecResult {
  if s.len() == 0 { return ParseU64DecResult { ok: false, val: 0 }; }
  if s.len() > 20 { return ParseU64DecResult { ok: false, val: 0 }; }
  if s.len() == 20 && dec_gt_u64_max(s) { return ParseU64DecResult { ok: false, val: 0 }; }

  // Accumulate as i64 with wrap semantics; this preserves the desired
  // two's-complement bit pattern for full u64 range values.
  let mut n: i64 = 0;
  let mut i: i32 = 0;
  while i < s.len() {
    let b: i32 = s.byte_at(i);
    if b < 48 || b > 57 { return ParseU64DecResult { ok: false, val: 0 }; }
    let mut d: i64 = 0;
    if b == 48 { d = 0; }
    else if b == 49 { d = 1; }
    else if b == 50 { d = 2; }
    else if b == 51 { d = 3; }
    else if b == 52 { d = 4; }
    else if b == 53 { d = 5; }
    else if b == 54 { d = 6; }
    else if b == 55 { d = 7; }
    else if b == 56 { d = 8; }
    else { d = 9; }
    n = n * 10 + d;
    i = i + 1;
  }
  return ParseU64DecResult { ok: true, val: n };
}
