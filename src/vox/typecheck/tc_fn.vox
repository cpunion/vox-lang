import "vox/ast" as ast
import "vox/ir" as ir

fn has_prefix_tc_fn(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

fn find_param_ty_idx_fn_body(ctx: Ctx, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < ctx.pool.tys.len() {
    let t: ir.Ty = ir.ty_pool_get(ctx.pool, i);
    if t.kind == ir.TyKind.Param && t.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn remap_tp_name_for_body(old_tps: Vec[String], new_tps: Vec[String], name: String) -> String {
  let mut i: i32 = 0;
  while i < old_tps.len() {
    if old_tps.get(i) == name { return new_tps.get(i); }
    i = i + 1;
  }
  return name;
}

fn remap_sig_for_body(ctx: Ctx, sig: FuncSig, src_method_tps: Vec[String]) -> FuncSig {
  if src_method_tps.len() == 0 || src_method_tps.len() > sig.type_params.len() { return sig; }
  let start: i32 = sig.type_params.len() - src_method_tps.len();

  let mut old_tail: Vec[String] = Vec();
  let mut new_tail: Vec[String] = Vec();
  let mut out_tps: Vec[String] = Vec();
  let mut subs: Vec[TySub] = Vec();

  let mut i: i32 = 0;
  while i < sig.type_params.len() {
    let old: String = sig.type_params.get(i);
    let nm: String = if i >= start { src_method_tps.get(i - start) } else { old };
    out_tps.push(nm);
    if i >= start && old != nm {
      old_tail.push(old);
      new_tail.push(nm);
      let nty: i32 = find_param_ty_idx_fn_body(ctx, nm);
      if nty != -1 { subs.push(TySub { name: old, ty: nty }); }
    }
    i = i + 1;
  }

  let mut out_params: Vec[i32] = Vec();
  i = 0;
  while i < sig.params.len() {
    out_params.push(subst_ty(ctx, sig.params.get(i), subs));
    i = i + 1;
  }
  let out_ret: i32 = subst_ty(ctx, sig.ret, subs);
  let out_variadic_elem: i32 = if sig.has_variadic { subst_ty(ctx, sig.variadic_elem, subs) } else { sig.variadic_elem };

  let mut out_bounds: Vec[TypeParamBoundSig] = Vec();
  i = 0;
  while i < sig.type_param_bounds.len() {
    let b: TypeParamBoundSig = sig.type_param_bounds.get(i);
    out_bounds.push(TypeParamBoundSig {
      type_param: remap_tp_name_for_body(old_tail, new_tail, b.type_param),
      trait_mod_path: b.trait_mod_path,
      trait_name: b.trait_name,
    });
    i = i + 1;
  }

  let mut out_tpps: Vec[String] = Vec();
  i = 0;
  while i < sig.type_param_packs.len() {
    out_tpps.push(remap_tp_name_for_body(old_tail, new_tail, sig.type_param_packs.get(i)));
    i = i + 1;
  }

  return FuncSig {
    params: out_params,
    param_borrow_kinds: sig.param_borrow_kinds,
    ret: out_ret,
    has_variadic: sig.has_variadic,
    variadic_elem: out_variadic_elem,
    vis: sig.vis,
    is_pub: sig.is_pub,
    type_params: out_tps,
    type_param_packs: out_tpps,
    const_params: sig.const_params,
    type_param_bounds: out_bounds,
    const_where_bounds: sig.const_where_bounds,
  };
}

fn typecheck_fn_with_sig(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, fnc: ast.FuncDecl, sig: FuncSig) -> TcResult {
  if fnc.ffi_imports.len() != 0 {
    return TcResult { ok: true, err: TcError.None };
  }
  let use_sig: FuncSig = remap_sig_for_body(ctx, sig, fnc.type_params);
  let mut l: Locals = locals_new();
  l.type_params = use_sig.type_params;
  l.type_param_bounds = use_sig.type_param_bounds;
  l.fn_is_async = fnc.is_async;
  let mut body_ret: i32 = use_sig.ret;
  if fnc.is_async {
    let ar: FindAsyncFnResult = find_async_fn(ctx, mod_path, fnc.name);
    if !ar.found {
      return TcResult { ok: false, err: type_error_at(fnc.sp, "missing async fn lowering metadata") };
    }
    body_ret = ar.sig.output_ty;
  }
  l.fn_ret_ty = body_ret;
  // Function const params are compile-time values (possibly unknown at definition check time).
  let mut ci: i32 = 0;
  while ci < use_sig.const_params.len() {
    let cp: ConstParamSig = use_sig.const_params.get(ci);
    l = locals_decl_const(l, cp.name, cp.ty);
    ci = ci + 1;
  }
  // params at depth 0
  let mut pi: i32 = 0;
  while pi < fnc.params.len() {
    let p: ast.Param = fnc.params.get(pi);
    l = locals_decl(l, p.name, use_sig.params.get(pi), false);
    pi = pi + 1;
  }

  let r: TcStmtResult = tc_block(ctx, w, mod_path, imps, exprs, l, body_ret, fnc.body);
  if !r.ok {
    return TcResult { ok: false, err: r.err };
  }
  return TcResult { ok: true, err: TcError.None };
}

fn typecheck_fn(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, fnc: ast.FuncDecl) -> TcResult {
  let fr: FindFuncResult = find_func(ctx, mod_path, fnc.name);
  if !fr.found {
    return TcResult { ok: false, err: type_error_at(fnc.sp, "missing fn sig") };
  }
  return typecheck_fn_with_sig(ctx, w, mod_path, imps, exprs, fnc, fr.sig);
}

struct TcStmtResult { ok: bool, err: TcError, ctx: Ctx, locals: Locals }

fn split_field_path(path: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut start: i32 = 0;
  let mut i: i32 = 0;
  while i < path.len() {
    if path.byte_at(i) == 46 {
      out.push(path.slice(start, i));
      start = i + 1;
    }
    i = i + 1;
  }
  out.push(path.slice(start, path.len()));
  return out;
}

fn tc_block(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, ret_ty: i32, b: ast.Block) -> TcStmtResult {
  let mut c: Ctx = ctx;
  let mut l: Locals = locals_enter(l0);
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let r: TcStmtResult = tc_stmt(c, w, mod_path, imps, exprs, l, ret_ty, b.stmts.get(i));
    if !r.ok { return r; }
    c = r.ctx;
    l = r.locals;
    i = i + 1;
  }
  l = locals_exit(l);
  let l1: Locals = locals_sync_moved(l0, l);
  return TcStmtResult { ok: true, err: TcError.None, ctx: c, locals: l1 };
}

fn tc_stmt(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, ret_ty: i32, st: ast.Stmt) -> TcStmtResult {
  let break_outside_err: String = "break outside loop";
  let continue_outside_err: String = "continue outside loop";
  return match st {
    ast.Stmt.Let(sp, mutable, name, has_ann, ann, init) => tc_stmt_let(ctx, w, mod_path, imps, exprs, l0, sp, mutable, name, has_ann, ann, init),
    ast.Stmt.Assign(sp, name, rhs) => tc_stmt_assign(ctx, w, mod_path, imps, exprs, l0, sp, name, rhs),
    ast.Stmt.AssignField(sp, recv, field, rhs) => tc_stmt_assign_field(ctx, w, mod_path, imps, exprs, l0, sp, recv, field, rhs),
    ast.Stmt.ExprStmt(sp, eid) => tc_stmt_expr(ctx, w, mod_path, imps, exprs, l0, sp, eid),
    ast.Stmt.IfStmt(sp, cond, then_b, has_else, else_b) => tc_stmt_if(ctx, w, mod_path, imps, exprs, l0, ret_ty, sp, cond, then_b, has_else, else_b),
    ast.Stmt.WhileStmt(sp, cond, body) => tc_stmt_while(ctx, w, mod_path, imps, exprs, l0, ret_ty, sp, cond, body),
    ast.Stmt.Break(sp) =>
      if l0.loop_depth > 0 {
        TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 }
      } else {
        TcStmtResult {
          ok: false,
          err: type_error_at(sp, break_outside_err),
          ctx: ctx,
          locals: l0,
        }
      },
    ast.Stmt.Continue(sp) =>
      if l0.loop_depth > 0 {
        TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 }
      } else {
        TcStmtResult {
          ok: false,
          err: type_error_at(sp, continue_outside_err),
          ctx: ctx,
          locals: l0,
        }
      },
    ast.Stmt.ReturnStmt(sp, has, eid) => tc_stmt_return(ctx, w, mod_path, imps, exprs, l0, ret_ty, sp, has, eid),
  };
}

struct LetInitPlaceResult { ok: bool, mutable: bool }

fn expr_let_init_place(exprs: ast.ExprPool, l0: Locals, expr_id: i32) -> LetInitPlaceResult {
  let mut cur: i32 = expr_id;
  while true {
    let n: ast.ExprNode = ast.expr_pool_get(exprs, cur);
    if match n { ast.ExprNode.Ident(_s) => true, _ => false } {
      let name: String = match n { ast.ExprNode.Ident(s) => s, _ => "" };
      let vr: LookupVarResult = locals_lookup(l0, name);
      if !vr.found { return LetInitPlaceResult { ok: false, mutable: false }; }
      return LetInitPlaceResult { ok: true, mutable: vr.mutable };
    }
    if match n { ast.ExprNode.Member(r, _name) => true, _ => false } {
      cur = match n { ast.ExprNode.Member(r, _name) => r, _ => -1 };
      continue;
    }
    return LetInitPlaceResult { ok: false, mutable: false };
  }
  return LetInitPlaceResult { ok: false, mutable: false };
}

fn check_let_borrow_init(exprs: ast.ExprPool, l0: Locals, ann: ast.TypeName, init: i32) -> TcError {
  let bk: i32 = tn_param_borrow_kind(ann);
  if bk == param_borrow_none() || bk == param_borrow_ref_static() { return TcError.None; }

  let pr: LetInitPlaceResult = expr_let_init_place(exprs, l0, init);
  let isp: ast.Span = ast.expr_pool_span(exprs, init);

  if bk == param_borrow_ref() {
    if !pr.ok { return type_error_at(isp, "let init for & annotation must be place"); }
    return TcError.None;
  }

  if param_borrow_is_mut(bk) {
    if !pr.ok { return type_error_at(isp, "let init for &mut annotation must be mutable place"); }
    if !pr.mutable { return type_error_at(isp, "let init for &mut annotation is immutable"); }
    return TcError.None;
  }

  return TcError.None;
}

fn tc_stmt_let(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, sp: ast.Span, mutable: bool, name: String, has_ann: bool, ann: ast.TypeName, init: i32) -> TcStmtResult {
  let mut c: Ctx = ctx;
  let mut expected: i32 = -1;
  if has_ann {
    if !tn_nonstatic_borrow_allowed_local_type(ann) {
      return TcStmtResult { ok: false, err: type_error_at(sp, "non-static borrowed type in let annotation must be top-level &T or &mut T"), ctx: c, locals: l0 };
    }
    let rr: ResolveTyResult = resolve_type(c, w, mod_path, imps, l0.type_params, ann);
    c = rr.ctx;
    if !rr.ok {
      let msg: String = named_lifetime_type_error(ann);
      return TcStmtResult { ok: false, err: type_error_at(sp, if msg != "" { msg } else { "bad let annotation" }), ctx: c, locals: l0 };
    }
    expected = rr.idx;
  }
  if has_ann {
    let berr: TcError = check_let_borrow_init(exprs, l0, ann, init);
    if berr != TcError.None { return TcStmtResult { ok: false, err: berr, ctx: c, locals: l0 }; }
  }
  let er: ExprTyResult = tc_expr(c, w, mod_path, imps, exprs, l0, init, expected);
  if !er.ok { return TcStmtResult { ok: false, err: er.err, ctx: c, locals: l0 }; }
  let mut final_ty: i32 = er.ty;
  if has_ann {
    final_ty = expected;
    if !assignable_to(c, final_ty, er.ty) { return TcStmtResult { ok: false, err: type_error_at(ast.expr_pool_span(exprs, init), "let init type mismatch"), ctx: c, locals: l0 }; }
  }
  let moved_names_release: Vec[String] = release_move_sources(c, l0, imps, exprs, init);
  let moved_names_value: Vec[String] = expr_value_move_sources(c, w, mod_path, l0, imps, exprs, init);
  let moved_names: Vec[String] = move_names_merge(moved_names_release, moved_names_value);
  let mut lbase: Locals = l0;
  let mut mi: i32 = 0;
  while mi < moved_names.len() {
    lbase = locals_mark_moved(lbase, moved_names.get(mi));
    mi = mi + 1;
  }
  let l1: Locals = locals_decl(lbase, name, final_ty, mutable);
  return TcStmtResult { ok: true, err: TcError.None, ctx: c, locals: l1 };
}

fn tc_stmt_assign(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, sp: ast.Span, name: String, rhs: i32) -> TcStmtResult {
  let vr: LookupVarResult = locals_lookup(l0, name);
  if !vr.found { return TcStmtResult { ok: false, err: type_error_at(sp, "unknown var"), ctx: ctx, locals: l0 }; }
  if !vr.mutable { return TcStmtResult { ok: false, err: type_error_at(sp, "assign to immutable var"), ctx: ctx, locals: l0 }; }
  let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, rhs, vr.ty);
  if !er.ok { return TcStmtResult { ok: false, err: er.err, ctx: ctx, locals: l0 }; }
  if !assignable_to(ctx, vr.ty, er.ty) { return TcStmtResult { ok: false, err: type_error_at(ast.expr_pool_span(exprs, rhs), "assign type mismatch"), ctx: ctx, locals: l0 }; }
  let moved_names_release: Vec[String] = release_move_sources(ctx, l0, imps, exprs, rhs);
  let moved_names_value: Vec[String] = expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, rhs);
  let moved_names: Vec[String] = move_names_merge(moved_names_release, moved_names_value);
  let mut l1: Locals = locals_clear_moved(l0, name);
  let mut mi: i32 = 0;
  while mi < moved_names.len() {
    let mn: String = moved_names.get(mi);
    if mn != name { l1 = locals_mark_moved(l1, mn); }
    mi = mi + 1;
  }
  return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l1 };
}

fn tc_stmt_assign_field(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, sp: ast.Span, recv: String, field: String, rhs: i32) -> TcStmtResult {
  let vr: LookupVarResult = locals_lookup(l0, recv);
  if !vr.found { return TcStmtResult { ok: false, err: type_error_at(sp, "unknown var"), ctx: ctx, locals: l0 }; }
  if vr.moved { return TcStmtResult { ok: false, err: type_error_at(sp, "assign to field of moved var"), ctx: ctx, locals: l0 }; }
  if !vr.mutable { return TcStmtResult { ok: false, err: type_error_at(sp, "assign to immutable var"), ctx: ctx, locals: l0 }; }

  let parts: Vec[String] = split_field_path(field);
  let mut cur_ty: i32 = vr.ty;
  let mut fty: i32 = ctx.ty_bad;
  let mut pi: i32 = 0;
  while pi < parts.len() {
    let rt: ir.Ty = ir.ty_pool_get(ctx.pool, cur_ty);
    if rt.kind != ir.TyKind.Struct { return TcStmtResult { ok: false, err: type_error_at(sp, "field assign recv must be struct"), ctx: ctx, locals: l0 }; }
    let fs: FindStructResult = find_struct(ctx, rt.mod_path, rt.name);
    if !fs.found { return TcStmtResult { ok: false, err: type_error_at(sp, "unknown struct type"), ctx: ctx, locals: l0 }; }
    // Visibility: crossing modules requires both the type and the field to be visible.
    if !vis_allows(fs.sig.vis, fs.sig.mod_path, mod_path) { return TcStmtResult { ok: false, err: type_error_at(sp, "type is private"), ctx: ctx, locals: l0 }; }

    let mut found: bool = false;
    let mut next_ty: i32 = ctx.ty_bad;
    let mut fvis: i32 = ast.vis_private();
    let mut i: i32 = 0;
    while i < fs.sig.fields.len() {
      let f: StructFieldSig = fs.sig.fields.get(i);
      if f.name == parts.get(pi) {
        found = true;
        next_ty = f.ty;
        fvis = f.vis;
        break;
      }
      i = i + 1;
    }
    if !found { return TcStmtResult { ok: false, err: type_error_at(sp, "unknown field"), ctx: ctx, locals: l0 }; }
    if !vis_allows(fvis, fs.sig.mod_path, mod_path) { return TcStmtResult { ok: false, err: type_error_at(sp, "field is private"), ctx: ctx, locals: l0 }; }
    fty = next_ty;
    cur_ty = next_ty;
    pi = pi + 1;
  }

  let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, rhs, fty);
  if !er.ok { return TcStmtResult { ok: false, err: er.err, ctx: ctx, locals: l0 }; }
  if !assignable_to(ctx, fty, er.ty) { return TcStmtResult { ok: false, err: type_error_at(ast.expr_pool_span(exprs, rhs), "assign type mismatch"), ctx: ctx, locals: l0 }; }
  let moved_names_release: Vec[String] = release_move_sources(ctx, l0, imps, exprs, rhs);
  let moved_names_value: Vec[String] = expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, rhs);
  let moved_names: Vec[String] = move_names_merge(moved_names_release, moved_names_value);
  let mut l1: Locals = l0;
  let mut mi: i32 = 0;
  while mi < moved_names.len() {
    l1 = locals_mark_moved(l1, moved_names.get(mi));
    mi = mi + 1;
  }
  return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l1 };
}

struct ReleaseMoveSourceResult { found: bool, name: String }
struct ExprPlaceRootResult { found: bool, name: String, from_member: bool }

fn expr_place_root(exprs: ast.ExprPool, eid: i32) -> ExprPlaceRootResult {
  let mut cur: i32 = eid;
  let mut from_member: bool = false;
  while true {
    let n: ast.ExprNode = ast.expr_pool_get(exprs, cur);
    if match n { ast.ExprNode.Ident(_name) => true, _ => false } {
      let name: String = match n { ast.ExprNode.Ident(s) => s, _ => "" };
      return ExprPlaceRootResult { found: true, name: name, from_member: from_member };
    }
    if match n { ast.ExprNode.Member(recv, _field) => true, _ => false } {
      cur = match n { ast.ExprNode.Member(recv, _field) => recv, _ => -1 };
      from_member = true;
      continue;
    }
    return ExprPlaceRootResult { found: false, name: "", from_member: false };
  }
  return ExprPlaceRootResult { found: false, name: "", from_member: false };
}

fn is_release_track_ty(ctx: Ctx, ty0: i32) -> bool {
  let ty: i32 = strip_range(ctx, ty0);
  if ty == ctx.ty_string || is_vec_ty(ctx, ty) { return true; }
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty);
  if t.kind == ir.TyKind.Struct && t.mod_path == "std/collections" && has_prefix_tc_fn(t.name, "Map") { return true; }
  return false;
}

fn release_trait_path(exprs: ast.ExprPool, eid: i32) -> bool {
  let pr: ExprTypePathResult = expr_type_path(exprs, eid);
  if !pr.ok || pr.parts.len() == 0 { return false; }
  return pr.parts.get(pr.parts.len() - 1) == "Release";
}

fn release_move_from_call(ctx: Ctx, l0: Locals, imps: Imports, exprs: ast.ExprPool, callee: i32, args: Vec[i32]) -> ReleaseMoveSourceResult {
  let cn: ast.ExprNode = ast.expr_pool_get(exprs, callee);

  if match cn { ast.ExprNode.Ident(name) => name == "release" || name == "release_vec", _ => false } {
    if args.len() == 1 {
      let pr: ExprPlaceRootResult = expr_place_root(exprs, args.get(0));
      if pr.found {
        let vr: LookupVarResult = locals_lookup(l0, pr.name);
        if vr.found {
          if pr.from_member || is_release_track_ty(ctx, vr.ty) { return ReleaseMoveSourceResult { found: true, name: pr.name }; }
        }
      }
    }
    return ReleaseMoveSourceResult { found: false, name: "" };
  }

  if match cn { ast.ExprNode.Member(_recv, _name) => true, _ => false } {
    let recv: i32 = match cn { ast.ExprNode.Member(r, _name) => r, _ => -1 };
    let mname: String = match cn { ast.ExprNode.Member(_r, name) => name, _ => "" };
    let rn: ast.ExprNode = ast.expr_pool_get(exprs, recv);

    if mname == "release" && args.len() == 0 {
      let pr0: ExprPlaceRootResult = expr_place_root(exprs, recv);
      if pr0.found {
        let vr0: LookupVarResult = locals_lookup(l0, pr0.name);
        if vr0.found {
          if pr0.from_member || is_release_track_ty(ctx, vr0.ty) { return ReleaseMoveSourceResult { found: true, name: pr0.name }; }
        }
      }
    }

    if mname == "release" && args.len() == 1 && release_trait_path(exprs, recv) {
      let prt: ExprPlaceRootResult = expr_place_root(exprs, args.get(0));
      if prt.found {
        let vrt: LookupVarResult = locals_lookup(l0, prt.name);
        if vrt.found {
          if prt.from_member || is_release_track_ty(ctx, vrt.ty) { return ReleaseMoveSourceResult { found: true, name: prt.name }; }
        }
      }
    }

    if match rn { ast.ExprNode.Ident(_alias) => true, _ => false } {
      let alias: String = match rn { ast.ExprNode.Ident(s) => s, _ => "" };
      let p: String = find_import_alias_path(imps, alias);
      let ok_mod_fn: bool =
        (p == "std/string" && mname == "release") ||
        (p == "std/collections" && (mname == "release" || mname == "release_vec"));
      if ok_mod_fn && args.len() == 1 {
        let pr1: ExprPlaceRootResult = expr_place_root(exprs, args.get(0));
        if pr1.found {
          let vr1: LookupVarResult = locals_lookup(l0, pr1.name);
          if vr1.found {
            if pr1.from_member || is_release_track_ty(ctx, vr1.ty) { return ReleaseMoveSourceResult { found: true, name: pr1.name }; }
          }
        }
      }
    }
  }

  return ReleaseMoveSourceResult { found: false, name: "" };
}

fn move_names_contains(xs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn move_names_add(xs0: Vec[String], s: String) -> Vec[String] {
  if s == "" { return xs0; }
  if move_names_contains(xs0, s) { return xs0; }
  let mut out: Vec[String] = xs0;
  out.push(s);
  return out;
}

fn move_names_merge(xs0: Vec[String], ys: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = xs0;
  let mut i: i32 = 0;
  while i < ys.len() {
    let s: String = ys.get(i);
    if s != "" {
      let mut found: bool = false;
      let mut j: i32 = 0;
      while j < out.len() {
        if out.get(j) == s { found = true; }
        j = j + 1;
      }
      if !found { out.push(s); }
    }
    i = i + 1;
  }
  return out;
}

fn is_copy_move_ty(ctx: Ctx, ty0: i32) -> bool {
  let t0: ir.Ty = ir.ty_pool_get(ctx.pool, ty0);
  if t0.kind == ir.TyKind.Ref { return true; }
  let ty: i32 = strip_range(ctx, ty0);
  if ty == ctx.ty_unit || ty == ctx.ty_bool || ty == ctx.ty_string { return true; }
  if is_int_like_ty(ctx, ty) || is_float_ty(ctx, ty) { return true; }
  return false;
}

fn is_value_move_track_ty(ctx: Ctx, ty0: i32) -> bool {
  return !is_copy_move_ty(ctx, ty0);
}

fn value_move_names_from_call(
  ctx: Ctx,
  w: World,
  mod_path: String,
  l0: Locals,
  imps: Imports,
  exprs: ast.ExprPool,
  callee: i32,
  type_args: Vec[ast.TypeName],
  args: Vec[i32]
) -> Vec[String] {
  let mr: CallMoveSlotsResult = resolve_call_move_slots(ctx, w, mod_path, imps, exprs, l0, callee, type_args, args);
  if !mr.ok { return Vec(); }

  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < mr.slots.len() {
    let s: CallMoveSlot = mr.slots.get(i);
    if s.borrow_kind == param_borrow_none() {
      let pr: ExprPlaceRootResult = expr_place_root(exprs, s.expr_id);
      if pr.found {
        let vr: LookupVarResult = locals_lookup(l0, pr.name);
        if vr.found {
          if !pr.from_member && is_value_move_track_ty(ctx, vr.ty) {
            out = move_names_add(out, pr.name);
          }
        }
      }
    }
    i = i + 1;
  }
  return out;
}

fn expr_value_move_sources_from_stmt(ctx: Ctx, w: World, mod_path: String, l0: Locals, imps: Imports, exprs: ast.ExprPool, st: ast.Stmt) -> Vec[String] {
  return match st {
    ast.Stmt.Let(_sp, _m, _name, _has_ann, _ann, init) => expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, init),
    ast.Stmt.Assign(_sp, _name, rhs) => expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, rhs),
    ast.Stmt.AssignField(_sp, _recv, _field, rhs) => expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, rhs),
    ast.Stmt.ExprStmt(_sp, eid) => expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, eid),
    ast.Stmt.IfStmt(_sp, cond, then_b, has_else, else_b) => {
      let mut out: Vec[String] = expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, cond);
      out = move_names_merge(out, expr_value_move_sources_from_block(ctx, w, mod_path, l0, imps, exprs, then_b));
      if has_else { out = move_names_merge(out, expr_value_move_sources_from_block(ctx, w, mod_path, l0, imps, exprs, else_b)); }
      out
    },
    ast.Stmt.WhileStmt(_sp, cond, body) => {
      let mut out: Vec[String] = expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, cond);
      out = move_names_merge(out, expr_value_move_sources_from_block(ctx, w, mod_path, l0, imps, exprs, body));
      out
    },
    ast.Stmt.ReturnStmt(_sp, has, eid) => if has { expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, eid) } else { Vec() },
    _ => Vec(),
  };
}

fn expr_value_move_sources_from_block(ctx: Ctx, w: World, mod_path: String, l0: Locals, imps: Imports, exprs: ast.ExprPool, b: ast.Block) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    out = move_names_merge(out, expr_value_move_sources_from_stmt(ctx, w, mod_path, l0, imps, exprs, b.stmts.get(i)));
    i = i + 1;
  }
  return out;
}

fn expr_value_move_sources(ctx: Ctx, w: World, mod_path: String, l0: Locals, imps: Imports, exprs: ast.ExprPool, eid: i32) -> Vec[String] {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);

  if match n { ast.ExprNode.Call(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(c, _t, _a) => c, _ => -1 };
    let type_args: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_c, ta, _a) => ta, _ => Vec() };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _t, a) => a, _ => Vec() };

    let mut out: Vec[String] = value_move_names_from_call(ctx, w, mod_path, l0, imps, exprs, callee, type_args, args);
    out = move_names_merge(out, expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, callee));
    let mut i: i32 = 0;
    while i < args.len() {
      out = move_names_merge(out, expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, args.get(i)));
      i = i + 1;
    }
    return out;
  }

  if match n { ast.ExprNode.MacroCall(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.MacroCall(c, _t, _a) => c, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.MacroCall(_c, _t, a) => a, _ => Vec() };
    let mut out: Vec[String] = expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, callee);
    let mut i: i32 = 0;
    while i < args.len() {
      out = move_names_merge(out, expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, args.get(i)));
      i = i + 1;
    }
    return out;
  }

  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Unary(_op, a0) => a0, _ => -1 };
    return expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, a);
  }

  if match n { ast.ExprNode.As(_a, _ty) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(a0, _ty) => a0, _ => -1 };
    return expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, a);
  }

  if match n { ast.ExprNode.Binary(_op, _a, _b) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Binary(_op, a0, _b) => a0, _ => -1 };
    let b: i32 = match n { ast.ExprNode.Binary(_op, _a, b0) => b0, _ => -1 };
    return move_names_merge(expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, a), expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, b));
  }

  if match n { ast.ExprNode.Member(_recv, _name) => true, _ => false } {
    let recv: i32 = match n { ast.ExprNode.Member(r, _name) => r, _ => -1 };
    return expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, recv);
  }

  if match n { ast.ExprNode.If(_cond, _then, _else) => true, _ => false } {
    let cond: i32 = match n { ast.ExprNode.If(c0, _t, _e) => c0, _ => -1 };
    let then_id: i32 = match n { ast.ExprNode.If(_c, t0, _e) => t0, _ => -1 };
    let else_id: i32 = match n { ast.ExprNode.If(_c, _t, e0) => e0, _ => -1 };
    let mut out: Vec[String] = expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, cond);
    out = move_names_merge(out, expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, then_id));
    out = move_names_merge(out, expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, else_id));
    return out;
  }

  if match n { ast.ExprNode.Block(_b) => true, _ => false } {
    let eb: ast.ExprBlock = match n { ast.ExprNode.Block(eb0) => eb0, _ => ast.ExprBlock { stmts: Vec(), has_tail: false, tail: -1 } };
    let mut out: Vec[String] = expr_value_move_sources_from_block(ctx, w, mod_path, l0, imps, exprs, ast.Block { stmts: eb.stmts });
    if eb.has_tail {
      out = move_names_merge(out, expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, eb.tail));
    }
    return out;
  }

  if match n { ast.ExprNode.TryBlock(_bid) => true, _ => false } {
    let bid: i32 = match n { ast.ExprNode.TryBlock(b0) => b0, _ => -1 };
    return expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, bid);
  }

  if match n { ast.ExprNode.Try(_a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Try(a0) => a0, _ => -1 };
    return expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, a);
  }

  if match n { ast.ExprNode.StructLit(_tyexpr, _fields) => true, _ => false } {
    let tyexpr: i32 = match n { ast.ExprNode.StructLit(t0, _fields) => t0, _ => -1 };
    let fields: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_t, fs0) => fs0, _ => Vec() };
    let mut out: Vec[String] = expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, tyexpr);
    let mut i: i32 = 0;
    while i < fields.len() {
      out = move_names_merge(out, expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, fields.get(i).expr));
      i = i + 1;
    }
    return out;
  }

  if match n { ast.ExprNode.Match(_scrut, _arms) => true, _ => false } {
    let scrut: i32 = match n { ast.ExprNode.Match(s0, _as) => s0, _ => -1 };
    let arms: Vec[ast.MatchArm] = match n { ast.ExprNode.Match(_s, as0) => as0, _ => Vec() };
    let mut out: Vec[String] = expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, scrut);
    let mut i: i32 = 0;
    while i < arms.len() {
      out = move_names_merge(out, expr_value_move_sources(ctx, w, mod_path, l0, imps, exprs, arms.get(i).expr));
      i = i + 1;
    }
    return out;
  }

  return Vec();
}

fn release_move_sources_from_stmt(ctx: Ctx, l0: Locals, imps: Imports, exprs: ast.ExprPool, st: ast.Stmt) -> Vec[String] {
  return match st {
    ast.Stmt.Let(_sp, _m, _name, _has_ann, _ann, init) => release_move_sources(ctx, l0, imps, exprs, init),
    ast.Stmt.Assign(_sp, _name, rhs) => release_move_sources(ctx, l0, imps, exprs, rhs),
    ast.Stmt.AssignField(_sp, _recv, _field, rhs) => release_move_sources(ctx, l0, imps, exprs, rhs),
    ast.Stmt.ExprStmt(_sp, eid) => release_move_sources(ctx, l0, imps, exprs, eid),
    ast.Stmt.IfStmt(_sp, cond, then_b, has_else, else_b) => {
      let mut out: Vec[String] = release_move_sources(ctx, l0, imps, exprs, cond);
      out = move_names_merge(out, release_move_sources_from_block(ctx, l0, imps, exprs, then_b));
      if has_else { out = move_names_merge(out, release_move_sources_from_block(ctx, l0, imps, exprs, else_b)); }
      out
    },
    ast.Stmt.WhileStmt(_sp, cond, body) => {
      let mut out: Vec[String] = release_move_sources(ctx, l0, imps, exprs, cond);
      out = move_names_merge(out, release_move_sources_from_block(ctx, l0, imps, exprs, body));
      out
    },
    ast.Stmt.ReturnStmt(_sp, has, eid) => if has { release_move_sources(ctx, l0, imps, exprs, eid) } else { Vec() },
    _ => Vec(),
  };
}

fn release_move_sources_from_block(ctx: Ctx, l0: Locals, imps: Imports, exprs: ast.ExprPool, b: ast.Block) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    out = move_names_merge(out, release_move_sources_from_stmt(ctx, l0, imps, exprs, b.stmts.get(i)));
    i = i + 1;
  }
  return out;
}

fn release_move_sources(ctx: Ctx, l0: Locals, imps: Imports, exprs: ast.ExprPool, eid: i32) -> Vec[String] {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);

  if match n { ast.ExprNode.Call(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(c, _t, _a) => c, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _t, a) => a, _ => Vec() };

    let mut out: Vec[String] = Vec();
    let rm: ReleaseMoveSourceResult = release_move_from_call(ctx, l0, imps, exprs, callee, args);
    if rm.found { out = move_names_add(out, rm.name); }
    out = move_names_merge(out, release_move_sources(ctx, l0, imps, exprs, callee));
    let mut i: i32 = 0;
    while i < args.len() {
      out = move_names_merge(out, release_move_sources(ctx, l0, imps, exprs, args.get(i)));
      i = i + 1;
    }
    return out;
  }

  if match n { ast.ExprNode.MacroCall(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.MacroCall(c, _t, _a) => c, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.MacroCall(_c, _t, a) => a, _ => Vec() };
    let mut out: Vec[String] = release_move_sources(ctx, l0, imps, exprs, callee);
    let mut i: i32 = 0;
    while i < args.len() {
      out = move_names_merge(out, release_move_sources(ctx, l0, imps, exprs, args.get(i)));
      i = i + 1;
    }
    return out;
  }

  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Unary(_op, a0) => a0, _ => -1 };
    return release_move_sources(ctx, l0, imps, exprs, a);
  }

  if match n { ast.ExprNode.As(_a, _ty) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(a0, _ty) => a0, _ => -1 };
    return release_move_sources(ctx, l0, imps, exprs, a);
  }

  if match n { ast.ExprNode.Binary(_op, _a, _b) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Binary(_op, a0, _b) => a0, _ => -1 };
    let b: i32 = match n { ast.ExprNode.Binary(_op, _a, b0) => b0, _ => -1 };
    return move_names_merge(release_move_sources(ctx, l0, imps, exprs, a), release_move_sources(ctx, l0, imps, exprs, b));
  }

  if match n { ast.ExprNode.Member(_recv, _name) => true, _ => false } {
    let recv: i32 = match n { ast.ExprNode.Member(r, _name) => r, _ => -1 };
    return release_move_sources(ctx, l0, imps, exprs, recv);
  }

  if match n { ast.ExprNode.If(_cond, _then, _else) => true, _ => false } {
    let cond: i32 = match n { ast.ExprNode.If(c0, _t, _e) => c0, _ => -1 };
    let then_id: i32 = match n { ast.ExprNode.If(_c, t0, _e) => t0, _ => -1 };
    let else_id: i32 = match n { ast.ExprNode.If(_c, _t, e0) => e0, _ => -1 };
    let mut out: Vec[String] = release_move_sources(ctx, l0, imps, exprs, cond);
    out = move_names_merge(out, release_move_sources(ctx, l0, imps, exprs, then_id));
    out = move_names_merge(out, release_move_sources(ctx, l0, imps, exprs, else_id));
    return out;
  }

  if match n { ast.ExprNode.Block(_b) => true, _ => false } {
    let eb: ast.ExprBlock = match n { ast.ExprNode.Block(eb0) => eb0, _ => ast.ExprBlock { stmts: Vec(), has_tail: false, tail: -1 } };
    let mut out: Vec[String] = release_move_sources_from_block(ctx, l0, imps, exprs, ast.Block { stmts: eb.stmts });
    if eb.has_tail {
      out = move_names_merge(out, release_move_sources(ctx, l0, imps, exprs, eb.tail));
    }
    return out;
  }

  if match n { ast.ExprNode.TryBlock(_bid) => true, _ => false } {
    let bid: i32 = match n { ast.ExprNode.TryBlock(b0) => b0, _ => -1 };
    return release_move_sources(ctx, l0, imps, exprs, bid);
  }

  if match n { ast.ExprNode.Try(_a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Try(a0) => a0, _ => -1 };
    return release_move_sources(ctx, l0, imps, exprs, a);
  }

  if match n { ast.ExprNode.StructLit(_tyexpr, _fields) => true, _ => false } {
    let tyexpr: i32 = match n { ast.ExprNode.StructLit(t0, _fields) => t0, _ => -1 };
    let fields: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_t, fs0) => fs0, _ => Vec() };
    let mut out: Vec[String] = release_move_sources(ctx, l0, imps, exprs, tyexpr);
    let mut i: i32 = 0;
    while i < fields.len() {
      out = move_names_merge(out, release_move_sources(ctx, l0, imps, exprs, fields.get(i).expr));
      i = i + 1;
    }
    return out;
  }

  if match n { ast.ExprNode.Match(_scrut, _arms) => true, _ => false } {
    let scrut: i32 = match n { ast.ExprNode.Match(s0, _as) => s0, _ => -1 };
    let arms: Vec[ast.MatchArm] = match n { ast.ExprNode.Match(_s, as0) => as0, _ => Vec() };
    let mut out: Vec[String] = release_move_sources(ctx, l0, imps, exprs, scrut);
    let mut i: i32 = 0;
    while i < arms.len() {
      out = move_names_merge(out, release_move_sources(ctx, l0, imps, exprs, arms.get(i).expr));
      i = i + 1;
    }
    return out;
  }

  return Vec();
}

fn find_import_alias_path(imps: Imports, alias: String) -> String {
  let mut i: i32 = 0;
  while i < imps.aliases.len() {
    let a: ImportAlias = imps.aliases.get(i);
    if a.alias == alias { return a.path; }
    i = i + 1;
  }
  return "";
}

fn is_std_release_module_call(imps: Imports, exprs: ast.ExprPool, callee: i32) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, callee);
  if match n { ast.ExprNode.Member(_recv, _name) => true, _ => false } {
    let recv: i32 = match n { ast.ExprNode.Member(r, _name) => r, _ => -1 };
    let name: String = match n { ast.ExprNode.Member(_r, s) => s, _ => "" };
    let rn: ast.ExprNode = ast.expr_pool_get(exprs, recv);
    if match rn { ast.ExprNode.Ident(_alias) => true, _ => false } {
      let alias: String = match rn { ast.ExprNode.Ident(s) => s, _ => "" };
      let p: String = find_import_alias_path(imps, alias);
      if p == "std/string" && name == "release" { return true; }
      if p == "std/collections" && (name == "release_vec" || name == "release") { return true; }
    }
    return false;
  }
  if match n { ast.ExprNode.Ident(name) => name == "release_vec", _ => false } { return true; }
  return false;
}

fn is_release_call_expr(ctx: Ctx, l0: Locals, imps: Imports, exprs: ast.ExprPool, eid: i32) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);
  if match n { ast.ExprNode.Call(callee, _type_args, _args) => is_std_release_module_call(imps, exprs, callee), _ => false } {
    return true;
  }
  let names: Vec[String] = release_move_sources(ctx, l0, imps, exprs, eid);
  return names.len() > 0;
}

fn tc_stmt_expr(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, sp: ast.Span, eid: i32) -> TcStmtResult {
  let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, eid, -1);
  if !er.ok { return TcStmtResult { ok: false, err: er.err, ctx: ctx, locals: l0 }; }
  if er.ty != ctx.ty_unit && is_release_call_expr(ctx, l0, imps, exprs, eid) {
    return TcStmtResult { ok: false, err: type_error_at(sp, "release call result must be assigned back"), ctx: ctx, locals: l0 };
  }
  return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 };
}

fn locals_join_if_moved(l0: Locals, then_in: Locals, has_else: bool, else_in: Locals) -> Locals {
  let then_l: Locals = locals_exit(then_in);
  let else_l: Locals = if has_else { locals_exit(else_in) } else { l0 };

  let mut out: Locals = l0;
  let mut i: i32 = 0;
  while i < out.vars.len() {
    let v: VarEntry = out.vars.get(i);
    if v.depth <= out.depth {
      let tv: LookupVarResult = locals_lookup(then_l, v.name);
      let ev: LookupVarResult = locals_lookup(else_l, v.name);
      let moved: bool =
        if has_else {
          (tv.found && tv.moved) || (ev.found && ev.moved)
        } else {
          v.moved || (tv.found && tv.moved)
        };
      out = locals_set_moved_at(out, i, moved);
    }
    i = i + 1;
  }
  return out;
}

fn locals_join_while_moved(l0: Locals, body_in: Locals) -> Locals {
  let body_l: Locals = locals_exit(body_in);
  let mut out: Locals = l0;
  let mut i: i32 = 0;
  while i < out.vars.len() {
    let v: VarEntry = out.vars.get(i);
    if v.depth <= out.depth {
      let bv: LookupVarResult = locals_lookup(body_l, v.name);
      let moved: bool = v.moved || (bv.found && bv.moved);
      out = locals_set_moved_at(out, i, moved);
    }
    i = i + 1;
  }
  return out;
}

fn tc_stmt_if(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, ret_ty: i32, _sp: ast.Span, cond: i32, then_b: ast.Block, has_else: bool, else_b: ast.Block) -> TcStmtResult {
  let cr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, cond, ctx.ty_bool);
  if !cr.ok { return TcStmtResult { ok: false, err: cr.err, ctx: ctx, locals: l0 }; }
  if cr.ty != ctx.ty_bool { return TcStmtResult { ok: false, err: type_error_at(ast.expr_pool_span(exprs, cond), "if cond must be bool"), ctx: ctx, locals: l0 }; }

  let r1: TcStmtResult = tc_block(ctx, w, mod_path, imps, exprs, locals_enter(l0), ret_ty, then_b);
  if !r1.ok { return r1; }
  let mut out: Locals = l0;
  if has_else {
    let r2: TcStmtResult = tc_block(ctx, w, mod_path, imps, exprs, locals_enter(l0), ret_ty, else_b);
    if !r2.ok { return r2; }
    out = locals_join_if_moved(l0, r1.locals, true, r2.locals);
  } else {
    out = locals_join_if_moved(l0, r1.locals, false, l0);
  }
  return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: out };
}

fn tc_stmt_while(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, ret_ty: i32, _sp: ast.Span, cond: i32, body: ast.Block) -> TcStmtResult {
  let cr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, cond, ctx.ty_bool);
  if !cr.ok { return TcStmtResult { ok: false, err: cr.err, ctx: ctx, locals: l0 }; }
  if cr.ty != ctx.ty_bool { return TcStmtResult { ok: false, err: type_error_at(ast.expr_pool_span(exprs, cond), "while cond must be bool"), ctx: ctx, locals: l0 }; }
  let mut lb: Locals = locals_enter(l0);
  lb.loop_depth = lb.loop_depth + 1;
  let r1: TcStmtResult = tc_block(ctx, w, mod_path, imps, exprs, lb, ret_ty, body);
  if !r1.ok { return r1; }
  let out: Locals = locals_join_while_moved(l0, r1.locals);
  return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: out };
}

fn tc_stmt_return(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, ret_ty: i32, sp: ast.Span, has: bool, eid: i32) -> TcStmtResult {
  if !has {
    if ret_ty != ctx.ty_unit { return TcStmtResult { ok: false, err: type_error_at(sp, "return type mismatch"), ctx: ctx, locals: l0 }; }
    return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 };
  }
  let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, eid, ret_ty);
  if !er.ok { return TcStmtResult { ok: false, err: er.err, ctx: ctx, locals: l0 }; }
  if !assignable_to(ctx, ret_ty, er.ty) { return TcStmtResult { ok: false, err: type_error_at(ast.expr_pool_span(exprs, eid), "return type mismatch"), ctx: ctx, locals: l0 }; }
  return TcStmtResult { ok: true, err: TcError.None, ctx: ctx, locals: l0 };
}
