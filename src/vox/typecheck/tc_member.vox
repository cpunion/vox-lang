import "vox/ast" as ast
import "vox/ir" as ir

fn find_enum_for_member(ctx: Ctx, enum_mod: String, enum_name: String, expected: i32) -> FindEnumResult {
  let fe0: FindEnumResult = find_enum(ctx, enum_mod, enum_name);
  if fe0.found { return fe0; }
  if expected == -1 || !is_enum_ty(ctx, expected) { return fe0; }

  let et: ir.Ty = ir.ty_pool_get(ctx.pool, expected);
  if ty_mod(et) != enum_mod { return fe0; }
  let fe1: FindEnumResult = find_enum(ctx, enum_mod, ty_name(et));
  if !fe1.found { return fe0; }
  if fe1.sig.base_name == enum_name || fe1.sig.name == enum_name { return fe1; }
  return fe0;
}

fn member_type_mismatch_error(ctx: Ctx, sp: ast.Span, expected: i32, got: i32) -> TcError {
  let msg: String = "member type mismatch: expected "
    .concat(ty_inst_str(ctx, expected))
    .concat(", got ")
    .concat(ty_inst_str(ctx, got));
  return type_error_at(sp, msg);
}

fn recv_is_local_symbol(exprs: ast.ExprPool, l0: Locals, recv: i32) -> bool {
  let mut cur: i32 = recv;
  while true {
    let n: ast.ExprNode = ast.expr_pool_get(exprs, cur);
    if match n { ast.ExprNode.Ident(_name) => true, _ => false } {
      let name: String = match n { ast.ExprNode.Ident(s) => s, _ => "" };
      if name == "" { return false; }
      if locals_lookup(l0, name).found { return true; }
      if locals_lookup_const(l0, name).found { return true; }
      return false;
    }
    if match n { ast.ExprNode.Member(recv0, _field) => true, _ => false } {
      cur = match n { ast.ExprNode.Member(recv0, _field) => recv0, _ => -1 };
      continue;
    }
    return false;
  }
  return false;
}

fn tc_expr_member(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, recv: i32, name: String, expected: i32) -> ExprTyResult {
  let recv_sp: ast.Span = ast.expr_pool_span(exprs, recv);

  // 1) Field access: `value.field`
  let rr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, recv, -1);
  let mut recv_ty: i32 = rr.ty;
  while rr.ok {
    let rt: ir.Ty = ir.ty_pool_get(ctx.pool, recv_ty);
    if rt.kind != ir.TyKind.Ref { break; }
    recv_ty = rt.elem;
  }
  if rr.ok && is_struct_ty(ctx, recv_ty) {
    let t: ir.Ty = ir.ty_pool_get(ctx.pool, recv_ty);
    let fm: FindStructResult = find_struct(ctx, ty_mod(t), ty_name(t));
    if !fm.found {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "unknown struct type for member access") };
    }
    let sig: StructSig = fm.sig;

    // Visibility: crossing modules requires both the type and the field to be visible.
    if !vis_allows(sig.vis, sig.mod_path, mod_path) {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "struct is private: ".concat(sig.name)) };
    }

    let mut i: i32 = 0;
    while i < sig.fields.len() {
      let f: StructFieldSig = sig.fields.get(i);
      if f.name == name {
        if !vis_allows(f.vis, sig.mod_path, mod_path) {
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "field is private: ".concat(name)) };
        }
        if expected != -1 && !assignable_to(ctx, expected, f.ty) {
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: member_type_mismatch_error(ctx, recv_sp, expected, f.ty) };
        }
        return ExprTyResult { ok: true, ty: f.ty, err: TcError.None };
      }
      i = i + 1;
    }
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "unknown field: ".concat(name)) };
  }
  // Keep chained type-path member forms alive (e.g. `p.ParseError.None`):
  // if receiver can still be interpreted as a type path, prefer that route.
  let pr: ExprTypePathResult = expr_type_path(exprs, recv);
  if !rr.ok && rr.err != TcError.None {
    if recv_is_local_symbol(exprs, l0, recv) || !pr.ok {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: rr.err };
    }
  }

  // 2) Unit enum variant value: `Enum.None` / `alias.Enum.None` / `Enum[T].None`
  if !pr.ok {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "invalid member access") };
  }
  let mut parts: Vec[String] = pr.parts;
  let enum_targs: Vec[ast.TypeName] = pr.targs;
  parts.push(name);

  if parts.len() != 2 && parts.len() != 3 {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "invalid member path") };
  }

  // 2.1) Module const/static: `alias.NAME` / `alias.mod.NAME` (only when alias resolves).
  let base_mod: String = find_alias(imps.aliases, parts.get(0));
  if base_mod != "" && enum_targs.len() == 0 {
    let const_mod: String = if parts.len() == 2 { base_mod } else { base_mod.concat("/").concat(parts.get(1)) };
    let const_name: String = if parts.len() == 2 { parts.get(1) } else { parts.get(2) };
    let cs: ConstSig = find_const(ctx, const_mod, const_name);
    if cs.name != "" {
      if !vis_allows(cs.vis, const_mod, mod_path) {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "const is private: ".concat(const_name)) };
      }
      if expected != -1 && !assignable_to(ctx, expected, cs.ty) {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: member_type_mismatch_error(ctx, recv_sp, expected, cs.ty) };
      }
      return ExprTyResult { ok: true, ty: cs.ty, err: TcError.None };
    }
    let ss: StaticSig = find_static(ctx, const_mod, const_name);
    if ss.name != "" {
      if !vis_allows(ss.vis, const_mod, mod_path) {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "static is private: ".concat(const_name)) };
      }
      if expected != -1 && !assignable_to(ctx, expected, ss.ty) {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: member_type_mismatch_error(ctx, recv_sp, expected, ss.ty) };
      }
      return ExprTyResult { ok: true, ty: ss.ty, err: TcError.None };
    }
  }

  let mut enum_mod: String = "";
  let mut enum_name: String = "";
  if parts.len() == 2 {
    enum_mod = mod_path;
    enum_name = parts.get(0);
    let nt: NamedTypeImport = find_named_type(imps.named_types, enum_name);
    if nt.local != "" {
      if nt.kind != named_type_kind_enum() {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "member enum path requires enum type: ".concat(enum_name)) };
      }
      enum_mod = nt.mod_path;
      enum_name = nt.name;
    }
  } else {
    enum_mod = find_alias(imps.aliases, parts.get(0));
    if enum_mod == "" {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "unknown module alias: ".concat(parts.get(0))) };
    }
    enum_name = parts.get(1);
  }
  let var_name: String = if parts.len() == 2 { parts.get(1) } else { parts.get(2) };

  let mut ty_idx_hint: i32 = -1;
  let mut fe: FindEnumResult = find_enum_for_member(ctx, enum_mod, enum_name, expected);
  if enum_targs.len() != 0 {
    let mut enum_type_parts: Vec[String] = Vec();
    if parts.len() == 2 {
      enum_type_parts.push(parts.get(0));
    } else {
      enum_type_parts.push(parts.get(0));
      enum_type_parts.push(parts.get(1));
    }
    let tn: ast.TypeName = ast.TypeName { parts: enum_type_parts, args: enum_targs };
    let tr: ResolveTyResult = resolve_type(ctx, w, mod_path, imps, l0.type_params, tn);
    if !tr.ok {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "invalid enum type arguments in member path") };
    }
    if tr.idx < 0 || tr.idx >= ctx.pool.tys.len() || !is_enum_ty(ctx, tr.idx) {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "member path does not resolve to enum") };
    }
    ty_idx_hint = tr.idx;
    let et0: ir.Ty = ir.ty_pool_get(ctx.pool, tr.idx);
    enum_mod = ty_mod(et0);
    enum_name = ty_name(et0);
    fe = find_enum(ctx, enum_mod, enum_name);
  }
  if !fe.found {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "unknown enum: ".concat(enum_name)) };
  }
  let es: EnumSig = fe.sig;
  if !vis_allows(es.vis, es.mod_path, mod_path) {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "enum is private: ".concat(es.name)) };
  }

  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      // Only unit variants are values without a call: `E.None`.
      if v.fields.len() != 0 {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "enum variant requires call syntax: ".concat(var_name)) };
      }
      let ty_idx: i32 = if ty_idx_hint != -1 { ty_idx_hint } else { find_enum_ty_idx(ctx, enum_mod, es.name) };
      if ty_idx == -1 {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "internal: enum type index not found") };
      }
      if expected != -1 && !assignable_to(ctx, expected, ty_idx) {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: member_type_mismatch_error(ctx, recv_sp, expected, ty_idx) };
      }
      return ExprTyResult { ok: true, ty: ty_idx, err: TcError.None };
    }
    vi = vi + 1;
  }

  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(recv_sp, "unknown enum variant: ".concat(var_name)) };
}
