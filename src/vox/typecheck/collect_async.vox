import "vox/ast" as ast
import "vox/ir" as ir
import "vox/async_cfg" as ac

// Async lowering metadata collection.

struct AsyncLocalDecl { name: String, ty: i32, mutable: bool, decl_sp: ast.Span }

fn stmt_span(st: ast.Stmt) -> ast.Span {
  return match st {
    ast.Stmt.Let(sp, _m, _n, _ha, _ann, _e) => sp,
    ast.Stmt.Assign(sp, _n, _e) => sp,
    ast.Stmt.AssignField(sp, _r, _f, _e) => sp,
    ast.Stmt.ExprStmt(sp, _e) => sp,
    ast.Stmt.IfStmt(sp, _c, _t, _h, _e) => sp,
    ast.Stmt.WhileStmt(sp, _c, _b) => sp,
    ast.Stmt.TryBegin(sp, _out) => sp,
    ast.Stmt.TryEnd(sp) => sp,
    ast.Stmt.Break(sp) => sp,
    ast.Stmt.Continue(sp) => sp,
    ast.Stmt.ReturnStmt(sp, _h, _e) => sp,
  };
}

fn string_vec_contains(xs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn local_decl_find(xs: Vec[AsyncLocalDecl], name: String) -> AsyncLocalDecl {
  let mut i: i32 = 0;
  while i < xs.len() {
    let x: AsyncLocalDecl = xs.get(i);
    if x.name == name { return x; }
    i = i + 1;
  }
  return AsyncLocalDecl { name: "", ty: -1, mutable: false, decl_sp: ast.span0() };
}

struct StmtAwaitInfo { ok: bool, operand: i32, is_try: bool }

fn stmt_await_info(exprs: ast.ExprPool, st: ast.Stmt) -> StmtAwaitInfo {
  let eid: i32 =
    if match st { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, _e) => true, _ => false } {
      match st { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, e) => e, _ => -1 }
    } else if match st { ast.Stmt.ExprStmt(_sp, _e) => true, _ => false } {
      match st { ast.Stmt.ExprStmt(_sp, e) => e, _ => -1 }
    } else if match st { ast.Stmt.ReturnStmt(_sp, h, _e) => true, _ => false } {
      let has0: bool = match st { ast.Stmt.ReturnStmt(_sp, h, _e) => h, _ => false };
      if has0 { match st { ast.Stmt.ReturnStmt(_sp, _h, e) => e, _ => -1 } } else { -1 }
    } else { -1 };
  if eid == -1 { return StmtAwaitInfo { ok: false, operand: -1, is_try: false }; }
  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);
  if match n { ast.ExprNode.Await(_x) => true, _ => false } {
    let op: i32 = match n { ast.ExprNode.Await(x) => x, _ => -1 };
    return StmtAwaitInfo { ok: true, operand: op, is_try: false };
  }
  if match n { ast.ExprNode.Try(_x) => true, _ => false } {
    let x: i32 = match n { ast.ExprNode.Try(y) => y, _ => -1 };
    let nx: ast.ExprNode = ast.expr_pool_get(exprs, x);
    if match nx { ast.ExprNode.Await(_y) => true, _ => false } {
      let op2: i32 = match nx { ast.ExprNode.Await(y) => y, _ => -1 };
      return StmtAwaitInfo { ok: true, operand: op2, is_try: true };
    }
  }
  return StmtAwaitInfo { ok: false, operand: -1, is_try: false };
}

struct WalkAsyncResult {
  ok: bool,
  err: TcError,
  ctx: Ctx,
  locals: Locals,
  decls: Vec[AsyncLocalDecl],
  await_operand_tys: Vec[i32],
  seen_names: Vec[String],
}

fn walk_async_block(
  ctx0: Ctx,
  w: World,
  mod_path: String,
  imps: Imports,
  exprs: ast.ExprPool,
  b0: ast.Block,
  l0: Locals,
  decls0: Vec[AsyncLocalDecl],
  await_operand_tys0: Vec[i32],
  seen0: Vec[String],
) -> WalkAsyncResult {
  let mut c: Ctx = ctx0;
  let mut l: Locals = l0;
  let mut decls: Vec[AsyncLocalDecl] = decls0;
  let mut await_tys: Vec[i32] = await_operand_tys0;
  let mut seen: Vec[String] = seen0;

  let mut si: i32 = 0;
  while si < b0.stmts.len() {
    let st0: ast.Stmt = b0.stmts.get(si);

    if match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, _e) => true, _ => false } {
      let sp0: ast.Span = stmt_span(st0);
      let is_mut: bool = match st0 { ast.Stmt.Let(_sp, m0, _n, _ha, _ann, _e) => m0, _ => false };
      let name0: String = match st0 { ast.Stmt.Let(_sp, _m, n0, _ha, _ann, _e) => n0, _ => "" };
      let has_ann: bool = match st0 { ast.Stmt.Let(_sp, _m, _n, ha0, _ann, _e) => ha0, _ => false };
      let ann0: ast.TypeName = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, an0, _e) => an0, _ => ast.TypeName { parts: Vec(), args: Vec() } };
      let init0: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, e0) => e0, _ => -1 };

      // Async capture rewrite is currently name-based; disallow shadowing to keep it correct.
      if string_vec_contains(seen, name0) {
        return WalkAsyncResult { ok: false, err: type_error_at(sp0, "async fn does not support shadowing yet: ".concat(name0)), ctx: c, locals: l, decls: decls, await_operand_tys: await_tys, seen_names: seen };
      }
      seen.push(name0);

      let mut vty: i32 = -1;
      if has_ann {
        let tr0: ResolveTyResult = resolve_type(c, w, mod_path, imps, l.type_params, ann0);
        c = tr0.ctx;
        if !tr0.ok { return WalkAsyncResult { ok: false, err: type_error_at(sp0, "let annotation type resolve failed"), ctx: c, locals: l, decls: decls, await_operand_tys: await_tys, seen_names: seen }; }
        vty = strip_range_only(c, tr0.idx);
      } else {
        let pr0: PrepAsyncInstResult = prep_async_inst_in_expr(c, w, mod_path, imps, exprs, l, init0);
        if !pr0.ok {
          let msg0: String = "failed to prepare async inst for let init: ".concat(tc_error_to_string(pr0.err));
          return WalkAsyncResult { ok: false, err: type_error_at(sp0, msg0), ctx: pr0.ctx, locals: l, decls: decls, await_operand_tys: await_tys, seen_names: seen };
        }
        c = pr0.ctx;
        let er0: ExprTyResult = tc_expr(c, w, mod_path, imps, exprs, l, init0, -1);
        if !er0.ok {
          let msg: String = "failed to typecheck let init in async fn: ".concat(tc_error_to_string(er0.err));
          return WalkAsyncResult { ok: false, err: type_error_at(sp0, msg), ctx: c, locals: l, decls: decls, await_operand_tys: await_tys, seen_names: seen };
        }
        vty = strip_range_only(c, er0.ty);
      }
      l = locals_decl(l, name0, vty, is_mut);
      decls.push(AsyncLocalDecl { name: name0, ty: vty, mutable: is_mut, decl_sp: sp0 });
    }

    // Await operand typing (statement-level await).
    let ai: StmtAwaitInfo = stmt_await_info(exprs, st0);
    if ai.ok {
      let pr1: PrepAsyncInstResult = prep_async_inst_in_expr(c, w, mod_path, imps, exprs, l, ai.operand);
      if !pr1.ok {
        let msg1: String = "failed to prepare async inst for await operand: ".concat(tc_error_to_string(pr1.err));
        return WalkAsyncResult { ok: false, err: type_error_at(stmt_span(st0), msg1), ctx: pr1.ctx, locals: l, decls: decls, await_operand_tys: await_tys, seen_names: seen };
      }
      c = pr1.ctx;
      let er_op: ExprTyResult = tc_expr(c, w, mod_path, imps, exprs, l, ai.operand, -1);
      if !er_op.ok {
        let msg: String = "failed to typecheck await operand: ".concat(tc_error_to_string(er_op.err));
        return WalkAsyncResult { ok: false, err: type_error_at(stmt_span(st0), msg), ctx: c, locals: l, decls: decls, await_operand_tys: await_tys, seen_names: seen };
      } else {
        let op_ty: i32 = strip_range_only(c, er_op.ty);
        if ty_has_forbidden_borrow(c, op_ty) {
          return WalkAsyncResult { ok: false, err: type_error_at(stmt_span(st0), "await operand cannot contain non-static borrow"), ctx: c, locals: l, decls: decls, await_operand_tys: await_tys, seen_names: seen };
        }
        await_tys.push(op_ty);
      }
    }

    // Recurse into nested statement blocks with proper scoping.
    if match st0 { ast.Stmt.IfStmt(_sp, _c, _t, _h, _e) => true, _ => false } {
      let then_b: ast.Block = match st0 { ast.Stmt.IfStmt(_sp, _c, t0, _h, _e) => t0, _ => ast.Block { stmts: Vec() } };
      let has_else: bool = match st0 { ast.Stmt.IfStmt(_sp, _c, _t, h0, _e) => h0, _ => false };
      let else_b: ast.Block = match st0 { ast.Stmt.IfStmt(_sp, _c, _t, _h, e0) => e0, _ => ast.Block { stmts: Vec() } };

      let rt: WalkAsyncResult = walk_async_block(c, w, mod_path, imps, exprs, then_b, locals_enter(l), decls, await_tys, seen);
      if !rt.ok { return rt; }
      c = rt.ctx;
      decls = rt.decls;
      await_tys = rt.await_operand_tys;
      seen = rt.seen_names;

      if has_else {
        let re: WalkAsyncResult = walk_async_block(c, w, mod_path, imps, exprs, else_b, locals_enter(l), decls, await_tys, seen);
        if !re.ok { return re; }
        c = re.ctx;
        decls = re.decls;
        await_tys = re.await_operand_tys;
        seen = re.seen_names;
      }
    }

    if match st0 { ast.Stmt.WhileStmt(_sp, _c, _b) => true, _ => false } {
      let body0: ast.Block = match st0 { ast.Stmt.WhileStmt(_sp, _c0, b0) => b0, _ => ast.Block { stmts: Vec() } };
      let rb: WalkAsyncResult = walk_async_block(c, w, mod_path, imps, exprs, body0, locals_enter(l), decls, await_tys, seen);
      if !rb.ok { return rb; }
      c = rb.ctx;
      decls = rb.decls;
      await_tys = rb.await_operand_tys;
      seen = rb.seen_names;
    }

    si = si + 1;
  }

  return WalkAsyncResult { ok: true, err: TcError.None, ctx: c, locals: l, decls: decls, await_operand_tys: await_tys, seen_names: seen };
}

fn expr_contains_try(exprs: ast.ExprPool, eid: i32) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);
  if match n { ast.ExprNode.Try(_x) => true, _ => false } { return true; }
  if match n { ast.ExprNode.TryBlock(_bid) => true, _ => false } { return true; }
  if match n { ast.ExprNode.Await(x) => true, _ => false } {
    let x: i32 = match n { ast.ExprNode.Await(y) => y, _ => -1 };
    return expr_contains_try(exprs, x);
  }
  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Unary(_op, x) => x, _ => -1 };
    return expr_contains_try(exprs, a);
  }
  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(x, _tn) => x, _ => -1 };
    return expr_contains_try(exprs, a);
  }
  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let l: i32 = match n { ast.ExprNode.Binary(_op, x, _r) => x, _ => -1 };
    let r: i32 = match n { ast.ExprNode.Binary(_op, _l, x) => x, _ => -1 };
    return expr_contains_try(exprs, l) || expr_contains_try(exprs, r);
  }
  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } {
    let c: i32 = match n { ast.ExprNode.If(x, _t, _e) => x, _ => -1 };
    let t: i32 = match n { ast.ExprNode.If(_c, x, _e) => x, _ => -1 };
    let e: i32 = match n { ast.ExprNode.If(_c, _t, x) => x, _ => -1 };
    return expr_contains_try(exprs, c) || expr_contains_try(exprs, t) || expr_contains_try(exprs, e);
  }
  if match n { ast.ExprNode.Member(_r, _f) => true, _ => false } {
    let r: i32 = match n { ast.ExprNode.Member(x, _f) => x, _ => -1 };
    return expr_contains_try(exprs, r);
  }
  if match n { ast.ExprNode.Call(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(x, _t, _a) => x, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _t, x) => x, _ => Vec() };
    if expr_contains_try(exprs, callee) { return true; }
    let mut i: i32 = 0;
    while i < args.len() {
      if expr_contains_try(exprs, args.get(i)) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.StructLit(_t, _fs) => true, _ => false } {
    let fs: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_t, x) => x, _ => Vec() };
    let mut i: i32 = 0;
    while i < fs.len() {
      if expr_contains_try(exprs, fs.get(i).expr) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.Block(_b) => true, _ => false } {
    // v0: treat block expression as potentially containing try.
    return true;
  }
  if match n { ast.ExprNode.Match(_s, _as) => true, _ => false } { return true; }
  return false;
}

fn ty_has_forbidden_borrow(ctx: Ctx, ty0: i32) -> bool {
  let ty: i32 = strip_range_only(ctx, ty0);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty);
  if t.kind == ir.TyKind.Ref {
    // Only allow `&'static T` (immutable) to live across await.
    if ir.ty_ref_is_mut(t) { return true; }
    if !ir.ty_ref_is_static(t) { return true; }
    return ty_has_forbidden_borrow(ctx, t.elem);
  }
  if t.kind == ir.TyKind.Vec { return ty_has_forbidden_borrow(ctx, t.elem); }
  if t.kind == ir.TyKind.Range { return ty_has_forbidden_borrow(ctx, t.elem); }
  if t.kind == ir.TyKind.Struct {
    let fs: FindStructResult = find_struct(ctx, t.mod_path, t.name);
    if !fs.found { return false; }
    let mut i: i32 = 0;
    while i < fs.sig.fields.len() {
      if ty_has_forbidden_borrow(ctx, fs.sig.fields.get(i).ty) { return true; }
      i = i + 1;
    }
    return false;
  }
  if t.kind == ir.TyKind.Enum {
    let fe: FindEnumResult = find_enum(ctx, t.mod_path, t.name);
    if !fe.found { return false; }
    let mut vi: i32 = 0;
    while vi < fe.sig.vars.len() {
      let v: EnumVariantSig = fe.sig.vars.get(vi);
      let mut fi: i32 = 0;
      while fi < v.fields.len() {
        if ty_has_forbidden_borrow(ctx, v.fields.get(fi)) { return true; }
        fi = fi + 1;
      }
      vi = vi + 1;
    }
    return false;
  }
  return false;
}

fn span_loc(sp: ast.Span) -> String {
  if sp.file == "" { return "<unknown>"; }
  return sp.file.concat(":").concat(sp.line.to_string()).concat(":").concat(sp.col.to_string());
}

fn capture_await_span(uses: Vec[ac.CaptureAwaitUse], name: String) -> ast.Span {
  let mut i: i32 = 0;
  while i < uses.len() {
    let u: ac.CaptureAwaitUse = uses.get(i);
    if u.name == name { return u.await_sp; }
    i = i + 1;
  }
  return ast.span0();
}

fn expr_uses_name(exprs: ast.ExprPool, eid: i32, name: String) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);
  if match n { ast.ExprNode.Ident(_s) => true, _ => false } {
    let s: String = match n { ast.ExprNode.Ident(x) => x, _ => "" };
    return s == name;
  }
  if match n { ast.ExprNode.Int(_v) => true, ast.ExprNode.Float(_v) => true, ast.ExprNode.Bool(_b) => true, ast.ExprNode.Str(_s) => true, ast.ExprNode.DotIdent(_s) => true, _ => false } {
    return false;
  }
  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Unary(_op, x) => x, _ => -1 };
    return expr_uses_name(exprs, a, name);
  }
  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(x, _tn) => x, _ => -1 };
    return expr_uses_name(exprs, a, name);
  }
  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let l: i32 = match n { ast.ExprNode.Binary(_op, x, _r) => x, _ => -1 };
    let r: i32 = match n { ast.ExprNode.Binary(_op, _l, x) => x, _ => -1 };
    return expr_uses_name(exprs, l, name) || expr_uses_name(exprs, r, name);
  }
  if match n { ast.ExprNode.Member(_r, _f) => true, _ => false } {
    let r: i32 = match n { ast.ExprNode.Member(x, _f) => x, _ => -1 };
    return expr_uses_name(exprs, r, name);
  }
  if match n { ast.ExprNode.Call(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(x, _t, _a) => x, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _t, x) => x, _ => Vec() };
    if expr_uses_name(exprs, callee, name) { return true; }
    let mut i: i32 = 0;
    while i < args.len() {
      if expr_uses_name(exprs, args.get(i), name) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.TryBlock(_bid) => true, _ => false } {
    let bid: i32 = match n { ast.ExprNode.TryBlock(x) => x, _ => -1 };
    return expr_uses_name(exprs, bid, name);
  }
  if match n { ast.ExprNode.Try(_a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Try(x) => x, _ => -1 };
    return expr_uses_name(exprs, a, name);
  }
  if match n { ast.ExprNode.Await(_a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Await(x) => x, _ => -1 };
    return expr_uses_name(exprs, a, name);
  }
  if match n { ast.ExprNode.StructLit(_t, _fs) => true, _ => false } {
    let fs: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_t, x) => x, _ => Vec() };
    let mut i: i32 = 0;
    while i < fs.len() {
      if expr_uses_name(exprs, fs.get(i).expr, name) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.Block(_b) => true, _ => false } { return true; }
  if match n { ast.ExprNode.Match(_s, _as) => true, _ => false } { return true; }
  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } { return true; }
  return false;
}

fn stmt_uses_name(exprs: ast.ExprPool, st: ast.Stmt, name: String) -> bool {
  return match st {
    ast.Stmt.Let(_sp, _m, _n, _ha, _ann, init) => expr_uses_name(exprs, init, name),
    ast.Stmt.Assign(_sp, _n, ex) => expr_uses_name(exprs, ex, name),
    ast.Stmt.AssignField(_sp, recv, _field, ex) => recv == name || expr_uses_name(exprs, ex, name),
    ast.Stmt.ExprStmt(_sp, ex) => expr_uses_name(exprs, ex, name),
    ast.Stmt.IfStmt(_sp, cond, then_b, has_else, else_b) => {
      if expr_uses_name(exprs, cond, name) { true } else if block_uses_name(exprs, then_b, name) { true } else if has_else { block_uses_name(exprs, else_b, name) } else { false }
    },
    ast.Stmt.WhileStmt(_sp, cond, body) => expr_uses_name(exprs, cond, name) || block_uses_name(exprs, body, name),
    ast.Stmt.TryBegin(_sp, out_name) => out_name == name,
    ast.Stmt.TryEnd(_sp) => false,
    ast.Stmt.Break(_sp) => false,
    ast.Stmt.Continue(_sp) => false,
    ast.Stmt.ReturnStmt(_sp, has_ex, ex) => if has_ex { expr_uses_name(exprs, ex, name) } else { false },
  };
}

fn block_uses_name(exprs: ast.ExprPool, b: ast.Block, name: String) -> bool {
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    if stmt_uses_name(exprs, b.stmts.get(i), name) { return true; }
    i = i + 1;
  }
  return false;
}

fn find_func_sym_idx(ctx: Ctx, mod_path: String, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < ctx.funcs.len() {
    let f: FuncSym = ctx.funcs.get(i);
    if f.mod_path == mod_path && f.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn funcs_replace(ctx0: Ctx, idx: i32, fsym: FuncSym) -> Ctx {
  let mut ctx: Ctx = ctx0;
  if idx < 0 || idx >= ctx.funcs.len() { return ctx; }
  let mut out: Vec[FuncSym] = Vec();
  let mut i: i32 = 0;
  while i < ctx.funcs.len() {
    out.push(if i == idx { fsym } else { ctx.funcs.get(i) });
    i = i + 1;
  }
  ctx.funcs = out;
  return ctx;
}

fn structs_has(ctx: Ctx, mod_path: String, name: String) -> bool {
  let fs: FindStructResult = find_struct(ctx, mod_path, name);
  return fs.found;
}

fn async_frame_fresh_name(ctx: Ctx, mod_path: String, base: String) -> String {
  let mut n: i32 = 0;
  while true {
    let cand: String = "__async_frame$".concat(base).concat("$").concat(n.to_string());
    if !structs_has(ctx, mod_path, cand) { return cand; }
    n = n + 1;
  }
  return "__async_frame$".concat(base).concat("$0");
}

fn async_poll_fresh_lowered(ctx: Ctx, mod_path: String, base: String) -> String {
  let mut n: i32 = 0;
  while true {
    let cand: String = "async$poll$".concat(base).concat("$").concat(n.to_string());
    let fr: FindFuncResult = find_func(ctx, mod_path, cand);
    if !fr.found { return cand; }
    n = n + 1;
  }
  return "async$poll$".concat(base).concat("$0");
}

fn async_frame_fields(ctx: Ctx, fd: ast.FuncDecl, sig: FuncSig) -> Vec[StructFieldSig] {
  let mut fs: Vec[StructFieldSig] = Vec();
  fs.push(StructFieldSig { name: "state", ty: ctx.ty_i32, vis: ast.vis_private(), is_pub: false });

  let mut i: i32 = 0;
  while i < fd.params.len() {
    let p: ast.Param = fd.params.get(i);
    let ty0: i32 = strip_range_only(ctx, sig.params.get(i));
    fs.push(StructFieldSig { name: "p_".concat(p.name), ty: ty0, vis: ast.vis_private(), is_pub: false });
    i = i + 1;
  }
  return fs;
}

fn ctx_add_struct_sig(ctx0: Ctx, sig: StructSig) -> Ctx {
  let mut ctx: Ctx = ctx0;
  ctx.structs.push(sig);
  return ctx;
}

fn ctx_add_func_sym(ctx0: Ctx, sym: FuncSym) -> Ctx {
  let mut ctx: Ctx = ctx0;
  ctx.funcs.push(sym);
  return ctx;
}

fn ctx_add_impl_sig(ctx0: Ctx, sig: ImplSig) -> Ctx {
  let mut ctx: Ctx = ctx0;
  ctx.impls.push(sig);
  return ctx;
}

fn ctx_add_async_fn_sig(ctx0: Ctx, sig: AsyncFnSig) -> Ctx {
  let mut ctx: Ctx = ctx0;
  ctx.async_fns.push(sig);
  return ctx;
}

fn imps_has_alias(imps: Imports, alias: String) -> bool {
  let mut i: i32 = 0;
  while i < imps.aliases.len() {
    let a: ImportAlias = imps.aliases.get(i);
    if a.alias == alias { return true; }
    i = i + 1;
  }
  return false;
}

fn imps_add_alias(imps0: Imports, alias: String, path: String) -> Imports {
  let mut imps: Imports = imps0;
  if imps_has_alias(imps, alias) { return imps; }
  imps.aliases.push(ImportAlias { alias: alias, path: path });
  return imps;
}

fn fresh_internal_async_alias(imps: Imports) -> String {
  let mut n: i32 = 0;
  while true {
    let cand: String = if n == 0 { "__async" } else { "__async".concat(n.to_string()) };
    if !imps_has_alias(imps, cand) { return cand; }
    n = n + 1;
  }
  return "__async";
}

fn find_impl_sig_idx_collect_async(c: Ctx, mod_path: String, decl_idx: i32) -> i32 {
  let mut i: i32 = 0;
  while i < c.impls.len() {
    let s: ImplSig = c.impls.get(i);
    if s.mod_path == mod_path && s.decl_idx == decl_idx { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_impl_method_idx_by_lowered(sig: ImplSig, lowered_name: String) -> i32 {
  let mut i: i32 = 0;
  while i < sig.methods.len() {
    let m: ImplMethodSig = sig.methods.get(i);
    if m.lowered_name == lowered_name { return i; }
    i = i + 1;
  }
  return -1;
}

fn impl_methods_replace(sig0: ImplSig, idx: i32, ms: ImplMethodSig) -> ImplSig {
  let mut sig: ImplSig = sig0;
  if idx < 0 || idx >= sig.methods.len() { return sig; }
  let mut out: Vec[ImplMethodSig] = Vec();
  let mut i: i32 = 0;
  while i < sig.methods.len() {
    out.push(if i == idx { ms } else { sig.methods.get(i) });
    i = i + 1;
  }
  sig.methods = out;
  return sig;
}

fn impls_replace(ctx0: Ctx, idx: i32, is: ImplSig) -> Ctx {
  let mut ctx: Ctx = ctx0;
  if idx < 0 || idx >= ctx.impls.len() { return ctx; }
  let mut out: Vec[ImplSig] = Vec();
  let mut i: i32 = 0;
  while i < ctx.impls.len() {
    out.push(if i == idx { is } else { ctx.impls.get(i) });
    i = i + 1;
  }
  ctx.impls = out;
  return ctx;
}

struct CollectAsyncOneResult {
  ok: bool,
  err: TcError,
  ctx: Ctx,
  frame_name: String,
  frame_ty: i32,
  poll_lowered: String,
}

struct CollectAsyncPrepareOneResult {
  ok: bool,
  err: TcError,
  ctx: Ctx,
  frame_name: String,
  frame_ty: i32,
  poll_lowered: String,
  output_ty: i32,
}

struct CollectAsyncFinalizeOneResult { ok: bool, err: TcError, ctx: Ctx }

fn structs_replace_by_name(ctx0: Ctx, mod_path: String, name: String, sig: StructSig) -> Ctx {
  let mut ctx: Ctx = ctx0;
  let mut out: Vec[StructSig] = Vec();
  let mut replaced: bool = false;
  let mut i: i32 = 0;
  while i < ctx.structs.len() {
    let s0: StructSig = ctx.structs.get(i);
    if s0.mod_path == mod_path && s0.name == name {
      out.push(sig);
      replaced = true;
    } else {
      out.push(s0);
    }
    i = i + 1;
  }
  if !replaced { out.push(sig); }
  ctx.structs = out;
  return ctx;
}

fn synth_params(names: Vec[String]) -> Vec[ast.Param] {
  let mut out: Vec[ast.Param] = Vec();
  let mut i: i32 = 0;
  while i < names.len() {
    out.push(ast.Param { name: names.get(i), ty: ast.TypeName { parts: Vec(), args: Vec() } });
    i = i + 1;
  }
  return out;
}

struct FindTraitMethodRetResult { found: bool, ret: ast.TypeName }

fn find_trait_method_ret(m: WorldModule, trait_name: String, method: String) -> FindTraitMethodRetResult {
  let mut ti: i32 = 0;
  while ti < m.prog.traits.len() {
    let td: ast.TraitDecl = m.prog.traits.get(ti);
    if td.name == trait_name {
      let mut mi: i32 = 0;
      while mi < td.methods.len() {
        let md: ast.TraitMethodDecl = td.methods.get(mi);
        if md.name == method {
          return FindTraitMethodRetResult { found: true, ret: md.ret };
        }
        mi = mi + 1;
      }
    }
    ti = ti + 1;
  }
  return FindTraitMethodRetResult { found: false, ret: ast.TypeName { parts: Vec(), args: Vec() } };
}

fn collect_async_prepare_one(
  ctx0: Ctx,
  w: World,
  sym_mod_path: String,
  body_mod_path: String,
  body_imports: Vec[ast.ImportDecl],
  exprs_mod: ast.ExprPool,
  fd: ast.FuncDecl,
  lowered: String,
) -> CollectAsyncPrepareOneResult {
  let mut c: Ctx = ctx0;

  let fidx: i32 = find_func_sym_idx(c, sym_mod_path, lowered);
  if fidx == -1 {
    return CollectAsyncPrepareOneResult { ok: false, err: type_error_at(fd.sp, "missing fn sig"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "", output_ty: c.ty_bad };
  }
  let fsym0: FuncSym = c.funcs.get(fidx);
  let output_ty: i32 = fsym0.sig.ret;

  // Async fn returns a Future value; without lifetimes in the language surface,
  // forbid non-static borrows in params/output because they'd escape via the frame.
  if ty_has_forbidden_borrow(c, strip_range_only(c, output_ty)) {
    return CollectAsyncPrepareOneResult { ok: false, err: type_error_at(fd.sp, "async fn output cannot contain non-static borrow"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "", output_ty: c.ty_bad };
  }
  let mut pi0: i32 = 0;
  while pi0 < fsym0.sig.params.len() {
    let pty0: i32 = strip_range_only(c, fsym0.sig.params.get(pi0));
    if ty_has_forbidden_borrow(c, pty0) {
      return CollectAsyncPrepareOneResult { ok: false, err: type_error_at(fd.sp, "async fn param cannot contain non-static borrow"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "", output_ty: c.ty_bad };
    }
    pi0 = pi0 + 1;
  }

  let ir0: ImportsResult = build_imports(w, body_mod_path, body_imports, fd.file);
  if !ir0.ok { return CollectAsyncPrepareOneResult { ok: false, err: ir0.err, ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "", output_ty: c.ty_bad }; }
  let base_imps: Imports = ir0.imps;
  let async_alias: String = fresh_internal_async_alias(base_imps);
  let imps2: Imports = imps_add_alias(base_imps, async_alias, "std/async");

  // Synthesize frame struct.
  let frame_name: String = async_frame_fresh_name(c, sym_mod_path, lowered);
  let irs: ResolveTyResult = nominal_intern_struct(c, sym_mod_path, frame_name);
  c = irs.ctx;
  if !irs.ok {
    return CollectAsyncPrepareOneResult { ok: false, err: type_error_at(fd.sp, "failed to intern async frame type"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "", output_ty: c.ty_bad };
  }
  let frame_ty: i32 = irs.idx;

  // Prepare with base fields only; await operands + captures are filled in finalize pass.
  let fs_base: Vec[StructFieldSig] = async_frame_fields(c, fd, fsym0.sig);
  c = ctx_add_struct_sig(c, StructSig { mod_path: sym_mod_path, name: frame_name, base_name: frame_name, vis: ast.vis_private(), is_pub: false, fields: fs_base });

  // Future impl lowered poll name and signature.
  let poll_lowered: String = async_poll_fresh_lowered(c, sym_mod_path, lowered);
  let mut poll_parts: Vec[String] = Vec();
  poll_parts.push(async_alias);
  poll_parts.push("Poll");
  let mut poll_args: Vec[ast.TypeName] = Vec();
  poll_args.push(fd.ret);
  let poll_tn: ast.TypeName = ast.TypeName { parts: poll_parts, args: poll_args };
  let pr: ResolveTyResult = resolve_type(c, w, body_mod_path, imps2, fsym0.sig.type_params, poll_tn);
  c = pr.ctx;
  if !pr.ok { return CollectAsyncPrepareOneResult { ok: false, err: type_error_at(fd.sp, "failed to resolve std/async::Poll for async lowering"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "", output_ty: c.ty_bad }; }

  let mut ctx_parts: Vec[String] = Vec();
  ctx_parts.push(async_alias);
  ctx_parts.push("Context");
  let ctx_tn: ast.TypeName = ast.TypeName { parts: ctx_parts, args: Vec() };
  let cr: ResolveTyResult = resolve_type(c, w, body_mod_path, imps2, fsym0.sig.type_params, ctx_tn);
  c = cr.ctx;
  if !cr.ok { return CollectAsyncPrepareOneResult { ok: false, err: type_error_at(fd.sp, "failed to resolve std/async::Context for async lowering"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "", output_ty: c.ty_bad }; }
  let ctx_ty: i32 = cr.idx;

  let poll_sig: FuncSig = FuncSig {
    params: vec2(frame_ty, ctx_ty),
    param_borrow_kinds: vec2(param_borrow_ref_mut(), param_borrow_ref()),
    ret: pr.idx,
    has_variadic: false,
    variadic_elem: -1,
    vis: ast.vis_private(),
    is_pub: false,
    type_params: Vec(),
    type_param_packs: Vec(),
    const_params: Vec(),
    type_param_bounds: Vec(),
    effects: fsym0.sig.effects,
    resource_reads: fsym0.sig.resource_reads,
    resource_writes: fsym0.sig.resource_writes,
    const_where_bounds: Vec(),
  };
  c = ctx_add_func_sym(c, FuncSym { mod_path: sym_mod_path, name: poll_lowered, sig: poll_sig });

  // Future impl signature for the frame type.
  let mut assoc: Vec[ImplAssocTypeSig] = Vec();
  assoc.push(ImplAssocTypeSig { name: "Output", ty: output_ty });
  let mut ms: Vec[ImplMethodSig] = Vec();
  ms.push(ImplMethodSig {
    name: "poll",
    lowered_name: poll_lowered,
    sig: poll_sig,
    from_default: false,
    default_mod_path: "",
    default_file: "",
    default_params: Vec(),
    default_body: ast.Block { stmts: Vec() },
  });
  c = ctx_add_impl_sig(c, ImplSig {
    mod_path: sym_mod_path,
    decl_idx: -1,
    is_inherent: false,
    is_negative: false,
    trait_mod_path: "std/async",
    trait_name: "Future",
    for_ty: frame_ty,
    head_type_params: Vec(),
    head_type_param_bounds: Vec(),
    assoc_types: assoc,
    methods: ms,
  });

  // Rewrite async function signature to return the frame type.
  let mut sig2: FuncSig = fsym0.sig;
  sig2.ret = frame_ty;
  c = funcs_replace(c, fidx, FuncSym { mod_path: fsym0.mod_path, name: fsym0.name, sig: sig2 });

  // Record metadata for typechecking async bodies and for IRGen lowering.
  c = ctx_add_async_fn_sig(c, AsyncFnSig { mod_path: sym_mod_path, name: lowered, output_ty: output_ty, frame_name: frame_name, frame_ty: frame_ty, poll_lowered: poll_lowered });

  return CollectAsyncPrepareOneResult { ok: true, err: TcError.None, ctx: c, frame_name: frame_name, frame_ty: frame_ty, poll_lowered: poll_lowered, output_ty: output_ty };
}

fn collect_async_finalize_one(
  ctx0: Ctx,
  w: World,
  sym_mod_path: String,
  body_mod_path: String,
  body_imports: Vec[ast.ImportDecl],
  exprs_mod: ast.ExprPool,
  fd: ast.FuncDecl,
  lowered: String,
) -> CollectAsyncFinalizeOneResult {
  let mut c: Ctx = ctx0;

  let ar: FindAsyncFnResult = find_async_fn(c, sym_mod_path, lowered);
  if !ar.found {
    return CollectAsyncFinalizeOneResult { ok: false, err: type_error_at(fd.sp, "missing async fn lowering metadata"), ctx: c };
  }
  let frame_name: String = ar.sig.frame_name;

  let fidx: i32 = find_func_sym_idx(c, sym_mod_path, lowered);
  if fidx == -1 {
    return CollectAsyncFinalizeOneResult { ok: false, err: type_error_at(fd.sp, "missing fn sig"), ctx: c };
  }
  let fsym0: FuncSym = c.funcs.get(fidx);

  let ir0: ImportsResult = build_imports(w, body_mod_path, body_imports, fd.file);
  if !ir0.ok { return CollectAsyncFinalizeOneResult { ok: false, err: ir0.err, ctx: c }; }
  let base_imps: Imports = ir0.imps;

  // Locals environment used for typed async normalization + await operand typing.
  let mut locals: Vec[AsyncLocalDecl] = Vec();
  let mut await_operand_tys: Vec[i32] = Vec();
  let mut l_cur: Locals = locals_new();
  l_cur.fn_is_async = true;
  l_cur.fn_effects = fsym0.sig.effects;
  l_cur.fn_resource_reads = fsym0.sig.resource_reads;
  l_cur.fn_resource_writes = fsym0.sig.resource_writes;
  // `?` inside async bodies targets the user-visible output type.
  l_cur.fn_ret_ty = ar.sig.output_ty;
  l_cur.type_params = fsym0.sig.type_params;
  l_cur.type_param_bounds = fsym0.sig.type_param_bounds;
  let mut seen_names: Vec[String] = Vec();
  let mut exclude_names: Vec[String] = Vec();

  let mut pi0: i32 = 0;
  while pi0 < fd.params.len() {
    let pty0: i32 = strip_range_only(c, fsym0.sig.params.get(pi0));
    let p: ast.Param = fd.params.get(pi0);
    l_cur = locals_decl(l_cur, p.name, pty0, false);
    // Params are already stored in the frame as p_<name>; do not capture them.
    exclude_names.push(p.name);
    seen_names.push(p.name);
    pi0 = pi0 + 1;
  }

  // Async normalization runs inside typecheck so it can infer join-slot types
  // (avoiding user-visible annotation requirements for await-in-expr cases).
  let nr: NormalizeResult = normalize_async_block(c, w, body_mod_path, base_imps, exprs_mod, fd.body, l_cur);
  if !nr.ok { return CollectAsyncFinalizeOneResult { ok: false, err: type_error_at(fd.sp, nr.err), ctx: c }; }
  let exprs: ast.ExprPool = nr.exprs;
  let body: ast.Block = nr.body;

  let wr: WalkAsyncResult = walk_async_block(c, w, body_mod_path, base_imps, exprs, body, l_cur, locals, await_operand_tys, seen_names);
  if !wr.ok { return CollectAsyncFinalizeOneResult { ok: false, err: wr.err, ctx: wr.ctx }; }
  c = wr.ctx;
  locals = wr.decls;
  await_operand_tys = wr.await_operand_tys;

  // Determine captures via CFG liveness across await resume points.
  let cfg: ac.BuildResult = ac.build(exprs, body, ar.sig.output_ty == c.ty_unit);
  if !cfg.ok { return CollectAsyncFinalizeOneResult { ok: false, err: type_error_at(fd.sp, cfg.err), ctx: c }; }
  if cfg.await_count != await_operand_tys.len() {
    return CollectAsyncFinalizeOneResult { ok: false, err: type_error_at(fd.sp, "internal: async await count mismatch"), ctx: c };
  }
  let cr: ac.CapturesResult = ac.captures(exprs, cfg, exclude_names);
  if !cr.ok { return CollectAsyncFinalizeOneResult { ok: false, err: type_error_at(fd.sp, cr.err), ctx: c }; }
  let mut captures: Vec[String] = Vec();
  let mut ci1: i32 = 0;
  while ci1 < cr.captures.len() {
    let nm: String = cr.captures.get(ci1);
    let ld0: AsyncLocalDecl = local_decl_find(locals, nm);
    if ld0.name != "" {
      if !string_vec_contains(captures, nm) { captures.push(nm); }
    }
    ci1 = ci1 + 1;
  }

  // Update frame struct signature with await operand + capture fields.
  let mut fs: Vec[StructFieldSig] = async_frame_fields(c, fd, fsym0.sig);
  let mut ak: i32 = 0;
  while ak < await_operand_tys.len() {
    fs.push(StructFieldSig { name: "a".concat(ak.to_string()), ty: await_operand_tys.get(ak), vis: ast.vis_private(), is_pub: false });
    ak = ak + 1;
  }
  let mut ci0: i32 = 0;
  while ci0 < captures.len() {
    let nm: String = captures.get(ci0);
    let ld: AsyncLocalDecl = local_decl_find(locals, nm);
    if ld.name == "" { return CollectAsyncFinalizeOneResult { ok: false, err: type_error_at(fd.sp, "internal: missing capture local decl"), ctx: c }; }
    if ty_has_forbidden_borrow(c, ld.ty) {
      let await_sp: ast.Span = capture_await_span(cr.uses, nm);
      let err_sp: ast.Span = if await_sp.file != "" { await_sp } else { fd.sp };
      let msg: String =
        "borrowed local cannot live across await: ".concat(nm)
          .concat(" (declared at ").concat(span_loc(ld.decl_sp))
          .concat(", crosses await at ").concat(span_loc(await_sp)).concat(")");
      return CollectAsyncFinalizeOneResult { ok: false, err: type_error_at(err_sp, msg), ctx: c };
    }
    fs.push(StructFieldSig { name: "l_".concat(nm), ty: ld.ty, vis: ast.vis_private(), is_pub: false });
    ci0 = ci0 + 1;
  }
  c = structs_replace_by_name(c, sym_mod_path, frame_name, StructSig { mod_path: sym_mod_path, name: frame_name, base_name: frame_name, vis: ast.vis_private(), is_pub: false, fields: fs });

  return CollectAsyncFinalizeOneResult { ok: true, err: TcError.None, ctx: c };
}

// Collect and synthesize async fn lowering metadata:
// - a per-fn frame struct type
// - a Future impl signature for that frame type (poll + Output)
// - rewrite the async function's signature return type to the frame type
fn collect_async_fns(ctx0: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx0;

  // Phase 1: prepare all async functions/methods so calls typecheck to frame future types
  // during finalize (await operand typing).
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let exprs_mod: ast.ExprPool = m.prog.exprs;

    // Impl methods.
    let mut ii: i32 = 0;
    while ii < m.prog.impls.len() {
      let id: ast.ImplDecl = m.prog.impls.get(ii);
      let impl_sig_idx: i32 = find_impl_sig_idx_collect_async(c, m.path, ii);
      if impl_sig_idx == -1 { return TcCtxResult { ok: false, err: type_error_at(id.sp, "missing impl sig"), ctx: c }; }

      let mut mdi: i32 = 0;
      while mdi < id.methods.len() {
        let md: ast.FuncDecl = id.methods.get(mdi);
        if md.is_async {
          let isig0: ImplSig = c.impls.get(impl_sig_idx);
          let mf: FindImplMethodResult = find_impl_method(isig0, md.name);
          if !mf.found { return TcCtxResult { ok: false, err: type_error_at(md.sp, "missing impl method sig"), ctx: c }; }
          let lowered: String = mf.m.lowered_name;

          let r: CollectAsyncPrepareOneResult = collect_async_prepare_one(c, w, m.path, m.path, m.prog.imports, exprs_mod, md, lowered);
          if !r.ok { return TcCtxResult { ok: false, err: r.err, ctx: r.ctx }; }
          c = r.ctx;

          // Update impl method signature to return the frame type.
          let isig1: ImplSig = c.impls.get(impl_sig_idx);
          let meth_idx: i32 = find_impl_method_idx_by_lowered(isig1, lowered);
          if meth_idx == -1 { return TcCtxResult { ok: false, err: type_error_at(md.sp, "internal: missing lowered impl method entry"), ctx: c }; }
          let mut ms0: ImplMethodSig = isig1.methods.get(meth_idx);
          let mut ms_sig: FuncSig = ms0.sig;
          ms_sig.ret = r.frame_ty;
          ms0.sig = ms_sig;
          let mut isig2: ImplSig = impl_methods_replace(isig1, meth_idx, ms0);
          if !id.is_inherent {
            let tf: FindTraitResult = find_trait(c, isig2.trait_mod_path, isig2.trait_name);
            if tf.found {
              let tmf: FindTraitMethodResult = find_trait_method(tf.sig, md.name);
              if tmf.found && tmf.m.is_async {
                let assoc_name: String = "__async$".concat(md.name);
                let mut found0: bool = false;
                let mut ai0: i32 = 0;
                while ai0 < isig2.assoc_types.len() {
                  let a0: ImplAssocTypeSig = isig2.assoc_types.get(ai0);
                  if a0.name == assoc_name {
                    found0 = true;
                    if a0.ty != r.frame_ty {
                      return TcCtxResult { ok: false, err: type_error_at(md.sp, "async trait assoc type binding mismatch"), ctx: c };
                    }
                  }
                  ai0 = ai0 + 1;
                }
                if !found0 {
                  isig2.assoc_types.push(ImplAssocTypeSig { name: assoc_name, ty: r.frame_ty });
                }
              }
            }
          }
          c = impls_replace(c, impl_sig_idx, isig2);
        }
        mdi = mdi + 1;
      }

      // Synthesized default trait methods live in impl signatures but have bodies in the trait module.
      // Prepare async lowering for those methods as well.
      if !id.is_inherent {
        let isig_def0: ImplSig = c.impls.get(impl_sig_idx);
        let tf_def0: FindTraitResult = find_trait(c, isig_def0.trait_mod_path, isig_def0.trait_name);
        if tf_def0.found {
          let mut msi: i32 = 0;
          while msi < isig_def0.methods.len() {
            let msd0: ImplMethodSig = isig_def0.methods.get(msi);
            if msd0.from_default {
              let tmf0: FindTraitMethodResult = find_trait_method(tf_def0.sig, msd0.name);
              if tmf0.found && tmf0.m.is_async {
                let fmd0: FindModResult = find_mod(w, msd0.default_mod_path);
                if !fmd0.found {
                  return TcCtxResult { ok: false, err: type_error_at(id.sp, "missing default trait method module"), ctx: c };
                }
                let mdm0: WorldModule = w.mods.get(fmd0.idx);
                let rr0: FindTraitMethodRetResult = find_trait_method_ret(mdm0, isig_def0.trait_name, msd0.name);
                if !rr0.found {
                  return TcCtxResult { ok: false, err: type_error_at(id.sp, "internal: missing trait method decl for async default body"), ctx: c };
                }
                let fd0: ast.FuncDecl = ast.FuncDecl {
                  file: msd0.default_file,
                  sp: ast.span0(),
                  vis: ast.vis_private(),
                  is_pub: false,
                  is_async: true,
                  track_caller: false,
                  name: msd0.lowered_name,
                  type_params: Vec(),
                  type_param_packs: Vec(),
                  const_params: Vec(),
                  type_param_bounds: Vec(),
                  const_where_bounds: Vec(),
                  params: synth_params(msd0.default_params),
                  ret: rr0.ret,
                  ffi_imports: Vec(),
                  ffi_exports: Vec(),
                  effects: Vec(),
                  resources: Vec(),
                  body: msd0.default_body,
                };

                let rdef0: CollectAsyncPrepareOneResult =
                  collect_async_prepare_one(c, w, m.path, mdm0.path, mdm0.prog.imports, mdm0.prog.exprs, fd0, msd0.lowered_name);
                if !rdef0.ok { return TcCtxResult { ok: false, err: rdef0.err, ctx: rdef0.ctx }; }
                c = rdef0.ctx;

                let isig1d: ImplSig = c.impls.get(impl_sig_idx);
                let meth_idxd: i32 = find_impl_method_idx_by_lowered(isig1d, msd0.lowered_name);
                if meth_idxd == -1 { return TcCtxResult { ok: false, err: type_error_at(id.sp, "internal: missing lowered impl method entry (default)"), ctx: c }; }
                let mut ms0d: ImplMethodSig = isig1d.methods.get(meth_idxd);
                let mut ms_sigd: FuncSig = ms0d.sig;
                ms_sigd.ret = rdef0.frame_ty;
                ms0d.sig = ms_sigd;
                let mut isig2d: ImplSig = impl_methods_replace(isig1d, meth_idxd, ms0d);

                // Bind synthesized async trait assoc type to the generated frame.
                let assoc_name: String = "__async$".concat(msd0.name);
                let mut foundd: bool = false;
                let mut ai0: i32 = 0;
                while ai0 < isig2d.assoc_types.len() {
                  let a0: ImplAssocTypeSig = isig2d.assoc_types.get(ai0);
                  if a0.name == assoc_name {
                    foundd = true;
                    if a0.ty != rdef0.frame_ty {
                      return TcCtxResult { ok: false, err: type_error_at(id.sp, "async trait assoc type binding mismatch"), ctx: c };
                    }
                  }
                  ai0 = ai0 + 1;
                }
                if !foundd {
                  isig2d.assoc_types.push(ImplAssocTypeSig { name: assoc_name, ty: rdef0.frame_ty });
                }

                c = impls_replace(c, impl_sig_idx, isig2d);
              }
            }
            msi = msi + 1;
          }
        }
      }

      ii = ii + 1;
    }

    // Module-level functions.
    let mut fi: i32 = 0;
    while fi < m.prog.funcs.len() {
      let fd: ast.FuncDecl = m.prog.funcs.get(fi);
      if fd.is_async {
        let r0: CollectAsyncPrepareOneResult = collect_async_prepare_one(c, w, m.path, m.path, m.prog.imports, exprs_mod, fd, fd.name);
        if !r0.ok { return TcCtxResult { ok: false, err: r0.err, ctx: r0.ctx }; }
        c = r0.ctx;
      }
      fi = fi + 1;
    }

    mi = mi + 1;
  }

  // Phase 2: finalize all async frames (await operand + capture fields) now that
  // all async call signatures have been rewritten to frame future types.
  mi = 0;
  while mi < w.mods.len() {
    let m2: WorldModule = w.mods.get(mi);
    let exprs_mod2: ast.ExprPool = m2.prog.exprs;

    let mut fi2: i32 = 0;
    while fi2 < m2.prog.funcs.len() {
      let fd2: ast.FuncDecl = m2.prog.funcs.get(fi2);
      if fd2.is_async {
        let r2: CollectAsyncFinalizeOneResult = collect_async_finalize_one(c, w, m2.path, m2.path, m2.prog.imports, exprs_mod2, fd2, fd2.name);
        if !r2.ok { return TcCtxResult { ok: false, err: r2.err, ctx: r2.ctx }; }
        c = r2.ctx;
      }
      fi2 = fi2 + 1;
    }

    let mut ii2: i32 = 0;
    while ii2 < m2.prog.impls.len() {
      let id2: ast.ImplDecl = m2.prog.impls.get(ii2);
      let impl_sig_idx2: i32 = find_impl_sig_idx_collect_async(c, m2.path, ii2);
      if impl_sig_idx2 == -1 { return TcCtxResult { ok: false, err: type_error_at(id2.sp, "missing impl sig"), ctx: c }; }
      let isig: ImplSig = c.impls.get(impl_sig_idx2);

      let mut mdi2: i32 = 0;
      while mdi2 < id2.methods.len() {
        let md2: ast.FuncDecl = id2.methods.get(mdi2);
        if md2.is_async {
          let mf2: FindImplMethodResult = find_impl_method(isig, md2.name);
          if !mf2.found { return TcCtxResult { ok: false, err: type_error_at(md2.sp, "missing impl method sig"), ctx: c }; }
          let lowered2: String = mf2.m.lowered_name;
          let r3: CollectAsyncFinalizeOneResult = collect_async_finalize_one(c, w, m2.path, m2.path, m2.prog.imports, exprs_mod2, md2, lowered2);
          if !r3.ok { return TcCtxResult { ok: false, err: r3.err, ctx: r3.ctx }; }
          c = r3.ctx;
        }
        mdi2 = mdi2 + 1;
      }

      if !id2.is_inherent {
        let isig_def2: ImplSig = c.impls.get(impl_sig_idx2);
        let tf_def2: FindTraitResult = find_trait(c, isig_def2.trait_mod_path, isig_def2.trait_name);
        if tf_def2.found {
          let mut msi2: i32 = 0;
          while msi2 < isig_def2.methods.len() {
            let msd2: ImplMethodSig = isig_def2.methods.get(msi2);
            if msd2.from_default {
              let tmf2: FindTraitMethodResult = find_trait_method(tf_def2.sig, msd2.name);
              if tmf2.found && tmf2.m.is_async {
                let fmd2: FindModResult = find_mod(w, msd2.default_mod_path);
                if !fmd2.found {
                  return TcCtxResult { ok: false, err: type_error_at(id2.sp, "missing default trait method module"), ctx: c };
                }
                let mdm2: WorldModule = w.mods.get(fmd2.idx);
                let rr2: FindTraitMethodRetResult = find_trait_method_ret(mdm2, isig_def2.trait_name, msd2.name);
                if !rr2.found {
                  return TcCtxResult { ok: false, err: type_error_at(id2.sp, "internal: missing trait method decl for async default body"), ctx: c };
                }
                let fd2d: ast.FuncDecl = ast.FuncDecl {
                  file: msd2.default_file,
                  sp: ast.span0(),
                  vis: ast.vis_private(),
                  is_pub: false,
                  is_async: true,
                  track_caller: false,
                  name: msd2.lowered_name,
                  type_params: Vec(),
                  type_param_packs: Vec(),
                  const_params: Vec(),
                  type_param_bounds: Vec(),
                  const_where_bounds: Vec(),
                  params: synth_params(msd2.default_params),
                  ret: rr2.ret,
                  ffi_imports: Vec(),
                  ffi_exports: Vec(),
                  effects: Vec(),
                  resources: Vec(),
                  body: msd2.default_body,
                };
                let rdef2: CollectAsyncFinalizeOneResult =
                  collect_async_finalize_one(c, w, m2.path, mdm2.path, mdm2.prog.imports, mdm2.prog.exprs, fd2d, msd2.lowered_name);
                if !rdef2.ok { return TcCtxResult { ok: false, err: rdef2.err, ctx: rdef2.ctx }; }
                c = rdef2.ctx;
              }
            }
            msi2 = msi2 + 1;
          }
        }
      }

      ii2 = ii2 + 1;
    }

    mi = mi + 1;
  }

  // Now that all async bodies have been analyzed and base frame layouts are finalized,
  // refine any instantiated async frames that were requested while typechecking.
  c = async_inst_finalize_frames(c);
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}
