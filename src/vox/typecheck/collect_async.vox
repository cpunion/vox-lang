import "vox/ast" as ast
import "vox/ir" as ir
import "vox/async_norm" as an

// Async lowering metadata collection.

struct AsyncLocalDecl { name: String, ty: i32, mutable: bool, stmt_idx: i32 }

fn stmt_span(st: ast.Stmt) -> ast.Span {
  return match st {
    ast.Stmt.Let(sp, _m, _n, _ha, _ann, _e) => sp,
    ast.Stmt.Assign(sp, _n, _e) => sp,
    ast.Stmt.AssignField(sp, _r, _f, _e) => sp,
    ast.Stmt.ExprStmt(sp, _e) => sp,
    ast.Stmt.IfStmt(sp, _c, _t, _h, _e) => sp,
    ast.Stmt.WhileStmt(sp, _c, _b) => sp,
    ast.Stmt.Break(sp) => sp,
    ast.Stmt.Continue(sp) => sp,
    ast.Stmt.ReturnStmt(sp, _h, _e) => sp,
  };
}

fn string_vec_contains(xs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn local_decl_find(xs: Vec[AsyncLocalDecl], name: String) -> AsyncLocalDecl {
  let mut i: i32 = 0;
  while i < xs.len() {
    let x: AsyncLocalDecl = xs.get(i);
    if x.name == name { return x; }
    i = i + 1;
  }
  return AsyncLocalDecl { name: "", ty: -1, mutable: false, stmt_idx: -1 };
}

fn expr_contains_try(exprs: ast.ExprPool, eid: i32) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);
  if match n { ast.ExprNode.Try(_x) => true, _ => false } { return true; }
  if match n { ast.ExprNode.TryBlock(_bid) => true, _ => false } { return true; }
  if match n { ast.ExprNode.Await(x) => true, _ => false } {
    let x: i32 = match n { ast.ExprNode.Await(y) => y, _ => -1 };
    return expr_contains_try(exprs, x);
  }
  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Unary(_op, x) => x, _ => -1 };
    return expr_contains_try(exprs, a);
  }
  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(x, _tn) => x, _ => -1 };
    return expr_contains_try(exprs, a);
  }
  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let l: i32 = match n { ast.ExprNode.Binary(_op, x, _r) => x, _ => -1 };
    let r: i32 = match n { ast.ExprNode.Binary(_op, _l, x) => x, _ => -1 };
    return expr_contains_try(exprs, l) || expr_contains_try(exprs, r);
  }
  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } {
    let c: i32 = match n { ast.ExprNode.If(x, _t, _e) => x, _ => -1 };
    let t: i32 = match n { ast.ExprNode.If(_c, x, _e) => x, _ => -1 };
    let e: i32 = match n { ast.ExprNode.If(_c, _t, x) => x, _ => -1 };
    return expr_contains_try(exprs, c) || expr_contains_try(exprs, t) || expr_contains_try(exprs, e);
  }
  if match n { ast.ExprNode.Member(_r, _f) => true, _ => false } {
    let r: i32 = match n { ast.ExprNode.Member(x, _f) => x, _ => -1 };
    return expr_contains_try(exprs, r);
  }
  if match n { ast.ExprNode.Call(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(x, _t, _a) => x, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _t, x) => x, _ => Vec() };
    if expr_contains_try(exprs, callee) { return true; }
    let mut i: i32 = 0;
    while i < args.len() {
      if expr_contains_try(exprs, args.get(i)) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.StructLit(_t, _fs) => true, _ => false } {
    let fs: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_t, x) => x, _ => Vec() };
    let mut i: i32 = 0;
    while i < fs.len() {
      if expr_contains_try(exprs, fs.get(i).expr) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.Block(_b) => true, _ => false } {
    // v0: treat block expression as potentially containing try.
    return true;
  }
  if match n { ast.ExprNode.Match(_s, _as) => true, _ => false } { return true; }
  return false;
}

fn ty_has_forbidden_borrow(ctx: Ctx, ty0: i32) -> bool {
  let ty: i32 = strip_range_only(ctx, ty0);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty);
  if t.kind == ir.TyKind.Ref {
    // Only allow `&'static T` (immutable) to live across await.
    if ir.ty_ref_is_mut(t) { return true; }
    if !ir.ty_ref_is_static(t) { return true; }
    return ty_has_forbidden_borrow(ctx, t.elem);
  }
  if t.kind == ir.TyKind.Vec { return ty_has_forbidden_borrow(ctx, t.elem); }
  if t.kind == ir.TyKind.Range { return ty_has_forbidden_borrow(ctx, t.elem); }
  if t.kind == ir.TyKind.Struct {
    let fs: FindStructResult = find_struct(ctx, t.mod_path, t.name);
    if !fs.found { return false; }
    let mut i: i32 = 0;
    while i < fs.sig.fields.len() {
      if ty_has_forbidden_borrow(ctx, fs.sig.fields.get(i).ty) { return true; }
      i = i + 1;
    }
    return false;
  }
  if t.kind == ir.TyKind.Enum {
    let fe: FindEnumResult = find_enum(ctx, t.mod_path, t.name);
    if !fe.found { return false; }
    let mut vi: i32 = 0;
    while vi < fe.sig.vars.len() {
      let v: EnumVariantSig = fe.sig.vars.get(vi);
      let mut fi: i32 = 0;
      while fi < v.fields.len() {
        if ty_has_forbidden_borrow(ctx, v.fields.get(fi)) { return true; }
        fi = fi + 1;
      }
      vi = vi + 1;
    }
    return false;
  }
  return false;
}

fn expr_uses_name(exprs: ast.ExprPool, eid: i32, name: String) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);
  if match n { ast.ExprNode.Ident(_s) => true, _ => false } {
    let s: String = match n { ast.ExprNode.Ident(x) => x, _ => "" };
    return s == name;
  }
  if match n { ast.ExprNode.Int(_v) => true, ast.ExprNode.Float(_v) => true, ast.ExprNode.Bool(_b) => true, ast.ExprNode.Str(_s) => true, ast.ExprNode.DotIdent(_s) => true, _ => false } {
    return false;
  }
  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Unary(_op, x) => x, _ => -1 };
    return expr_uses_name(exprs, a, name);
  }
  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(x, _tn) => x, _ => -1 };
    return expr_uses_name(exprs, a, name);
  }
  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let l: i32 = match n { ast.ExprNode.Binary(_op, x, _r) => x, _ => -1 };
    let r: i32 = match n { ast.ExprNode.Binary(_op, _l, x) => x, _ => -1 };
    return expr_uses_name(exprs, l, name) || expr_uses_name(exprs, r, name);
  }
  if match n { ast.ExprNode.Member(_r, _f) => true, _ => false } {
    let r: i32 = match n { ast.ExprNode.Member(x, _f) => x, _ => -1 };
    return expr_uses_name(exprs, r, name);
  }
  if match n { ast.ExprNode.Call(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(x, _t, _a) => x, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _t, x) => x, _ => Vec() };
    if expr_uses_name(exprs, callee, name) { return true; }
    let mut i: i32 = 0;
    while i < args.len() {
      if expr_uses_name(exprs, args.get(i), name) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.TryBlock(_bid) => true, _ => false } {
    let bid: i32 = match n { ast.ExprNode.TryBlock(x) => x, _ => -1 };
    return expr_uses_name(exprs, bid, name);
  }
  if match n { ast.ExprNode.Try(_a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Try(x) => x, _ => -1 };
    return expr_uses_name(exprs, a, name);
  }
  if match n { ast.ExprNode.Await(_a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Await(x) => x, _ => -1 };
    return expr_uses_name(exprs, a, name);
  }
  if match n { ast.ExprNode.StructLit(_t, _fs) => true, _ => false } {
    let fs: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_t, x) => x, _ => Vec() };
    let mut i: i32 = 0;
    while i < fs.len() {
      if expr_uses_name(exprs, fs.get(i).expr, name) { return true; }
      i = i + 1;
    }
    return false;
  }
  if match n { ast.ExprNode.Block(_b) => true, _ => false } { return true; }
  if match n { ast.ExprNode.Match(_s, _as) => true, _ => false } { return true; }
  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } { return true; }
  return false;
}

fn stmt_uses_name(exprs: ast.ExprPool, st: ast.Stmt, name: String) -> bool {
  return match st {
    ast.Stmt.Let(_sp, _m, _n, _ha, _ann, init) => expr_uses_name(exprs, init, name),
    ast.Stmt.Assign(_sp, _n, ex) => expr_uses_name(exprs, ex, name),
    ast.Stmt.AssignField(_sp, recv, _field, ex) => recv == name || expr_uses_name(exprs, ex, name),
    ast.Stmt.ExprStmt(_sp, ex) => expr_uses_name(exprs, ex, name),
    ast.Stmt.IfStmt(_sp, cond, then_b, has_else, else_b) => {
      if expr_uses_name(exprs, cond, name) { true } else if block_uses_name(exprs, then_b, name) { true } else if has_else { block_uses_name(exprs, else_b, name) } else { false }
    },
    ast.Stmt.WhileStmt(_sp, cond, body) => expr_uses_name(exprs, cond, name) || block_uses_name(exprs, body, name),
    ast.Stmt.Break(_sp) => false,
    ast.Stmt.Continue(_sp) => false,
    ast.Stmt.ReturnStmt(_sp, has_ex, ex) => if has_ex { expr_uses_name(exprs, ex, name) } else { false },
  };
}

fn block_uses_name(exprs: ast.ExprPool, b: ast.Block, name: String) -> bool {
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    if stmt_uses_name(exprs, b.stmts.get(i), name) { return true; }
    i = i + 1;
  }
  return false;
}

fn find_func_sym_idx(ctx: Ctx, mod_path: String, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < ctx.funcs.len() {
    let f: FuncSym = ctx.funcs.get(i);
    if f.mod_path == mod_path && f.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn funcs_replace(ctx0: Ctx, idx: i32, fsym: FuncSym) -> Ctx {
  let mut ctx: Ctx = ctx0;
  if idx < 0 || idx >= ctx.funcs.len() { return ctx; }
  let mut out: Vec[FuncSym] = Vec();
  let mut i: i32 = 0;
  while i < ctx.funcs.len() {
    out.push(if i == idx { fsym } else { ctx.funcs.get(i) });
    i = i + 1;
  }
  ctx.funcs = out;
  return ctx;
}

fn structs_has(ctx: Ctx, mod_path: String, name: String) -> bool {
  let fs: FindStructResult = find_struct(ctx, mod_path, name);
  return fs.found;
}

fn async_frame_fresh_name(ctx: Ctx, mod_path: String, base: String) -> String {
  let mut n: i32 = 0;
  while true {
    let cand: String = "__async_frame$".concat(base).concat("$").concat(n.to_string());
    if !structs_has(ctx, mod_path, cand) { return cand; }
    n = n + 1;
  }
  return "__async_frame$".concat(base).concat("$0");
}

fn async_poll_fresh_lowered(ctx: Ctx, mod_path: String, base: String) -> String {
  let mut n: i32 = 0;
  while true {
    let cand: String = "async$poll$".concat(base).concat("$").concat(n.to_string());
    let fr: FindFuncResult = find_func(ctx, mod_path, cand);
    if !fr.found { return cand; }
    n = n + 1;
  }
  return "async$poll$".concat(base).concat("$0");
}

fn async_frame_fields(ctx: Ctx, fd: ast.FuncDecl, sig: FuncSig) -> Vec[StructFieldSig] {
  let mut fs: Vec[StructFieldSig] = Vec();
  fs.push(StructFieldSig { name: "state", ty: ctx.ty_i32, vis: ast.vis_private(), is_pub: false });

  let mut i: i32 = 0;
  while i < fd.params.len() {
    let p: ast.Param = fd.params.get(i);
    let ty0: i32 = strip_range_only(ctx, sig.params.get(i));
    fs.push(StructFieldSig { name: "p_".concat(p.name), ty: ty0, vis: ast.vis_private(), is_pub: false });
    i = i + 1;
  }
  return fs;
}

fn ctx_add_struct_sig(ctx0: Ctx, sig: StructSig) -> Ctx {
  let mut ctx: Ctx = ctx0;
  ctx.structs.push(sig);
  return ctx;
}

fn ctx_add_func_sym(ctx0: Ctx, sym: FuncSym) -> Ctx {
  let mut ctx: Ctx = ctx0;
  ctx.funcs.push(sym);
  return ctx;
}

fn ctx_add_impl_sig(ctx0: Ctx, sig: ImplSig) -> Ctx {
  let mut ctx: Ctx = ctx0;
  ctx.impls.push(sig);
  return ctx;
}

fn ctx_add_async_fn_sig(ctx0: Ctx, sig: AsyncFnSig) -> Ctx {
  let mut ctx: Ctx = ctx0;
  ctx.async_fns.push(sig);
  return ctx;
}

fn imps_has_alias(imps: Imports, alias: String) -> bool {
  let mut i: i32 = 0;
  while i < imps.aliases.len() {
    let a: ImportAlias = imps.aliases.get(i);
    if a.alias == alias { return true; }
    i = i + 1;
  }
  return false;
}

fn imps_add_alias(imps0: Imports, alias: String, path: String) -> Imports {
  let mut imps: Imports = imps0;
  if imps_has_alias(imps, alias) { return imps; }
  imps.aliases.push(ImportAlias { alias: alias, path: path });
  return imps;
}

fn fresh_internal_async_alias(imps: Imports) -> String {
  let mut n: i32 = 0;
  while true {
    let cand: String = if n == 0 { "__async" } else { "__async".concat(n.to_string()) };
    if !imps_has_alias(imps, cand) { return cand; }
    n = n + 1;
  }
  return "__async";
}

fn find_impl_sig_idx_collect_async(c: Ctx, mod_path: String, decl_idx: i32) -> i32 {
  let mut i: i32 = 0;
  while i < c.impls.len() {
    let s: ImplSig = c.impls.get(i);
    if s.mod_path == mod_path && s.decl_idx == decl_idx { return i; }
    i = i + 1;
  }
  return -1;
}

fn find_impl_method_idx_by_lowered(sig: ImplSig, lowered_name: String) -> i32 {
  let mut i: i32 = 0;
  while i < sig.methods.len() {
    let m: ImplMethodSig = sig.methods.get(i);
    if m.lowered_name == lowered_name { return i; }
    i = i + 1;
  }
  return -1;
}

fn impl_methods_replace(sig0: ImplSig, idx: i32, ms: ImplMethodSig) -> ImplSig {
  let mut sig: ImplSig = sig0;
  if idx < 0 || idx >= sig.methods.len() { return sig; }
  let mut out: Vec[ImplMethodSig] = Vec();
  let mut i: i32 = 0;
  while i < sig.methods.len() {
    out.push(if i == idx { ms } else { sig.methods.get(i) });
    i = i + 1;
  }
  sig.methods = out;
  return sig;
}

fn impls_replace(ctx0: Ctx, idx: i32, is: ImplSig) -> Ctx {
  let mut ctx: Ctx = ctx0;
  if idx < 0 || idx >= ctx.impls.len() { return ctx; }
  let mut out: Vec[ImplSig] = Vec();
  let mut i: i32 = 0;
  while i < ctx.impls.len() {
    out.push(if i == idx { is } else { ctx.impls.get(i) });
    i = i + 1;
  }
  ctx.impls = out;
  return ctx;
}

struct CollectAsyncOneResult {
  ok: bool,
  err: TcError,
  ctx: Ctx,
  frame_name: String,
  frame_ty: i32,
  poll_lowered: String,
}

fn collect_async_one(ctx0: Ctx, w: World, mod_path: String, prog_imports: Vec[ast.ImportDecl], exprs_mod: ast.ExprPool, fd: ast.FuncDecl, lowered: String) -> CollectAsyncOneResult {
  let mut c: Ctx = ctx0;

  let fidx: i32 = find_func_sym_idx(c, mod_path, lowered);
  if fidx == -1 {
    return CollectAsyncOneResult { ok: false, err: type_error_at(fd.sp, "missing fn sig"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" };
  }
  let fsym0: FuncSym = c.funcs.get(fidx);
  let output_ty: i32 = fsym0.sig.ret;
  if fsym0.sig.type_params.len() != 0 || fsym0.sig.const_params.len() != 0 {
    return CollectAsyncOneResult { ok: false, err: type_error_at(fd.sp, "async fn with generics is not supported yet"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" };
  }

  let ir0: ImportsResult = build_imports(w, mod_path, prog_imports, fd.file);
  if !ir0.ok { return CollectAsyncOneResult { ok: false, err: ir0.err, ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" }; }
  let base_imps: Imports = ir0.imps;
  let async_alias: String = fresh_internal_async_alias(base_imps);
  let imps2: Imports = imps_add_alias(base_imps, async_alias, "std/async");

  let nr: an.NormalizeResult = an.normalize_async_block(exprs_mod, fd.body);
  if !nr.ok { return CollectAsyncOneResult { ok: false, err: type_error_at(fd.sp, nr.err), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" }; }
  let exprs: ast.ExprPool = nr.exprs;
  let body: ast.Block = nr.body;
  let aps: Vec[an.AwaitPoint] = an.find_await_points(exprs, body.stmts);

  // Typecheck in order: let bindings and await operands.
  let mut locals: Vec[AsyncLocalDecl] = Vec();
  let mut await_operand_tys: Vec[i32] = Vec();
  let mut l_cur: Locals = locals_new();
  l_cur.fn_is_async = true;

  let mut pi0: i32 = 0;
  while pi0 < fd.params.len() {
    let pty0: i32 = strip_range_only(c, fsym0.sig.params.get(pi0));
    let p: ast.Param = fd.params.get(pi0);
    l_cur = locals_decl(l_cur, p.name, pty0, false);
    pi0 = pi0 + 1;
  }

  let mut ap_i: i32 = 0;
  let mut si0: i32 = 0;
  while si0 < body.stmts.len() {
    let st0: ast.Stmt = body.stmts.get(si0);
    if match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, _e) => true, _ => false } {
      let sp0: ast.Span = stmt_span(st0);
      let is_mut: bool = match st0 { ast.Stmt.Let(_sp, m0, _n, _ha, _ann, _e) => m0, _ => false };
      let name0: String = match st0 { ast.Stmt.Let(_sp, _m, n0, _ha, _ann, _e) => n0, _ => "" };
      let has_ann: bool = match st0 { ast.Stmt.Let(_sp, _m, _n, ha0, _ann, _e) => ha0, _ => false };
      let ann0: ast.TypeName = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, an0, _e) => an0, _ => ast.TypeName { parts: Vec(), args: Vec() } };
      let init0: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, e0) => e0, _ => -1 };
      let mut vty: i32 = -1;
      if has_ann {
        let tr0: ResolveTyResult = resolve_type(c, w, mod_path, base_imps, l_cur.type_params, ann0);
        c = tr0.ctx;
        if !tr0.ok { return CollectAsyncOneResult { ok: false, err: type_error_at(sp0, "let annotation type resolve failed"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" }; }
        vty = strip_range_only(c, tr0.idx);
      } else {
        let er0: ExprTyResult = tc_expr(c, w, mod_path, base_imps, exprs, l_cur, init0, -1);
        if !er0.ok {
          let msg: String = "failed to typecheck let init in async fn: ".concat(tc_error_to_string(er0.err));
          return CollectAsyncOneResult { ok: false, err: type_error_at(sp0, msg), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" };
        }
        vty = strip_range_only(c, er0.ty);
      }
      l_cur = locals_decl(l_cur, name0, vty, is_mut);
      locals.push(AsyncLocalDecl { name: name0, ty: vty, mutable: is_mut, stmt_idx: si0 });
    }

    if ap_i < aps.len() && aps.get(ap_i).stmt_idx == si0 {
      let op: i32 = aps.get(ap_i).operand;
      let er_op: ExprTyResult = tc_expr(c, w, mod_path, base_imps, exprs, l_cur, op, -1);
      if !er_op.ok {
        let msg: String = "failed to typecheck await operand: ".concat(tc_error_to_string(er_op.err));
        return CollectAsyncOneResult { ok: false, err: type_error_at(stmt_span(st0), msg), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" };
      }
      let op_ty: i32 = strip_range_only(c, er_op.ty);
      if ty_has_forbidden_borrow(c, op_ty) {
        return CollectAsyncOneResult { ok: false, err: type_error_at(stmt_span(st0), "await operand cannot contain non-static borrow"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" };
      }
      await_operand_tys.push(op_ty);
      ap_i = ap_i + 1;
    }

    si0 = si0 + 1;
  }

  // Determine captures: locals used after any await statement.
  let mut await_stmt_idxs: Vec[i32] = Vec();
  ap_i = 0;
  while ap_i < aps.len() { await_stmt_idxs.push(aps.get(ap_i).stmt_idx); ap_i = ap_i + 1; }
  let mut captures: Vec[String] = Vec();
  let mut li0: i32 = 0;
  while li0 < locals.len() {
    let ld: AsyncLocalDecl = locals.get(li0);
    let mut ai1: i32 = 0;
    while ai1 < await_stmt_idxs.len() {
      let aidx: i32 = await_stmt_idxs.get(ai1);
      if ld.stmt_idx < aidx {
        let mut sj: i32 = aidx + 1;
        while sj < body.stmts.len() {
          let stj: ast.Stmt = body.stmts.get(sj);
          if stmt_uses_name(exprs, stj, ld.name) {
            if !string_vec_contains(captures, ld.name) { captures.push(ld.name); }
            sj = body.stmts.len();
            ai1 = await_stmt_idxs.len();
          }
          sj = sj + 1;
        }
      }
      ai1 = ai1 + 1;
    }
    li0 = li0 + 1;
  }

  // Synthesize frame struct.
  let frame_name: String = async_frame_fresh_name(c, mod_path, lowered);
  let irs: ResolveTyResult = nominal_intern_struct(c, mod_path, frame_name);
  c = irs.ctx;
  if !irs.ok {
    return CollectAsyncOneResult { ok: false, err: type_error_at(fd.sp, "failed to intern async frame type"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" };
  }
  let frame_ty: i32 = irs.idx;

  let mut fs: Vec[StructFieldSig] = async_frame_fields(c, fd, fsym0.sig);
  let mut ak: i32 = 0;
  while ak < await_operand_tys.len() {
    fs.push(StructFieldSig { name: "a".concat(ak.to_string()), ty: await_operand_tys.get(ak), vis: ast.vis_private(), is_pub: false });
    ak = ak + 1;
  }
  let mut ci0: i32 = 0;
  while ci0 < captures.len() {
    let nm: String = captures.get(ci0);
    let ld: AsyncLocalDecl = local_decl_find(locals, nm);
    if ld.name == "" { return CollectAsyncOneResult { ok: false, err: type_error_at(fd.sp, "internal: missing capture local decl"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" }; }
    if ty_has_forbidden_borrow(c, ld.ty) {
      return CollectAsyncOneResult { ok: false, err: type_error_at(fd.sp, "borrowed local cannot live across await: ".concat(nm)), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" };
    }
    fs.push(StructFieldSig { name: "l_".concat(nm), ty: ld.ty, vis: ast.vis_private(), is_pub: false });
    ci0 = ci0 + 1;
  }
  c = ctx_add_struct_sig(c, StructSig { mod_path: mod_path, name: frame_name, base_name: frame_name, vis: ast.vis_private(), is_pub: false, fields: fs });

  // Future impl lowered poll name and signature.
  let poll_lowered: String = async_poll_fresh_lowered(c, mod_path, lowered);
  let mut poll_parts: Vec[String] = Vec();
  poll_parts.push(async_alias);
  poll_parts.push("Poll");
  let mut poll_args: Vec[ast.TypeName] = Vec();
  poll_args.push(fd.ret);
  let poll_tn: ast.TypeName = ast.TypeName { parts: poll_parts, args: poll_args };
  let pr: ResolveTyResult = resolve_type(c, w, mod_path, imps2, Vec(), poll_tn);
  c = pr.ctx;
  if !pr.ok { return CollectAsyncOneResult { ok: false, err: type_error_at(fd.sp, "failed to resolve std/async::Poll for async lowering"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" }; }

  let mut ctx_parts: Vec[String] = Vec();
  ctx_parts.push(async_alias);
  ctx_parts.push("Context");
  let ctx_tn: ast.TypeName = ast.TypeName { parts: ctx_parts, args: Vec() };
  let cr: ResolveTyResult = resolve_type(c, w, mod_path, imps2, Vec(), ctx_tn);
  c = cr.ctx;
  if !cr.ok { return CollectAsyncOneResult { ok: false, err: type_error_at(fd.sp, "failed to resolve std/async::Context for async lowering"), ctx: c, frame_name: "", frame_ty: c.ty_bad, poll_lowered: "" }; }
  let ctx_ty: i32 = cr.idx;

  let poll_sig: FuncSig = FuncSig {
    params: vec2(frame_ty, ctx_ty),
    param_borrow_kinds: vec2(param_borrow_ref_mut(), param_borrow_ref()),
    ret: pr.idx,
    has_variadic: false,
    variadic_elem: -1,
    vis: ast.vis_private(),
    is_pub: false,
    type_params: Vec(),
    type_param_packs: Vec(),
    const_params: Vec(),
    type_param_bounds: Vec(),
    const_where_bounds: Vec(),
  };
  c = ctx_add_func_sym(c, FuncSym { mod_path: mod_path, name: poll_lowered, sig: poll_sig });

  // Future impl signature for the frame type.
  let mut assoc: Vec[ImplAssocTypeSig] = Vec();
  assoc.push(ImplAssocTypeSig { name: "Output", ty: output_ty });
  let mut ms: Vec[ImplMethodSig] = Vec();
  ms.push(ImplMethodSig {
    name: "poll",
    lowered_name: poll_lowered,
    sig: poll_sig,
    from_default: false,
    default_mod_path: "",
    default_file: "",
    default_params: Vec(),
    default_body: ast.Block { stmts: Vec() },
  });
  c = ctx_add_impl_sig(c, ImplSig {
    mod_path: mod_path,
    decl_idx: -1,
    is_inherent: false,
    trait_mod_path: "std/async",
    trait_name: "Future",
    for_ty: frame_ty,
    head_type_params: Vec(),
    head_type_param_bounds: Vec(),
    assoc_types: assoc,
    methods: ms,
  });

  // Rewrite async function signature to return the frame type.
  let mut sig2: FuncSig = fsym0.sig;
  sig2.ret = frame_ty;
  c = funcs_replace(c, fidx, FuncSym { mod_path: fsym0.mod_path, name: fsym0.name, sig: sig2 });

  // Record metadata for typechecking async bodies and for IRGen lowering.
  c = ctx_add_async_fn_sig(c, AsyncFnSig { mod_path: mod_path, name: lowered, output_ty: output_ty, frame_name: frame_name, frame_ty: frame_ty, poll_lowered: poll_lowered });

  return CollectAsyncOneResult { ok: true, err: TcError.None, ctx: c, frame_name: frame_name, frame_ty: frame_ty, poll_lowered: poll_lowered };
}

// Collect and synthesize async fn lowering metadata:
// - a per-fn frame struct type
// - a Future impl signature for that frame type (poll + Output)
// - rewrite the async function's signature return type to the frame type
fn collect_async_fns(ctx0: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx0;

  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let exprs_mod: ast.ExprPool = m.prog.exprs;

    // Module-level functions.
    let mut fi: i32 = 0;
    while fi < m.prog.funcs.len() {
      let fd: ast.FuncDecl = m.prog.funcs.get(fi);
      if fd.is_async {
        let r: CollectAsyncOneResult = collect_async_one(c, w, m.path, m.prog.imports, exprs_mod, fd, fd.name);
        if !r.ok { return TcCtxResult { ok: false, err: r.err, ctx: r.ctx }; }
        c = r.ctx;
      }
      fi = fi + 1;
    }

    // Impl methods.
    let mut ii: i32 = 0;
    while ii < m.prog.impls.len() {
      let id: ast.ImplDecl = m.prog.impls.get(ii);
      let impl_sig_idx: i32 = find_impl_sig_idx_collect_async(c, m.path, ii);
      if impl_sig_idx == -1 { return TcCtxResult { ok: false, err: type_error_at(id.sp, "missing impl sig"), ctx: c }; }

      let mut mdi: i32 = 0;
      while mdi < id.methods.len() {
        let md: ast.FuncDecl = id.methods.get(mdi);
        if md.is_async {
          let isig0: ImplSig = c.impls.get(impl_sig_idx);
          let mf: FindImplMethodResult = find_impl_method(isig0, md.name);
          if !mf.found { return TcCtxResult { ok: false, err: type_error_at(md.sp, "missing impl method sig"), ctx: c }; }
          let lowered: String = mf.m.lowered_name;

          let r: CollectAsyncOneResult = collect_async_one(c, w, m.path, m.prog.imports, exprs_mod, md, lowered);
          if !r.ok { return TcCtxResult { ok: false, err: r.err, ctx: r.ctx }; }
          c = r.ctx;

          // Update impl method signature to return the frame type.
          let isig1: ImplSig = c.impls.get(impl_sig_idx);
          let meth_idx: i32 = find_impl_method_idx_by_lowered(isig1, lowered);
          if meth_idx == -1 { return TcCtxResult { ok: false, err: type_error_at(md.sp, "internal: missing lowered impl method entry"), ctx: c }; }
          let mut ms0: ImplMethodSig = isig1.methods.get(meth_idx);
          let mut ms_sig: FuncSig = ms0.sig;
          ms_sig.ret = r.frame_ty;
          ms0.sig = ms_sig;
          let mut isig2: ImplSig = impl_methods_replace(isig1, meth_idx, ms0);
          if !id.is_inherent {
            let tf: FindTraitResult = find_trait(c, isig2.trait_mod_path, isig2.trait_name);
            if tf.found {
              let tmf: FindTraitMethodResult = find_trait_method(tf.sig, md.name);
              if tmf.found && tmf.m.is_async {
                let assoc_name: String = "__async$".concat(md.name);
                let mut found0: bool = false;
                let mut ai0: i32 = 0;
                while ai0 < isig2.assoc_types.len() {
                  let a0: ImplAssocTypeSig = isig2.assoc_types.get(ai0);
                  if a0.name == assoc_name {
                    found0 = true;
                    if a0.ty != r.frame_ty {
                      return TcCtxResult { ok: false, err: type_error_at(md.sp, "async trait assoc type binding mismatch"), ctx: c };
                    }
                  }
                  ai0 = ai0 + 1;
                }
                if !found0 {
                  isig2.assoc_types.push(ImplAssocTypeSig { name: assoc_name, ty: r.frame_ty });
                }
              }
            }
          }
          c = impls_replace(c, impl_sig_idx, isig2);
        }
        mdi = mdi + 1;
      }

      ii = ii + 1;
    }

    mi = mi + 1;
  }

  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}
