struct ConstEqResult { ok: bool, err: String, eq: bool }

fn const_eq_ok(v: bool) -> ConstEqResult {
  return ConstEqResult { ok: true, err: "", eq: v };
}

fn const_eq_err(msg: String) -> ConstEqResult {
  return ConstEqResult { ok: false, err: msg, eq: false };
}

fn const_value_eq_parts(
  ctx: Ctx,
  ka: i32, ta: i32, ia: i64, ba: bool, sa: String,
  kb: i32, tb: i32, ib: i64, bb: bool, sb: String,
) -> ConstEqResult {
  let abase: i32 = strip_range(ctx, ta);
  let bbase: i32 = strip_range(ctx, tb);
  if abase != bbase { return const_eq_err("const ==/!= type mismatch"); }

  if is_int_like_ty(ctx, abase) {
    if ka != const_kind_int() || kb != const_kind_int() {
      return const_eq_err("const ==/!= expects int");
    }
    return const_eq_ok(ia == ib);
  }

  if is_float_scalar_ty(ctx, abase) {
    if ka != const_kind_float() || kb != const_kind_float() {
      return const_eq_err("const ==/!= expects float");
    }
    return const_eq_ok(float_norm_text(sa) == float_norm_text(sb));
  }

  if abase == ctx.ty_bool {
    if ka != const_kind_bool() || kb != const_kind_bool() {
      return const_eq_err("const ==/!= expects bool");
    }
    return const_eq_ok(ba == bb);
  }

  if abase == ctx.ty_string {
    if ka != const_kind_str() || kb != const_kind_str() {
      return const_eq_err("const ==/!= expects string");
    }
    return const_eq_ok(sa == sb);
  }

  if is_enum_ty(ctx, abase) {
    if ka != const_kind_enum() || kb != const_kind_enum() {
      return const_eq_err("const ==/!= expects enum");
    }
    if ia != ib { return const_eq_ok(false); }

    let da: ConstEnumPayloadDecode = const_enum_unpack(sa);
    if !da.ok { return const_eq_err("bad const enum payload encoding"); }
    let db: ConstEnumPayloadDecode = const_enum_unpack(sb);
    if !db.ok { return const_eq_err("bad const enum payload encoding"); }

    if da.variant != db.variant { return const_eq_ok(false); }
    if da.fields.len() != db.fields.len() { return const_eq_ok(false); }

    let mut i: i32 = 0;
    while i < da.fields.len() {
      let fa: ConstEnumPayloadField = da.fields.get(i);
      let fb: ConstEnumPayloadField = db.fields.get(i);
      let er: ConstEqResult = const_value_eq_parts(
        ctx,
        fa.kind, fa.ty, fa.iv, fa.bv, fa.sv,
        fb.kind, fb.ty, fb.iv, fb.bv, fb.sv,
      );
      if !er.ok { return er; }
      if !er.eq { return const_eq_ok(false); }
      i = i + 1;
    }
    return const_eq_ok(true);
  }

  if is_struct_ty(ctx, abase) {
    if ka != const_kind_struct() || kb != const_kind_struct() {
      return const_eq_err("const ==/!= expects struct");
    }

    let da: ConstStructDecode = const_struct_unpack(sa);
    if !da.ok { return const_eq_err("bad const struct encoding"); }
    let db: ConstStructDecode = const_struct_unpack(sb);
    if !db.ok { return const_eq_err("bad const struct encoding"); }

    if da.fields.len() != db.fields.len() { return const_eq_ok(false); }

    let mut i2: i32 = 0;
    while i2 < da.fields.len() {
      let fa2: ConstEnumPayloadField = da.fields.get(i2);
      let fb2: ConstEnumPayloadField = db.fields.get(i2);
      let er2: ConstEqResult = const_value_eq_parts(
        ctx,
        fa2.kind, fa2.ty, fa2.iv, fa2.bv, fa2.sv,
        fb2.kind, fb2.ty, fb2.iv, fb2.bv, fb2.sv,
      );
      if !er2.ok { return er2; }
      if !er2.eq { return const_eq_ok(false); }
      i2 = i2 + 1;
    }
    return const_eq_ok(true);
  }

  return const_eq_err("const ==/!= expects primitive or enum/struct");
}

fn const_value_eq(ctx: Ctx, a: EvalConstExprResult, b: EvalConstExprResult) -> ConstEqResult {
  return const_value_eq_parts(
    ctx,
    a.kind, a.ty, a.iv, a.bv, a.sv,
    b.kind, b.ty, b.iv, b.bv, b.sv,
  );
}
