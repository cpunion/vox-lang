import "vox/ast" as ast
import "vox/ir" as ir

struct ResolveTraitRefResult { ok: bool, mod_path: String, name: String }

fn vec_self() -> Vec[String] {
  let mut v: Vec[String] = Vec();
  v.push("Self");
  return v;
}

fn vec_self_tps(tps: Vec[String]) -> Vec[String] {
  let mut v: Vec[String] = vec_self();
  let mut i: i32 = 0;
  while i < tps.len() {
    v.push(tps.get(i));
    i = i + 1;
  }
  return v;
}

fn str_starts_with(s: String, prefix: String) -> bool {
  if s.len() < prefix.len() { return false; }
  let mut i: i32 = 0;
  while i < prefix.len() {
    if s.byte_at(i) != prefix.byte_at(i) { return false; }
    i = i + 1;
  }
  return true;
}

fn type_name1(s: String) -> ast.TypeName {
  let mut ps: Vec[String] = Vec();
  ps.push(s);
  return ast.TypeName { parts: ps, args: Vec() };
}

fn type_param_pos(tps: Vec[String], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < tps.len() {
    if tps.get(i) == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn resolve_trait_ref(ctx: Ctx, _w: World, cur_mod: String, imps: Imports, tn: ast.TypeName) -> ResolveTraitRefResult {
  if tn.args.len() != 0 { return ResolveTraitRefResult { ok: false, mod_path: "", name: "" }; }
  if tn.parts.len() == 1 {
    let name0: String = tn.parts.get(0);
    let ni: NamedTypeImport = find_named_type(imps.named_types, name0);
    if ni.local != "" {
      if ni.kind != named_type_kind_trait() { return ResolveTraitRefResult { ok: false, mod_path: "", name: "" }; }
      return ResolveTraitRefResult { ok: true, mod_path: ni.mod_path, name: ni.name };
    }
    let fl: FindTraitResult = find_trait(ctx, cur_mod, name0);
    if fl.found { return ResolveTraitRefResult { ok: true, mod_path: cur_mod, name: name0 }; }
    let prelude: String = "std/prelude";
    let fp: FindTraitResult = find_trait(ctx, prelude, name0);
    if fp.found && vis_allows(fp.sig.vis, prelude, cur_mod) {
      return ResolveTraitRefResult { ok: true, mod_path: prelude, name: name0 };
    }
    return ResolveTraitRefResult { ok: true, mod_path: cur_mod, name: name0 };
  }
  if tn.parts.len() == 2 {
    let mp: String = find_alias(imps.aliases, tn.parts.get(0));
    if mp == "" { return ResolveTraitRefResult { ok: false, mod_path: "", name: "" }; }
    return ResolveTraitRefResult { ok: true, mod_path: mp, name: tn.parts.get(1) };
  }
  return ResolveTraitRefResult { ok: false, mod_path: "", name: "" };
}

fn has_trait_name(ctx: Ctx, mod_path: String, name: String) -> bool {
  let mut i: i32 = 0;
  while i < ctx.traits.len() {
    let t: TraitSig = ctx.traits.get(i);
    if t.mod_path == mod_path && t.name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn has_super_sig(ss: Vec[TraitSuperSig], mod_path: String, name: String) -> bool {
  let mut i: i32 = 0;
  while i < ss.len() {
    let s: TraitSuperSig = ss.get(i);
    if s.mod_path == mod_path && s.name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn trait_method_exists(ms: Vec[TraitMethodSig], name: String) -> bool {
  let mut i: i32 = 0;
  while i < ms.len() {
    if ms.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn trait_assoc_type_exists(as0: Vec[TraitAssocTypeSig], name: String) -> bool {
  let mut i: i32 = 0;
  while i < as0.len() {
    if as0.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn impl_assoc_type_exists(as0: Vec[ImplAssocTypeSig], name: String) -> bool {
  let mut i: i32 = 0;
  while i < as0.len() {
    if as0.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn cti_has_type_param_pack_decl(tp_packs: Vec[String]) -> bool {
  return tp_packs.len() != 0;
}

fn cti_is_pack_type_name(tn: ast.TypeName) -> bool {
  return tn.parts.len() == 1 && tn.parts.get(0) == "@pack" && tn.args.len() == 1;
}

fn cti_has_variadic_param_decl(ps: Vec[ast.Param]) -> bool {
  let mut i: i32 = 0;
  while i < ps.len() {
    if cti_is_pack_type_name(ps.get(i).ty) { return true; }
    i = i + 1;
  }
  return false;
}

struct CtiValidateTypeParamPacksResult {
  ok: bool,
  err: TcError,
}

fn cti_type_param_pos(tps: Vec[String], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < tps.len() {
    if tps.get(i) == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn cti_validate_type_param_packs(sp: ast.Span, tps: Vec[String], tp_packs: Vec[String]) -> CtiValidateTypeParamPacksResult {
  if tp_packs.len() == 0 { return CtiValidateTypeParamPacksResult { ok: true, err: TcError.None }; }
  if tp_packs.len() > 1 {
    return CtiValidateTypeParamPacksResult { ok: false, err: type_error_at(sp, "only one type parameter pack is currently supported") };
  }
  let p: String = tp_packs.get(0);
  if cti_type_param_pos(tps, p) == -1 {
    return CtiValidateTypeParamPacksResult { ok: false, err: type_error_at(sp, "unknown type parameter pack: ".concat(p)) };
  }
  if cti_type_param_pos(tps, p) != tps.len() - 1 {
    return CtiValidateTypeParamPacksResult { ok: false, err: type_error_at(sp, "type parameter pack must be the last type parameter") };
  }
  return CtiValidateTypeParamPacksResult { ok: true, err: TcError.None };
}

struct CtiNormalizeParamTypeResult {
  ok: bool,
  err: TcError,
  ty: ast.TypeName,
}

fn cti_vec_type_name(elem: ast.TypeName) -> ast.TypeName {
  let mut parts: Vec[String] = Vec();
  parts.push("Vec");
  let mut args: Vec[ast.TypeName] = Vec();
  args.push(elem);
  return ast.TypeName { parts: parts, args: args };
}

fn cti_normalize_param_type(sp: ast.Span, ps: Vec[ast.Param], idx: i32, ty: ast.TypeName) -> CtiNormalizeParamTypeResult {
  if !cti_is_pack_type_name(ty) {
    return CtiNormalizeParamTypeResult { ok: true, err: TcError.None, ty: ty };
  }
  if idx != ps.len() - 1 {
    return CtiNormalizeParamTypeResult { ok: false, err: type_error_at(sp, "variadic parameter must be the last parameter"), ty: ty };
  }
  let elem: ast.TypeName = ty.args.get(0);
  if cti_is_pack_type_name(elem) {
    return CtiNormalizeParamTypeResult { ok: false, err: type_error_at(sp, "nested variadic parameter is not allowed"), ty: ty };
  }
  return CtiNormalizeParamTypeResult { ok: true, err: TcError.None, ty: cti_vec_type_name(elem) };
}

fn type_unknown_self_assoc(tn: ast.TypeName, assocs: Vec[TraitAssocTypeSig]) -> String {
  if tn.args.len() == 0 && tn.parts.len() == 2 && tn.parts.get(0) == "Self" {
    let a: String = tn.parts.get(1);
    if !trait_assoc_type_exists(assocs, a) { return a; }
  }
  let mut i: i32 = 0;
  while i < tn.args.len() {
    let r: String = type_unknown_self_assoc(tn.args.get(i), assocs);
    if r != "" { return r; }
    i = i + 1;
  }
  return "";
}

fn impl_self_assoc_binds(for_ty: i32, assocs: Vec[ImplAssocTypeSig]) -> Vec[TypeBind] {
  let mut out: Vec[TypeBind] = Vec();
  out.push(TypeBind { name: "Self", ty: for_ty });
  let mut i: i32 = 0;
  while i < assocs.len() {
    let a: ImplAssocTypeSig = assocs.get(i);
    out.push(TypeBind { name: "Self.".concat(a.name), ty: a.ty });
    i = i + 1;
  }
  return out;
}

fn trait_method_param_names(ps: Vec[ast.Param]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < ps.len() {
    out.push(ps.get(i).name);
    i = i + 1;
  }
  return out;
}

fn cti_const_where_op_text(op: ast.BinaryOp) -> String {
  if match op { ast.BinaryOp.Eq => true, _ => false } { return "=="; }
  if match op { ast.BinaryOp.Ne => true, _ => false } { return "!="; }
  if match op { ast.BinaryOp.Lt => true, _ => false } { return "<"; }
  if match op { ast.BinaryOp.Le => true, _ => false } { return "<="; }
  if match op { ast.BinaryOp.Gt => true, _ => false } { return ">"; }
  if match op { ast.BinaryOp.Ge => true, _ => false } { return ">="; }
  return "?";
}

fn cti_const_where_lhs_text(kind: i32, name: String) -> String {
  if kind == ast.comptime_where_lhs_const_param() { return name; }
  if kind == ast.comptime_where_lhs_size_of() { return "@size_of(".concat(name).concat(")"); }
  if kind == ast.comptime_where_lhs_align_of() { return "@align_of(".concat(name).concat(")"); }
  if kind == ast.comptime_where_lhs_field_count() { return "@field_count(".concat(name).concat(")"); }
  if kind == ast.comptime_where_lhs_type() { return "@type(".concat(name).concat(")"); }
  return name;
}

fn cti_const_where_bound_text(b: ConstWhereBoundSig) -> String {
  let lhs: String = cti_const_where_lhs_text(b.lhs_kind, b.name);
  let rhs: String =
    if b.rhs_is_param {
      if b.rhs_text != "" { b.rhs_text } else { b.rhs_param }
    } else {
      b.rhs_text
    };
  return lhs.concat(" ").concat(cti_const_where_op_text(b.op)).concat(" ").concat(rhs);
}

fn impl_method_decl_idx(ds: Vec[ast.FuncDecl], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < ds.len() {
    if ds.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn fresh_impl_lowered_name(c: Ctx, mod_path: String, ts: TraitSig, method: String, seed: i32) -> String {
  let mut n: i32 = seed;
  while true {
    let lowered: String = impl_lowered_name(ts, method, n);
    let ex: FindFuncResult = find_func(c, mod_path, lowered);
    if !ex.found { return lowered; }
    n = n + 1;
  }
  return impl_lowered_name(ts, method, seed);
}

fn inherent_lowered_name(method: String, nth: i32) -> String {
  return "impl$inherent$".concat(method).concat("$").concat(nth.to_string());
}

fn fresh_inherent_lowered_name(c: Ctx, mod_path: String, method: String, seed: i32) -> String {
  let mut n: i32 = seed;
  while true {
    let lowered: String = inherent_lowered_name(method, n);
    let ex: FindFuncResult = find_func(c, mod_path, lowered);
    if !ex.found { return lowered; }
    n = n + 1;
  }
  return inherent_lowered_name(method, seed);
}

fn impl_method_sig_exists(ms: Vec[ImplMethodSig], name: String) -> bool {
  let mut i: i32 = 0;
  while i < ms.len() {
    if ms.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn impl_method_decl_name_unique(ds: Vec[ast.FuncDecl], name: String, idx: i32) -> bool {
  let mut i: i32 = 0;
  while i < ds.len() {
    if i != idx && ds.get(i).name == name { return false; }
    i = i + 1;
  }
  return true;
}

fn cti_ty_compat(ctx: Ctx, want: i32, got: i32) -> bool {
  if want == got { return true; }
  let ur: UnifyResult = unify_ty(ctx, want, got, Vec());
  return ur.ok;
}

fn impl_lowered_name(ts: TraitSig, method: String, nth: i32) -> String {
  let mut m: String = ts.mod_path;
  let mut i: i32 = 0;
  while i < m.len() {
    if m.byte_at(i) == 47 { m = m.slice(0, i).concat(".").concat(m.slice(i + 1, m.len())); }
    i = i + 1;
  }
  return "impl$".concat(m).concat("$").concat(ts.name).concat("$").concat(method).concat("$").concat(nth.to_string());
}

struct CtiSubstTyResult { ok: bool, ctx: Ctx, ty: i32 }
struct TraitMethodSigForResult { ok: bool, ctx: Ctx, sig: FuncSig, async_output_ty: i32 }

fn cti_fresh_subst_nominal_name(ctx: Ctx, mod_path: String, base_name: String, tag: String) -> String {
  let mut n: i32 = 0;
  while true {
    let cand: String = base_name.concat("$").concat(tag).concat("$").concat(n.to_string());
    let fs: FindStructResult = find_struct(ctx, mod_path, cand);
    let fe: FindEnumResult = find_enum(ctx, mod_path, cand);
    if !fs.found && !fe.found { return cand; }
    n = n + 1;
  }
  return base_name.concat("$").concat(tag).concat("$0");
}

fn cti_find_struct_by_layout(ctx: Ctx, sig: StructSig, tys: Vec[i32]) -> String {
  let mut si: i32 = 0;
  while si < ctx.structs.len() {
    let s: StructSig = ctx.structs.get(si);
    if s.mod_path == sig.mod_path && s.base_name == sig.base_name && s.fields.len() == sig.fields.len() {
      let mut ok: bool = true;
      let mut fi: i32 = 0;
      while fi < s.fields.len() {
        let sf: StructFieldSig = s.fields.get(fi);
        let pf: StructFieldSig = sig.fields.get(fi);
        if sf.name != pf.name || sf.ty != tys.get(fi) {
          ok = false;
          fi = s.fields.len();
        } else {
          fi = fi + 1;
        }
      }
      if ok { return s.name; }
    }
    si = si + 1;
  }
  return "";
}

fn cti_find_enum_by_layout(ctx: Ctx, sig: EnumSig, vars: Vec[EnumVariantSig]) -> String {
  let mut ei: i32 = 0;
  while ei < ctx.enums.len() {
    let e: EnumSig = ctx.enums.get(ei);
    if e.mod_path == sig.mod_path && e.base_name == sig.base_name && e.vars.len() == vars.len() {
      let mut ok: bool = true;
      let mut vi: i32 = 0;
      while vi < e.vars.len() {
        let ev: EnumVariantSig = e.vars.get(vi);
        let wv: EnumVariantSig = vars.get(vi);
        if ev.name != wv.name || ev.fields.len() != wv.fields.len() {
          ok = false;
          vi = e.vars.len();
        } else {
          let mut fi: i32 = 0;
          while fi < ev.fields.len() {
            if ev.fields.get(fi) != wv.fields.get(fi) {
              ok = false;
              fi = ev.fields.len();
            } else {
              fi = fi + 1;
            }
          }
          vi = vi + 1;
        }
      }
      if ok { return e.name; }
    }
    ei = ei + 1;
  }
  return "";
}

fn cti_subst_struct_nominal_intern(ctx0: Ctx, ty_idx: i32, subs: Vec[TySub]) -> CtiSubstTyResult {
  let mut c: Ctx = ctx0;
  let t: ir.Ty = ir.ty_pool_get(c.pool, ty_idx);
  let fs: FindStructResult = find_struct(c, t.mod_path, t.name);
  if !fs.found { return CtiSubstTyResult { ok: true, ctx: c, ty: ty_idx }; }

  let mut changed: bool = false;
  let mut tys: Vec[i32] = Vec();
  let mut fi: i32 = 0;
  while fi < fs.sig.fields.len() {
    let f: StructFieldSig = fs.sig.fields.get(fi);
    // Keep recursive nominals deferred; full recursive substitution is handled
    // by resolve_type placeholder construction.
    if f.ty == ty_idx { return CtiSubstTyResult { ok: true, ctx: c, ty: ty_idx }; }
    let sr: CtiSubstTyResult = cti_subst_ty_intern(c, f.ty, subs);
    c = sr.ctx;
    if !sr.ok { return CtiSubstTyResult { ok: false, ctx: c, ty: c.ty_bad }; }
    if sr.ty != f.ty { changed = true; }
    tys.push(sr.ty);
    fi = fi + 1;
  }
  if !changed { return CtiSubstTyResult { ok: true, ctx: c, ty: ty_idx }; }

  let ex: String = cti_find_struct_by_layout(c, fs.sig, tys);
  if ex != "" {
    let irs: ResolveTyResult = nominal_intern_struct(c, fs.sig.mod_path, ex);
    return CtiSubstTyResult { ok: true, ctx: irs.ctx, ty: irs.idx };
  }

  let mut wi: i32 = 0;
  while wi < tys.len() {
    if ty_has_param(c, tys.get(wi)) { return CtiSubstTyResult { ok: true, ctx: c, ty: ty_idx }; }
    wi = wi + 1;
  }

  let inst: String = cti_fresh_subst_nominal_name(c, fs.sig.mod_path, fs.sig.base_name, "subst_s");
  let mut fields: Vec[StructFieldSig] = Vec();
  fi = 0;
  while fi < fs.sig.fields.len() {
    let pf: StructFieldSig = fs.sig.fields.get(fi);
    fields.push(StructFieldSig { name: pf.name, ty: tys.get(fi), vis: pf.vis, is_pub: pf.is_pub });
    fi = fi + 1;
  }
  c.structs.push(StructSig {
    mod_path: fs.sig.mod_path,
    name: inst,
    base_name: fs.sig.base_name,
    vis: fs.sig.vis,
    is_pub: fs.sig.is_pub,
    fields: fields,
  });
  let ir_new: ResolveTyResult = nominal_intern_struct(c, fs.sig.mod_path, inst);
  return CtiSubstTyResult { ok: true, ctx: ir_new.ctx, ty: ir_new.idx };
}

fn cti_subst_enum_nominal_intern(ctx0: Ctx, ty_idx: i32, subs: Vec[TySub]) -> CtiSubstTyResult {
  let mut c: Ctx = ctx0;
  let t: ir.Ty = ir.ty_pool_get(c.pool, ty_idx);
  let fe: FindEnumResult = find_enum(c, t.mod_path, t.name);
  if !fe.found { return CtiSubstTyResult { ok: true, ctx: c, ty: ty_idx }; }

  let mut changed: bool = false;
  let mut vars: Vec[EnumVariantSig] = Vec();
  let mut vi: i32 = 0;
  while vi < fe.sig.vars.len() {
    let v: EnumVariantSig = fe.sig.vars.get(vi);
    let mut ftys: Vec[i32] = Vec();
    let mut fi: i32 = 0;
    while fi < v.fields.len() {
      let fty: i32 = v.fields.get(fi);
      if fty == ty_idx { return CtiSubstTyResult { ok: true, ctx: c, ty: ty_idx }; }
      let sr: CtiSubstTyResult = cti_subst_ty_intern(c, fty, subs);
      c = sr.ctx;
      if !sr.ok { return CtiSubstTyResult { ok: false, ctx: c, ty: c.ty_bad }; }
      if sr.ty != fty { changed = true; }
      ftys.push(sr.ty);
      fi = fi + 1;
    }
    vars.push(EnumVariantSig { name: v.name, fields: ftys });
    vi = vi + 1;
  }
  if !changed { return CtiSubstTyResult { ok: true, ctx: c, ty: ty_idx }; }

  let ex: String = cti_find_enum_by_layout(c, fe.sig, vars);
  if ex != "" {
    let ire: ResolveTyResult = nominal_intern_enum(c, fe.sig.mod_path, ex);
    return CtiSubstTyResult { ok: true, ctx: ire.ctx, ty: ire.idx };
  }

  vi = 0;
  while vi < vars.len() {
    let vv: EnumVariantSig = vars.get(vi);
    let mut fi2: i32 = 0;
    while fi2 < vv.fields.len() {
      if ty_has_param(c, vv.fields.get(fi2)) {
        return CtiSubstTyResult { ok: true, ctx: c, ty: ty_idx };
      }
      fi2 = fi2 + 1;
    }
    vi = vi + 1;
  }

  let inst: String = cti_fresh_subst_nominal_name(c, fe.sig.mod_path, fe.sig.base_name, "subst_e");
  c.enums.push(EnumSig {
    mod_path: fe.sig.mod_path,
    name: inst,
    base_name: fe.sig.base_name,
    vis: fe.sig.vis,
    is_pub: fe.sig.is_pub,
    vars: vars,
  });
  let ir_new: ResolveTyResult = nominal_intern_enum(c, fe.sig.mod_path, inst);
  return CtiSubstTyResult { ok: true, ctx: ir_new.ctx, ty: ir_new.idx };
}

fn cti_subst_ty_intern(ctx0: Ctx, ty_idx: i32, subs: Vec[TySub]) -> CtiSubstTyResult {
  let mut c: Ctx = ctx0;
  let t: ir.Ty = ir.ty_pool_get(c.pool, ty_idx);
  if t.kind == ir.TyKind.Param {
    let r: i32 = subs_lookup(subs, t.name);
    if r != -1 { return CtiSubstTyResult { ok: true, ctx: c, ty: r }; }
    let rp: i32 = subst_proj_param(c, t.name, subs);
    if rp != -1 { return CtiSubstTyResult { ok: true, ctx: c, ty: rp }; }
    return CtiSubstTyResult { ok: true, ctx: c, ty: ty_idx };
  }
  if t.kind == ir.TyKind.Ref {
    let er: CtiSubstTyResult = cti_subst_ty_intern(c, t.elem, subs);
    c = er.ctx;
    if !er.ok { return CtiSubstTyResult { ok: false, ctx: c, ty: c.ty_bad }; }
    if er.ty == t.elem { return CtiSubstTyResult { ok: true, ctx: c, ty: ty_idx }; }
    let mut ridx: i32 = find_ref_ty_idx(c, er.ty, ir.ty_ref_is_mut(t), ir.ty_ref_is_static(t));
    if ridx == -1 {
      let ir0: InternResult = intern_ty(c, ir.ty_ref(er.ty, ir.ty_ref_is_mut(t), ir.ty_ref_is_static(t)));
      c = ir0.ctx;
      ridx = ir0.idx;
    }
    return CtiSubstTyResult { ok: true, ctx: c, ty: ridx };
  }
  if t.kind == ir.TyKind.Vec {
    let er: CtiSubstTyResult = cti_subst_ty_intern(c, t.elem, subs);
    c = er.ctx;
    if !er.ok { return CtiSubstTyResult { ok: false, ctx: c, ty: c.ty_bad }; }
    if er.ty == t.elem { return CtiSubstTyResult { ok: true, ctx: c, ty: ty_idx }; }
    let mut vidx: i32 = find_vec_ty_idx(c, er.ty);
    if vidx == -1 {
      let ir0: InternResult = intern_ty(c, ir.ty_vec(er.ty));
      c = ir0.ctx;
      vidx = ir0.idx;
    }
    return CtiSubstTyResult { ok: true, ctx: c, ty: vidx };
  }
  if t.kind == ir.TyKind.Range {
    let er: CtiSubstTyResult = cti_subst_ty_intern(c, t.elem, subs);
    c = er.ctx;
    if !er.ok { return CtiSubstTyResult { ok: false, ctx: c, ty: c.ty_bad }; }
    if er.ty == t.elem { return CtiSubstTyResult { ok: true, ctx: c, ty: ty_idx }; }
    let mut ridx: i32 = find_range_ty_idx_subst(c, er.ty, t.lo, t.hi);
    if ridx == -1 {
      let ir0: InternResult = intern_ty(c, ir.ty_range(er.ty, t.lo, t.hi));
      c = ir0.ctx;
      ridx = ir0.idx;
    }
    return CtiSubstTyResult { ok: true, ctx: c, ty: ridx };
  }
  if t.kind == ir.TyKind.Struct {
    return cti_subst_struct_nominal_intern(c, ty_idx, subs);
  }
  if t.kind == ir.TyKind.Enum {
    return cti_subst_enum_nominal_intern(c, ty_idx, subs);
  }

  let s: i32 = subst_ty(c, ty_idx, subs);
  if s == c.ty_bad {
    return CtiSubstTyResult { ok: false, ctx: c, ty: c.ty_bad };
  }
  return CtiSubstTyResult { ok: true, ctx: c, ty: s };
}

fn trait_method_sig_for(ctx0: Ctx, ms: TraitMethodSig, for_ty: i32, assocs: Vec[ImplAssocTypeSig]) -> TraitMethodSigForResult {
  let mut c: Ctx = ctx0;
  let mut subs: Vec[TySub] = Vec();
  subs.push(TySub { name: "Self", ty: for_ty });
  let mut ai: i32 = 0;
  while ai < assocs.len() {
    let a: ImplAssocTypeSig = assocs.get(ai);
    subs.push(TySub { name: "Self.".concat(a.name), ty: a.ty });
    ai = ai + 1;
  }

  let mut ps: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < ms.sig.params.len() {
    let pr: CtiSubstTyResult = cti_subst_ty_intern(c, ms.sig.params.get(i), subs);
    c = pr.ctx;
    if !pr.ok {
      return TraitMethodSigForResult {
        ok: false,
        ctx: c,
        sig: FuncSig {
          params: Vec(), param_borrow_kinds: Vec(), ret: c.ty_bad,
          has_variadic: false, variadic_elem: -1,
          vis: ast.vis_private(), is_pub: false,
          type_params: Vec(), type_param_packs: Vec(), const_params: Vec(),
          type_param_bounds: Vec(), effects: Vec(), const_where_bounds: Vec(),
        },
        async_output_ty: -1,
      };
    }
    ps.push(pr.ty);
    i = i + 1;
  }

  let rr: CtiSubstTyResult = cti_subst_ty_intern(c, ms.sig.ret, subs);
  c = rr.ctx;
  if !rr.ok {
    return TraitMethodSigForResult {
      ok: false,
      ctx: c,
      sig: FuncSig {
        params: Vec(), param_borrow_kinds: Vec(), ret: c.ty_bad,
        has_variadic: false, variadic_elem: -1,
        vis: ast.vis_private(), is_pub: false,
        type_params: Vec(), type_param_packs: Vec(), const_params: Vec(),
        type_param_bounds: Vec(), effects: Vec(), const_where_bounds: Vec(),
      },
      async_output_ty: -1,
    };
  }

  let mut var_ty: i32 = ms.sig.variadic_elem;
  if ms.sig.has_variadic {
    let vr: CtiSubstTyResult = cti_subst_ty_intern(c, ms.sig.variadic_elem, subs);
    c = vr.ctx;
    if !vr.ok {
      return TraitMethodSigForResult {
        ok: false,
        ctx: c,
        sig: FuncSig {
          params: Vec(), param_borrow_kinds: Vec(), ret: c.ty_bad,
          has_variadic: false, variadic_elem: -1,
          vis: ast.vis_private(), is_pub: false,
          type_params: Vec(), type_param_packs: Vec(), const_params: Vec(),
          type_param_bounds: Vec(), effects: Vec(), const_where_bounds: Vec(),
        },
        async_output_ty: -1,
      };
    }
    var_ty = vr.ty;
  }

  let mut aout: i32 = -1;
  if ms.is_async && ms.async_output_ty != -1 {
    let ar0: CtiSubstTyResult = cti_subst_ty_intern(c, ms.async_output_ty, subs);
    c = ar0.ctx;
    if !ar0.ok {
      return TraitMethodSigForResult {
        ok: false,
        ctx: c,
        sig: FuncSig {
          params: Vec(), param_borrow_kinds: Vec(), ret: c.ty_bad,
          has_variadic: false, variadic_elem: -1,
          vis: ast.vis_private(), is_pub: false,
          type_params: Vec(), type_param_packs: Vec(), const_params: Vec(),
          type_param_bounds: Vec(), effects: Vec(), const_where_bounds: Vec(),
        },
        async_output_ty: -1,
      };
    }
    aout = ar0.ty;
  }

  return TraitMethodSigForResult {
    ok: true,
    ctx: c,
    sig: FuncSig {
      params: ps,
      param_borrow_kinds: ms.sig.param_borrow_kinds,
      ret: rr.ty,
      has_variadic: ms.sig.has_variadic,
      variadic_elem: var_ty,
      vis: ast.vis_private(),
      is_pub: false,
      type_params: ms.sig.type_params,
      type_param_packs: ms.sig.type_param_packs,
      const_params: ms.sig.const_params,
      type_param_bounds: ms.sig.type_param_bounds,
      effects: ms.sig.effects,
      const_where_bounds: ms.sig.const_where_bounds,
    },
    async_output_ty: aout,
  };
}

fn concat_strs(a: Vec[String], b: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < a.len() { out.push(a.get(i)); i = i + 1; }
  let mut j: i32 = 0;
  while j < b.len() { out.push(b.get(j)); j = j + 1; }
  return out;
}

fn concat_bounds(a: Vec[TypeParamBoundSig], b: Vec[TypeParamBoundSig]) -> Vec[TypeParamBoundSig] {
  let mut out: Vec[TypeParamBoundSig] = Vec();
  let mut i: i32 = 0;
  while i < a.len() { out.push(a.get(i)); i = i + 1; }
  let mut j: i32 = 0;
  while j < b.len() {
    let bj: TypeParamBoundSig = b.get(j);
    if !has_bound_sig(out, bj.type_param, bj.trait_mod_path, bj.trait_name) {
      out.push(bj);
    }
    j = j + 1;
  }
  return out;
}

fn impl_method_emit_sig(head_tps: Vec[String], head_tpbs: Vec[TypeParamBoundSig], want: FuncSig) -> FuncSig {
  return FuncSig {
    params: want.params,
    param_borrow_kinds: want.param_borrow_kinds,
    ret: want.ret,
    has_variadic: want.has_variadic,
    variadic_elem: want.variadic_elem,
    vis: ast.vis_private(),
    is_pub: false,
    type_params: concat_strs(head_tps, want.type_params),
    type_param_packs: want.type_param_packs,
    const_params: want.const_params,
    type_param_bounds: concat_bounds(head_tpbs, want.type_param_bounds),
    effects: want.effects,
    const_where_bounds: want.const_where_bounds,
  };
}

fn impl_for_ty_overlap(ctx: Ctx, a: i32, b: i32) -> bool {
  let ur1: UnifyResult = unify_ty(ctx, a, b, Vec());
  if ur1.ok { return true; }
  let ur2: UnifyResult = unify_ty(ctx, b, a, Vec());
  return ur2.ok;
}

// `a` is strictly more specific than `b` when `b` can match `a` but `a` cannot
// match every `b` (min-specialization style partial order on impl heads).
fn impl_for_ty_more_specific(ctx: Ctx, a: i32, b: i32) -> bool {
  let b_to_a: UnifyResult = unify_ty(ctx, b, a, Vec());
  if !b_to_a.ok { return false; }
  let a_to_b: UnifyResult = unify_ty(ctx, a, b, Vec());
  return !a_to_b.ok;
}

fn trait_is_or_extends_impl(ctx: Ctx, mod_path: String, name: String, want_mod: String, want_name: String) -> bool {
  if mod_path == want_mod && name == want_name { return true; }
  let tf: FindTraitResult = find_trait(ctx, mod_path, name);
  if !tf.found { return false; }
  let mut i: i32 = 0;
  while i < tf.sig.supers.len() {
    let s: TraitSuperSig = tf.sig.supers.get(i);
    if trait_is_or_extends_impl(ctx, s.mod_path, s.name, want_mod, want_name) { return true; }
    i = i + 1;
  }
  return false;
}

fn impl_bound_on_pos_covers(
  ctx: Ctx,
  a_tps: Vec[String],
  a_bounds: Vec[TypeParamBoundSig],
  b_pos: i32,
  b_trait_mod: String,
  b_trait_name: String
) -> bool {
  let mut i: i32 = 0;
  while i < a_bounds.len() {
    let ab: TypeParamBoundSig = a_bounds.get(i);
    let ap: i32 = type_param_pos(a_tps, ab.type_param);
    if ap == b_pos {
      if trait_is_or_extends_impl(ctx, ab.trait_mod_path, ab.trait_name, b_trait_mod, b_trait_name) {
        return true;
      }
    }
    i = i + 1;
  }
  return false;
}

fn impl_bounds_cover(
  ctx: Ctx,
  a_tps: Vec[String],
  a_bounds: Vec[TypeParamBoundSig],
  b_tps: Vec[String],
  b_bounds: Vec[TypeParamBoundSig]
) -> bool {
  let mut i: i32 = 0;
  while i < b_bounds.len() {
    let bb: TypeParamBoundSig = b_bounds.get(i);
    let bp: i32 = type_param_pos(b_tps, bb.type_param);
    if bp < 0 { return false; }
    if !impl_bound_on_pos_covers(ctx, a_tps, a_bounds, bp, bb.trait_mod_path, bb.trait_name) {
      return false;
    }
    i = i + 1;
  }
  return true;
}

fn impl_bounds_more_specific(
  ctx: Ctx,
  a_tps: Vec[String],
  a_bounds: Vec[TypeParamBoundSig],
  b_tps: Vec[String],
  b_bounds: Vec[TypeParamBoundSig]
) -> bool {
  if !impl_bounds_cover(ctx, a_tps, a_bounds, b_tps, b_bounds) { return false; }
  return !impl_bounds_cover(ctx, b_tps, b_bounds, a_tps, a_bounds);
}

fn impl_sig_more_specific_parts(
  ctx: Ctx,
  a_for_ty: i32,
  a_tps: Vec[String],
  a_bounds: Vec[TypeParamBoundSig],
  b_for_ty: i32,
  b_tps: Vec[String],
  b_bounds: Vec[TypeParamBoundSig]
) -> bool {
  let a_head_more: bool = impl_for_ty_more_specific(ctx, a_for_ty, b_for_ty);
  let b_head_more: bool = impl_for_ty_more_specific(ctx, b_for_ty, a_for_ty);
  if a_head_more && !b_head_more { return true; }
  if b_head_more && !a_head_more { return false; }
  return impl_bounds_more_specific(ctx, a_tps, a_bounds, b_tps, b_bounds);
}

pub fn impl_sig_more_specific(ctx: Ctx, a: ImplSig, b: ImplSig) -> bool {
  return impl_sig_more_specific_parts(
    ctx,
    a.for_ty, a.head_type_params, a.head_type_param_bounds,
    b.for_ty, b.head_type_params, b.head_type_param_bounds
  );
}


fn type_param_name_or_projection(name: String, tp: String) -> bool {
  if name == tp { return true; }
  let pfx: String = tp.concat(".");
  if name.len() <= pfx.len() { return false; }
  return name.slice(0, pfx.len()) == pfx;
}

fn ty_uses_impl_type_param(ctx: Ctx, ty: i32, tp: String) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty);
  if t.kind == ir.TyKind.Param { return type_param_name_or_projection(t.name, tp); }
  if t.kind == ir.TyKind.Vec || t.kind == ir.TyKind.Range { return ty_uses_impl_type_param(ctx, t.elem, tp); }
  if t.kind == ir.TyKind.Struct {
    let fs: FindStructResult = find_struct(ctx, t.mod_path, t.name);
    if !fs.found { return false; }
    let mut i: i32 = 0;
    while i < fs.sig.fields.len() {
      if ty_uses_impl_type_param(ctx, fs.sig.fields.get(i).ty, tp) { return true; }
      i = i + 1;
    }
    return false;
  }
  if t.kind == ir.TyKind.Enum {
    let fe: FindEnumResult = find_enum(ctx, t.mod_path, t.name);
    if !fe.found { return false; }
    let mut vi: i32 = 0;
    while vi < fe.sig.vars.len() {
      let ev: EnumVariantSig = fe.sig.vars.get(vi);
      let mut fi: i32 = 0;
      while fi < ev.fields.len() {
        if ty_uses_impl_type_param(ctx, ev.fields.get(fi), tp) { return true; }
        fi = fi + 1;
      }
      vi = vi + 1;
    }
    return false;
  }
  return false;
}

fn first_unconstrained_impl_type_param(ctx: Ctx, for_ty: i32, tps: Vec[String]) -> String {
  let mut i: i32 = 0;
  while i < tps.len() {
    let tp: String = tps.get(i);
    if !ty_uses_impl_type_param(ctx, for_ty, tp) { return tp; }
    i = i + 1;
  }
  return "";
}
fn impl_decl_span(w: World, mod_path: String, decl_idx: i32) -> ast.Span {
  let fm: FindModResult = find_mod(w, mod_path);
  if !fm.found { return ast.span0(); }
  let m: WorldModule = w.mods.get(fm.idx);
  if decl_idx < 0 || decl_idx >= m.prog.impls.len() { return ast.span0(); }
  return m.prog.impls.get(decl_idx).sp;
}

struct FindWorldTraitDeclResult { found: bool, vis: i32, is_pub: bool, file: String, sp: ast.Span }

fn find_world_trait_decl(w: World, mod_path: String, name: String) -> FindWorldTraitDeclResult {
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    if m.path == mod_path {
      let mut ti: i32 = 0;
      while ti < m.prog.traits.len() {
        let td: ast.TraitDecl = m.prog.traits.get(ti);
        if td.name == name { return FindWorldTraitDeclResult { found: true, vis: td.vis, is_pub: td.is_pub, file: td.file, sp: td.sp }; }
        ti = ti + 1;
      }
    }
    mi = mi + 1;
  }
  return FindWorldTraitDeclResult { found: false, vis: ast.vis_private(), is_pub: false, file: "", sp: ast.span0() };
}

fn find_trait_idx(ts: Vec[TraitSig], mod_path: String, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < ts.len() {
    let t: TraitSig = ts.get(i);
    if t.mod_path == mod_path && t.name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn set_trait_sig(ctx: Ctx, idx: i32, sig: TraitSig) -> Ctx {
  let mut c: Ctx = ctx;
  let mut out: Vec[TraitSig] = Vec();
  let mut i: i32 = 0;
  while i < c.traits.len() {
    if i == idx {
      out.push(sig);
    } else {
      out.push(c.traits.get(i));
    }
    i = i + 1;
  }
  c.traits = out;
  return c;
}

fn contains_i32_local(xs: Vec[i32], x: i32) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == x { return true; }
    i = i + 1;
  }
  return false;
}

fn trait_has_super_cycle(ctx: Ctx, start_idx: i32) -> bool {
  let mut seen: Vec[i32] = Vec();
  let mut work: Vec[i32] = Vec();
  work.push(start_idx);
  let mut wi: i32 = 0;
  while wi < work.len() {
    let cur: i32 = work.get(wi);
    wi = wi + 1;
    let ts: TraitSig = ctx.traits.get(cur);
    let mut si: i32 = 0;
    while si < ts.supers.len() {
      let sup: TraitSuperSig = ts.supers.get(si);
      let next: i32 = find_trait_idx(ctx.traits, sup.mod_path, sup.name);
      if next == start_idx { return true; }
      if next >= 0 && !contains_i32_local(seen, next) {
        seen.push(next);
        work.push(next);
      }
      si = si + 1;
    }
  }
  return false;
}

fn collect_traits(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;

  // Pass 1: register trait names/visibility so supertraits can forward-reference.
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ti: i32 = 0;
    while ti < m.prog.traits.len() {
      let td: ast.TraitDecl = m.prog.traits.get(ti);
      if is_reserved_intrinsic_name(td.name) {
        return TcCtxResult { ok: false, err: type_error_at(td.sp, "reserved name: ".concat(td.name)), ctx: c };
      }
      if has_trait_name(c, m.path, td.name) {
        return TcCtxResult { ok: false, err: type_error_at(td.sp, "duplicate trait: ".concat(td.name)), ctx: c };
      }
      c.traits.push(TraitSig { mod_path: m.path, name: td.name, vis: td.vis, is_pub: td.is_pub, supers: Vec(), assoc_types: Vec(), methods: Vec() });
      ti = ti + 1;
    }
    mi = mi + 1;
  }

  // Pass 2: resolve supertraits and method signatures.
  mi = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ti: i32 = 0;
    while ti < m.prog.traits.len() {
      let td: ast.TraitDecl = m.prog.traits.get(ti);
      let idx: i32 = find_trait_idx(c.traits, m.path, td.name);
      if idx < 0 { return TcCtxResult { ok: false, err: type_error_at(td.sp, "internal: trait placeholder missing"), ctx: c }; }

      let ir: ImportsResult = build_imports(w, m.path, m.prog.imports, td.file);
      if !ir.ok { return TcCtxResult { ok: false, err: ir.err, ctx: c }; }
      let imps: Imports = ir.imps;

      let mut supers: Vec[TraitSuperSig] = Vec();
      let mut si: i32 = 0;
      while si < td.supers.len() {
        let sr: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, td.supers.get(si));
        if !sr.ok { return TcCtxResult { ok: false, err: type_error_at(td.sp, "bad supertrait path"), ctx: c }; }
        let sfw: FindWorldTraitDeclResult = find_world_trait_decl(w, sr.mod_path, sr.name);
        if !sfw.found { return TcCtxResult { ok: false, err: type_error_at(td.sp, "unknown supertrait"), ctx: c }; }
        if !vis_allows(sfw.vis, sr.mod_path, m.path) {
          return TcCtxResult { ok: false, err: type_error_at(td.sp, "supertrait is private"), ctx: c };
        }
        if sr.mod_path == m.path && sr.name == td.name {
          return TcCtxResult { ok: false, err: type_error_at(td.sp, "trait cannot inherit from itself"), ctx: c };
        }
        if !has_super_sig(supers, sr.mod_path, sr.name) {
          supers.push(TraitSuperSig { mod_path: sr.mod_path, name: sr.name });
        }
        si = si + 1;
      }

      let mut assocs: Vec[TraitAssocTypeSig] = Vec();
      let mut ai: i32 = 0;
      while ai < td.assoc_types.len() {
        let ad: ast.TraitAssocTypeDecl = td.assoc_types.get(ai);
        if trait_assoc_type_exists(assocs, ad.name) {
          return TcCtxResult { ok: false, err: type_error_at(ad.sp, "duplicate trait associated type: ".concat(ad.name)), ctx: c };
        }
        assocs.push(TraitAssocTypeSig { name: ad.name });
        ai = ai + 1;
      }

      // Make current trait associated types visible while checking its methods.
      // This allows bounds like `T: ThisTrait` to resolve `T.Assoc` correctly.
      c = set_trait_sig(c, idx, TraitSig {
        mod_path: m.path,
        name: td.name,
        vis: td.vis,
        is_pub: td.is_pub,
        supers: supers,
        assoc_types: assocs,
        methods: Vec(),
      });

      let mut ms: Vec[TraitMethodSig] = Vec();
      let mut fi: i32 = 0;
      while fi < td.methods.len() {
        let md: ast.TraitMethodDecl = td.methods.get(fi);
        let pv: CtiValidateTypeParamPacksResult = cti_validate_type_param_packs(md.sp, md.type_params, md.type_param_packs);
        if !pv.ok { return TcCtxResult { ok: false, err: pv.err, ctx: c }; }
        if trait_method_exists(ms, md.name) {
          return TcCtxResult { ok: false, err: type_error_at(md.sp, "duplicate trait method: ".concat(md.name)), ctx: c };
        }
        if trait_assoc_type_exists(assocs, md.name) {
          return TcCtxResult { ok: false, err: type_error_at(md.sp, "trait method conflicts with associated type: ".concat(md.name)), ctx: c };
        }

        let tps_self: Vec[String] = vec_self_tps(md.type_params);
        let mut cps: Vec[ConstParamSig] = Vec();
        let mut cpi: i32 = 0;
        while cpi < md.const_params.len() {
          let cp: ast.ConstParamDecl = md.const_params.get(cpi);
          if contains_str_local(md.type_params, cp.name) {
            return TcCtxResult { ok: false, err: type_error_at(td.sp, "const param duplicates type param: ".concat(cp.name)), ctx: c };
          }
          let mut dup: bool = false;
          let mut cj: i32 = 0;
          while cj < cps.len() {
            if cps.get(cj).name == cp.name { dup = true; }
            cj = cj + 1;
          }
          if dup {
            return TcCtxResult { ok: false, err: type_error_at(td.sp, "duplicate const param: ".concat(cp.name)), ctx: c };
          }
          let cpr: ResolveTyResult = resolve_type(c, w, m.path, imps, tps_self, cp.ty);
          c = cpr.ctx;
          if !cpr.ok {
            return TcCtxResult { ok: false, err: type_error_at(td.sp, resolve_fail_msg(cp.ty, "type resolve failed in trait method const param")), ctx: c };
          }
          if !is_int_like_ty(c, cpr.idx) {
            return TcCtxResult { ok: false, err: type_error_at(td.sp, "trait method const param type must be integer"), ctx: c };
          }
          let mut has_default: bool = false;
          let mut default_iv: i64 = 0;
          let mut default_text: String = "";
          if cp.has_default {
            let mut dparts: Vec[String] = Vec();
            dparts.push("@const");
            dparts.push(cp.default_text);
            let dpr: ParseConstGenericArgResult = parse_const_generic_arg(c, ast.TypeName { parts: dparts, args: Vec() }, cpr.idx);
            if !dpr.ok {
              return TcCtxResult { ok: false, err: type_error_at(td.sp, "trait method const param default out of range"), ctx: c };
            }
            has_default = true;
            default_iv = dpr.iv;
            default_text = dpr.text;
          }
          cps.push(ConstParamSig { name: cp.name, ty: cpr.idx, has_default: has_default, default_iv: default_iv, default_text: default_text });
          cpi = cpi + 1;
        }
        let mut ps: Vec[i32] = Vec();
        let mut pbks: Vec[i32] = Vec();
        let mut pi: i32 = 0;
        while pi < md.params.len() {
          let pr: ast.Param = md.params.get(pi);
          let nr: CtiNormalizeParamTypeResult = cti_normalize_param_type(md.sp, md.params, pi, pr.ty);
          if !nr.ok { return TcCtxResult { ok: false, err: nr.err, ctx: c }; }
          if !tn_nonstatic_borrow_allowed_param_type(nr.ty) {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, "non-static borrowed type in parameter must be top-level &T or &mut T"), ctx: c };
          }
          let bad_assoc0: String = type_unknown_self_assoc(nr.ty, assocs);
          if bad_assoc0 != "" {
            return TcCtxResult { ok: false, err: type_error_at(td.sp, "unknown associated type in trait method: ".concat(bad_assoc0)), ctx: c };
          }
          let tr: ResolveTyResult = resolve_type(c, w, m.path, imps, tps_self, nr.ty);
          c = tr.ctx;
          if !tr.ok {
            return TcCtxResult { ok: false, err: type_error_at(td.sp, resolve_fail_msg(nr.ty, "type resolve failed in trait method param")), ctx: c };
          }
          ps.push(tr.idx);
          pbks.push(tn_param_borrow_kind(nr.ty));
          pi = pi + 1;
        }
        if tn_has_nonstatic_borrow(md.ret) {
          return TcCtxResult { ok: false, err: type_error_at(md.sp, "non-static borrowed type is not allowed in return type"), ctx: c };
        }
        let bad_assoc1: String = type_unknown_self_assoc(md.ret, assocs);
        if bad_assoc1 != "" {
          return TcCtxResult { ok: false, err: type_error_at(td.sp, "unknown associated type in trait method: ".concat(bad_assoc1)), ctx: c };
        }
        let rr: ResolveTyResult = resolve_type(c, w, m.path, imps, tps_self, md.ret);
        c = rr.ctx;
        if !rr.ok {
          return TcCtxResult { ok: false, err: type_error_at(td.sp, resolve_fail_msg(md.ret, "type resolve failed in trait method ret")), ctx: c };
        }
        let mut ret_sig_ty: i32 = rr.idx;
        let mut async_output_ty: i32 = -1;
        if md.is_async {
          // Desugar `async fn m(..) -> T` in trait into:
          // - add assoc type `__async$m`
          // - rewrite return type to `Self.__async$m`
          let assoc_name: String = "__async$".concat(md.name);
          if trait_assoc_type_exists(assocs, assoc_name) {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, "async trait method conflicts with existing associated type: ".concat(assoc_name)), ctx: c };
          }
          assocs.push(TraitAssocTypeSig { name: assoc_name });
          async_output_ty = rr.idx;
          let mut parts: Vec[String] = Vec();
          parts.push("Self");
          parts.push(assoc_name);
          let proj_tn: ast.TypeName = ast.TypeName { parts: parts, args: Vec() };
          let prj: ResolveTyResult = resolve_type(c, w, m.path, imps, tps_self, proj_tn);
          c = prj.ctx;
          if !prj.ok {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, "failed to resolve async trait method return projection type"), ctx: c };
          }
          ret_sig_ty = prj.idx;
        }

        let mut tbs: Vec[TypeParamBoundSig] = Vec();
        let mut bi: i32 = 0;
        while bi < md.type_param_bounds.len() {
          let bdecl: ast.TypeParamBoundsDecl = md.type_param_bounds.get(bi);
          if !type_param_ref_exists(md.type_params, bdecl.name) {
            return TcCtxResult { ok: false, err: type_error_at(td.sp, "unknown type param in trait method bound: ".concat(bdecl.name)), ctx: c };
          }
          let mut bj: i32 = 0;
          while bj < bdecl.bounds.len() {
            let rtr: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, bdecl.bounds.get(bj));
            if !rtr.ok {
              return TcCtxResult { ok: false, err: type_error_at(td.sp, "bad trait method bound"), ctx: c };
            }
            let tf2: FindTraitResult = find_trait(c, rtr.mod_path, rtr.name);
            if !tf2.found {
              return TcCtxResult { ok: false, err: type_error_at(td.sp, "unknown trait in method bound"), ctx: c };
            }
            if !vis_allows(tf2.sig.vis, rtr.mod_path, m.path) {
              return TcCtxResult { ok: false, err: type_error_at(td.sp, "trait method bound refers to private trait"), ctx: c };
            }
            if !has_bound_sig(tbs, bdecl.name, rtr.mod_path, rtr.name) {
              tbs.push(TypeParamBoundSig { type_param: bdecl.name, trait_mod_path: rtr.mod_path, trait_name: rtr.name });
            }
            bj = bj + 1;
          }
          bi = bi + 1;
        }
        let mut pji: i32 = 0;
        while pji < md.params.len() {
          let prj: ast.Param = md.params.get(pji);
          let nrj: CtiNormalizeParamTypeResult = cti_normalize_param_type(md.sp, md.params, pji, prj.ty);
          if !nrj.ok { return TcCtxResult { ok: false, err: nrj.err, ctx: c }; }
          let perr0: String = projection_bound_issue(c, md.type_params, tbs, nrj.ty);
          if perr0 != "" {
            return TcCtxResult { ok: false, err: type_error_at(td.sp, perr0), ctx: c };
          }
          pji = pji + 1;
        }
        let perr1: String = projection_bound_issue(c, md.type_params, tbs, md.ret);
        if perr1 != "" {
          return TcCtxResult { ok: false, err: type_error_at(td.sp, perr1), ctx: c };
        }
        let cwr: CollectConstWhereResult = collect_const_where_bounds(md.sp, md.type_params, cps, md.const_where_bounds);
        if !cwr.ok {
          return TcCtxResult { ok: false, err: cwr.err, ctx: c };
        }
        let has_variadic_md: bool = cti_has_variadic_param_decl(md.params);
        let variadic_elem_md: i32 = if has_variadic_md { vec_elem(c, ps.get(ps.len() - 1)) } else { -1 };
        ms.push(TraitMethodSig {
          name: md.name,
          sig: FuncSig {
            params: ps,
            param_borrow_kinds: pbks,
            ret: ret_sig_ty,
            has_variadic: has_variadic_md,
            variadic_elem: variadic_elem_md,
            vis: ast.vis_pub(),
            is_pub: true,
            type_params: md.type_params,
            type_param_packs: md.type_param_packs,
            const_params: cps,
            type_param_bounds: tbs,
            effects: Vec(),
            const_where_bounds: cwr.bounds,
          },
          is_async: md.is_async,
          async_output_ty: async_output_ty,
          has_default: md.has_body,
          default_mod_path: m.path,
          default_file: td.file,
          default_params: trait_method_param_names(md.params),
          default_body: md.body,
        });
        fi = fi + 1;
      }

      c = set_trait_sig(c, idx, TraitSig { mod_path: m.path, name: td.name, vis: td.vis, is_pub: td.is_pub, supers: supers, assoc_types: assocs, methods: ms });
      ti = ti + 1;
    }
    mi = mi + 1;
  }

  // Reject supertrait cycles.
  let mut ci: i32 = 0;
  while ci < c.traits.len() {
    if trait_has_super_cycle(c, ci) {
      let ts: TraitSig = c.traits.get(ci);
      let tdecl: FindWorldTraitDeclResult = find_world_trait_decl(w, ts.mod_path, ts.name);
      let tsp: ast.Span = if tdecl.found { tdecl.sp } else { ast.span0() };
      return TcCtxResult { ok: false, err: type_error_at(tsp, "supertrait cycle detected: ".concat(ts.name)), ctx: c };
    }
    ci = ci + 1;
  }
  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}

fn collect_impls(ctx: Ctx, w: World) -> TcCtxResult {
  let mut c: Ctx = ctx;
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: WorldModule = w.mods.get(mi);
    let mut ii: i32 = 0;
    while ii < m.prog.impls.len() {
      let id: ast.ImplDecl = m.prog.impls.get(ii);
      let imr: ImportsResult = build_imports(w, m.path, m.prog.imports, id.file);
      if !imr.ok { return TcCtxResult { ok: false, err: imr.err, ctx: c }; }
      let imps: Imports = imr.imps;

      if id.is_inherent {
        let mut head_tpbs: Vec[TypeParamBoundSig] = Vec();
        let mut bi0_inh: i32 = 0;
        while bi0_inh < id.type_param_bounds.len() {
          let bdecl0_inh: ast.TypeParamBoundsDecl = id.type_param_bounds.get(bi0_inh);
          if !type_param_ref_exists(id.type_params, bdecl0_inh.name) {
            return TcCtxResult { ok: false, err: type_error_at(id.sp, "unknown type param in impl bound: ".concat(bdecl0_inh.name)), ctx: c };
          }
          let mut bj0_inh: i32 = 0;
          while bj0_inh < bdecl0_inh.bounds.len() {
            let rtr0_inh: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, bdecl0_inh.bounds.get(bj0_inh));
            if !rtr0_inh.ok { return TcCtxResult { ok: false, err: type_error_at(id.sp, "bad impl type bound"), ctx: c }; }
            let tf0_inh: FindTraitResult = find_trait(c, rtr0_inh.mod_path, rtr0_inh.name);
            if !tf0_inh.found { return TcCtxResult { ok: false, err: type_error_at(id.sp, "unknown trait in impl bound"), ctx: c }; }
            if !vis_allows(tf0_inh.sig.vis, rtr0_inh.mod_path, m.path) {
              return TcCtxResult { ok: false, err: type_error_at(id.sp, "impl bound refers to private trait"), ctx: c };
            }
            if !has_bound_sig(head_tpbs, bdecl0_inh.name, rtr0_inh.mod_path, rtr0_inh.name) {
              head_tpbs.push(TypeParamBoundSig { type_param: bdecl0_inh.name, trait_mod_path: rtr0_inh.mod_path, trait_name: rtr0_inh.name });
            }
            bj0_inh = bj0_inh + 1;
          }
          bi0_inh = bi0_inh + 1;
        }

        let fr_inh: ResolveTyResult = resolve_type(c, w, m.path, imps, id.type_params, id.for_ty);
        c = fr_inh.ctx;
        if !fr_inh.ok {
          return TcCtxResult { ok: false, err: type_error_at(id.sp, "bad impl target type"), ctx: c };
        }
        let for_ty_inh: i32 = strip_range(c, fr_inh.idx);
        let unconstrained_inh: String = first_unconstrained_impl_type_param(c, for_ty_inh, id.type_params);
        if unconstrained_inh != "" {
          let msg_u_inh: String = "impl type param is unconstrained by impl target type: ".concat(unconstrained_inh);
          return TcCtxResult { ok: false, err: type_error_at(id.sp, msg_u_inh), ctx: c };
        }

        if id.assoc_types.len() != 0 {
          return TcCtxResult { ok: false, err: type_error_at(id.sp, "inherent impl does not support associated types"), ctx: c };
        }

        let mut di_inh: i32 = 0;
        while di_inh < c.impls.len() {
          let ds_inh: ImplSig = c.impls.get(di_inh);
          if ds_inh.is_inherent && impl_for_ty_overlap(c, ds_inh.for_ty, for_ty_inh) {
            let mut mj_inh: i32 = 0;
            while mj_inh < id.methods.len() {
              let mn_inh: String = id.methods.get(mj_inh).name;
              if impl_method_sig_exists(ds_inh.methods, mn_inh) {
                let msg_inh: String = "overlapping inherent impl method: ".concat(mn_inh).concat(" for ").concat(ty_inst_str(c, for_ty_inh));
                return TcCtxResult { ok: false, err: type_error_at(id.sp, msg_inh), ctx: c };
              }
              mj_inh = mj_inh + 1;
            }
          }
          di_inh = di_inh + 1;
        }

        let mut ims_inh: Vec[ImplMethodSig] = Vec();
        let mut mdi_inh: i32 = 0;
        while mdi_inh < id.methods.len() {
          let md_inh: ast.FuncDecl = id.methods.get(mdi_inh);
          if !impl_method_decl_name_unique(id.methods, md_inh.name, mdi_inh) {
            return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "duplicate inherent impl method: ".concat(md_inh.name)), ctx: c };
          }
          let pv_inh: CtiValidateTypeParamPacksResult = cti_validate_type_param_packs(md_inh.sp, md_inh.type_params, md_inh.type_param_packs);
          if !pv_inh.ok { return TcCtxResult { ok: false, err: pv_inh.err, ctx: c }; }

          let mut hpi_inh: i32 = 0;
          while hpi_inh < id.type_params.len() {
            if contains_str_local(md_inh.type_params, id.type_params.get(hpi_inh)) {
              return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "inherent impl method type param duplicates impl type param"), ctx: c };
            }
            hpi_inh = hpi_inh + 1;
          }

          let mut cps_inh: Vec[ConstParamSig] = Vec();
          let mut cpi_inh: i32 = 0;
          while cpi_inh < md_inh.const_params.len() {
            let cp_inh: ast.ConstParamDecl = md_inh.const_params.get(cpi_inh);
            if contains_str_local(md_inh.type_params, cp_inh.name) {
              return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "inherent impl method const param duplicates type param"), ctx: c };
            }
            let mut hpi2_inh: i32 = 0;
            while hpi2_inh < id.type_params.len() {
              if id.type_params.get(hpi2_inh) == cp_inh.name {
                return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "inherent impl method const param duplicates impl type param"), ctx: c };
              }
              hpi2_inh = hpi2_inh + 1;
            }
            let cpr_inh: ResolveTyResult = resolve_type(c, w, m.path, imps, concat_strs(id.type_params, md_inh.type_params), cp_inh.ty);
            c = cpr_inh.ctx;
            if !cpr_inh.ok {
              return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, resolve_fail_msg(cp_inh.ty, "inherent impl method const param type resolve failed")), ctx: c };
            }
            let mut default_iv_inh: i64 = 0;
            if cp_inh.has_default {
              let mut dparts_inh: Vec[String] = Vec();
              dparts_inh.push("@const");
              dparts_inh.push(cp_inh.default_text);
              let dpr_inh: ParseConstGenericArgResult = parse_const_generic_arg(c, ast.TypeName { parts: dparts_inh, args: Vec() }, cpr_inh.idx);
              if !dpr_inh.ok {
                return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "inherent impl method const param default out of range"), ctx: c };
              }
              default_iv_inh = dpr_inh.iv;
            }
            cps_inh.push(ConstParamSig {
              name: cp_inh.name,
              ty: cpr_inh.idx,
              has_default: cp_inh.has_default,
              default_iv: default_iv_inh,
              default_text: cp_inh.default_text,
            });
            cpi_inh = cpi_inh + 1;
          }

          let mut got_tbs_inh: Vec[TypeParamBoundSig] = Vec();
          let mut bi_inh: i32 = 0;
          while bi_inh < md_inh.type_param_bounds.len() {
            let bdecl_inh: ast.TypeParamBoundsDecl = md_inh.type_param_bounds.get(bi_inh);
            if !type_param_ref_exists(md_inh.type_params, bdecl_inh.name) {
              return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "unknown type param in inherent impl method bound: ".concat(bdecl_inh.name)), ctx: c };
            }
            let mut bj_inh: i32 = 0;
            while bj_inh < bdecl_inh.bounds.len() {
              let rtr_inh: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, bdecl_inh.bounds.get(bj_inh));
              if !rtr_inh.ok { return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "bad inherent impl method bound"), ctx: c }; }
              let tf_inh: FindTraitResult = find_trait(c, rtr_inh.mod_path, rtr_inh.name);
              if !tf_inh.found { return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "unknown trait in inherent impl method bound"), ctx: c }; }
              if !vis_allows(tf_inh.sig.vis, rtr_inh.mod_path, m.path) {
                return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "inherent impl method bound refers to private trait"), ctx: c };
              }
              if !has_bound_sig(got_tbs_inh, bdecl_inh.name, rtr_inh.mod_path, rtr_inh.name) {
                got_tbs_inh.push(TypeParamBoundSig { type_param: bdecl_inh.name, trait_mod_path: rtr_inh.mod_path, trait_name: rtr_inh.name });
              }
              bj_inh = bj_inh + 1;
            }
            bi_inh = bi_inh + 1;
          }

          let mut ps_inh: Vec[i32] = Vec();
          let mut pbks_inh: Vec[i32] = Vec();
          let mut pi_inh: i32 = 0;
          while pi_inh < md_inh.params.len() {
            let pr_inh: ast.Param = md_inh.params.get(pi_inh);
            let nr_inh: CtiNormalizeParamTypeResult = cti_normalize_param_type(md_inh.sp, md_inh.params, pi_inh, pr_inh.ty);
            if !nr_inh.ok { return TcCtxResult { ok: false, err: nr_inh.err, ctx: c }; }
            if !tn_nonstatic_borrow_allowed_param_type(nr_inh.ty) {
              return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "non-static borrowed type in parameter must be top-level &T or &mut T"), ctx: c };
            }
            let rr_inh: ResolveTyResult = resolve_type_bound(c, w, m.path, imps, concat_strs(id.type_params, md_inh.type_params), impl_self_assoc_binds(for_ty_inh, Vec()), nr_inh.ty);
            c = rr_inh.ctx;
            if !rr_inh.ok {
              return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, resolve_fail_msg(nr_inh.ty, "inherent impl method param type resolve failed")), ctx: c };
            }
            ps_inh.push(rr_inh.idx);
            pbks_inh.push(tn_param_borrow_kind(nr_inh.ty));
            pi_inh = pi_inh + 1;
          }
          if ps_inh.len() == 0 {
            return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "inherent impl method requires receiver parameter"), ctx: c };
          }
          if strip_range(c, ps_inh.get(0)) != for_ty_inh {
            return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "inherent impl method receiver type mismatch"), ctx: c };
          }

          if tn_has_nonstatic_borrow(md_inh.ret) {
            return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, "non-static borrowed type is not allowed in return type"), ctx: c };
          }
          let ret_inh: ResolveTyResult = resolve_type_bound(c, w, m.path, imps, concat_strs(id.type_params, md_inh.type_params), impl_self_assoc_binds(for_ty_inh, Vec()), md_inh.ret);
          c = ret_inh.ctx;
          if !ret_inh.ok {
            return TcCtxResult { ok: false, err: type_error_at(md_inh.sp, resolve_fail_msg(md_inh.ret, "inherent impl method ret type resolve failed")), ctx: c };
          }

          let cwr_inh: CollectConstWhereResult = collect_const_where_bounds(md_inh.sp, concat_strs(id.type_params, md_inh.type_params), cps_inh, md_inh.const_where_bounds);
          if !cwr_inh.ok { return TcCtxResult { ok: false, err: cwr_inh.err, ctx: c }; }

          let has_variadic_inh: bool = cti_has_variadic_param_decl(md_inh.params);
          let variadic_elem_inh: i32 = if has_variadic_inh { vec_elem(c, ps_inh.get(ps_inh.len() - 1)) } else { -1 };

          let emit_inh: FuncSig = FuncSig {
            params: ps_inh,
            param_borrow_kinds: pbks_inh,
            ret: ret_inh.idx,
            has_variadic: has_variadic_inh,
            variadic_elem: variadic_elem_inh,
            vis: ast.vis_private(),
            is_pub: false,
            type_params: concat_strs(id.type_params, md_inh.type_params),
            type_param_packs: md_inh.type_param_packs,
            const_params: cps_inh,
            type_param_bounds: concat_bounds(head_tpbs, got_tbs_inh),
            effects: Vec(),
            const_where_bounds: cwr_inh.bounds,
          };
          let lowered_inh: String = fresh_inherent_lowered_name(c, m.path, md_inh.name, c.impls.len() * 1000 + mdi_inh);
          c.funcs.push(FuncSym { mod_path: m.path, name: lowered_inh, sig: emit_inh });
          ims_inh.push(ImplMethodSig {
            name: md_inh.name,
            lowered_name: lowered_inh,
            sig: emit_inh,
            from_default: false,
            default_mod_path: "",
            default_file: "",
            default_params: Vec(),
            default_body: ast.Block { stmts: Vec() },
          });
          mdi_inh = mdi_inh + 1;
        }

        c.impls.push(ImplSig {
          mod_path: m.path,
          decl_idx: ii,
          is_inherent: true,
          trait_mod_path: "",
          trait_name: "",
          for_ty: for_ty_inh,
          head_type_params: id.type_params,
          head_type_param_bounds: head_tpbs,
          assoc_types: Vec(),
          methods: ims_inh,
        });
        ii = ii + 1;
        continue;
      }

      let trr: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, id.trait_name);
      if !trr.ok {
        return TcCtxResult { ok: false, err: type_error_at(id.sp, "bad trait path in impl"), ctx: c };
      }
      let tf: FindTraitResult = find_trait(c, trr.mod_path, trr.name);
      if !tf.found {
        return TcCtxResult { ok: false, err: type_error_at(id.sp, "unknown trait in impl"), ctx: c };
      }
      if !vis_allows(tf.sig.vis, trr.mod_path, m.path) {
        return TcCtxResult { ok: false, err: type_error_at(id.sp, "trait is private"), ctx: c };
      }

      let mut head_tpbs: Vec[TypeParamBoundSig] = Vec();
      let mut bi0: i32 = 0;
      while bi0 < id.type_param_bounds.len() {
        let bdecl0: ast.TypeParamBoundsDecl = id.type_param_bounds.get(bi0);
        if !type_param_ref_exists(id.type_params, bdecl0.name) {
          return TcCtxResult { ok: false, err: type_error_at(id.sp, "unknown type param in impl bound: ".concat(bdecl0.name)), ctx: c };
        }
        let mut bj0: i32 = 0;
        while bj0 < bdecl0.bounds.len() {
          let rtr0: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, bdecl0.bounds.get(bj0));
          if !rtr0.ok { return TcCtxResult { ok: false, err: type_error_at(id.sp, "bad impl type bound"), ctx: c }; }
          let tf0: FindTraitResult = find_trait(c, rtr0.mod_path, rtr0.name);
          if !tf0.found { return TcCtxResult { ok: false, err: type_error_at(id.sp, "unknown trait in impl bound"), ctx: c }; }
          if !vis_allows(tf0.sig.vis, rtr0.mod_path, m.path) {
            return TcCtxResult { ok: false, err: type_error_at(id.sp, "impl bound refers to private trait"), ctx: c };
          }
          if !has_bound_sig(head_tpbs, bdecl0.name, rtr0.mod_path, rtr0.name) {
            head_tpbs.push(TypeParamBoundSig { type_param: bdecl0.name, trait_mod_path: rtr0.mod_path, trait_name: rtr0.name });
          }
          bj0 = bj0 + 1;
        }
        bi0 = bi0 + 1;
      }

      let fr: ResolveTyResult = resolve_type(c, w, m.path, imps, id.type_params, id.for_ty);
      c = fr.ctx;
      if !fr.ok {
        return TcCtxResult { ok: false, err: type_error_at(id.sp, "bad impl target type"), ctx: c };
      }
      let for_ty: i32 = strip_range(c, fr.idx);
      let unconstrained_tp: String = first_unconstrained_impl_type_param(c, for_ty, id.type_params);
      if unconstrained_tp != "" {
        let msg_u: String = "impl type param is unconstrained by impl target type: ".concat(unconstrained_tp);
        return TcCtxResult { ok: false, err: type_error_at(id.sp, msg_u), ctx: c };
      }
      let for_t: ir.Ty = ir.ty_pool_get(c.pool, for_ty);
      let trait_local: bool = trr.mod_path == m.path;
      let type_local: bool = ty_mod(for_t) == m.path;
      if !trait_local && !type_local {
        return TcCtxResult { ok: false, err: type_error_at(id.sp, "orphan impl is not allowed"), ctx: c };
      }

      let mut di: i32 = 0;
      while di < c.impls.len() {
        let ds: ImplSig = c.impls.get(di);
        if ds.trait_mod_path == trr.mod_path && ds.trait_name == trr.name {
          if impl_for_ty_overlap(c, ds.for_ty, for_ty) {
            let new_more: bool = impl_sig_more_specific_parts(c, for_ty, id.type_params, head_tpbs, ds.for_ty, ds.head_type_params, ds.head_type_param_bounds);
            let old_more: bool = impl_sig_more_specific_parts(c, ds.for_ty, ds.head_type_params, ds.head_type_param_bounds, for_ty, id.type_params, head_tpbs);
            if !new_more && !old_more {
              let msg_ov: String = "overlapping impl without strict specialization: ".concat(ty_inst_str(c, for_ty)).concat(" vs ").concat(ty_inst_str(c, ds.for_ty));
              return TcCtxResult { ok: false, err: type_error_at(id.sp, msg_ov), ctx: c };
            }
          }
        }
        di = di + 1;
      }

      let mut impl_assocs: Vec[ImplAssocTypeSig] = Vec();
      let mut ai2: i32 = 0;
      while ai2 < id.assoc_types.len() {
        let ad2: ast.ImplAssocTypeBinding = id.assoc_types.get(ai2);
        if impl_assoc_type_exists(impl_assocs, ad2.name) {
          return TcCtxResult { ok: false, err: type_error_at(ad2.sp, "duplicate impl associated type: ".concat(ad2.name)), ctx: c };
        }
        if !trait_assoc_type_exists(tf.sig.assoc_types, ad2.name) {
          return TcCtxResult { ok: false, err: type_error_at(ad2.sp, "impl associated type not in trait: ".concat(ad2.name)), ctx: c };
        }
        if tn_has_nonstatic_borrow(ad2.ty) {
          return TcCtxResult { ok: false, err: type_error_at(ad2.sp, "non-static borrowed type is not allowed in impl associated type"), ctx: c };
        }
        let ar2: ResolveTyResult = resolve_type(c, w, m.path, imps, id.type_params, ad2.ty);
        c = ar2.ctx;
        if !ar2.ok {
          return TcCtxResult { ok: false, err: type_error_at(ad2.sp, resolve_fail_msg(ad2.ty, "impl associated type resolve failed: ".concat(ad2.name))), ctx: c };
        }
        impl_assocs.push(ImplAssocTypeSig { name: ad2.name, ty: ar2.idx });
        ai2 = ai2 + 1;
      }
      let mut ai3: i32 = 0;
      while ai3 < tf.sig.assoc_types.len() {
        let ta: TraitAssocTypeSig = tf.sig.assoc_types.get(ai3);
        // Async trait methods synthesize hidden associated types `__async$<method>`;
        // those are bound by async lowering and do not need explicit impl bindings.
        if str_starts_with(ta.name, "__async$") {
          ai3 = ai3 + 1;
          continue;
        }
        if !impl_assoc_type_exists(impl_assocs, ta.name) {
          return TcCtxResult { ok: false, err: type_error_at(id.sp, "impl missing associated type: ".concat(ta.name)), ctx: c };
        }
        ai3 = ai3 + 1;
      }

      let mut ims: Vec[ImplMethodSig] = Vec();
      let mut tm: i32 = 0;
      while tm < tf.sig.methods.len() {
        let tms: TraitMethodSig = tf.sig.methods.get(tm);
        let mdi: i32 = impl_method_decl_idx(id.methods, tms.name);
        if mdi == -1 {
          if !tms.has_default {
            let ms: String = trait_method_candidates_text(tf.sig);
            let msg: String = "impl missing trait method: ".concat(tms.name).concat(" (required methods: ").concat(ms).concat(")");
            return TcCtxResult { ok: false, err: type_error_at(id.sp, msg), ctx: c };
          }

          let wr0: TraitMethodSigForResult = trait_method_sig_for(c, tms, for_ty, impl_assocs);
          c = wr0.ctx;
          if !wr0.ok { return TcCtxResult { ok: false, err: type_error_at(id.sp, "trait method type substitution failed"), ctx: c }; }
          let want0: FuncSig = wr0.sig;
          let mut emit_want0: FuncSig = want0;
          if tms.is_async {
            if wr0.async_output_ty == -1 {
              return TcCtxResult { ok: false, err: type_error_at(id.sp, "internal: missing async output type for trait method"), ctx: c };
            }
            // Before async lowering runs, store the declared output type in the lowered fn signature.
            // collect_async_fns will later rewrite it to the synthesized frame future type.
            emit_want0.ret = wr0.async_output_ty;
          }
          let emit0: FuncSig = impl_method_emit_sig(id.type_params, head_tpbs, emit_want0);
          let lowered0: String = fresh_impl_lowered_name(c, m.path, tf.sig, tms.name, c.impls.len() * 1000 + 500 + tm);
          c.funcs.push(FuncSym { mod_path: m.path, name: lowered0, sig: emit0 });
          ims.push(ImplMethodSig {
            name: tms.name,
            lowered_name: lowered0,
            sig: emit0,
            from_default: true,
            default_mod_path: tms.default_mod_path,
            default_file: tms.default_file,
            default_params: tms.default_params,
            default_body: tms.default_body,
          });
          tm = tm + 1;
          continue;
        }
        if !impl_method_decl_name_unique(id.methods, tms.name, mdi) {
          return TcCtxResult { ok: false, err: type_error_at(id.sp, "duplicate impl method: ".concat(tms.name)), ctx: c };
        }

        let md: ast.FuncDecl = id.methods.get(mdi);
        let pv0: CtiValidateTypeParamPacksResult = cti_validate_type_param_packs(md.sp, md.type_params, md.type_param_packs);
        if !pv0.ok { return TcCtxResult { ok: false, err: pv0.err, ctx: c }; }
        let wr1: TraitMethodSigForResult = trait_method_sig_for(c, tms, for_ty, impl_assocs);
        c = wr1.ctx;
        if !wr1.ok { return TcCtxResult { ok: false, err: type_error_at(md.sp, "trait method type substitution failed"), ctx: c }; }
        let want: FuncSig = wr1.sig;
        if md.const_params.len() != want.const_params.len() {
          return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method const param count mismatch"), ctx: c };
        }
        let mut cpi2: i32 = 0;
        while cpi2 < md.const_params.len() {
          let cp2: ast.ConstParamDecl = md.const_params.get(cpi2);
          let wcp: ConstParamSig = want.const_params.get(cpi2);
          if cp2.name != wcp.name {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method const param name mismatch"), ctx: c };
          }
          let mut hpi0: i32 = 0;
          while hpi0 < id.type_params.len() {
            if id.type_params.get(hpi0) == cp2.name {
              return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method const param duplicates impl type param"), ctx: c };
            }
            hpi0 = hpi0 + 1;
          }
          let cpr2: ResolveTyResult = resolve_type(c, w, m.path, imps, concat_strs(id.type_params, md.type_params), cp2.ty);
          c = cpr2.ctx;
          if !cpr2.ok {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, resolve_fail_msg(cp2.ty, "impl method const param type resolve failed")), ctx: c };
          }
          if cpr2.idx != wcp.ty {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method const param type mismatch"), ctx: c };
          }
          if cp2.has_default && !wcp.has_default {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method const param default not in trait"), ctx: c };
          }
          if cp2.has_default && wcp.has_default {
            let mut dparts2: Vec[String] = Vec();
            dparts2.push("@const");
            dparts2.push(cp2.default_text);
            let dpr2: ParseConstGenericArgResult = parse_const_generic_arg(c, ast.TypeName { parts: dparts2, args: Vec() }, wcp.ty);
            if !dpr2.ok {
              return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method const param default out of range"), ctx: c };
            }
            if dpr2.iv != wcp.default_iv {
              return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method const param default mismatch"), ctx: c };
            }
          }
          cpi2 = cpi2 + 1;
        }
        let got_cwr: CollectConstWhereResult = collect_const_where_bounds(md.sp, md.type_params, want.const_params, md.const_where_bounds);
        if !got_cwr.ok { return TcCtxResult { ok: false, err: got_cwr.err, ctx: c }; }
        if got_cwr.bounds.len() != want.const_where_bounds.len() {
          let msgc: String =
            "impl method comptime where bound count mismatch: expected "
              .concat(want.const_where_bounds.len().to_string())
              .concat(", got ")
              .concat(got_cwr.bounds.len().to_string());
          return TcCtxResult { ok: false, err: type_error_at(md.sp, msgc), ctx: c };
        }
        let mut cbi0: i32 = 0;
        while cbi0 < want.const_where_bounds.len() {
          let wb: ConstWhereBoundSig = want.const_where_bounds.get(cbi0);
          if !has_const_where_sig(got_cwr.bounds, wb.lhs_kind, wb.name, wb.op, wb.rhs_is_param, wb.rhs_param, wb.rhs_iv) {
            let msgw: String = "impl method missing comptime where bound: ".concat(cti_const_where_bound_text(wb));
            return TcCtxResult { ok: false, err: type_error_at(md.sp, msgw), ctx: c };
          }
          cbi0 = cbi0 + 1;
        }
        cbi0 = 0;
        while cbi0 < got_cwr.bounds.len() {
          let gb: ConstWhereBoundSig = got_cwr.bounds.get(cbi0);
          if !has_const_where_sig(want.const_where_bounds, gb.lhs_kind, gb.name, gb.op, gb.rhs_is_param, gb.rhs_param, gb.rhs_iv) {
            let msgw2: String = "impl method has extra comptime where bound: ".concat(cti_const_where_bound_text(gb));
            return TcCtxResult { ok: false, err: type_error_at(md.sp, msgw2), ctx: c };
          }
          cbi0 = cbi0 + 1;
        }
        let mut hpi: i32 = 0;
        while hpi < id.type_params.len() {
          if contains_str_local(md.type_params, id.type_params.get(hpi)) {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method type param duplicates impl type param"), ctx: c };
          }
          hpi = hpi + 1;
        }
        if md.type_params.len() != want.type_params.len() {
          return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method type param count mismatch"), ctx: c };
        }
        if md.type_param_packs.len() != want.type_param_packs.len() {
          return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method type parameter pack count mismatch"), ctx: c };
        }
        if md.type_param_packs.len() == 1 {
          let got_pack_pos: i32 = cti_type_param_pos(md.type_params, md.type_param_packs.get(0));
          let want_pack_pos: i32 = cti_type_param_pos(want.type_params, want.type_param_packs.get(0));
          if got_pack_pos != want_pack_pos {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method type parameter pack position mismatch"), ctx: c };
          }
        }

        // Impl method generic param names may differ from trait method names;
        // map impl names to trait names positionally for type/bound comparison.
        let mut impl_to_trait_tps: Vec[TySub] = Vec();
        let mut tpi: i32 = 0;
        while tpi < md.type_params.len() {
          let trtp: ResolveTyResult = resolve_type(c, w, m.path, imps, want.type_params, type_name1(want.type_params.get(tpi)));
          c = trtp.ctx;
          if !trtp.ok { return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method type param resolve failed"), ctx: c }; }
          impl_to_trait_tps.push(TySub { name: md.type_params.get(tpi), ty: trtp.idx });
          tpi = tpi + 1;
        }

        let mut got_tbs: Vec[TypeParamBoundSig] = Vec();
        let mut bi2: i32 = 0;
        while bi2 < md.type_param_bounds.len() {
          let bdecl2: ast.TypeParamBoundsDecl = md.type_param_bounds.get(bi2);
          if !type_param_ref_exists(md.type_params, bdecl2.name) {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, "unknown type param in impl method bound: ".concat(bdecl2.name)), ctx: c };
          }
          let bbase: String = type_param_ref_base_name(bdecl2.name);
          let bsuf: String = type_param_ref_projection_suffix(bdecl2.name);
          let bpos: i32 = type_param_pos(md.type_params, bbase);
          if bpos < 0 { return TcCtxResult { ok: false, err: type_error_at(md.sp, "unknown type param in impl method bound: ".concat(bdecl2.name)), ctx: c }; }
          let mut btp: String = want.type_params.get(bpos);
          if bsuf != "" { btp = btp.concat(".").concat(bsuf); }
          let mut bj2: i32 = 0;
          while bj2 < bdecl2.bounds.len() {
            let rtr2: ResolveTraitRefResult = resolve_trait_ref(c, w, m.path, imps, bdecl2.bounds.get(bj2));
            if !rtr2.ok { return TcCtxResult { ok: false, err: type_error_at(md.sp, "bad impl method bound"), ctx: c }; }
            let tf3: FindTraitResult = find_trait(c, rtr2.mod_path, rtr2.name);
            if !tf3.found { return TcCtxResult { ok: false, err: type_error_at(md.sp, "unknown trait in impl method bound"), ctx: c }; }
            if !vis_allows(tf3.sig.vis, rtr2.mod_path, m.path) {
              return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method bound refers to private trait"), ctx: c };
            }
            if !has_bound_sig(got_tbs, btp, rtr2.mod_path, rtr2.name) {
              got_tbs.push(TypeParamBoundSig { type_param: btp, trait_mod_path: rtr2.mod_path, trait_name: rtr2.name });
            }
            bj2 = bj2 + 1;
          }
          bi2 = bi2 + 1;
        }
        let mut bi3: i32 = 0;
        while bi3 < want.type_param_bounds.len() {
          let b: TypeParamBoundSig = want.type_param_bounds.get(bi3);
          if !has_bound_sig(got_tbs, b.type_param, b.trait_mod_path, b.trait_name) {
            let msg: String = "impl method missing type bound: ".concat(b.type_param).concat(": ").concat(b.trait_name);
            return TcCtxResult { ok: false, err: type_error_at(md.sp, msg), ctx: c };
          }
          bi3 = bi3 + 1;
        }
        let mut bi4: i32 = 0;
        while bi4 < got_tbs.len() {
          let b2: TypeParamBoundSig = got_tbs.get(bi4);
          if !has_bound_sig(want.type_param_bounds, b2.type_param, b2.trait_mod_path, b2.trait_name) {
            let msg2: String = "impl method has extra type bound: ".concat(b2.type_param).concat(": ").concat(b2.trait_name);
            return TcCtxResult { ok: false, err: type_error_at(md.sp, msg2), ctx: c };
          }
          bi4 = bi4 + 1;
        }

        if md.params.len() != want.params.len() {
          return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl method param count mismatch"), ctx: c };
        }

        let mut pi: i32 = 0;
        while pi < md.params.len() {
          let pr: ast.Param = md.params.get(pi);
          let nr: CtiNormalizeParamTypeResult = cti_normalize_param_type(md.sp, md.params, pi, pr.ty);
          if !nr.ok { return TcCtxResult { ok: false, err: nr.err, ctx: c }; }
          if !tn_nonstatic_borrow_allowed_param_type(nr.ty) {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, "non-static borrowed type in parameter must be top-level &T or &mut T"), ctx: c };
          }
          let rr: ResolveTyResult = resolve_type_bound(c, w, m.path, imps, concat_strs(id.type_params, md.type_params), impl_self_assoc_binds(for_ty, impl_assocs), nr.ty);
          c = rr.ctx;
          if !rr.ok { return TcCtxResult { ok: false, err: type_error_at(md.sp, resolve_fail_msg(nr.ty, "impl method param type resolve failed")), ctx: c }; }
          let gotp: i32 = subst_ty(c, rr.idx, impl_to_trait_tps);
          if !cti_ty_compat(c, want.params.get(pi), gotp) {
            let msgp: String =
              "impl method param type mismatch at index "
                .concat(pi.to_string())
                .concat(": got ")
                .concat(ty_inst_str(c, gotp))
                .concat(", want ")
                .concat(ty_inst_str(c, want.params.get(pi)));
            return TcCtxResult { ok: false, err: type_error_at(md.sp, msgp), ctx: c };
          }
          pi = pi + 1;
        }
        if tn_has_nonstatic_borrow(md.ret) {
          return TcCtxResult { ok: false, err: type_error_at(md.sp, "non-static borrowed type is not allowed in return type"), ctx: c };
        }
        let ret_r: ResolveTyResult = resolve_type_bound(c, w, m.path, imps, concat_strs(id.type_params, md.type_params), impl_self_assoc_binds(for_ty, impl_assocs), md.ret);
        c = ret_r.ctx;
        if !ret_r.ok { return TcCtxResult { ok: false, err: type_error_at(md.sp, resolve_fail_msg(md.ret, "impl method ret type resolve failed")), ctx: c }; }
        let got_ret: i32 = subst_ty(c, ret_r.idx, impl_to_trait_tps);
        let mut emit_want: FuncSig = want;
        if tms.is_async {
          if !md.is_async {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, "impl must use async fn to implement async trait method"), ctx: c };
          }
          if wr1.async_output_ty == -1 {
            return TcCtxResult { ok: false, err: type_error_at(md.sp, "internal: missing async output type for trait method"), ctx: c };
          }
          let want_out: i32 = wr1.async_output_ty;
          if !cti_ty_compat(c, want_out, got_ret) {
            let msgr: String =
              "impl async method output type mismatch: got "
                .concat(ty_inst_str(c, got_ret))
                .concat(", want ")
                .concat(ty_inst_str(c, want_out));
            return TcCtxResult { ok: false, err: type_error_at(md.sp, msgr), ctx: c };
          }
          // Before async lowering runs, store the declared output type in the lowered fn signature.
          // collect_async_fns will later rewrite it to the synthesized frame future type.
          emit_want.ret = want_out;
        } else {
          if !cti_ty_compat(c, want.ret, got_ret) {
            let msgr: String =
              "impl method ret type mismatch: got "
                .concat(ty_inst_str(c, got_ret))
                .concat(", want ")
                .concat(ty_inst_str(c, want.ret));
            return TcCtxResult { ok: false, err: type_error_at(md.sp, msgr), ctx: c };
          }
        }

        let emit_sig: FuncSig = impl_method_emit_sig(id.type_params, head_tpbs, emit_want);
        let lowered: String = fresh_impl_lowered_name(c, m.path, tf.sig, tms.name, c.impls.len() * 1000 + mdi);
        c.funcs.push(FuncSym { mod_path: m.path, name: lowered, sig: emit_sig });
        ims.push(ImplMethodSig {
          name: tms.name,
          lowered_name: lowered,
          sig: emit_sig,
          from_default: false,
          default_mod_path: "",
          default_file: "",
          default_params: Vec(),
          default_body: ast.Block { stmts: Vec() },
        });
        tm = tm + 1;
      }

      // Reject methods that are not part of the trait.
      let mut extra_i: i32 = 0;
      while extra_i < id.methods.len() {
        let md2: ast.FuncDecl = id.methods.get(extra_i);
        let tmf: FindTraitMethodResult = find_trait_method(tf.sig, md2.name);
        if !tmf.found {
          let ms2: String = trait_method_candidates_text(tf.sig);
          let msg2: String = "impl method not in trait: ".concat(md2.name).concat(" (available methods: ").concat(ms2).concat(")");
          return TcCtxResult { ok: false, err: type_error_at(md2.sp, msg2), ctx: c };
        }
        extra_i = extra_i + 1;
      }

      c.impls.push(ImplSig {
        mod_path: m.path,
        decl_idx: ii,
        is_inherent: false,
        trait_mod_path: trr.mod_path,
        trait_name: trr.name,
        for_ty: for_ty,
        head_type_params: id.type_params,
        head_type_param_bounds: head_tpbs,
        assoc_types: impl_assocs,
        methods: ims,
      });
      ii = ii + 1;
    }
    mi = mi + 1;
  }

  // Validate supertrait requirements after all impls are collected (order-independent).
  let mut ii2: i32 = 0;
  while ii2 < c.impls.len() {
    let isg: ImplSig = c.impls.get(ii2);
    if isg.is_inherent {
      ii2 = ii2 + 1;
      continue;
    }
    let tf2: FindTraitResult = find_trait(c, isg.trait_mod_path, isg.trait_name);
    if !tf2.found {
      return TcCtxResult { ok: false, err: type_error_at(impl_decl_span(w, isg.mod_path, isg.decl_idx), "unknown trait in impl"), ctx: c };
    }
    let mut si2: i32 = 0;
    while si2 < tf2.sig.supers.len() {
      let sup: TraitSuperSig = tf2.sig.supers.get(si2);
      let mut has_sup: bool = false;
      let mut sj: i32 = 0;
      while sj < c.impls.len() {
        let cand: ImplSig = c.impls.get(sj);
        if cand.trait_mod_path == sup.mod_path && cand.trait_name == sup.name {
          if impl_for_ty_overlap(c, cand.for_ty, isg.for_ty) {
            has_sup = true;
            sj = c.impls.len();
          }
        }
        sj = sj + 1;
      }
      if !has_sup {
        let msg: String = "impl of ".concat(isg.trait_name).concat(" requires supertrait ").concat(sup.name);
        return TcCtxResult { ok: false, err: type_error_at(impl_decl_span(w, isg.mod_path, isg.decl_idx), msg), ctx: c };
      }
      si2 = si2 + 1;
    }
    ii2 = ii2 + 1;
  }

  return TcCtxResult { ok: true, err: TcError.None, ctx: c };
}
