import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc

fn resource_tc_add_mod(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn resource_tc_run_main(src: String) -> tc.TcResult {
  let mut w: tc.World = tc.world();
  w = resource_tc_add_mod(w, "main", src);
  return tc.typecheck_world(w);
}

fn test_typecheck_resource_read_missing_rejected() -> () {
  let src: String = """
    @resource(read, Fs)
    fn read() -> i32 { return 1; }
    fn caller() -> i32 { return read(); }
    fn main() -> i32 { return 0; }
  """;
  let r: tc.TcResult = resource_tc_run_main(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "resource check failed"), msg);
  t.assert_with(contains(msg, "missing read resource(s): Fs"), msg);
}

fn test_typecheck_resource_read_declared_ok() -> () {
  let src: String = """
    @resource(read, Fs)
    fn read() -> i32 { return 1; }
    @resource(read, Fs)
    fn caller() -> i32 { return read(); }
    fn main() -> i32 { return 0; }
  """;
  let r: tc.TcResult = resource_tc_run_main(src);
  t.assert(r.ok);
}

fn test_typecheck_resource_write_missing_rejected() -> () {
  let src: String = """
    @resource(write, Db)
    fn write() -> i32 { return 1; }
    fn caller() -> i32 { return write(); }
    fn main() -> i32 { return 0; }
  """;
  let r: tc.TcResult = resource_tc_run_main(src);
  t.assert(!r.ok);
  let msg: String = tc.tc_error_to_string(r.err);
  t.assert_with(contains(msg, "resource check failed"), msg);
  t.assert_with(contains(msg, "missing write resource(s): Db"), msg);
}

fn test_typecheck_resource_write_declared_ok() -> () {
  let src: String = """
    @resource(write, Db)
    fn write() -> i32 { return 1; }
    @resource(write, Db)
    fn caller() -> i32 { return write(); }
    fn main() -> i32 { return 0; }
  """;
  let r: tc.TcResult = resource_tc_run_main(src);
  t.assert(r.ok);
}

fn test_typecheck_resource_write_covers_read_on_call() -> () {
  let src: String = """
    @resource(read, Fs)
    fn read() -> i32 { return 1; }
    @resource(write, Fs)
    fn caller() -> i32 { return read(); }
    @resource(write, Fs)
    fn main() -> i32 { return caller(); }
  """;
  let r: tc.TcResult = resource_tc_run_main(src);
  t.assert(r.ok);
}

fn test_typecheck_resource_write_covers_read_on_method_call() -> () {
  let src: String = """
    struct I { v: i32 }
    impl I { @resource(read, Fs) fn read(x: I) -> i32 { return x.v; } }
    @resource(write, Fs) fn main() -> i32 { let x: I = I { v: 7 }; return x.read(); }
  """;
  let r: tc.TcResult = resource_tc_run_main(src);
  t.assert(r.ok);
}

fn test_typecheck_resource_duplicate_read_rejected() -> () {
  let src: String = """
    @resource(read, Fs)
    @resource(read, Fs)
    fn read() -> i32 { return 1; }
    fn main() -> i32 { return 0; }
  """;
  let r: tc.TcResult = resource_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "duplicate read resource on function"));
}

fn test_typecheck_resource_duplicate_write_rejected() -> () {
  let src: String = """
    @resource(write, Fs)
    @resource(write, Fs)
    fn write() -> i32 { return 1; }
    fn main() -> i32 { return 0; }
  """;
  let r: tc.TcResult = resource_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "duplicate write resource on function"));
}

fn test_typecheck_resource_read_write_same_name_rejected() -> () {
  let src: String = """
    @resource(read, Fs)
    @resource(write, Fs)
    fn rw() -> i32 { return 1; }
    fn main() -> i32 { return 0; }
  """;
  let r: tc.TcResult = resource_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "resource cannot be both read and write on function"));
}

fn test_typecheck_trait_method_resource_read_match_smoke() -> () {
  let src: String = """
    trait Read { @resource(read, Fs) fn read(x: Self) -> i32; }
    struct I { v: i32 }
    impl Read for I { @resource(read, Fs) fn read(x: I) -> i32 { return x.v; } }
    fn main() -> i32 { return 0; }
  """;
  let r: tc.TcResult = resource_tc_run_main(src);
  t.assert(r.ok);
}

fn test_typecheck_trait_method_resource_read_mismatch_rejected() -> () {
  let src: String = """
    trait Read { @resource(read, Fs) fn read(x: Self) -> i32; }
    struct I { v: i32 }
    impl Read for I { fn read(x: I) -> i32 { return x.v; } }
    fn main() -> i32 { return 0; }
  """;
  let r: tc.TcResult = resource_tc_run_main(src);
  t.assert(!r.ok);
  t.assert(contains(tc.tc_error_to_string(r.err), "impl method read resource set mismatch"));
}
