pub struct LookupVarResult { pub found: bool, pub ty: i32, pub mutable: bool, pub moved: bool }
pub struct LookupConstResult { pub found: bool, pub ty: i32, pub has_val: bool, pub iv: i64 }
pub struct VarEntry { pub name: String, pub ty: i32, pub mutable: bool, pub depth: i32, pub moved: bool }
pub struct ConstEntry { pub name: String, pub ty: i32, pub has_val: bool, pub iv: i64, pub depth: i32 }
pub struct Locals {
  pub vars: Vec[VarEntry],
  pub consts: Vec[ConstEntry],
  pub depth: i32,
  pub type_params: Vec[String],
  pub type_param_bounds: Vec[TypeParamBoundSig],
  pub fn_is_async: bool,
  pub fn_effects: Vec[String],
  pub fn_ret_ty: i32,
  // Current `try` propagation target for `expr?` (top of stack).
  pub try_ret_ty: i32,
  // Explicit try target stack used by internal lowering (e.g. async normalization).
  pub try_ret_stack: Vec[i32],
  pub loop_depth: i32,
}

fn vars_replace_at(xs: Vec[VarEntry], idx: i32, val: VarEntry) -> Vec[VarEntry] {
  let mut out: Vec[VarEntry] = Vec();
  let mut i: i32 = 0;
  let n: i32 = xs.len();
  while i < n {
    if i == idx {
      out.push(val);
    } else {
      out.push(xs.get(i));
    }
    i = i + 1;
  }
  return out;
}

pub fn locals_new() -> Locals {
  return Locals {
    vars: Vec(),
    consts: Vec(),
    depth: 0,
    type_params: Vec(),
    type_param_bounds: Vec(),
    fn_is_async: false,
    fn_effects: Vec(),
    fn_ret_ty: -1,
    try_ret_ty: -1,
    try_ret_stack: Vec(),
    loop_depth: 0,
  };
}
pub fn locals_enter(l: Locals) -> Locals { let mut q: Locals = l; q.depth = q.depth + 1; return q; }
pub fn locals_exit(l: Locals) -> Locals { let mut q: Locals = l; q.depth = q.depth - 1; return q; }

pub fn locals_try_push(l0: Locals, ty: i32) -> Locals {
  let mut l: Locals = l0;
  l.try_ret_stack.push(ty);
  l.try_ret_ty = ty;
  return l;
}

pub fn locals_try_pop(l0: Locals) -> Locals {
  let mut l: Locals = l0;
  if l.try_ret_stack.len() == 0 {
    l.try_ret_ty = -1;
    return l;
  }
  // Pop last.
  let mut out: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < l.try_ret_stack.len() - 1 {
    out.push(l.try_ret_stack.get(i));
    i = i + 1;
  }
  l.try_ret_stack = out;
  if l.try_ret_stack.len() == 0 {
    l.try_ret_ty = -1;
  } else {
    l.try_ret_ty = l.try_ret_stack.get(l.try_ret_stack.len() - 1);
  }
  return l;
}

pub fn locals_decl(l: Locals, name: String, ty: i32, mutable: bool) -> Locals {
  let mut q: Locals = l;
  q.vars.push(VarEntry { name: name, ty: ty, mutable: mutable, depth: q.depth, moved: false });
  return q;
}

pub fn locals_decl_const(l: Locals, name: String, ty: i32) -> Locals {
  let mut q: Locals = l;
  q.consts.push(ConstEntry { name: name, ty: ty, has_val: false, iv: 0, depth: q.depth });
  return q;
}

pub fn locals_decl_const_value(l: Locals, name: String, ty: i32, iv: i64) -> Locals {
  let mut q: Locals = l;
  q.consts.push(ConstEntry { name: name, ty: ty, has_val: true, iv: iv, depth: q.depth });
  return q;
}

pub fn locals_lookup(l: Locals, name: String) -> LookupVarResult {
  let vs: Vec[VarEntry] = l.vars;
  let mut i: i32 = vs.len() - 1;
  while i >= 0 {
    let v: VarEntry = vs.get(i);
    if v.depth <= l.depth && v.name == name {
      return LookupVarResult { found: true, ty: v.ty, mutable: v.mutable, moved: v.moved };
    }
    i = i - 1;
  }
  return LookupVarResult { found: false, ty: -1, mutable: false, moved: false };
}

pub fn locals_set_moved_at(l: Locals, idx: i32, moved: bool) -> Locals {
  let mut q: Locals = l;
  if idx < 0 || idx >= q.vars.len() { return q; }
  let v: VarEntry = q.vars.get(idx);
  q.vars = vars_replace_at(q.vars, idx, VarEntry { name: v.name, ty: v.ty, mutable: v.mutable, depth: v.depth, moved: moved });
  return q;
}

pub fn locals_set_moved(l: Locals, name: String, moved: bool) -> Locals {
  let mut q: Locals = l;
  let mut i: i32 = q.vars.len() - 1;
  while i >= 0 {
    let v: VarEntry = q.vars.get(i);
    if v.depth <= q.depth && v.name == name {
      q = locals_set_moved_at(q, i, moved);
      return q;
    }
    i = i - 1;
  }
  return q;
}

pub fn locals_mark_moved(l: Locals, name: String) -> Locals {
  return locals_set_moved(l, name, true);
}

pub fn locals_clear_moved(l: Locals, name: String) -> Locals {
  return locals_set_moved(l, name, false);
}

pub fn locals_sync_moved(base: Locals, src: Locals) -> Locals {
  let mut out: Locals = base;
  let mut i: i32 = 0;
  while i < out.vars.len() {
    let v: VarEntry = out.vars.get(i);
    if v.depth <= out.depth {
      let vr: LookupVarResult = locals_lookup(src, v.name);
      if vr.found {
        out = locals_set_moved_at(out, i, vr.moved);
      }
    }
    i = i + 1;
  }
  return out;
}

pub fn locals_lookup_const(l: Locals, name: String) -> LookupConstResult {
  let vs: Vec[ConstEntry] = l.consts;
  let mut i: i32 = vs.len() - 1;
  while i >= 0 {
    let v: ConstEntry = vs.get(i);
    if v.depth <= l.depth && v.name == name {
      return LookupConstResult { found: true, ty: v.ty, has_val: v.has_val, iv: v.iv };
    }
    i = i - 1;
  }
  return LookupConstResult { found: false, ty: -1, has_val: false, iv: 0 };
}
