import "vox/ast" as ast
import "vox/ir" as ir

// Stage1 typecheck (v0): minimal expression typing used by tc_fn.vox.
// This module intentionally stays small; we will expand it with TDD when typecheck
// becomes part of Stage1's critical path.

pub struct ExprTyResult { pub ok: bool, pub ty: i32, pub err: TcError }
struct TryContainerInfo { ok: bool, is_result: bool, ok_ty: i32, residual_ty: i32 }
struct AwaitPollInfo { ok: bool, out_ty: i32 }
struct AwaitFutureInfo { ok: bool, out_ty: i32 }
struct VariantLookupFieldResult { found: bool, field_count: i32, field0: i32 }
struct TryErrCompatResult { ok: bool, err: TcError }

fn try_subs_lookup_tc(subs: Vec[TySub], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < subs.len() {
    let s: TySub = subs.get(i);
    if s.name == name { return s.ty; }
    i = i + 1;
  }
  return -1;
}

pub fn tc_expr(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, id: i32, expected: i32) -> ExprTyResult {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);

  let r: ExprTyResult = match n {
    ast.ExprNode.Int(text) => tc_expr_int(ctx, ast.expr_pool_span(exprs, id), text, expected),
    ast.ExprNode.Float(text) => tc_expr_float(ctx, ast.expr_pool_span(exprs, id), text, expected),
    ast.ExprNode.Str(_) => tc_expr_str(ctx, expected),
    ast.ExprNode.Bool(_) => tc_expr_bool(ctx, expected),
    ast.ExprNode.Ident(name) => tc_expr_ident(ctx, ast.expr_pool_span(exprs, id), mod_path, imps, l0, name, expected),
    ast.ExprNode.DotIdent(name) => tc_expr_dot_ident(ctx, mod_path, name, expected),
    ast.ExprNode.Block(b) => tc_expr_block(ctx, w, mod_path, imps, exprs, l0, b, expected),

    ast.ExprNode.If(c, t, e) => tc_expr_if(ctx, w, mod_path, imps, exprs, l0, c, t, e, expected),
    ast.ExprNode.Unary(op, a) => tc_expr_unary(ctx, w, mod_path, imps, exprs, l0, op, a, expected),
    ast.ExprNode.As(a, tn) => tc_expr_as(ctx, w, mod_path, imps, exprs, l0, a, tn, expected),
    ast.ExprNode.Binary(op, l, r) => tc_expr_binary(ctx, w, mod_path, imps, exprs, l0, op, l, r, expected),

    ast.ExprNode.Member(recv, name) => tc_expr_member(ctx, w, mod_path, imps, exprs, l0, recv, name, expected),
    ast.ExprNode.Call(callee, type_args, args) => tc_expr_call(ctx, w, mod_path, imps, exprs, l0, ast.expr_pool_span(exprs, id), callee, type_args, args, expected),
    ast.ExprNode.MacroCall(callee, _targs, _args) => tc_expr_macro_call(ctx, exprs, callee, ast.expr_pool_span(exprs, id)),
    ast.ExprNode.TryBlock(bid) => tc_expr_try_block(ctx, w, mod_path, imps, exprs, l0, id, bid, expected),
    ast.ExprNode.Try(a) => tc_expr_try(ctx, w, mod_path, imps, exprs, l0, id, a, expected),
    ast.ExprNode.Await(a) => tc_expr_await(ctx, w, mod_path, imps, exprs, l0, id, a, expected),
    ast.ExprNode.StructLit(ty_expr, fields) => tc_expr_struct_lit(ctx, w, mod_path, imps, exprs, l0, ty_expr, fields, expected),
    ast.ExprNode.Match(scrut, arms) => tc_expr_match(ctx, w, mod_path, imps, exprs, l0, scrut, arms, expected),
  };

  if r.ok { return r; }
  if r.err != TcError.None { return r; }
  // If a helper didn't attach a reason, fall back to a generic error at the expr span.
  let sp: ast.Span = ast.expr_pool_span(exprs, id);
  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "typecheck failed") };
}

fn tc_expr_await(
  ctx: Ctx,
  w: World,
  mod_path: String,
  imps: Imports,
  exprs: ast.ExprPool,
  l0: Locals,
  id: i32,
  a: i32,
  expected: i32,
) -> ExprTyResult {
  let sp: ast.Span = ast.expr_pool_span(exprs, id);
  if !l0.fn_is_async {
    return ExprTyResult {
      ok: false,
      ty: ctx.ty_bad,
      err: type_error_at(sp, "await can only be used in async fn"),
    };
  }
  let pr0: PrepAsyncInstResult = prep_async_inst_in_expr(ctx, w, mod_path, imps, exprs, l0, a);
  if !pr0.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: pr0.err }; }
  let c: Ctx = pr0.ctx;

  let ar: ExprTyResult = tc_expr(c, w, mod_path, imps, exprs, l0, a, -1);
  if !ar.ok { return ar; }

  let mut out_ty: i32 = -1;
  let ai: AwaitPollInfo = await_poll_info(c, ar.ty);
  if ai.ok {
    out_ty = ai.out_ty;
  } else {
    let afi: AwaitFutureInfo = await_future_info(c, ar.ty);
    if afi.ok {
      out_ty = afi.out_ty;
    } else {
      return ExprTyResult {
        ok: false,
        ty: c.ty_bad,
        err: type_error_at(sp, "`await` requires Poll-like enum { Pending, Ready(T) } or std/async::Future impl"),
      };
    }
  }

  if expected != -1 && !assignable_to(c, expected, out_ty) {
    return ExprTyResult { ok: false, ty: c.ty_bad, err: TcError.None };
  }
  return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
}
fn macro_callee_display_name(exprs: ast.ExprPool, callee: i32) -> String {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, callee);
  return match n {
    ast.ExprNode.Ident(s) => s,
    ast.ExprNode.Member(_recv, name) => name,
    _ => "<expr>",
  };
}

fn tc_expr_macro_call(ctx: Ctx, exprs: ast.ExprPool, callee: i32, sp: ast.Span) -> ExprTyResult {
  let mname: String = macro_callee_display_name(exprs, callee);
  return ExprTyResult {
    ok: false,
    ty: ctx.ty_bad,
    err: type_error_at(sp, "internal: unexpanded macro call reached typecheck: ".concat(mname).concat("!")),
  };
}

fn find_enum_variant_field(es: EnumSig, name: String) -> VariantLookupFieldResult {
  let mut i: i32 = 0;
  while i < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(i);
    if v.name == name {
      let mut t0: i32 = -1;
      if v.fields.len() == 1 { t0 = v.fields.get(0); }
      return VariantLookupFieldResult { found: true, field_count: v.fields.len(), field0: t0 };
    }
    i = i + 1;
  }
  return VariantLookupFieldResult { found: false, field_count: 0, field0: -1 };
}

fn try_container_info(ctx: Ctx, ty0: i32) -> TryContainerInfo {
  let ty: i32 = strip_range(ctx, ty0);
  if ty < 0 || ty >= ctx.pool.tys.len() { return TryContainerInfo { ok: false, is_result: false, ok_ty: ctx.ty_bad, residual_ty: ctx.ty_bad }; }
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty);
  if t.kind != ir.TyKind.Enum { return TryContainerInfo { ok: false, is_result: false, ok_ty: ctx.ty_bad, residual_ty: ctx.ty_bad }; }
  let fe: FindEnumResult = find_enum(ctx, ty_mod(t), ty_name(t));
  if !fe.found { return TryContainerInfo { ok: false, is_result: false, ok_ty: ctx.ty_bad, residual_ty: ctx.ty_bad }; }
  let es: EnumSig = fe.sig;

  let okv: VariantLookupFieldResult = find_enum_variant_field(es, "Ok");
  let errv: VariantLookupFieldResult = find_enum_variant_field(es, "Err");
  if okv.found && errv.found && okv.field_count == 1 && errv.field_count == 1 {
    return TryContainerInfo { ok: true, is_result: true, ok_ty: okv.field0, residual_ty: errv.field0 };
  }

  let somev: VariantLookupFieldResult = find_enum_variant_field(es, "Some");
  let nonev: VariantLookupFieldResult = find_enum_variant_field(es, "None");
  if somev.found && nonev.found && somev.field_count == 1 && nonev.field_count == 0 {
    return TryContainerInfo { ok: true, is_result: false, ok_ty: somev.field0, residual_ty: ctx.ty_unit };
  }

  return TryContainerInfo { ok: false, is_result: false, ok_ty: ctx.ty_bad, residual_ty: ctx.ty_bad };
}

fn await_poll_info(ctx: Ctx, ty0: i32) -> AwaitPollInfo {
  let ty: i32 = strip_range(ctx, ty0);
  if ty < 0 || ty >= ctx.pool.tys.len() { return AwaitPollInfo { ok: false, out_ty: ctx.ty_bad }; }
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty);
  if t.kind != ir.TyKind.Enum { return AwaitPollInfo { ok: false, out_ty: ctx.ty_bad }; }
  let fe: FindEnumResult = find_enum(ctx, ty_mod(t), ty_name(t));
  if !fe.found { return AwaitPollInfo { ok: false, out_ty: ctx.ty_bad }; }
  let es: EnumSig = fe.sig;

  let pending: VariantLookupFieldResult = find_enum_variant_field(es, "Pending");
  let ready: VariantLookupFieldResult = find_enum_variant_field(es, "Ready");
  if !pending.found || !ready.found { return AwaitPollInfo { ok: false, out_ty: ctx.ty_bad }; }
  if pending.field_count != 0 || ready.field_count != 1 { return AwaitPollInfo { ok: false, out_ty: ctx.ty_bad }; }
  return AwaitPollInfo { ok: true, out_ty: ready.field0 };
}

fn await_future_info(ctx: Ctx, ty0: i32) -> AwaitFutureInfo {
  let recv_ty: i32 = strip_range(ctx, ty0);
  let fi: FindImplForTyResult = find_impl_for_ty(ctx, "std/async", "Future", recv_ty);
  if fi.ambiguous || !fi.found {
    return AwaitFutureInfo { ok: false, out_ty: ctx.ty_bad };
  }

  let ur: UnifyResult = unify_ty(ctx, fi.sig.for_ty, recv_ty, Vec());
  if !ur.ok {
    return AwaitFutureInfo { ok: false, out_ty: ctx.ty_bad };
  }
  let subs: Vec[TySub] = ur.subs;

  let out0: i32 = try_impl_assoc_ty(fi.sig, "Output");
  if out0 == -1 {
    return AwaitFutureInfo { ok: false, out_ty: ctx.ty_bad };
  }
  let out_ty: i32 = subst_ty(ctx, out0, subs);

  let im: FindImplMethodResult = find_impl_method(fi.sig, "poll");
  if !im.found {
    return AwaitFutureInfo { ok: false, out_ty: ctx.ty_bad };
  }
  let poll_ret: i32 = subst_ty(ctx, im.m.sig.ret, subs);
  let pi: AwaitPollInfo = await_poll_info(ctx, poll_ret);
  if !pi.ok {
    return AwaitFutureInfo { ok: false, out_ty: ctx.ty_bad };
  }
  if !assignable_to(ctx, out_ty, pi.out_ty) || !assignable_to(ctx, pi.out_ty, out_ty) {
    return AwaitFutureInfo { ok: false, out_ty: ctx.ty_bad };
  }
  return AwaitFutureInfo { ok: true, out_ty: out_ty };
}
fn try_impl_assoc_ty(sig: ImplSig, assoc: String) -> i32 {
  let mut i: i32 = 0;
  while i < sig.assoc_types.len() {
    let a: ImplAssocTypeSig = sig.assoc_types.get(i);
    if a.name == assoc { return a.ty; }
    i = i + 1;
  }
  return -1;
}

fn try_result_err_compatible(ctx: Ctx, mod_path: String, sp: ast.Span, src_err_ty: i32, dst_err_ty: i32) -> TryErrCompatResult {
  if assignable_to(ctx, dst_err_ty, src_err_ty) {
    return TryErrCompatResult { ok: true, err: TcError.None };
  }

  let prelude: String = "std/prelude";
  let tf: FindTraitResult = find_trait(ctx, prelude, "Into");
  if !tf.found || !vis_allows(tf.sig.vis, prelude, mod_path) {
    return TryErrCompatResult { ok: false, err: type_error_at(sp, "cannot propagate error: Err type mismatch") };
  }

  let fi: FindImplForTyResult = find_impl_for_ty(ctx, prelude, "Into", strip_range(ctx, src_err_ty));
  if fi.ambiguous {
    let msg0: String = "cannot propagate error: Err type mismatch (ambiguous Into impls: ".concat(fi.candidates).concat(")");
    return TryErrCompatResult { ok: false, err: type_error_at(sp, msg0) };
  }
  if !fi.found {
    return TryErrCompatResult { ok: false, err: type_error_at(sp, "cannot propagate error: Err type mismatch") };
  }

  let im: FindImplMethodResult = find_impl_method(fi.sig, "into");
  if !im.found {
    return TryErrCompatResult { ok: false, err: type_error_at(sp, "cannot propagate error: Err type mismatch") };
  }
  if im.m.sig.params.len() != 1 {
    return TryErrCompatResult { ok: false, err: type_error_at(sp, "cannot propagate error: Err type mismatch") };
  }
  if im.m.sig.const_params.len() != 0 {
    return TryErrCompatResult { ok: false, err: type_error_at(sp, "cannot propagate error: Err type mismatch") };
  }

  let mut subs: Vec[TySub] = Vec();
  let ur0: UnifyResult = unify_ty(ctx, im.m.sig.ret, dst_err_ty, subs);
  if !ur0.ok {
    return TryErrCompatResult { ok: false, err: type_error_at(sp, "cannot propagate error: Err type mismatch") };
  }
  subs = ur0.subs;
  let ur1: UnifyResult = unify_ty(ctx, im.m.sig.params.get(0), src_err_ty, subs);
  if !ur1.ok {
    return TryErrCompatResult { ok: false, err: type_error_at(sp, "cannot propagate error: Err type mismatch") };
  }
  subs = ur1.subs;

  // For `?` conversion we may not have explicit generic args; default any remaining
  // unconstrained method params to destination Err type.
  let mut ti: i32 = 0;
  while ti < im.m.sig.type_params.len() {
    let tp: String = im.m.sig.type_params.get(ti);
    if try_subs_lookup_tc(subs, tp) == -1 {
      subs.push(TySub { name: tp, ty: dst_err_ty });
    }
    ti = ti + 1;
  }

  let mut bi: i32 = 0;
  while bi < im.m.sig.type_param_bounds.len() {
    let b: TypeParamBoundSig = im.m.sig.type_param_bounds.get(bi);
    let ty0: i32 = try_subs_lookup_tc(subs, b.type_param);
    if ty0 == -1 {
      return TryErrCompatResult { ok: false, err: type_error_at(sp, "cannot propagate error: Err type mismatch") };
    }
    let fi2: FindImplForTyResult = find_impl_for_ty(ctx, b.trait_mod_path, b.trait_name, strip_range(ctx, ty0));
    if fi2.ambiguous || !fi2.found {
      return TryErrCompatResult { ok: false, err: type_error_at(sp, "cannot propagate error: Err type mismatch") };
    }
    bi = bi + 1;
  }

  let assoc_target: i32 = try_impl_assoc_ty(fi.sig, "Target");
  let via_ty0: i32 = if assoc_target != -1 { assoc_target } else { im.m.sig.ret };
  let via_ty: i32 = subst_ty(ctx, via_ty0, subs);
  if !assignable_to(ctx, dst_err_ty, via_ty) {
    return TryErrCompatResult { ok: false, err: type_error_at(sp, "cannot propagate error: Err type mismatch") };
  }

  return TryErrCompatResult { ok: true, err: TcError.None };
}

fn select_try_target_ty(ctx: Ctx, l0: Locals, expected: i32) -> i32 {
  if expected != -1 {
    let ei: TryContainerInfo = try_container_info(ctx, expected);
    if ei.ok { return expected; }
  }
  if l0.try_ret_ty != -1 {
    let ti: TryContainerInfo = try_container_info(ctx, l0.try_ret_ty);
    if ti.ok { return l0.try_ret_ty; }
  }
  if l0.fn_ret_ty != -1 {
    let fi: TryContainerInfo = try_container_info(ctx, l0.fn_ret_ty);
    if fi.ok { return l0.fn_ret_ty; }
  }
  return -1;
}

fn tc_expr_try_block(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, id: i32, bid: i32, expected: i32) -> ExprTyResult {
  let sp: ast.Span = ast.expr_pool_span(exprs, id);
  let target: i32 = select_try_target_ty(ctx, l0, expected);
  if target == -1 {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "`try {}` requires expected Result/Option type") };
  }
  let ti: TryContainerInfo = try_container_info(ctx, target);

  let mut l1: Locals = l0;
  l1.try_ret_ty = target;
  let br: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l1, bid, -1);
  if !br.ok { return br; }
  if br.ty == target {
    if expected != -1 && !assignable_to(ctx, expected, target) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: target, err: TcError.None };
  }
  if !assignable_to(ctx, ti.ok_ty, br.ty) {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "`try {}` tail type incompatible with success payload type") };
  }
  if expected != -1 && !assignable_to(ctx, expected, target) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: target, err: TcError.None };
}

fn tc_expr_try(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, id: i32, a: i32, expected: i32) -> ExprTyResult {
  let sp: ast.Span = ast.expr_pool_span(exprs, id);
  let ar: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, a, -1);
  if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  let src: TryContainerInfo = try_container_info(ctx, ar.ty);
  if !src.ok {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "`?` requires Result[T, E] or Option[T]") };
  }
  let mut target: i32 = if l0.try_ret_ty != -1 { l0.try_ret_ty } else { l0.fn_ret_ty };
  if target == -1 {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "`?` can only be used inside function/try block") };
  }

  // Allow `?` to propagate through a Poll-like wrapper:
  // `fn ... -> Poll[Result[T, E]] { ... x? ... }` should be valid and will lower
  // to returning `.Ready(.Err(..))` in the poll state machine.
  let mut dst: TryContainerInfo = try_container_info(ctx, target);
  if !dst.ok {
    let pi: AwaitPollInfo = await_poll_info(ctx, target);
    if pi.ok {
      let d2: TryContainerInfo = try_container_info(ctx, pi.out_ty);
      if d2.ok {
        target = pi.out_ty;
        dst = d2;
      }
    }
  }

  if !dst.ok {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "propagation target type must be Result[T, E] or Option[T] when using `?`") };
  }
  if src.is_result != dst.is_result {
    if src.is_result {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "cannot use Result `?` in function returning Option") };
    }
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "cannot use Option `?` in function returning Result") };
  }

  if src.is_result {
    let cr: TryErrCompatResult = try_result_err_compatible(ctx, mod_path, sp, src.residual_ty, dst.residual_ty);
    if !cr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: cr.err }; }
  }

  let out_ty: i32 = src.ok_ty;
  if expected != -1 && !assignable_to(ctx, expected, out_ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
}

fn tc_expr_as(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, a: i32, tn: ast.TypeName, expected: i32) -> ExprTyResult {
  let tr: ResolveTyResult = resolve_type(ctx, w, mod_path, imps, l0.type_params, tn);
  let c2: Ctx = tr.ctx;
  if !tr.ok { return ExprTyResult { ok: false, ty: c2.ty_bad, err: TcError.None }; }

  let to_ty: i32 = tr.idx;
  let to_base0: i32 = strip_range(c2, to_ty);
  let to_t0: ir.Ty = ir.ty_pool_get(c2.pool, to_base0);
  let to_unsigned0: bool = match to_t0.kind { ir.TyKind.U8 => true, ir.TyKind.U16 => true, ir.TyKind.U32 => true, ir.TyKind.U64 => true, ir.TyKind.USize => true, _ => false };
  let an: ast.ExprNode = ast.expr_pool_get(exprs, a);
  let is_int_lit: bool = match an { ast.ExprNode.Int(_s) => true, _ => false };
  let a_expected: i32 = if is_int_lit && to_unsigned0 { to_base0 } else { -1 };

  let ar: ExprTyResult = tc_expr(c2, w, mod_path, imps, exprs, l0, a, a_expected);
  if !ar.ok { return ExprTyResult { ok: false, ty: c2.ty_bad, err: TcError.None }; }

  let from_ty: i32 = ar.ty;
  // Stage1 v0:
  // - int-like <-> int-like (ranges allowed on int side)
  // - float <-> float
  // - int-like <-> float
  let from_float: bool = is_float_ty(c2, from_ty);
  let to_float: bool = is_float_ty(c2, to_ty);
  if from_float || to_float {
    let from_ok: bool = from_float || is_int_like_ty(c2, from_ty);
    let to_ok: bool = to_float || is_int_like_ty(c2, to_ty);
    if !from_ok || !to_ok { return ExprTyResult { ok: false, ty: c2.ty_bad, err: TcError.None }; }
    if expected != -1 && !assignable_to(c2, expected, to_ty) { return ExprTyResult { ok: false, ty: c2.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: to_ty, err: TcError.None };
  }

  if !is_int_like_ty(c2, from_ty) || !is_int_like_ty(c2, to_ty) { return ExprTyResult { ok: false, ty: c2.ty_bad, err: TcError.None }; }
  let from_base: i32 = strip_range(c2, from_ty);
  let to_base: i32 = strip_range(c2, to_ty);
  if from_base != to_base {
    let fb: ir.Ty = ir.ty_pool_get(c2.pool, from_base);
    let tb: ir.Ty = ir.ty_pool_get(c2.pool, to_base);
    let f_ok: bool = match fb.kind {
      ir.TyKind.I8 => true,
      ir.TyKind.U8 => true,
      ir.TyKind.I16 => true,
      ir.TyKind.U16 => true,
      ir.TyKind.I32 => true,
      ir.TyKind.U32 => true,
      ir.TyKind.I64 => true,
      ir.TyKind.U64 => true,
      ir.TyKind.ISize => true,
      ir.TyKind.USize => true,
      _ => false,
    };
    let t_ok: bool = match tb.kind {
      ir.TyKind.I8 => true,
      ir.TyKind.U8 => true,
      ir.TyKind.I16 => true,
      ir.TyKind.U16 => true,
      ir.TyKind.I32 => true,
      ir.TyKind.U32 => true,
      ir.TyKind.I64 => true,
      ir.TyKind.U64 => true,
      ir.TyKind.ISize => true,
      ir.TyKind.USize => true,
      _ => false,
    };
    if !f_ok || !t_ok { return ExprTyResult { ok: false, ty: c2.ty_bad, err: TcError.None }; }
  }

  if expected != -1 && !assignable_to(c2, expected, to_ty) { return ExprTyResult { ok: false, ty: c2.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: to_ty, err: TcError.None };
}

fn tc_expr_block(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, b: ast.ExprBlock, expected: i32) -> ExprTyResult {
  // Expression block: `{ stmt*; tailExpr }`. Tail is optional (missing => unit).
  // Terminators are allowed; when control flow definitely terminates inside the
  // block, the expression is treated as diverging and can coerce to `expected`.
  let mut c: Ctx = ctx;
  let mut l: Locals = locals_enter(l0);
  let block_ret_ty: i32 = if l.fn_ret_ty != -1 { l.fn_ret_ty } else { c.ty_unit };
  let mut diverges: bool = false;

  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let st: ast.Stmt = b.stmts.get(i);
    let r: TcStmtResult = tc_stmt(c, w, mod_path, imps, exprs, l, block_ret_ty, st);
    if !r.ok { return ExprTyResult { ok: false, ty: c.ty_bad, err: r.err }; }
    l = r.locals;
    if stmt_definitely_diverges(st) {
      diverges = true;
      i = b.stmts.len();
    } else {
      i = i + 1;
    }
  }

  if diverges {
    let out_div: i32 = if expected != -1 { expected } else { c.ty_unit };
    return ExprTyResult { ok: true, ty: out_div, err: TcError.None };
  }

  if !b.has_tail {
    if expected != -1 && expected != c.ty_unit { return ExprTyResult { ok: false, ty: c.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: c.ty_unit, err: TcError.None };
  }

  let er: ExprTyResult = tc_expr(c, w, mod_path, imps, exprs, l, b.tail, expected);
  if !er.ok { return ExprTyResult { ok: false, ty: c.ty_bad, err: TcError.None }; }
  let out_ty: i32 = if expected != -1 { expected } else { er.ty };
  if expected != -1 && !assignable_to(c, expected, er.ty) { return ExprTyResult { ok: false, ty: c.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: out_ty, err: TcError.None };
}

fn block_definitely_diverges(b: ast.Block) -> bool {
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    if stmt_definitely_diverges(b.stmts.get(i)) { return true; }
    i = i + 1;
  }
  return false;
}

fn stmt_definitely_diverges(st: ast.Stmt) -> bool {
  return match st {
    ast.Stmt.ReturnStmt(_, _, _) => true,
    ast.Stmt.Break(_) => true,
    ast.Stmt.Continue(_) => true,
    ast.Stmt.IfStmt(_sp, _cond, then_b, has_else, else_b) => has_else && block_definitely_diverges(then_b) && block_definitely_diverges(else_b),
    _ => false,
  };
}

fn expr_definitely_diverges(exprs: ast.ExprPool, id: i32) -> bool {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);
  return match n {
    ast.ExprNode.Block(b) => {
      let mut i: i32 = 0;
      while i < b.stmts.len() {
        if stmt_definitely_diverges(b.stmts.get(i)) { return true; }
        i = i + 1;
      }
      if b.has_tail { return expr_definitely_diverges(exprs, b.tail); }
      false
    },
    ast.ExprNode.If(_c, t, e) => expr_definitely_diverges(exprs, t) && expr_definitely_diverges(exprs, e),
    _ => false,
  };
}

fn tc_expr_dot_ident(ctx: Ctx, mod_path: String, name: String, expected: i32) -> ExprTyResult {
  // `.Variant` needs an expected enum type.
  if expected == -1 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let et: ir.Ty = ir.ty_pool_get(ctx.pool, expected);
  if et.kind != ir.TyKind.Enum { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let fe: FindEnumResult = find_enum(ctx, ty_mod(et), ty_name(et));
  if !fe.found { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  let es: EnumSig = fe.sig;
  // Unit variant only.
  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    if v.name == name {
      if v.fields.len() != 0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      return ExprTyResult { ok: true, ty: expected, err: TcError.None };
    }
    vi = vi + 1;
  }
  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}

fn tc_expr_int(ctx: Ctx, sp: ast.Span, text: String, expected: i32) -> ExprTyResult {
  // Infer integer literal type:
  // - if expected is an integer scalar type, constrain to that type with range check
  // - otherwise, pick i32 if it fits, else i64 if it fits.
  if expected != -1 {
    // Allow implicit deref of `&i32` etc for numeric contexts. Borrow/place
    // requirements are enforced at call/let sites.
    let expected0: i32 = strip_ref(ctx, expected);
    // Range types require an explicit `as` cast.
    let eb: i32 = strip_range_only(ctx, expected0);
    if eb != expected0 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "integer literal requires expected scalar int") }; }

    if expected0 == ctx.ty_u64 || expected0 == ctx.ty_usize {
      let pru: ParseU64DecResult = parse_u64_dec(text);
      if !pru.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "integer literal out of range") }; }
      if expected0 == ctx.ty_u64 { return ExprTyResult { ok: true, ty: ctx.ty_u64, err: TcError.None }; }
      if ctx_is_32bit_ptr(ctx) {
        let pri: ParseI64DecResult = parse_i64_dec(text);
        if !pri.ok || pri.val < 0 || pri.val > ctx_usize_max_i64(ctx) {
          return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "usize literal out of range") };
        }
      }
      return ExprTyResult { ok: true, ty: ctx.ty_usize, err: TcError.None };
    }

    let pr: ParseI64DecResult = parse_i64_dec(text);
    if !pr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "integer literal out of range") }; }
    let v: i64 = pr.val;

    if expected0 == ctx.ty_i8 {
      if v < -128 || v > 127 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "i8 literal out of range") }; }
      return ExprTyResult { ok: true, ty: ctx.ty_i8, err: TcError.None };
    }
    if expected0 == ctx.ty_u8 {
      if v < 0 || v > 255 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "u8 literal out of range") }; }
      return ExprTyResult { ok: true, ty: ctx.ty_u8, err: TcError.None };
    }
    if expected0 == ctx.ty_i16 {
      if v < -32768 || v > 32767 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "i16 literal out of range") }; }
      return ExprTyResult { ok: true, ty: ctx.ty_i16, err: TcError.None };
    }
    if expected0 == ctx.ty_u16 {
      if v < 0 || v > 65535 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "u16 literal out of range") }; }
      return ExprTyResult { ok: true, ty: ctx.ty_u16, err: TcError.None };
    }
    if expected0 == ctx.ty_i32 {
      if v < -2147483648 || v > 2147483647 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "i32 literal out of range") }; }
      return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None };
    }
    if expected0 == ctx.ty_u32 {
      if v < 0 || v > 4294967295 { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "u32 literal out of range") }; }
      return ExprTyResult { ok: true, ty: ctx.ty_u32, err: TcError.None };
    }
    if expected0 == ctx.ty_i64 {
      return ExprTyResult { ok: true, ty: ctx.ty_i64, err: TcError.None };
    }
    if expected0 == ctx.ty_isize {
      if v < ctx_isize_min(ctx) || v > ctx_isize_max(ctx) {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "isize literal out of range") };
      }
      return ExprTyResult { ok: true, ty: ctx.ty_isize, err: TcError.None };
    }
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "integer literal requires expected scalar int") };
  }

  let pr3: ParseI32DecResult = parse_i32_dec(text);
  if pr3.ok { return ExprTyResult { ok: true, ty: ctx.ty_i32, err: TcError.None }; }
  let pr4: ParseI64DecResult = parse_i64_dec(text);
  if pr4.ok { return ExprTyResult { ok: true, ty: ctx.ty_i64, err: TcError.None }; }
  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "integer literal out of range") };
}

fn tc_expr_float(ctx: Ctx, sp: ast.Span, text: String, expected: i32) -> ExprTyResult {
  // Float literal inference:
  // - explicit suffix (`f32`/`f64`) => fixed literal type
  // - otherwise expected f32/f64 => use expected
  // - otherwise default to f64
  let suf: i32 = float_suffix_kind_text(text);
  if suf == 32 || suf == 64 {
    let lit_ty: i32 = if suf == 32 { ctx.ty_f32 } else { ctx.ty_f64 };
    if expected != -1 {
      let expected0: i32 = strip_ref(ctx, expected);
      let eb: i32 = strip_range_only(ctx, expected0);
      if eb != expected0 || !is_float_ty(ctx, eb) {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "float literal requires expected f32/f64") };
      }
      if eb != lit_ty {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "float suffix conflicts with expected type") };
      }
    }
    return ExprTyResult { ok: true, ty: lit_ty, err: TcError.None };
  }
  if expected != -1 {
    let expected0: i32 = strip_ref(ctx, expected);
    if expected0 == ctx.ty_f32 { return ExprTyResult { ok: true, ty: ctx.ty_f32, err: TcError.None }; }
    if expected0 == ctx.ty_f64 { return ExprTyResult { ok: true, ty: ctx.ty_f64, err: TcError.None }; }
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "float literal requires expected f32/f64") };
  }
  return ExprTyResult { ok: true, ty: ctx.ty_f64, err: TcError.None };
}

fn tc_expr_str(ctx: Ctx, expected: i32) -> ExprTyResult {
  if expected != -1 && strip_ref(ctx, expected) != ctx.ty_string { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: ctx.ty_string, err: TcError.None };
}

fn tc_expr_bool(ctx: Ctx, expected: i32) -> ExprTyResult {
  if expected != -1 && expected != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: ctx.ty_bool, err: TcError.None };
}

fn tc_expr_ident(ctx: Ctx, sp: ast.Span, mod_path: String, imps: Imports, l0: Locals, name: String, expected: i32) -> ExprTyResult {
  let vr: LookupVarResult = locals_lookup(l0, name);
  if vr.found {
    if vr.moved { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "use of moved value: ".concat(name)) }; }
    if expected != -1 && !assignable_to(ctx, expected, vr.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: vr.ty, err: TcError.None };
  }
  let cr: LookupConstResult = locals_lookup_const(l0, name);
  if cr.found {
    if expected != -1 && !assignable_to(ctx, expected, cr.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: cr.ty, err: TcError.None };
  }

  // Const reference.
  let ni: NamedConstImport = find_named_const(imps.named_consts, name);
  let want_mod: String = if ni.local != "" { ni.mod_path } else { mod_path };
  let want_name: String = if ni.local != "" { ni.name } else { name };
  let cs: ConstSig = find_const(ctx, want_mod, want_name);
  if cs.name == "" {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "unknown name: ".concat(name)) };
  }
  if !vis_allows(cs.vis, want_mod, mod_path) {
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(sp, "const is private: ".concat(name)) };
  }
  if expected != -1 && !assignable_to(ctx, expected, cs.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: cs.ty, err: TcError.None };
}

fn tc_expr_unary(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, op: ast.UnaryOp, a: i32, expected: i32) -> ExprTyResult {
  let is_not: bool = match op { ast.UnaryOp.Not => true, _ => false };
  let is_pos: bool = match op { ast.UnaryOp.Pos => true, _ => false };
  if is_not {
    let mut a_expected0: i32 = -1;
    if expected != -1 {
      let eb0: i32 = strip_range(ctx, expected);
      if eb0 == ctx.ty_bool {
        a_expected0 = ctx.ty_bool;
      } else if is_int_like_ty(ctx, eb0) {
        a_expected0 = eb0;
      } else {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
      }
    }
    let ar0: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, a, a_expected0);
    if !ar0.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let out0: i32 = strip_range(ctx, ar0.ty);
    if out0 == ctx.ty_bool {
      if expected != -1 && expected != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      return ExprTyResult { ok: true, ty: ctx.ty_bool, err: TcError.None };
    }
    if !is_int_like_ty(ctx, out0) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && !assignable_to(ctx, expected, out0) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: out0, err: TcError.None };
  }
  if is_pos {
    let mut a_expected1: i32 = -1;
    if expected != -1 {
      let eb1: i32 = strip_range(ctx, expected);
      if is_int_like_ty(ctx, eb1) || is_float_ty(ctx, eb1) { a_expected1 = eb1; }
    }
    let ar1: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, a, a_expected1);
    if !ar1.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    let out1: i32 = strip_range(ctx, ar1.ty);
    if !is_int_like_ty(ctx, out1) && !is_float_ty(ctx, out1) {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
    }
    if expected != -1 && !assignable_to(ctx, expected, out1) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: out1, err: TcError.None };
  }
  let mut a_expected: i32 = -1;
  if expected != -1 {
    if is_float_ty(ctx, expected) {
      a_expected = strip_range(ctx, expected);
    }
    let eb: i32 = strip_range(ctx, expected);
    let et: ir.Ty = ir.ty_pool_get(ctx.pool, eb);
    let ok: bool = match et.kind { ir.TyKind.I8 => true, ir.TyKind.I16 => true, ir.TyKind.I32 => true, ir.TyKind.I64 => true, ir.TyKind.ISize => true, _ => false };
    if ok { a_expected = eb; }
  }
  let ar: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, a, a_expected);
  if !ar.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if is_float_ty(ctx, ar.ty) {
    let outf: i32 = strip_range(ctx, ar.ty);
    if expected != -1 && !assignable_to(ctx, expected, outf) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: outf, err: TcError.None };
  }
  // Negation: `-x` is an integer op; ranges widen to base.
  let out: i32 = strip_range(ctx, ar.ty);
  let ot: ir.Ty = ir.ty_pool_get(ctx.pool, out);
  let is_signed_int: bool = match ot.kind { ir.TyKind.I8 => true, ir.TyKind.I16 => true, ir.TyKind.I32 => true, ir.TyKind.I64 => true, ir.TyKind.ISize => true, _ => false };
  if !is_signed_int { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if expected != -1 && !assignable_to(ctx, expected, out) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: out, err: TcError.None };
}

fn enum_unit_tag_in_enum(ctx: Ctx, enum_ty: i32, var_name: String) -> i32 {
  let et: ir.Ty = ir.ty_pool_get(ctx.pool, enum_ty);
  if et.kind != ir.TyKind.Enum { return -1; }
  let fe: FindEnumResult = find_enum(ctx, ty_mod(et), ty_name(et));
  if !fe.found { return -1; }
  let es: EnumSig = fe.sig;
  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != 0 { return -1; }
      return vi;
    }
    vi = vi + 1;
  }
  return -1;
}

fn contains_str_tc_expr(xs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn eq_ty_capable(ctx: Ctx, ty: i32, seen0: Vec[String]) -> bool {
  let base: i32 = strip_range(ctx, ty);
  if base == ctx.ty_bool || base == ctx.ty_string { return true; }
  if is_int_like_ty(ctx, base) || is_float_ty(ctx, base) { return true; }

  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  let is_enum: bool = t.kind == ir.TyKind.Enum;
  let is_struct: bool = t.kind == ir.TyKind.Struct;
  if !is_enum && !is_struct { return false; }

  let kind_prefix: String = if is_enum { "E:" } else { "S:" };
  let qn: String = kind_prefix.concat(ty_mod(t)).concat("::").concat(ty_name(t));
  if contains_str_tc_expr(seen0, qn) { return true; }
  let mut seen: Vec[String] = seen0;
  seen.push(qn);

  if is_struct {
    let fs: FindStructResult = find_struct(ctx, ty_mod(t), ty_name(t));
    if !fs.found { return false; }
    let ss: StructSig = fs.sig;
    let mut fi: i32 = 0;
    while fi < ss.fields.len() {
      if !eq_ty_capable(ctx, ss.fields.get(fi).ty, seen) { return false; }
      fi = fi + 1;
    }
    return true;
  }

  let fe: FindEnumResult = find_enum(ctx, ty_mod(t), ty_name(t));
  if !fe.found { return false; }
  let es: EnumSig = fe.sig;
  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: EnumVariantSig = es.vars.get(vi);
    let mut fi: i32 = 0;
    while fi < v.fields.len() {
      if !eq_ty_capable(ctx, v.fields.get(fi), seen) { return false; }
      fi = fi + 1;
    }
    vi = vi + 1;
  }
  return true;
}

fn is_enum_unit_value(ctx: Ctx, mod_path: String, imps: Imports, exprs: ast.ExprPool, id: i32, enum_ty: i32) -> bool {
  if !is_enum_ty(ctx, enum_ty) { return false; }
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);
  if match n { ast.ExprNode.DotIdent(_x) => true, _ => false } {
    let name: String = match n { ast.ExprNode.DotIdent(s) => s, _ => "" };
    return enum_unit_tag_in_enum(ctx, enum_ty, name) != -1;
  }
  if match n { ast.ExprNode.Call(_c, _targs, _args) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(c, _targs, _args) => c, _ => -1 };
    let targs: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_c, ta, _args) => ta, _ => Vec() };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _ta, a) => a, _ => Vec() };
    if targs.len() == 0 && args.len() == 0 { return is_enum_unit_value(ctx, mod_path, imps, exprs, callee, enum_ty); }
    return false;
  }
  if !match n { ast.ExprNode.Member(_recv, _name) => true, _ => false } { return false; }

  // Only treat path-like member chains as enum unit values (e.g. `E.None` / `alias.E.None`).
  let recv: i32 = match n { ast.ExprNode.Member(r, _name) => r, _ => -1 };
  let name: String = match n { ast.ExprNode.Member(_r, s) => s, _ => "" };
  let pr: ExprPartsResult = expr_parts(exprs, recv);
  if !pr.ok { return false; }
  let mut parts: Vec[String] = pr.parts;
  parts.push(name);
  if parts.len() != 2 && parts.len() != 3 { return false; }

  // Ensure it resolves to the same enum type (avoid accidentally accepting field access that happens to share a name).
  let want_et: ir.Ty = ir.ty_pool_get(ctx.pool, enum_ty);
  let want_mod: String = ty_mod(want_et);
  let want_name: String = ty_name(want_et);

  let mut enum_mod: String = "";
  let mut enum_name: String = "";
  if parts.len() == 2 {
    enum_mod = mod_path;
    enum_name = parts.get(0);
    let ni: NamedTypeImport = find_named_type(imps.named_types, enum_name);
    if ni.local != "" {
      if ni.kind != named_type_kind_enum() { return false; }
      enum_mod = ni.mod_path;
      enum_name = ni.name;
    }
  } else {
    enum_mod = find_alias(imps.aliases, parts.get(0));
    if enum_mod == "" { return false; }
    enum_name = parts.get(1);
  }
  if enum_mod != want_mod || enum_name != want_name { return false; }

  let var_name: String = if parts.len() == 2 { parts.get(1) } else { parts.get(2) };
  return enum_unit_tag_in_enum(ctx, enum_ty, var_name) != -1;
}

fn tc_expr_binary(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, op: ast.BinaryOp, l: i32, r: i32, expected: i32) -> ExprTyResult {
  // bool results
  let is_cmp: bool = match op { ast.BinaryOp.Lt => true, ast.BinaryOp.Le => true, ast.BinaryOp.Gt => true, ast.BinaryOp.Ge => true, _ => false };
  let is_eq: bool = match op { ast.BinaryOp.Eq => true, ast.BinaryOp.Ne => true, _ => false };
  let is_logic: bool = match op { ast.BinaryOp.AndAnd => true, ast.BinaryOp.OrOr => true, _ => false };

  // Use the result expected type as a hint for operand typing when it is a numeric type.
  // This matters for cases like `0 - some_i64` where `0` would otherwise default to i32.
  let mut want_numeric: i32 = -1;
  if expected != -1 {
    let eb: i32 = strip_range(ctx, expected);
    if is_int_like_ty(ctx, eb) || is_float_ty(ctx, eb) { want_numeric = eb; }
  }
  let l_expected: i32 = if is_logic { ctx.ty_bool } else { want_numeric };
  let r_expected0: i32 = if is_logic { ctx.ty_bool } else { want_numeric };

  let mut lr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, l, l_expected);
  if !lr.ok {
    if lr.err != TcError.None { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: lr.err }; }
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(ast.expr_pool_span(exprs, l), "binary lhs typecheck failed") };
  }
  let mut rr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, r, r_expected0);
  if !rr.ok {
    if rr.err != TcError.None { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: rr.err }; }
    return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(ast.expr_pool_span(exprs, r), "binary rhs typecheck failed") };
  }

  // If one side is a numeric literal that defaulted to the wrong width, re-typecheck it
  // using the other side's scalar type.
  if (is_cmp || is_eq || !is_logic) && strip_range(ctx, lr.ty) != strip_range(ctx, rr.ty) {
    let l_is_lit: bool = match ast.expr_pool_get(exprs, l) {
      ast.ExprNode.Int(_s) => true,
      ast.ExprNode.Float(_s) => true,
      ast.ExprNode.Unary(op0, a0) => {
        if op0 == ast.UnaryOp.Neg || op0 == ast.UnaryOp.Pos {
          match ast.expr_pool_get(exprs, a0) {
            ast.ExprNode.Int(_s2) => true,
            ast.ExprNode.Float(_s2) => true,
            _ => false,
          }
        } else { false }
      },
      _ => false,
    };
    let r_is_lit: bool = match ast.expr_pool_get(exprs, r) {
      ast.ExprNode.Int(_s) => true,
      ast.ExprNode.Float(_s) => true,
      ast.ExprNode.Unary(op0, a0) => {
        if op0 == ast.UnaryOp.Neg || op0 == ast.UnaryOp.Pos {
          match ast.expr_pool_get(exprs, a0) {
            ast.ExprNode.Int(_s2) => true,
            ast.ExprNode.Float(_s2) => true,
            _ => false,
          }
        } else { false }
      },
      _ => false,
    };

    let lbase0: i32 = strip_range(ctx, lr.ty);
    let rbase0: i32 = strip_range(ctx, rr.ty);
    if l_is_lit && (is_int_like_ty(ctx, rbase0) || is_float_ty(ctx, rbase0)) {
      lr = tc_expr(ctx, w, mod_path, imps, exprs, l0, l, rbase0);
    } else if r_is_lit && (is_int_like_ty(ctx, lbase0) || is_float_ty(ctx, lbase0)) {
      rr = tc_expr(ctx, w, mod_path, imps, exprs, l0, r, lbase0);
    }
    if !lr.ok {
      if lr.err != TcError.None { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: lr.err }; }
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(ast.expr_pool_span(exprs, l), "binary lhs typecheck failed") };
    }
    if !rr.ok {
      if rr.err != TcError.None { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: rr.err }; }
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: type_error_at(ast.expr_pool_span(exprs, r), "binary rhs typecheck failed") };
    }
  }

  if is_logic {
    if lr.ty != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if expected != -1 && expected != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_bool, err: TcError.None };
  }

  if is_cmp {
    let lbase: i32 = strip_range(ctx, lr.ty);
    let rbase: i32 = strip_range(ctx, rr.ty);
    if lbase != rbase { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    if !is_int_like_ty(ctx, lbase) && !is_float_ty(ctx, lbase) && lbase != ctx.ty_string {
      // Generic ordered comparison is allowed when the type parameter has an
      // explicit Ord bound (local trait path or prelude fallback).
      let lt: ir.Ty = ir.ty_pool_get(ctx.pool, lbase);
      if lt.kind == ir.TyKind.Param {
        let tp: String = lt.name;
        let prelude: String = "std/prelude";
        let has_ord: bool =
          locals_has_type_param_bound(ctx, l0, tp, mod_path, "Ord") ||
          locals_has_type_param_bound(ctx, l0, tp, prelude, "Ord");
        if !has_ord { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      } else {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
      }
    }
    if expected != -1 && expected != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_bool, err: TcError.None };
  }

  if is_eq {
    // Allow equality between a range and its base (compare by base value).
    if strip_range(ctx, rr.ty) != strip_range(ctx, lr.ty) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    // Primitive equality is always allowed; nominal types are handled below.
    let lbase: i32 = strip_range(ctx, lr.ty);
    let lt: ir.Ty = ir.ty_pool_get(ctx.pool, lbase);
    let ok_prim: bool =
      lbase == ctx.ty_bool ||
      lbase == ctx.ty_string ||
      match lt.kind {
        ir.TyKind.I8 => true,
        ir.TyKind.U8 => true,
        ir.TyKind.I16 => true,
        ir.TyKind.U16 => true,
        ir.TyKind.I32 => true,
        ir.TyKind.U32 => true,
        ir.TyKind.I64 => true,
        ir.TyKind.U64 => true,
        ir.TyKind.ISize => true,
        ir.TyKind.USize => true,
        ir.TyKind.F32 => true,
        ir.TyKind.F64 => true,
        _ => false,
      };
    if !ok_prim {
      // Generic type parameter equality is allowed when the type param is
      // explicitly bounded by Eq (local trait or prelude fallback).
      if lt.kind == ir.TyKind.Param {
        let tp: String = lt.name;
        let prelude: String = "std/prelude";
        let has_eq: bool =
          locals_has_type_param_bound(ctx, l0, tp, mod_path, "Eq") ||
          locals_has_type_param_bound(ctx, l0, tp, prelude, "Eq");
        if !has_eq { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        if expected != -1 && expected != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
        return ExprTyResult { ok: true, ty: ctx.ty_bool, err: TcError.None };
      }
      // Nominal equality: recursively allow struct/enum whose fields are equality-capable.
      if is_enum_ty(ctx, lbase) || is_struct_ty(ctx, lbase) {
        if !eq_ty_capable(ctx, lbase, Vec()) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
      } else {
        return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
      }
    }
    if expected != -1 && expected != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_bool, err: TcError.None };
  }

  // arithmetic
  let out: i32 = strip_range(ctx, lr.ty);
  let rbase: i32 = strip_range(ctx, rr.ty);
  if rbase != out { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  let is_bitop: bool = match op { ast.BinaryOp.BitAnd => true, ast.BinaryOp.BitOr => true, ast.BinaryOp.BitXor => true, _ => false };
  if is_bitop && out == ctx.ty_bool {
    if expected != -1 && expected != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
    return ExprTyResult { ok: true, ty: ctx.ty_bool, err: TcError.None };
  }

  let is_mod: bool = match op { ast.BinaryOp.Mod => true, _ => false };
  let int_only: bool = match op {
    ast.BinaryOp.BitAnd => true,
    ast.BinaryOp.BitOr => true,
    ast.BinaryOp.BitXor => true,
    ast.BinaryOp.Shl => true,
    ast.BinaryOp.Shr => true,
    _ => false,
  };
  if int_only {
    if !is_int_like_ty(ctx, out) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  } else if is_mod {
    if !is_int_like_ty(ctx, out) && !is_float_ty(ctx, out) {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
    }
  } else {
    if !is_int_like_ty(ctx, out) && !is_float_ty(ctx, out) {
      return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
    }
  }
  if expected != -1 && !assignable_to(ctx, expected, out) { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  return ExprTyResult { ok: true, ty: out, err: TcError.None };
}

fn tc_expr_if(ctx: Ctx, w: World, mod_path: String, imps: Imports, exprs: ast.ExprPool, l0: Locals, c: i32, t: i32, e: i32, expected: i32) -> ExprTyResult {
  let cr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, c, ctx.ty_bool);
  if !cr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }
  if cr.ty != ctx.ty_bool { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None }; }

  let t_div: bool = expr_definitely_diverges(exprs, t);
  let e_div: bool = expr_definitely_diverges(exprs, e);

  let want: i32 = expected;
  let tr: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, t, want);
  if !tr.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: tr.err }; }
  let er: ExprTyResult = tc_expr(ctx, w, mod_path, imps, exprs, l0, e, want);
  if !er.ok { return ExprTyResult { ok: false, ty: ctx.ty_bad, err: er.err }; }

  if expected != -1 {
    // Branches already checked under `expected`; accept.
    return ExprTyResult { ok: true, ty: expected, err: TcError.None };
  }

  if t_div && !e_div { return ExprTyResult { ok: true, ty: er.ty, err: TcError.None }; }
  if e_div && !t_div { return ExprTyResult { ok: true, ty: tr.ty, err: TcError.None }; }
  if t_div && e_div { return ExprTyResult { ok: true, ty: ctx.ty_unit, err: TcError.None }; }

  if tr.ty == er.ty { return ExprTyResult { ok: true, ty: tr.ty, err: TcError.None }; }

  // Unify `@range(..) <int>` with `<int>` to the base integer type.
  let tbase: i32 = strip_range(ctx, tr.ty);
  let ebase: i32 = strip_range(ctx, er.ty);
  if tbase == ebase && is_int_like_ty(ctx, tbase) {
    return ExprTyResult { ok: true, ty: tbase, err: TcError.None };
  }
  return ExprTyResult { ok: false, ty: ctx.ty_bad, err: TcError.None };
}
