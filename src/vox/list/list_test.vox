import "std/testing" as t
import "vox/loader" as ld
import "vox/list" as lst

fn contains(s: String, part: String) -> bool {
  if part.len() == 0 { return true; }
  if s.len() < part.len() { return false; }
  let mut i: i32 = 0;
  while i + part.len() <= s.len() {
    if s.slice(i, i + part.len()) == part { return true; }
    i = i + 1;
  }
  return false;
}

fn test_list_graph_from_files_smoke() -> () {
  let mut files: Vec[ld.SourceFile] = Vec();
  files.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"util\"\nfn main() -> i32 { return util.one(); }",
  });
  files.push(ld.SourceFile { path: "src/util/u.vox", text: "pub fn one() -> i32 { return 1; }" });

  let r: lst.BuildResult = lst.graph_from_files(files);
  t.assert_with(r.ok, r.err);
  t.assert_eq(r.graph.modules.len(), 2);
  t.assert_eq(r.graph.edges.len(), 1);
  t.assert_eq(r.graph.edges.get(0).from_mod, "main");
  t.assert_eq(r.graph.edges.get(0).to_mod, "util");
}

fn test_list_graph_named_import_edge_smoke() -> () {
  let mut files: Vec[ld.SourceFile] = Vec();
  files.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import { one } from \"util\"\nfn main() -> i32 { return one(); }",
  });
  files.push(ld.SourceFile { path: "src/util/u.vox", text: "pub fn one() -> i32 { return 1; }" });

  let r: lst.BuildResult = lst.graph_from_files(files);
  t.assert_with(r.ok, r.err);
  t.assert_eq(r.graph.edges.len(), 1);
  t.assert_eq(r.graph.edges.get(0).from_mod, "main");
  t.assert_eq(r.graph.edges.get(0).to_mod, "util");
}

fn test_list_graph_json_and_text_output() -> () {
  let mut files: Vec[ld.SourceFile] = Vec();
  files.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"util\"\nfn main() -> i32 { return util.one(); }",
  });
  files.push(ld.SourceFile { path: "src/util/u.vox", text: "pub fn one() -> i32 { return 1; }" });

  let r: lst.BuildResult = lst.graph_from_files(files);
  t.assert_with(r.ok, r.err);

  let j: String = lst.graph_to_json(r.graph);
  t.assert(contains(j, "\"modules\""));
  t.assert(contains(j, "\"edges\""));
  t.assert(contains(j, "\"from\":\"main\""));

  let txt: String = lst.graph_to_text(r.graph);
  t.assert(contains(txt, "[module] main"));
  t.assert(contains(txt, "[edge] main -> util"));
}

fn test_list_graph_loader_error_meta() -> () {
  let mut files: Vec[ld.SourceFile] = Vec();
  files.push(ld.SourceFile { path: "README.vox", text: "fn main() -> i32 { return 0; }" });

  let r: lst.BuildResult = lst.graph_from_files(files);
  t.assert(!r.ok);
  t.assert_eq(r.err_kind, lst.list_diag_kind_loader());
}
