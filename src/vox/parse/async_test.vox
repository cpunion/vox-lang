import "std/testing" as t
import "vox/parse" as p
import "vox/ast" as ast

fn ok(e: p.ParseError) -> bool {
  return e == p.ParseError.None;
}

fn test_parse_async_fn_marks_flag_smoke() -> () {
  let r: p.ParseResult = p.parse_text("async fn main() -> i32 { return 0; }");
  t.assert(ok(r.err));
  t.assert_eq(r.prog.funcs.len(), 1);
  let fd: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert(fd.is_async);
  t.assert_eq(fd.name, "main");
}

fn test_parse_await_expr_builds_await_node() -> () {
  let src: String = "fn main() -> i32 { let x: i32 = await 1; return x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ty, id) => id, _ => -1 };
  let n0: ast.ExprNode = ast.expr_pool_get(r.prog.exprs, init);
  let ok_await: bool = match n0 {
    ast.ExprNode.Await(inner) => match ast.expr_pool_get(r.prog.exprs, inner) {
      ast.ExprNode.Int(v) => v == "1",
      _ => false,
    },
    _ => false,
  };
  t.assert(ok_await);
}

fn test_parse_postfix_await_expr_builds_await_node() -> () {
  let src: String = "fn main() -> i32 { let x: i32 = f().await; return x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ty, id) => id, _ => -1 };
  let n0: ast.ExprNode = ast.expr_pool_get(r.prog.exprs, init);
  let ok_await: bool = match n0 {
    ast.ExprNode.Await(inner) => match ast.expr_pool_get(r.prog.exprs, inner) {
      ast.ExprNode.Call(callee, _targs, args) =>
        args.len() == 0 &&
        match ast.expr_pool_get(r.prog.exprs, callee) {
          ast.ExprNode.Ident(name) => name == "f",
          _ => false,
        },
      _ => false,
    },
    _ => false,
  };
  t.assert(ok_await);
}

fn test_parse_postfix_await_then_try_parses_as_try_of_await() -> () {
  let src: String = "fn main() -> i32 { let x: i32 = f().await?; return x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ty, id) => id, _ => -1 };
  let n0: ast.ExprNode = ast.expr_pool_get(r.prog.exprs, init);
  let ok_shape: bool = match n0 {
    ast.ExprNode.Try(inner) => match ast.expr_pool_get(r.prog.exprs, inner) {
      ast.ExprNode.Await(a) => match ast.expr_pool_get(r.prog.exprs, a) {
        ast.ExprNode.Call(callee, _targs, args) =>
          args.len() == 0 &&
          match ast.expr_pool_get(r.prog.exprs, callee) {
            ast.ExprNode.Ident(name) => name == "f",
            _ => false,
          },
        _ => false,
      },
      _ => false,
    },
    _ => false,
  };
  t.assert(ok_shape);
}

fn test_parse_async_trait_method_is_deferred_error() -> () {
  let src: String = "trait T { async fn f() -> i32; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!ok(r.err));
  let msg: String = p.parse_error_to_string(r.err);
  t.assert(contains(msg, "async trait method is deferred"));
}
