import "std/testing" as t
import "vox/parse" as p
import "vox/ast" as ast

fn resource_parse_ok(e: p.ParseError) -> bool { return e == p.ParseError.None; }

fn test_parse_resource_attr_read_smoke() -> () {
  let src: String = "@resource(read, Fs)\nfn read() -> i32 { return 1; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(resource_parse_ok(r.err));
  t.assert_eq(r.prog.funcs.len(), 1);
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  t.assert_eq(f.resources.len(), 1);
  t.assert_eq(f.resources.get(0).kind, ast.resource_read());
  t.assert_eq(f.resources.get(0).name, "Fs");
}

fn test_parse_resource_attr_write_string_smoke() -> () {
  let src: String = "@resource(write, \"Db\")\nfn write() -> i32 { return 1; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(resource_parse_ok(r.err));
  t.assert_eq(r.prog.funcs.get(0).resources.len(), 1);
  t.assert_eq(r.prog.funcs.get(0).resources.get(0).kind, ast.resource_write());
  t.assert_eq(r.prog.funcs.get(0).resources.get(0).name, "Db");
}

fn test_parse_resource_attr_bad_args_rejected() -> () {
  let src: String = "@resource(read)\nfn read() -> i32 { return 1; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!resource_parse_ok(r.err));
  t.assert(contains(p.parse_error_to_string(r.err), "bad resource attribute arguments"));
}

fn test_parse_resource_attr_bad_mode_rejected() -> () {
  let src: String = "@resource(exec, Fs)\nfn read() -> i32 { return 1; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!resource_parse_ok(r.err));
  t.assert(contains(p.parse_error_to_string(r.err), "bad resource attribute arguments"));
}

fn test_parse_resource_attr_on_trait_method_smoke() -> () {
  let src: String = "trait R { @resource(read, Fs) fn read(x: Self) -> i32; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(resource_parse_ok(r.err));
  t.assert_eq(r.prog.traits.len(), 1);
  let td: ast.TraitDecl = r.prog.traits.get(0);
  t.assert_eq(td.methods.get(0).resources.len(), 1);
  t.assert_eq(td.methods.get(0).resources.get(0).kind, ast.resource_read());
  t.assert_eq(td.methods.get(0).resources.get(0).name, "Fs");
}

fn test_parse_resource_attr_on_impl_method_smoke() -> () {
  let src: String = """
    struct I { v: i32 }
    impl I { @resource(write, Fs) fn write(x: I) -> i32 { return x.v; } }
    fn main() -> i32 { return 0; }
  """;
  let r: p.ParseResult = p.parse_text(src);
  t.assert(resource_parse_ok(r.err));
  t.assert_eq(r.prog.impls.len(), 1);
  let id: ast.ImplDecl = r.prog.impls.get(0);
  t.assert_eq(id.methods.get(0).resources.len(), 1);
  t.assert_eq(id.methods.get(0).resources.get(0).kind, ast.resource_write());
  t.assert_eq(id.methods.get(0).resources.get(0).name, "Fs");
}
