import "std/testing" as t
import "vox/parse" as p
import "vox/ast" as ast

fn test_parse_char_literal_lowers_to_int_expr() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> u32 { return 'A'; }");
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st: ast.Stmt = f.body.stmts.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match st {
    ast.Stmt.ReturnStmt(_sp, has, id) =>
      has && match ast.expr_pool_get(exprs, id) { ast.ExprNode.Int(v) => v == "65", _ => false },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_char_literal_escape_lowers_to_int_expr() -> () {
  let r: p.ParseResult = p.parse_text("fn main() -> u32 { return '\\n'; }");
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st: ast.Stmt = f.body.stmts.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match st {
    ast.Stmt.ReturnStmt(_sp, has, id) =>
      has && match ast.expr_pool_get(exprs, id) { ast.ExprNode.Int(v) => v == "10", _ => false },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_char_pattern_lowers_to_int_pattern() -> () {
  let src: String = "fn f(c: u32) -> i32 { return match c { 'a' => 1, _ => 0 }; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(ok(r.err));
  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st: ast.Stmt = f.body.stmts.get(0);
  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match st {
    ast.Stmt.ReturnStmt(_sp, has, id) =>
      has && match ast.expr_pool_get(exprs, id) {
        ast.ExprNode.Match(_scrut, arms) =>
          arms.len() == 2 &&
          match arms.get(0).pat { ast.Pat.Int(_sp2, text) => text == "97", _ => false },
        _ => false,
      },
    _ => false,
  };
  t.assert(ok0);
}
