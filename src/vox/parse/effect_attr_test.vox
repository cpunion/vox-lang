import "std/testing" as t
import "vox/parse" as p

fn effect_parse_ok(e: p.ParseError) -> bool {
  return e == p.ParseError.None;
}

fn test_parse_effect_attr_ident_smoke() -> () {
  let src: String = "@effect(FsRead)\nfn read() -> i32 { return 1; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(effect_parse_ok(r.err));
  t.assert_eq(r.prog.funcs.len(), 1);

  let f = r.prog.funcs.get(0);
  t.assert_eq(f.name, "read");
  t.assert_eq(f.effects.len(), 1);
  t.assert_eq(f.effects.get(0).name, "FsRead");
}

fn test_parse_effect_attr_string_smoke() -> () {
  let src: String = "@effect(\"Net\")\nfn dial() -> i32 { return 1; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(effect_parse_ok(r.err));
  t.assert_eq(r.prog.funcs.len(), 1);
  t.assert_eq(r.prog.funcs.get(0).effects.len(), 1);
  t.assert_eq(r.prog.funcs.get(0).effects.get(0).name, "Net");
}

fn test_parse_effect_attr_bad_args_rejected() -> () {
  let src: String = "@effect()\nfn read() -> i32 { return 1; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!effect_parse_ok(r.err));
  t.assert(contains(p.parse_error_to_string(r.err), "bad effect attribute arguments"));
}

fn test_parse_effect_attr_must_precede_fn() -> () {
  let src: String = "@effect(FsRead)\nstruct S { x: i32 }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!effect_parse_ok(r.err));
  t.assert(contains(p.parse_error_to_string(r.err), "expected fn"));
}

fn test_parse_effect_attr_on_trait_method_smoke() -> () {
  let src: String = "trait R { @effect(FsRead) fn read(x: Self) -> i32; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(effect_parse_ok(r.err));
  t.assert_eq(r.prog.traits.len(), 1);
  let td = r.prog.traits.get(0);
  t.assert_eq(td.methods.len(), 1);
  t.assert_eq(td.methods.get(0).effects.len(), 1);
  t.assert_eq(td.methods.get(0).effects.get(0).name, "FsRead");
}

fn test_parse_effect_attr_on_impl_method_smoke() -> () {
  let src: String = """
    struct I { v: i32 }
    impl I { @effect(FsRead) fn read(x: I) -> i32 { return x.v; } }
    fn main() -> i32 { return 0; }
  """;
  let r: p.ParseResult = p.parse_text(src);
  t.assert(effect_parse_ok(r.err));
  t.assert_eq(r.prog.impls.len(), 1);
  let id = r.prog.impls.get(0);
  t.assert_eq(id.methods.len(), 1);
  t.assert_eq(id.methods.get(0).effects.len(), 1);
  t.assert_eq(id.methods.get(0).effects.get(0).name, "FsRead");
}

fn test_parse_ffi_attr_on_trait_method_rejected() -> () {
  let src: String = "trait R { @ffi_import(\"c\", \"puts\") fn read(x: Self) -> i32; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!effect_parse_ok(r.err));
  t.assert(contains(p.parse_error_to_string(r.err), "ffi attributes are only allowed on top-level fn"));
}

fn test_parse_ffi_attr_on_impl_method_rejected() -> () {
  let src: String = "struct I { v: i32 }\nimpl I { @ffi_export(\"c\", \"x\") fn read(x: I) -> i32 { return x.v; } }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!effect_parse_ok(r.err));
  t.assert(contains(p.parse_error_to_string(r.err), "ffi attributes are only allowed on top-level fn"));
}
