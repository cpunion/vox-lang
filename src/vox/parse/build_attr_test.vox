import "std/testing" as t
import "vox/parse" as p

fn build_parse_ok(e: p.ParseError) -> bool {
  return e == p.ParseError.None;
}

fn test_parse_build_attr_file_scope_smoke() -> () {
  let src: String = """
@build(unix && (linux || darwin) && amd64)
fn f() -> i32 { return 1; }
""";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(build_parse_ok(r.err));
  t.assert_eq(r.prog.file_builds.len(), 1);
  t.assert_eq(r.prog.file_builds.get(0).expr, "unix&&(linux||darwin)&&amd64");
}

fn test_parse_build_attr_multiple_and_combined() -> () {
  let src: String = """
@build(unix)
@build(amd64)
fn f() -> i32 { return 1; }
""";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(build_parse_ok(r.err));
  t.assert_eq(r.prog.file_builds.len(), 2);
  t.assert_eq(r.prog.file_builds.get(0).expr, "unix");
  t.assert_eq(r.prog.file_builds.get(1).expr, "amd64");
}

fn test_parse_build_attr_bad_expr_rejected() -> () {
  let src: String = """
@build(unix &&)
fn f() -> i32 { return 1; }
""";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!build_parse_ok(r.err));
  t.assert(contains(p.parse_error_to_string(r.err), "bad build attribute expression"));
}

fn test_parse_build_attr_on_fn_rejected() -> () {
  let src: String = """
fn main() -> i32 { return 0; }
@build(unix)
fn f() -> i32 { return 1; }
""";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!build_parse_ok(r.err));
  t.assert(contains(p.parse_error_to_string(r.err), "build attribute is only allowed at file scope"));
}
