import "std/testing" as t
import "vox/parse" as p
import "vox/ast" as ast

fn test_parse_range_type_alias_decl() -> () {
  let src: String = "type Tiny = @range(0..=3) i32\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  t.assert_eq(r.prog.types.len(), 1);
  let td: ast.TypeAliasDecl = r.prog.types.get(0);
  t.assert_eq(td.name, "Tiny");
  t.assert_eq(td.ty.parts.len(), 3);
  t.assert(td.ty.parts.get(0) == "@range");
  t.assert(td.ty.parts.get(1) == "0");
  t.assert(td.ty.parts.get(2) == "3");
  t.assert_eq(td.ty.args.len(), 1);
  t.assert(td.ty.args.get(0).parts.len() == 1 && td.ty.args.get(0).parts.get(0) == "i32");
}

fn test_parse_range_type_alias_decl_negative_bounds() -> () {
  let src: String = "type Small = @range(-5..=5) i32\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  t.assert_eq(r.prog.types.len(), 1);
  let td: ast.TypeAliasDecl = r.prog.types.get(0);
  t.assert_eq(td.name, "Small");
  t.assert_eq(td.ty.parts.len(), 3);
  t.assert(td.ty.parts.get(0) == "@range");
  t.assert(td.ty.parts.get(1) == "-5");
  t.assert(td.ty.parts.get(2) == "5");
  t.assert_eq(td.ty.args.len(), 1);
  t.assert(td.ty.args.get(0).parts.len() == 1 && td.ty.args.get(0).parts.get(0) == "i32");
}

fn test_parse_range_type_alias_decl_char_bounds_smoke() -> () {
  let src: String = "type Lower = @range('a'..='z') char\nfn main() -> u32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  t.assert_eq(r.prog.types.len(), 1);
  let td: ast.TypeAliasDecl = r.prog.types.get(0);
  t.assert_eq(td.name, "Lower");
  t.assert_eq(td.ty.parts.len(), 3);
  t.assert(td.ty.parts.get(0) == "@range");
  t.assert(td.ty.parts.get(1) == "97");
  t.assert(td.ty.parts.get(2) == "122");
  t.assert_eq(td.ty.args.len(), 1);
  t.assert(td.ty.args.get(0).parts.len() == 1 && td.ty.args.get(0).parts.get(0) == "char");
}

fn test_parse_range_type_alias_decl_char_escape_bounds_smoke() -> () {
  let src: String = "type C0 = @range('\\n'..='\\r') char\nfn main() -> u32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  t.assert_eq(r.prog.types.len(), 1);
  let td: ast.TypeAliasDecl = r.prog.types.get(0);
  t.assert_eq(td.name, "C0");
  t.assert_eq(td.ty.parts.len(), 3);
  t.assert(td.ty.parts.get(0) == "@range");
  t.assert(td.ty.parts.get(1) == "10");
  t.assert(td.ty.parts.get(2) == "13");
}

fn test_parse_range_type_alias_decl_u32() -> () {
  let src: String = "type Tiny = @range(0..=3) u32\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  t.assert_eq(r.prog.types.len(), 1);
  let td: ast.TypeAliasDecl = r.prog.types.get(0);
  t.assert_eq(td.name, "Tiny");
  t.assert_eq(td.ty.parts.len(), 3);
  t.assert(td.ty.parts.get(0) == "@range");
  t.assert(td.ty.parts.get(1) == "0");
  t.assert(td.ty.parts.get(2) == "3");
  t.assert_eq(td.ty.args.len(), 1);
  t.assert(td.ty.args.get(0).parts.len() == 1 && td.ty.args.get(0).parts.get(0) == "u32");
}

fn test_parse_range_type_alias_decl_i8() -> () {
  let src: String = "type Tiny = @range(0..=3) i8\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  t.assert_eq(r.prog.types.len(), 1);
  let td: ast.TypeAliasDecl = r.prog.types.get(0);
  t.assert_eq(td.name, "Tiny");
  t.assert_eq(td.ty.parts.len(), 3);
  t.assert(td.ty.parts.get(0) == "@range");
  t.assert(td.ty.parts.get(1) == "0");
  t.assert(td.ty.parts.get(2) == "3");
  t.assert_eq(td.ty.args.len(), 1);
  t.assert(td.ty.args.get(0).parts.len() == 1 && td.ty.args.get(0).parts.get(0) == "i8");
}

fn test_parse_range_type_alias_decl_u8() -> () {
  let src: String = "type Tiny = @range(0..=3) u8\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  t.assert_eq(r.prog.types.len(), 1);
  let td: ast.TypeAliasDecl = r.prog.types.get(0);
  t.assert_eq(td.name, "Tiny");
  t.assert_eq(td.ty.parts.len(), 3);
  t.assert(td.ty.parts.get(0) == "@range");
  t.assert(td.ty.parts.get(1) == "0");
  t.assert(td.ty.parts.get(2) == "3");
  t.assert_eq(td.ty.args.len(), 1);
  t.assert(td.ty.args.get(0).parts.len() == 1 && td.ty.args.get(0).parts.get(0) == "u8");
}

fn test_parse_range_type_alias_decl_u64() -> () {
  let src: String = "type Tiny = @range(0..=3) u64\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  t.assert_eq(r.prog.types.len(), 1);
  let td: ast.TypeAliasDecl = r.prog.types.get(0);
  t.assert_eq(td.name, "Tiny");
  t.assert_eq(td.ty.parts.len(), 3);
  t.assert(td.ty.parts.get(0) == "@range");
  t.assert(td.ty.parts.get(1) == "0");
  t.assert(td.ty.parts.get(2) == "3");
  t.assert_eq(td.ty.args.len(), 1);
  t.assert(td.ty.args.get(0).parts.len() == 1 && td.ty.args.get(0).parts.get(0) == "u64");
}

fn test_parse_range_type_alias_decl_isize() -> () {
  let src: String = "type Tiny = @range(-3..=3) isize\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  t.assert_eq(r.prog.types.len(), 1);
  let td: ast.TypeAliasDecl = r.prog.types.get(0);
  t.assert_eq(td.name, "Tiny");
  t.assert_eq(td.ty.parts.len(), 3);
  t.assert(td.ty.parts.get(0) == "@range");
  t.assert(td.ty.parts.get(1) == "-3");
  t.assert(td.ty.parts.get(2) == "3");
  t.assert_eq(td.ty.args.len(), 1);
  t.assert(td.ty.args.get(0).parts.len() == 1 && td.ty.args.get(0).parts.get(0) == "isize");
}

fn test_parse_range_type_alias_decl_usize() -> () {
  let src: String = "type Tiny = @range(0..=3) usize\nfn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  t.assert_eq(r.prog.types.len(), 1);
  let td: ast.TypeAliasDecl = r.prog.types.get(0);
  t.assert_eq(td.name, "Tiny");
  t.assert_eq(td.ty.parts.len(), 3);
  t.assert(td.ty.parts.get(0) == "@range");
  t.assert(td.ty.parts.get(1) == "0");
  t.assert(td.ty.parts.get(2) == "3");
  t.assert_eq(td.ty.args.len(), 1);
  t.assert(td.ty.args.get(0).parts.len() == 1 && td.ty.args.get(0).parts.get(0) == "usize");
}

fn test_parse_verified_type_alias_decl() -> () {
  let src: String = """
fn in_range(x: i32) -> bool { return x >= 0 && x <= 10; }
type Safe = @verified(in_range) i32
fn main() -> i32 { return 0; }
""";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  t.assert_eq(r.prog.types.len(), 1);
  let td: ast.TypeAliasDecl = r.prog.types.get(0);
  t.assert_eq(td.name, "Safe");
  t.assert_eq(td.ty.parts.len(), 2);
  t.assert(td.ty.parts.get(0) == "@verified");
  t.assert(td.ty.parts.get(1) == "in_range");
  t.assert_eq(td.ty.args.len(), 1);
  t.assert(td.ty.args.get(0).parts.len() == 1 && td.ty.args.get(0).parts.get(0) == "i32");
}

fn test_parse_verified_type_alias_decl_module_alias_ref() -> () {
  let src: String = """
import "util" as u
type Safe = @verified(u.check) i32
fn main() -> i32 { return 0; }
""";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  t.assert_eq(r.prog.types.len(), 1);
  let td: ast.TypeAliasDecl = r.prog.types.get(0);
  t.assert_eq(td.name, "Safe");
  t.assert_eq(td.ty.parts.len(), 2);
  t.assert(td.ty.parts.get(0) == "@verified");
  t.assert(td.ty.parts.get(1) == "u.check");
}
