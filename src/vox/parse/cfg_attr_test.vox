import "std/testing" as t
import "vox/parse" as p

fn cfg_parse_ok(e: p.ParseError) -> bool {
  return e == p.ParseError.None;
}

fn test_parse_cfg_attr_target_os_smoke() -> () {
  let src: String = "@cfg(target_os, linux)\nfn f() -> i32 { return 1; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(cfg_parse_ok(r.err));
  t.assert_eq(r.prog.funcs.len(), 1);
  let f = r.prog.funcs.get(0);
  t.assert_eq(f.cfgs.len(), 1);
  t.assert_eq(f.cfgs.get(0).key, "target_os");
  t.assert_eq(f.cfgs.get(0).value, "linux");
}

fn test_parse_cfg_attr_target_ptr_bits_int_smoke() -> () {
  let src: String = "@cfg(target_ptr_bits, 64)\nfn f() -> i32 { return 1; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(cfg_parse_ok(r.err));
  t.assert_eq(r.prog.funcs.len(), 1);
  let f = r.prog.funcs.get(0);
  t.assert_eq(f.cfgs.len(), 1);
  t.assert_eq(f.cfgs.get(0).key, "target_ptr_bits");
  t.assert_eq(f.cfgs.get(0).value, "64");
}

fn test_parse_cfg_attr_bad_args_rejected() -> () {
  let src: String = "@cfg(target_env, gnu)\nfn f() -> i32 { return 1; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!cfg_parse_ok(r.err));
  t.assert(contains(p.parse_error_to_string(r.err), "bad cfg attribute arguments"));
}

fn test_parse_cfg_attr_on_trait_method_rejected() -> () {
  let src: String = "trait R { @cfg(target_os, linux) fn f(x: Self) -> i32; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!cfg_parse_ok(r.err));
  t.assert(contains(p.parse_error_to_string(r.err), "cfg attribute is only allowed on top-level fn"));
}

fn test_parse_cfg_attr_on_impl_method_rejected() -> () {
  let src: String = "struct I { v: i32 }\nimpl I { @cfg(target_os, linux) fn f(x: I) -> i32 { return x.v; } }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(!cfg_parse_ok(r.err));
  t.assert(contains(p.parse_error_to_string(r.err), "cfg attribute is only allowed on top-level fn"));
}
