import "std/testing" as t
import "vox/parse" as p
import "vox/ast" as ast

fn test_parse_precedence_or_and() -> () {
  let src: String = "fn main() -> i32 { let x: bool = true || false && false; return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  t.assert(init != -1);

  let exprs: ast.ExprPool = r.prog.exprs;
  let n0: ast.ExprNode = ast.expr_pool_get(exprs, init);
  let ok0: bool = match n0 {
    ast.ExprNode.Binary(op0, l0, r0) =>
      match op0 { ast.BinaryOp.OrOr => true, _ => false } &&
        match ast.expr_pool_get(exprs, l0) { ast.ExprNode.Bool(b) => b == true, _ => false } &&
        match ast.expr_pool_get(exprs, r0) {
          ast.ExprNode.Binary(op1, a, b) =>
            match op1 { ast.BinaryOp.AndAnd => true, _ => false } &&
              match ast.expr_pool_get(exprs, a) { ast.ExprNode.Bool(x) => x == false, _ => false } &&
              match ast.expr_pool_get(exprs, b) { ast.ExprNode.Bool(y) => y == false, _ => false },
          _ => false,
        },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_precedence_mul_add() -> () {
  let src: String = "fn main() -> i32 { let x: i32 = 1 + 2 * 3; return x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  t.assert(init != -1);

  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.Binary(op0, l0, r0) =>
      match op0 { ast.BinaryOp.Add => true, _ => false } &&
        match ast.expr_pool_get(exprs, l0) { ast.ExprNode.Int(v) => v == "1", _ => false } &&
        match ast.expr_pool_get(exprs, r0) {
          ast.ExprNode.Binary(op1, a, b) =>
            match op1 { ast.BinaryOp.Mul => true, _ => false } &&
              match ast.expr_pool_get(exprs, a) { ast.ExprNode.Int(v) => v == "2", _ => false } &&
              match ast.expr_pool_get(exprs, b) { ast.ExprNode.Int(v) => v == "3", _ => false },
          _ => false,
        },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_precedence_parens() -> () {
  let src: String = "fn main() -> i32 { let x: bool = (true || false) && false; if x { return 1; } return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  t.assert(init != -1);

  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.Binary(op0, l0, r0) =>
      match op0 { ast.BinaryOp.AndAnd => true, _ => false } &&
        match ast.expr_pool_get(exprs, l0) {
          ast.ExprNode.Binary(op1, a, b) =>
            match op1 { ast.BinaryOp.OrOr => true, _ => false } &&
              match ast.expr_pool_get(exprs, a) { ast.ExprNode.Bool(x) => x == true, _ => false } &&
              match ast.expr_pool_get(exprs, b) { ast.ExprNode.Bool(y) => y == false, _ => false },
          _ => false,
        } &&
        match ast.expr_pool_get(exprs, r0) { ast.ExprNode.Bool(z) => z == false, _ => false },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_precedence_unary_binds_tighter_than_and() -> () {
  let src: String = "fn main() -> i32 { let x: bool = !true && false; if x { return 1; } return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  t.assert(init != -1);

  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.Binary(op0, l0, r0) =>
      match op0 { ast.BinaryOp.AndAnd => true, _ => false } &&
        match ast.expr_pool_get(exprs, l0) {
          ast.ExprNode.Unary(uop, a) =>
            match uop { ast.UnaryOp.Not => true, _ => false } &&
              match ast.expr_pool_get(exprs, a) { ast.ExprNode.Bool(x) => x == true, _ => false },
          _ => false,
        } &&
        match ast.expr_pool_get(exprs, r0) { ast.ExprNode.Bool(y) => y == false, _ => false },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_precedence_unary_plus_binds_tighter_than_mul() -> () {
  let src: String = "fn main() -> i32 { let x: i32 = +1 * 2; return x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  t.assert(init != -1);

  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.Binary(op0, l0, r0) =>
      match op0 { ast.BinaryOp.Mul => true, _ => false } &&
        match ast.expr_pool_get(exprs, l0) {
          ast.ExprNode.Unary(uop, a) =>
            match uop { ast.UnaryOp.Pos => true, _ => false } &&
              match ast.expr_pool_get(exprs, a) { ast.ExprNode.Int(x) => x == "1", _ => false },
          _ => false,
        } &&
        match ast.expr_pool_get(exprs, r0) { ast.ExprNode.Int(y) => y == "2", _ => false },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_left_associative_sub() -> () {
  let src: String = "fn main() -> i32 { let x: i32 = 1 - 2 - 3; return x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  t.assert(init != -1);

  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.Binary(op0, l0, r0) =>
      match op0 { ast.BinaryOp.Sub => true, _ => false } &&
        match ast.expr_pool_get(exprs, r0) { ast.ExprNode.Int(v) => v == "3", _ => false } &&
        match ast.expr_pool_get(exprs, l0) {
          ast.ExprNode.Binary(op1, a, b) =>
            match op1 { ast.BinaryOp.Sub => true, _ => false } &&
              match ast.expr_pool_get(exprs, a) { ast.ExprNode.Int(v) => v == "1", _ => false } &&
              match ast.expr_pool_get(exprs, b) { ast.ExprNode.Int(v) => v == "2", _ => false },
          _ => false,
        },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_precedence_as_binds_tighter_than_add() -> () {
  let src: String = "fn main() -> i32 { let x: i64 = 1 + 2 as i64; return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  t.assert(init != -1);

  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.Binary(op0, l0, r0) =>
      match op0 { ast.BinaryOp.Add => true, _ => false } &&
        match ast.expr_pool_get(exprs, l0) { ast.ExprNode.Int(v) => v == "1", _ => false } &&
        match ast.expr_pool_get(exprs, r0) {
          ast.ExprNode.As(a, tn) =>
            match ast.expr_pool_get(exprs, a) { ast.ExprNode.Int(v) => v == "2", _ => false } &&
              tn.parts.len() == 1 && tn.parts.get(0) == "i64" && tn.args.len() == 0,
          _ => false,
        },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_precedence_shift_lower_than_add() -> () {
  let src: String = "fn main() -> i32 { let x: i32 = 1 + 2 << 3; return x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  t.assert(init != -1);

  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.Binary(op0, l0, r0) =>
      match op0 { ast.BinaryOp.Shl => true, _ => false } &&
        match ast.expr_pool_get(exprs, l0) {
          ast.ExprNode.Binary(op1, a, b) =>
            match op1 { ast.BinaryOp.Add => true, _ => false } &&
              match ast.expr_pool_get(exprs, a) { ast.ExprNode.Int(v) => v == "1", _ => false } &&
              match ast.expr_pool_get(exprs, b) { ast.ExprNode.Int(v) => v == "2", _ => false },
          _ => false,
        } &&
        match ast.expr_pool_get(exprs, r0) { ast.ExprNode.Int(v) => v == "3", _ => false },
    _ => false,
  };
  t.assert(ok0);
}

fn test_parse_precedence_bitwise_chain() -> () {
  let src: String = "fn main() -> i32 { let x: i32 = 1 | 2 ^ 3 & 4; return x; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);

  let f: ast.FuncDecl = r.prog.funcs.get(0);
  let st0: ast.Stmt = f.body.stmts.get(0);
  let init: i32 = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, id) => id, _ => -1 };
  t.assert(init != -1);

  let exprs: ast.ExprPool = r.prog.exprs;
  let ok0: bool = match ast.expr_pool_get(exprs, init) {
    ast.ExprNode.Binary(op0, l0, r0) =>
      match op0 { ast.BinaryOp.BitOr => true, _ => false } &&
        match ast.expr_pool_get(exprs, l0) { ast.ExprNode.Int(v) => v == "1", _ => false } &&
        match ast.expr_pool_get(exprs, r0) {
          ast.ExprNode.Binary(op1, a, b) =>
            match op1 { ast.BinaryOp.BitXor => true, _ => false } &&
              match ast.expr_pool_get(exprs, a) { ast.ExprNode.Int(v) => v == "2", _ => false } &&
              match ast.expr_pool_get(exprs, b) {
                ast.ExprNode.Binary(op2, c, d) =>
                  match op2 { ast.BinaryOp.BitAnd => true, _ => false } &&
                    match ast.expr_pool_get(exprs, c) { ast.ExprNode.Int(v) => v == "3", _ => false } &&
                    match ast.expr_pool_get(exprs, d) { ast.ExprNode.Int(v) => v == "4", _ => false },
                _ => false,
              },
          _ => false,
        },
    _ => false,
  };
  t.assert(ok0);
}
