import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc
import "vox/macroexpand" as mx
import "vox/ast" as ast

fn me_contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn me_has_suffix(s: String, suf: String) -> bool {
  if s.len() < suf.len() { return false; }
  return s.slice(s.len() - suf.len(), s.len()) == suf;
}

fn me_notes_contains(notes: Vec[String], needle: String) -> bool {
  let mut i: i32 = 0;
  while i < notes.len() {
    if me_contains(notes.get(i), needle) { return true; }
    i = i + 1;
  }
  return false;
}

fn me_world_from(path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text_with_path("src/main.vox", src);
  t.assert(r.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, path, r.prog);
  return w;
}

fn me_world_add(w: tc.World, path: String, src: String) -> tc.World {
  let r: p.ParseResult = p.parse_text_with_path("src/main.vox", src);
  t.assert(r.err == p.ParseError.None);
  return tc.world_add(w, path, r.prog);
}

fn me_main_return_expr_node(w: tc.World, mod_path: String) -> ast.ExprNode {
  return me_func_return_expr_node(w, mod_path, "main");
}

fn me_func_return_expr_node(w: tc.World, mod_path: String, fn_name: String) -> ast.ExprNode {
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let wm: tc.WorldModule = w.mods.get(mi);
    if wm.path == mod_path {
      let mut fi: i32 = 0;
      while fi < wm.prog.funcs.len() {
        let fd: ast.FuncDecl = wm.prog.funcs.get(fi);
        if fd.name == fn_name {
          let mut si: i32 = 0;
          while si < fd.body.stmts.len() {
            let st: ast.Stmt = fd.body.stmts.get(si);
            if match st { ast.Stmt.ReturnStmt(_sp, has_ex, _ex) => has_ex, _ => false } {
              let ex: i32 = match st { ast.Stmt.ReturnStmt(_sp, _has_ex, id) => id, _ => -1 };
              return ast.expr_pool_get(wm.prog.exprs, ex);
            }
            si = si + 1;
          }
        }
        fi = fi + 1;
      }
    }
    mi = mi + 1;
  }
  return ast.ExprNode.Int("0");
}

fn me_func_decl(w: tc.World, mod_path: String, fn_name: String) -> ast.FuncDecl {
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let wm: tc.WorldModule = w.mods.get(mi);
    if wm.path == mod_path {
      let mut fi: i32 = 0;
      while fi < wm.prog.funcs.len() {
        let fd: ast.FuncDecl = wm.prog.funcs.get(fi);
        if fd.name == fn_name { return fd; }
        fi = fi + 1;
      }
    }
    mi = mi + 1;
  }
  return ast.FuncDecl {
    file: "",
    sp: ast.span0(),
    vis: ast.vis_private(),
    is_pub: false,
    is_async: false,
    track_caller: false,
    deprecated_message: "",
    name: "",
    type_params: Vec(),
    type_param_packs: Vec(),
    const_params: Vec(),
    type_param_bounds: Vec(),
    const_where_bounds: Vec(),
    params: Vec(),
    ret: ast.TypeName { parts: Vec(), args: Vec() },
    cfgs: Vec(),
    ffi_imports: Vec(),
    ffi_exports: Vec(),
    effects: Vec(),
    resources: Vec(),
    body: ast.Block { stmts: Vec() },
  };
}

fn me_func_count(w: tc.World, mod_path: String) -> i32 {
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let wm: tc.WorldModule = w.mods.get(mi);
    if wm.path == mod_path { return wm.prog.funcs.len(); }
    mi = mi + 1;
  }
  return -1;
}

fn me_world_mod(w: tc.World, mod_path: String) -> tc.WorldModule {
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let wm: tc.WorldModule = w.mods.get(mi);
    if wm.path == mod_path { return wm; }
    mi = mi + 1;
  }
  return tc.WorldModule {
    path: "",
    prog: ast.Program {
      file_builds: Vec(),
      imports: Vec(),
      types: Vec(),
      consts: Vec(),
      structs: Vec(),
      enums: Vec(),
      traits: Vec(),
      impls: Vec(),
      funcs: Vec(),
      exprs: ast.expr_pool(),
    },
  };
}

fn me_file_has_named_import(w: tc.World, mod_path: String, file: String, path: String, local: String) -> bool {
  let m: tc.WorldModule = me_world_mod(w, mod_path);
  let mut i: i32 = 0;
  while i < m.prog.imports.len() {
    let imp: ast.ImportDecl = m.prog.imports.get(i);
    if imp.file == file && imp.path == path {
      let mut j: i32 = 0;
      while j < imp.names.len() {
        let nm: ast.ImportName = imp.names.get(j);
        let local_name: String = if nm.alias != "" { nm.alias } else { nm.name };
        if local_name == local { return true; }
        j = j + 1;
      }
    }
    i = i + 1;
  }
  return false;
}

fn me_is_int_lit(w: tc.World, mod_path: String, id: i32, text: String) -> bool {
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let wm: tc.WorldModule = w.mods.get(mi);
    if wm.path == mod_path {
      let n: ast.ExprNode = ast.expr_pool_get(wm.prog.exprs, id);
      return match n { ast.ExprNode.Int(v) => v == text, _ => false };
    }
    mi = mi + 1;
  }
  return false;
}

fn me_deep_macro_expr(depth: i32) -> String {
  let mut out: String = "1";
  let mut i: i32 = 0;
  while i < depth {
    out = "id!(".concat(out).concat(")");
    i = i + 1;
  }
  return out;
}

fn test_macroexpand_no_macro_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return 1 + 2; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.err == tc.TcError.None);
}

fn test_macroexpand_user_macro_missing_callee_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return add1!(41); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "macro callee function not found"));
  t.assert(me_contains(msg, "main::add1"));
}

fn test_macroexpand_compile_bang_splices_expr_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return compile!(1 + 2); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.rounds == 1);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_file_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "const P: String = __file!()\nfn main() -> i32 { return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let m: tc.WorldModule = er.world.mods.get(0);
  let c0: ast.ConstDecl = m.prog.consts.get(0);
  let n: ast.ExprNode = ast.expr_pool_get(m.prog.exprs, c0.init);
  let v: String = match n { ast.ExprNode.Str(s) => s, _ => "" };
  t.assert(v != "");
  t.assert(me_has_suffix(v, "/src/main.vox") || me_has_suffix(v, "src/main.vox"));
}

fn test_macroexpand_line_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "const L: i32 = __line!()\nfn main() -> i32 { return L; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let m: tc.WorldModule = er.world.mods.get(0);
  let c0: ast.ConstDecl = m.prog.consts.get(0);
  let n: ast.ExprNode = ast.expr_pool_get(m.prog.exprs, c0.init);
  t.assert(match n { ast.ExprNode.Int(v) => v == "1", _ => false });
}

fn test_macroexpand_line_bang_reports_call_line_smoke() -> () {
  let w: tc.World = me_world_from("main", "const A: i32 = 0\nconst L: i32 = __line!()\nfn main() -> i32 { return L; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let m: tc.WorldModule = er.world.mods.get(0);
  let c1: ast.ConstDecl = m.prog.consts.get(1);
  let n: ast.ExprNode = ast.expr_pool_get(m.prog.exprs, c1.init);
  t.assert(match n { ast.ExprNode.Int(v) => v == "2", _ => false });
}

fn test_macroexpand_col_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "const C: i32 = __col!()\nfn main() -> i32 { return C; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let m: tc.WorldModule = er.world.mods.get(0);
  let c0: ast.ConstDecl = m.prog.consts.get(0);
  let n: ast.ExprNode = ast.expr_pool_get(m.prog.exprs, c0.init);
  t.assert(match n { ast.ExprNode.Int(v) => v == "16", _ => false });
}

fn test_macroexpand_module_path_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "const M: String = __module_path!()\nfn main() -> i32 { return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let m: tc.WorldModule = er.world.mods.get(0);
  let c0: ast.ConstDecl = m.prog.consts.get(0);
  let n: ast.ExprNode = ast.expr_pool_get(m.prog.exprs, c0.init);
  t.assert(match n { ast.ExprNode.Str(v) => v == "main", _ => false });
}

fn test_macroexpand_func_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> String { return __func!(); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Str(v) => v == "main", _ => false });
}

fn test_macroexpand_caller_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", """
    struct Caller { file: String, line: i32, col: i32, module: String, func: String }
    fn main() -> Caller { return __caller!(); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.StructLit(_ty, fields) => fields.len() == 5, _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_track_caller_injects_param_and_callsite_smoke() -> () {
  let w: tc.World = me_world_from(
    "main",
    """
      struct Caller { file: String, line: i32, col: i32, module: String, func: String }
      @track_caller fn leaf() -> i32 { return 7; }
      fn main() -> i32 { return leaf(); }
    """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));

  let leaf: ast.FuncDecl = me_func_decl(er.world, "main", "leaf");
  t.assert(leaf.track_caller);
  t.assert_eq(leaf.params.len(), 1);
  t.assert_eq(leaf.params.get(0).name, "caller");

  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Call(_c, _ta, args) => args.len() == 1,
      _ => false,
    },
    "expected track_caller callsite to append one caller argument");

  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_track_caller_forwards_in_tracked_owner_smoke() -> () {
  let w: tc.World = me_world_from(
    "main",
    """
      struct Caller { file: String, line: i32, col: i32, module: String, func: String }
      @track_caller fn inner() -> i32 { return 1; }
      @track_caller fn outer() -> i32 { return inner(); }
      fn main() -> i32 { return outer(); }
    """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));

  let n: ast.ExprNode = me_func_return_expr_node(er.world, "main", "outer");
  t.assert_with(
    match n {
      ast.ExprNode.Call(_c, _ta, args) => args.len() == 1,
      _ => false,
    },
    "expected tracked owner to call tracked callee with one forwarded caller arg");

  let m: tc.WorldModule = er.world.mods.get(0);
  let outer_expr: ast.ExprNode =
    match n {
      ast.ExprNode.Call(_c, _ta, args) => ast.expr_pool_get(m.prog.exprs, args.get(0)),
      _ => ast.ExprNode.Int("0"),
    };
  t.assert_with(
    match outer_expr { ast.ExprNode.Ident(s) => s == "caller", _ => false },
    "expected forwarded caller arg to be ident `caller`");

  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_track_caller_with_bang_call_sugar_smoke() -> () {
  let w: tc.World = me_world_from(
    "main",
    """
      struct Caller { file: String, line: i32, col: i32, module: String, func: String }
      @track_caller fn leaf() -> i32 { return 7; }
      fn main() -> i32 { return leaf!(); }
    """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_track_caller_builtin_in_tracked_fn_uses_forwarded_caller_smoke() -> () {
  let w: tc.World = me_world_from(
    "main",
    """
      struct Caller { file: String, line: i32, col: i32, module: String, func: String }
      @track_caller fn where_from() -> Caller { return __caller!(); }
      fn main() -> Caller { return where_from(); }
    """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));

  let n: ast.ExprNode = me_func_return_expr_node(er.world, "main", "where_from");
  t.assert_with(
    match n { ast.ExprNode.Ident(s) => s == "caller", _ => false },
    "expected __caller! inside @track_caller fn to lower to forwarded caller param");

  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_track_caller_cross_module_alias_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "std/prelude", "pub struct Caller { pub file: String, pub line: i32, pub col: i32, pub module: String, pub func: String }");
  w = me_world_add(w, "dep", "@track_caller pub fn leaf() -> i32 { return 7; }");
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return dep.leaf(); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  t.assert_with(
    me_file_has_named_import(er.world, "main", "src/main.vox", "std/prelude", "Caller"),
    "expected auto named import Caller in main");
  t.assert_with(
    me_file_has_named_import(er.world, "dep", "src/main.vox", "std/prelude", "Caller"),
    "expected auto named import Caller in dep");
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Call(_c, _ta, args) => args.len() == 1,
      _ => false,
    },
    "expected dep.leaf() callsite to append caller arg");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_track_caller_cross_module_named_import_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "std/prelude", "pub struct Caller { pub file: String, pub line: i32, pub col: i32, pub module: String, pub func: String }");
  w = me_world_add(w, "dep", "@track_caller pub fn leaf() -> i32 { return 7; }");
  w = me_world_add(w, "main", "import { leaf } from \"dep\"\nfn main() -> i32 { return leaf(); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Call(_c, _ta, args) => args.len() == 1,
      _ => false,
    },
    "expected named import leaf() callsite to append caller arg");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_track_caller_recursive_call_forwards_caller_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "std/prelude", "pub struct Caller { pub file: String, pub line: i32, pub col: i32, pub module: String, pub func: String }");
  w = me_world_add(w, "main", """
    @track_caller fn sum(n: i32) -> i32 {
      if n <= 0 { return 0; }
      return sum(n - 1);
    }
    fn main() -> i32 { return sum(2); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));

  let n: ast.ExprNode = me_func_return_expr_node(er.world, "main", "sum");
  t.assert_with(
    match n {
      ast.ExprNode.Call(_c, _ta, args) => args.len() == 2,
      _ => false,
    },
    "expected recursive call to forward caller as hidden second arg");

  let m: tc.WorldModule = me_world_mod(er.world, "main");
  let caller_arg: ast.ExprNode =
    match n {
      ast.ExprNode.Call(_c, _ta, args) => ast.expr_pool_get(m.prog.exprs, args.get(1)),
      _ => ast.ExprNode.Int("0"),
    };
  t.assert_with(
    match caller_arg { ast.ExprNode.Ident(s) => s == "caller", _ => false },
    "expected recursive tracked call to pass caller ident");

  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_dirname_bang_nested_file_smoke() -> () {
  let w: tc.World = me_world_from("main", "const D: String = dirname!(__file!())\nfn main() -> i32 { return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let m: tc.WorldModule = er.world.mods.get(0);
  let c0: ast.ConstDecl = m.prog.consts.get(0);
  let n: ast.ExprNode = ast.expr_pool_get(m.prog.exprs, c0.init);
  let v: String = match n { ast.ExprNode.Str(s) => s, _ => "" };
  t.assert(v != "");
  t.assert(me_has_suffix(v, "/src") || v == "src");
}

fn test_macroexpand_user_macro_sugar_preserves_type_args() -> () {
  let w: tc.World = me_world_from("main", """
    fn id[T](x: T) -> T { return x; }
    fn main() -> i32 { return id[i32]!(7); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_sugar_in_const_init_smoke() -> () {
  let w: tc.World = me_world_from("main", """
    fn add1(x: i32) -> i32 { return x + 1; }
    const X: i32 = add1!(41)
    fn main() -> i32 { return X; }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_sugar_and_builtin_macro_compose_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn add1(x: i32) -> i32 { return compile!(x + 1); }\n"
      .concat("fn main() -> i32 { return add1!(41); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_local_template_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn add1(x: i32) -> i32 { return x + 1; }\n"
      .concat("fn main() -> i32 { return add1!(41); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(me_notes_contains(er.notes, "decision=inline-template"));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Binary(ast.BinaryOp.Add, _l, _r) => true, _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_ast_expr_macro_fn_exec_and_strip_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn add1(x: AstExpr) -> AstExpr { return x + 1; }\n"
      .concat("fn main() -> i32 { return add1!(41); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Binary(ast.BinaryOp.Add, _l, _r) => true, _ => false }, "expected AstExpr macro fn to expand at call site");
  t.assert_with(me_func_count(er.world, "main") == 1, "AstExpr macro fn should be stripped before typecheck");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_ast_block_macro_fn_exec_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn add1(x: AstExpr) -> AstBlock { return { let y: i32 = x + 1; y }; }\n"
      .concat("fn main() -> i32 { return add1!(41); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Block(_b) => true, _ => false }, "expected AstBlock macro fn to expand into block expression");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_compile_bang_ast_block_fn_call_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn add1(x: AstExpr) -> AstBlock { return { let y: i32 = x + 1; y }; }\n"
      .concat("fn main() -> i32 { return compile!(add1(41)); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Block(_b) => true, _ => false }, "expected compile!(AstBlock fn call) to splice block expression");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_ast_stmt_macro_fn_stmt_position_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn tick(x: AstExpr) -> AstStmt { return x + 1; }\n"
      .concat("fn main() -> i32 { tick!(1); return 0; }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_compile_bang_ast_stmt_fn_stmt_position_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn tick(x: AstExpr) -> AstStmt { return x + 1; }\n"
      .concat("fn main() -> i32 { compile!(tick(1)); return 0; }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_ast_stmt_macro_fn_call_rejected() -> () {
  let w: tc.World = me_world_from("main",
    "fn mk(x: AstExpr) -> AstStmt { return x; }\n"
      .concat("fn main() -> i32 { return mk!(1); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "macro call requires AstExpr or AstBlock return type; got AstStmt"));
}

fn test_macroexpand_compile_bang_ast_stmt_fn_call_rejected() -> () {
  let w: tc.World = me_world_from("main",
    "fn mk(x: AstExpr) -> AstStmt { return x; }\n"
      .concat("fn main() -> i32 { return compile!(mk(1)); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "macro call requires AstExpr or AstBlock return type; got AstStmt"));
}

fn test_macroexpand_ast_item_macro_fn_call_rejected() -> () {
  let w: tc.World = me_world_from("main", """
    fn mk(x: AstExpr) -> AstItem { return x; }
    fn main() -> i32 { return mk!(1); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "macro call requires AstExpr or AstBlock return type; got AstItem"));
}

fn test_macroexpand_ast_item_macro_fn_stmt_position_rejected() -> () {
  let w: tc.World = me_world_from("main", """
    fn mk(x: AstExpr) -> AstItem { return x; }
    fn main() -> i32 { mk!(1); return 0; }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "macro call requires AstExpr or AstBlock or AstStmt return type; got AstItem"));
}

fn test_macroexpand_user_macro_inline_block_template_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn add1(x: i32) -> i32 { return { let y: i32 = x + 1; y }; }\n"
      .concat("fn main() -> i32 { return add1!(41); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Block(_b) => true, _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_multi_stmt_template_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn add1(x: i32) -> i32 { let y: i32 = x + 1; return y; }\n"
      .concat("fn main() -> i32 { return add1!(41); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Block(_b) => true, _ => false }, "expected inline to synthesize block template from multi-stmt fn body");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_user_macro_inline_multi_stmt_with_early_return_fallback_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn add1(x: i32) -> i32 { if x > 0 { return x; } return x + 1; }\n"
      .concat("fn main() -> i32 { return add1!(41); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Call(_c, _ta, _args) => true, _ => false }, "expected fallback to call sugar when prefix contains return");
  t.assert_with(me_notes_contains(er.notes, "decision=fallback-call"), "expected deterministic fallback decision note");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_user_macro_inline_match_template_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn pick(x: i32) -> i32 { return match x { 0 => 1, _ => x }; }\n"
      .concat("fn main() -> i32 { return pick!(0); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Match(_scrut, _arms) => true, _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_try_block_template_smoke() -> () {
  let w: tc.World = me_world_from("main", """
    enum Result[T, E] { Ok(T), Err(E) }
    fn get() -> Result[i32, String] { return .Ok(7); }
    fn id(x: Result[i32, String]) -> Result[i32, String] { return try { let v: i32 = x?; v }; }
    fn main() -> Result[i32, String] { return id!(get()); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.TryBlock(_b) => true, _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_member_callee_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn add1(x: i32) -> i32 { return x + 1; }");
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return dep.add1!(41); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Binary(ast.BinaryOp.Add, _l, _r) => true, _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_member_fallback_for_cross_module_ident_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", """
    pub fn helper(x: i32) -> i32 { return x + 2; }
    pub fn add1(x: i32) -> i32 { return helper(x); }
  """);
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return dep.add1!(41); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert_with(me_notes_contains(er.notes, "cross-module template is not scope-safe (root:"), "expected detailed cross-module fallback reason");
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Call(_c, _ta, _args) => true, _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_member_block_template_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep",
    "pub fn add1(x: i32) -> i32 { return { let y: i32 = x + 1; y }; }");
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return dep.add1!(41); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Block(_b) => true, _ => false }, "expected cross-module block template inline");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_user_macro_inline_member_multi_stmt_template_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep",
    "pub fn add1(x: i32) -> i32 { let y: i32 = x + 1; return y; }");
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return dep.add1!(41); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Block(_b) => true, _ => false }, "expected cross-module multi-stmt fn body inline");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_user_macro_inline_member_match_template_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep",
    "pub fn pick(x: i32) -> i32 { return match x { 0 => 1, _ => x }; }");
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return dep.pick!(0); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Match(_scrut, _arms) => true, _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_member_try_block_template_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", """
    pub enum Result[T, E] { Ok(T), Err(E) }
    pub fn id(x: Result[i32, String]) -> Result[i32, String] { return try { let v: i32 = x?; v }; }
  """);
  w = me_world_add(w, "main", """
    import "dep" as dep
    fn get() -> dep.Result[i32, String] { return dep.Result[i32, String].Ok(7); }
    fn main() -> dep.Result[i32, String] { return dep.id!(get()); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.TryBlock(_b) => true, _ => false }, "expected cross-module try-block template inline");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_user_macro_inline_generic_type_args_smoke() -> () {
  let w: tc.World = me_world_from("main", """
    fn id[T](x: T) -> T { return x; }
    fn main() -> i32 { return id[i32]!(7); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Int(v) => v == "7", _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_const_generic_args_smoke() -> () {
  let w: tc.World = me_world_from("main", """
    fn callee[const N: i32](x: i32) -> i32 { return x + N; }
    fn wrap[const N: i32](x: i32) -> i32 { return callee[N](x); }
    fn main() -> i32 { return wrap[3]!(7); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Call(_c, targs, _args) => targs.len() == 1 && targs.get(0).parts.len() == 2 && targs.get(0).parts.get(0) == "@const" && targs.get(0).parts.get(1) == "3",
      _ => false,
    },
    "expected const-generic inline to forward const arg into callee call");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_user_macro_inline_const_generic_value_substitution_smoke() -> () {
  let w: tc.World = me_world_from("main", """
    fn addn[const N: i32](x: i32) -> i32 { return x + N; }
    fn main() -> i32 { return addn[3]!(40); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Binary(ast.BinaryOp.Add, l, r) =>
        me_is_int_lit(er.world, "main", l, "40") && me_is_int_lit(er.world, "main", r, "3"),
      _ => false,
    },
    "expected const-generic param N to be substituted as integer literal");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_user_macro_inline_member_generic_type_args_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn id[T](x: T) -> T { return x; }");
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return dep.id[i32]!(7); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Int(v) => v == "7", _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_named_import_generic_type_args_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn id[T](x: T) -> T { return x; }");
  w = me_world_add(w, "main", "import { id as inc } from \"dep\"\nfn main() -> i32 { return inc[i32]!(7); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Int(v) => v == "7", _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_generic_missing_targs_fallback_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn id[T](x: T) -> T { return x; }\n"
      .concat("fn main() -> i32 { return id!(7); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.notes.len() >= 2);
  t.assert(me_notes_contains(er.notes, "generic arg count mismatch"));
  t.assert(me_notes_contains(er.notes, "lowered to call sugar"));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Call(_callee, _ta, _args) => true, _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_named_import_generic_missing_targs_fallback_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn id[T](x: T) -> T { return x; }");
  w = me_world_add(w, "main", "import { id as inc } from \"dep\"\nfn main() -> i32 { return inc!(7); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.notes.len() >= 2);
  t.assert(me_notes_contains(er.notes, "generic arg count mismatch"));
  t.assert(me_notes_contains(er.notes, "lowered to call sugar"));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Call(_callee, _ta, _args) => true, _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_member_generic_missing_targs_fallback_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn id[T](x: T) -> T { return x; }");
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return dep.id!(7); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.notes.len() >= 2);
  t.assert(me_notes_contains(er.notes, "generic arg count mismatch"));
  t.assert(me_notes_contains(er.notes, "lowered to call sugar"));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert(match n { ast.ExprNode.Call(_callee, _ta, _args) => true, _ => false });
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_user_macro_inline_const_generic_missing_targs_uses_default_inline_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn addn[const N: i32 = 2](x: i32) -> i32 { return x + N; }\n"
      .concat("fn main() -> i32 { return addn!(40); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Binary(ast.BinaryOp.Add, l, r) =>
        me_is_int_lit(er.world, "main", l, "40") && me_is_int_lit(er.world, "main", r, "2"),
      _ => false,
    },
    "expected default const arg to be substituted during inline");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_user_macro_inline_named_import_const_generic_missing_targs_uses_default_inline_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn addn[const N: i32 = 2](x: i32) -> i32 { return x + N; }");
  w = me_world_add(w, "main", "import { addn as inc } from \"dep\"\nfn main() -> i32 { return inc!(40); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Binary(ast.BinaryOp.Add, l, r) =>
        me_is_int_lit(er.world, "main", l, "40") && me_is_int_lit(er.world, "main", r, "2"),
      _ => false,
    },
    "expected named-import default const arg to be substituted during inline");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_user_macro_inline_member_const_generic_missing_targs_uses_default_inline_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn addn[const N: i32 = 2](x: i32) -> i32 { return x + N; }");
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return dep.addn!(40); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Binary(ast.BinaryOp.Add, l, r) =>
        me_is_int_lit(er.world, "main", l, "40") && me_is_int_lit(er.world, "main", r, "2"),
      _ => false,
    },
    "expected member default const arg to be substituted during inline");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_deep_user_macro_chain_smoke() -> () {
  let expr: String = me_deep_macro_expr(80);
  let src: String =
    "fn id(x: i32) -> i32 { return x; }\n"
      .concat("fn main() -> i32 { return ")
      .concat(expr)
      .concat("; }");
  let w: tc.World = me_world_from("main", src);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_nested_splices_expr_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return compile!(compile!(1 + 2)); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.rounds == 2);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_executes_ast_expr_fn_call_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn add1(x: AstExpr) -> AstExpr { return x + 1; }\n"
      .concat("fn main() -> i32 { return compile!(add1(41)); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Binary(ast.BinaryOp.Add, _l, _r) => true, _ => false }, "expected compile!(ast-expr-call) to execute macro fn call");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_user_macro_inline_named_import_const_generic_value_substitution_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn addn[const N: i32](x: i32) -> i32 { return x + N; }");
  w = me_world_add(w, "main", "import { addn as inc } from \"dep\"\nfn main() -> i32 { return inc[3]!(40); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Binary(ast.BinaryOp.Add, l, r) =>
        me_is_int_lit(er.world, "main", l, "40") && me_is_int_lit(er.world, "main", r, "3"),
      _ => false,
    },
    "expected named-import const generic N substitution in macro template");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_compile_bang_executes_cross_module_ast_expr_fn_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn add1(x: AstExpr) -> AstExpr { return x + 1; }");
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return compile!(dep.add1(41)); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Binary(ast.BinaryOp.Add, _l, _r) => true, _ => false }, "expected compile!(dep.macro_fn(...)) to execute across module");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_compile_bang_executes_named_import_ast_expr_fn_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn add1(x: AstExpr) -> AstExpr { return x + 1; }");
  w = me_world_add(w, "main", "import { add1 as inc } from \"dep\"\nfn main() -> i32 { return compile!(inc(41)); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Binary(ast.BinaryOp.Add, _l, _r) => true, _ => false }, "expected compile!(named-import(...)) to execute macro fn call");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_compile_bang_executes_named_import_const_generic_ast_expr_fn_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn addn[const N: i32](x: AstExpr) -> AstExpr { return x + N; }");
  w = me_world_add(w, "main", "import { addn as inc } from \"dep\"\nfn main() -> i32 { return compile!(inc[3](40)); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Binary(ast.BinaryOp.Add, l, r) =>
        me_is_int_lit(er.world, "main", l, "40") && me_is_int_lit(er.world, "main", r, "3"),
      _ => false,
    },
    "expected compile!(named-import const-generic ast fn call) to substitute N");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_compile_bang_executes_member_const_generic_ast_expr_fn_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn addn[const N: i32](x: AstExpr) -> AstExpr { return x + N; }");
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return compile!(dep.addn[3](40)); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Binary(ast.BinaryOp.Add, l, r) =>
        me_is_int_lit(er.world, "main", l, "40") && me_is_int_lit(er.world, "main", r, "3"),
      _ => false,
    },
    "expected compile!(member const-generic ast fn call) to substitute N");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_compile_bang_executes_const_generic_ast_expr_fn_call_default_arg_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn addn[const N: i32 = 2](x: AstExpr) -> AstExpr { return x + N; }\n"
      .concat("fn main() -> i32 { return compile!(addn(40)); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Binary(ast.BinaryOp.Add, l, r) =>
        me_is_int_lit(er.world, "main", l, "40") && me_is_int_lit(er.world, "main", r, "2"),
      _ => false,
    },
    "expected compile!(const-generic ast fn call) to use default N");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_compile_bang_executes_named_import_const_generic_ast_expr_fn_call_default_arg_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn addn[const N: i32 = 2](x: AstExpr) -> AstExpr { return x + N; }");
  w = me_world_add(w, "main", "import { addn as inc } from \"dep\"\nfn main() -> i32 { return compile!(inc(40)); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Binary(ast.BinaryOp.Add, l, r) =>
        me_is_int_lit(er.world, "main", l, "40") && me_is_int_lit(er.world, "main", r, "2"),
      _ => false,
    },
    "expected compile!(named-import const-generic ast fn call) to use default N");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_compile_bang_executes_member_const_generic_ast_expr_fn_call_default_arg_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn addn[const N: i32 = 2](x: AstExpr) -> AstExpr { return x + N; }");
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return compile!(dep.addn(40)); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(
    match n {
      ast.ExprNode.Binary(ast.BinaryOp.Add, l, r) =>
        me_is_int_lit(er.world, "main", l, "40") && me_is_int_lit(er.world, "main", r, "2"),
      _ => false,
    },
    "expected compile!(member const-generic ast fn call) to use default N");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_named_import_ast_expr_fn_call_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn add1(x: AstExpr) -> AstExpr { return x + 1; }");
  w = me_world_add(w, "main", "import { add1 as inc } from \"dep\"\nfn main() -> i32 { return inc!(41); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Binary(ast.BinaryOp.Add, _l, _r) => true, _ => false }, "expected named-import macro call to execute macro fn call");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_compile_bang_ast_expr_fn_call_can_expand_nested_macros_smoke() -> () {
  let w: tc.World = me_world_from("main", """
    fn add1(x: AstExpr) -> AstExpr { return x + 1; }
    fn add2(x: AstExpr) -> AstExpr { return add1!(add1!(x)); }
    fn main() -> i32 { return compile!(add2(40)); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Binary(ast.BinaryOp.Add, _l, _r) => true, _ => false }, "expected compile!(add2(...)) to keep expanding nested macro calls");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_compile_bang_cross_module_ast_expr_fn_call_can_expand_nested_macros_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", """
    pub fn add1(x: AstExpr) -> AstExpr { return x + 1; }
    pub fn add2(x: AstExpr) -> AstExpr { return add1!(add1!(x)); }
  """);
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { return compile!(dep.add2(40)); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Binary(ast.BinaryOp.Add, _l, _r) => true, _ => false }, "expected compile!(dep.add2(...)) to keep expanding nested macro calls");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_quote_unquote_mvp_smoke() -> () {
  let w: tc.World = me_world_from("main", """
    fn add1(x: AstExpr) -> AstExpr { return quote!(unquote!(x) + 1); }
    fn main() -> i32 { return add1!(41); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Binary(ast.BinaryOp.Add, _l, _r) => true, _ => false }, "expected quote!/unquote! to lower into plain expr");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_quote_expr_dollar_surface_syntax_smoke() -> () {
  let w: tc.World = me_world_from("main", """
    fn add1(x: AstExpr) -> AstExpr { return quote expr { $x + 1 }; }
    fn main() -> i32 { return add1!(41); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Binary(ast.BinaryOp.Add, _l, _r) => true, _ => false }, "expected quote expr {$x} to lower via quote!/unquote!");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_quote_unquote_if_expr_shape_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn add_if(x: AstExpr) -> AstExpr { return quote!(if true { unquote!(x) + 1 } else { 0 }); }\n"
      .concat("fn main() -> i32 { return add_if!(41); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false }, "expected quote!/unquote! to preserve if expression shape");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_quote_unquote_match_expr_shape_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "fn into_match(x: AstExpr) -> AstExpr { return quote!(match unquote!(x) { 0 => 1, _ => 2 }); }\n"
      .concat("fn main() -> i32 { return into_match!(0); }"));
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert_with(er.ok, tc.tc_error_to_string(er.err));
  let n: ast.ExprNode = me_main_return_expr_node(er.world, "main");
  t.assert_with(match n { ast.ExprNode.Match(_scrut, _arms) => true, _ => false }, "expected quote!/unquote! to preserve match expression shape");
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert_with(tr.ok, tc.tc_error_to_string(tr.err));
}

fn test_macroexpand_quote_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return quote!(1, 2); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "quote! expects exactly one value arg"));
}

fn test_macroexpand_unquote_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return unquote!(1, 2); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "unquote! expects exactly one value arg"));
}

fn test_macroexpand_compile_bang_const_init_smoke() -> () {
  let w: tc.World = me_world_from("main", "const X: i32 = compile!(1 + 2)\nfn main() -> i32 { return X; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  t.assert(er.rounds == 1);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_in_trait_default_method_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "trait A { fn a(x: Self) -> i32 { return compile!(1 + 2); } }\nimpl A for i32 {}\nfn main() -> i32 { return A.a(1); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_in_impl_method_smoke() -> () {
  let w: tc.World = me_world_from("main",
    "trait A { fn a(x: Self) -> i32; }\nimpl A for i32 { fn a(x: i32) -> i32 { return compile!(x + 1); } }\nfn main() -> i32 { return A.a(1); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_compile_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { return compile!(1, 2); }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "compile! expects exactly one value arg"));
}

fn test_macroexpand_panic_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { if false { panic!(\"boom\"); } return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_panic_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { panic!(\"a\", \"b\"); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "panic! expects exactly one value arg"));
}

fn test_macroexpand_compile_error_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { compile_error!(\"boom\"); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(!tr.ok);
  let msg: String = tc.tc_error_to_string(tr.err);
  t.assert(me_contains(msg, "boom"));
}

fn test_macroexpand_compile_error_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { compile_error!(\"a\", \"b\"); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "compile_error! expects exactly one value arg"));
}

fn test_macroexpand_assert_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn assert(cond: bool) -> () { if !cond { panic(\"bad\"); } }\nfn main() -> i32 { assert!(true); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_assert_bang_with_msg_smoke() -> () {
  let w: tc.World = me_world_from("main", "fn assert_with(cond: bool, msg: String) -> () { if !cond { panic(msg); } }\nfn main() -> i32 { assert!(true, \"ok\"); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_assert_bang_with_msg_member_callee_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", "pub fn assert_with(cond: bool, msg: String) -> () { if !cond { panic(msg); } }");
  w = me_world_add(w, "main", "import \"dep\" as dep\nfn main() -> i32 { dep.assert!(true, \"ok\"); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_assert_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { assert!(); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "assert! expects one or two value args"));
}

fn test_macroexpand_assert_cmp_bang_smoke() -> () {
  let w: tc.World = me_world_from("main", """
    fn assert_eq(a: i32, b: i32) -> () {}
    fn assert_ne(a: i32, b: i32) -> () {}
    fn assert_lt(a: i32, b: i32) -> () {}
    fn assert_le(a: i32, b: i32) -> () {}
    fn assert_gt(a: i32, b: i32) -> () {}
    fn assert_ge(a: i32, b: i32) -> () {}
    fn main() -> i32 {
      assert_eq!(1, 1);
      assert_ne!(1, 2);
      assert_lt!(1, 2);
      assert_le!(1, 1);
      assert_gt!(2, 1);
      assert_ge!(2, 2);
      return 0;
    }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_assert_cmp_bang_member_callee_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = me_world_add(w, "dep", """
    pub fn assert_eq(a: i32, b: i32) -> () {}
    pub fn assert_ne(a: i32, b: i32) -> () {}
    pub fn assert_lt(a: i32, b: i32) -> () {}
    pub fn assert_le(a: i32, b: i32) -> () {}
    pub fn assert_gt(a: i32, b: i32) -> () {}
    pub fn assert_ge(a: i32, b: i32) -> () {}
  """);
  w = me_world_add(w, "main", """
    import "dep" as dep
    fn main() -> i32 {
      dep.assert_eq!(1, 1);
      dep.assert_ne!(1, 2);
      dep.assert_lt!(1, 2);
      dep.assert_le!(1, 1);
      dep.assert_gt!(2, 1);
      dep.assert_ge!(2, 2);
      return 0;
    }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(er.ok);
  let tr: tc.TcResult = tc.typecheck_world(er.world);
  t.assert(tr.ok);
}

fn test_macroexpand_assert_cmp_bang_bad_arity_rejected() -> () {
  let w: tc.World = me_world_from("main", "fn main() -> i32 { assert_eq!(1); return 0; }");
  let er: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "assert_eq! expects exactly two value args and no type args"));
}

fn test_macroexpand_exceeds_max_rounds_rejected() -> () {
  let w: tc.World = me_world_from("main", """
    fn helper() -> i32 {
      return compile!(compile!(1 + 2));
    }
    fn main() -> i32 { return helper(); }
  """);
  let er: mx.ExpandResult = mx.expand_world(w, mx.ExpandConfig { max_rounds: 1 });
  t.assert(!er.ok);
  let msg: String = tc.tc_error_to_string(er.err);
  t.assert(me_contains(msg, "src/main.vox:2:"));
  t.assert(!me_contains(msg, "src/main.vox:1:1:"));
  t.assert(me_contains(msg, "macro expansion exceeded max rounds"));
  t.assert(me_contains(msg, "pending macro calls:"));
  t.assert(me_contains(msg, "next: main::compile!"));
}
