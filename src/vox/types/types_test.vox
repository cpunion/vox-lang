import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc
import "vox/types" as tys

fn parse_err_none(e: p.ParseError) -> bool {
  return match e { p.ParseError.None => true, _ => false, };
}

fn parse_world(src: String) -> tc.World {
  let pr: p.ParseResult = p.parse_text_with_path("src/main.vox", src);
  t.assert(parse_err_none(pr.err));
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "main", pr.prog);
  return w;
}

fn test_types_check_world_smoke() -> () {
  let w: tc.World = parse_world("fn main() -> i32 { return 0; }");
  let r: tys.CheckResult = tys.check_world(w);
  t.assert_with(r.ok, tys.error_string(r.err));
}

fn test_types_check_world_type_error() -> () {
  let w: tc.World = parse_world("fn main() -> i32 { return true; }");
  let r: tys.CheckResult = tys.check_world(w);
  t.assert(!r.ok);
  t.assert_eq(r.err.kind, tys.diag_kind_type());
  t.assert(r.err.code.len() > 0);
  t.assert(tys.error_string(r.err).len() > 0);
}

fn test_types_check_world_without_body_check() -> () {
  let w: tc.World = parse_world("fn main() -> i32 { return true; }");
  let mut cfg: tys.Config = tys.default_config();
  cfg.body_check = false;

  let r: tys.CheckResult = tys.check_world_with_config(w, cfg);
  t.assert(r.ok);
}
