import "vox/ast" as ast
import "vox/ir" as ir
import "vox/typecheck" as tc

fn const_sub_lookup_gen(xs: Vec[tc.ConstSub], name: String) -> tc.ConstSub {
  let mut i: i32 = 0;
  while i < xs.len() {
    let cs: tc.ConstSub = xs.get(i);
    if cs.name == name { return cs; }
    i = i + 1;
  }
  return tc.ConstSub { name: "", ty: -1, iv: 0, text: "" };
}

fn gen_func_impl(
  ctx: tc.Ctx,
  w: tc.World,
  mod_path: String,
  name_mod_path: String,
  imps: tc.Imports,
  exprs: ast.ExprPool,
  fd: ast.FuncDecl,
  fn_name: String,
  sig: tc.FuncSig,
  type_subs: Vec[tc.TySub],
  const_subs: Vec[tc.ConstSub]
) -> GenFuncResult {
  let mut g: Gen = Gen{
    ctx: ctx,
    w: w,
    mod_path: mod_path,
    imps: imps,
    exprs: exprs,
    tmp_id: 0,
    slot_id: 0,
    blocks: Vec(),
    cur: -1,
    slots: slots_new(),
    locals: tc.locals_new(),
    loops: Vec(),
    tries: Vec(),
    ret_ty: tc.strip_range_only(ctx, sig.ret),
    inout_params: Vec(),
    pending: Vec(),
    type_subs: type_subs,
    const_subs: const_subs,
  };
  let mut l0: tc.Locals = g.locals;
  l0.fn_is_async = fd.is_async;
  l0.fn_ret_ty = tc.strip_range_only(g.ctx, sig.ret);
  let mut ci: i32 = 0;
  while ci < sig.const_params.len() {
    let cp: tc.ConstParamSig = sig.const_params.get(ci);
    let cs: tc.ConstSub = const_sub_lookup_gen(g.const_subs, cp.name);
    if cs.name == "" {
      l0 = tc.locals_decl_const(l0, cp.name, cp.ty);
    } else {
      l0 = tc.locals_decl_const_value(l0, cp.name, cp.ty, cs.iv);
    }
    ci = ci + 1;
  }
  g.locals = l0;

  // Create entry block.
  let r0: GenNewIdResult = gen_new_block(g, "entry");
  g = r0.g;
  g = gen_set_block(g, r0.id);

  let mut f: ir.Func = ir.Func { name: qname(name_mod_path, fn_name), params: Vec(), ret: tc.strip_range_only(g.ctx, sig.ret), blocks: Vec() };

  // Params: declare slots and store params.
  let mut pi: i32 = 0;
  while pi < fd.params.len() {
    let p: ast.Param = fd.params.get(pi);
    let pty: i32 = tc.strip_range_only(g.ctx, sig.params.get(pi));
    let pbk: i32 = if pi < sig.param_borrow_kinds.len() { sig.param_borrow_kinds.get(pi) } else { tc.param_borrow_none() };

    if tc.param_borrow_is_mut(pbk) {
      let static0: bool = pbk == tc.param_borrow_ref_static_mut();
      let rr: tc.ResolveTyResult = tc.intern_ref(g.ctx, pty, true, static0);
      g.ctx = rr.ctx;
      if !rr.ok { return GenFuncResult { ok: false, err: "failed to intern &mut param type", ctx: g.ctx, f: f, extras: Vec(), pending: Vec() }; }
      let ref_ty: i32 = rr.idx;
      f.params.push(ir.Param { name: p.name, ty: ref_ty });

      // Copy-in: slot = *param_ptr
      let rs: GenNewIdResult = gen_new_slot(g);
      g = rs.g;
      let sid: i32 = rs.id;
      g = gen_emit(g, ir.Instr.SlotDecl(sid, pty));
      let nt: GenNewIdResult = gen_new_temp(g);
      g = nt.g;
      let tid: i32 = nt.id;
      g = gen_emit(g, ir.Instr.RefLoad(tid, pty, ir.v_param(pi)));
      g = gen_emit(g, ir.Instr.Store(sid, ir.v_temp(tid)));

      // Pointee is mutable even if the binding is not.
      g.slots = slots_decl(g.slots, p.name, sid, pty, true);
      g.locals = tc.locals_decl(g.locals, p.name, pty, true);
      let mut ips: Vec[InoutParam] = g.inout_params;
      ips.push(InoutParam { param_idx: pi, slot: sid, elem_ty: pty });
      g.inout_params = ips;
    } else {
      f.params.push(ir.Param { name: p.name, ty: pty });

      let rs: GenNewIdResult = gen_new_slot(g);
      g = rs.g;
      let sid: i32 = rs.id;
      g = gen_emit(g, ir.Instr.SlotDecl(sid, pty));
      g = gen_emit(g, ir.Instr.Store(sid, ir.v_param(pi)));
      g.slots = slots_decl(g.slots, p.name, sid, pty, false);
      g.locals = tc.locals_decl(g.locals, p.name, pty, false);
    }
    pi = pi + 1;
  }

  // Body.
  let rb: GenStmtResult = gen_block(g, fd.body);
  if !rb.ok {
    return GenFuncResult { ok: false, err: rb.err, ctx: g.ctx, f: f, extras: Vec(), pending: Vec() };
  }
  g = rb.g;

  // Ensure terminator.
  let cur_blk: ir.Block = g.blocks.get(g.cur);
  if !cur_blk.has_term {
    if g.ret_ty == ctx.ty_unit {
      g = gen_flush_inout_params(g);
      g = gen_term(g, ir.Term.Ret(false, ir.v_int(0)));
    } else {
      return GenFuncResult { ok: false, err: tc.irgen_error_at(fd.sp, "missing return"), ctx: g.ctx, f: f, extras: Vec(), pending: Vec() };
    }
  }

  f.blocks = g.blocks;
  return GenFuncResult { ok: true, err: "", ctx: g.ctx, f: f, extras: Vec(), pending: g.pending };
}

fn gen_func(ctx: tc.Ctx, w: tc.World, mod_path: String, imps: tc.Imports, exprs: ast.ExprPool, fd: ast.FuncDecl) -> GenFuncResult {
  let fr: tc.FindFuncResult = tc.find_func(ctx, mod_path, fd.name);
  if !fr.found { return GenFuncResult { ok: false, err: "missing fn sig", ctx: ctx, f: ir.Func { name: "", params: Vec(), ret: ctx.ty_bad, blocks: Vec() }, extras: Vec(), pending: Vec() }; }
  if fd.is_async {
    let ar: tc.FindAsyncFnResult = tc.find_async_fn(ctx, mod_path, fd.name);
    if !ar.found {
      return GenFuncResult { ok: false, err: "missing async lowering metadata", ctx: ctx, f: ir.Func { name: "", params: Vec(), ret: ctx.ty_bad, blocks: Vec() }, extras: Vec(), pending: Vec() };
    }

    // Constructor: `fn f(args) -> Frame { return Frame { state: 0, p_arg: arg, ... }; }`
    let sr_ctor: SynthResult = synth_async_ctor_body(exprs, fd, ar.sig.frame_name);
    if !sr_ctor.ok {
      return GenFuncResult { ok: false, err: sr_ctor.err, ctx: ctx, f: ir.Func { name: "", params: Vec(), ret: ctx.ty_bad, blocks: Vec() }, extras: Vec(), pending: Vec() };
    }
    let fd_ctor: ast.FuncDecl = ast.FuncDecl {
      file: fd.file,
      sp: fd.sp,
      vis: fd.vis,
      is_pub: fd.is_pub,
      is_async: false,
      name: fd.name,
      type_params: Vec(),
      type_param_packs: Vec(),
      const_params: Vec(),
      type_param_bounds: Vec(),
      const_where_bounds: Vec(),
      params: fd.params,
      ret: fd.ret,
      ffi_imports: Vec(),
      ffi_exports: Vec(),
      body: sr_ctor.body,
    };
    let rc: GenFuncResult = gen_func_impl(ctx, w, mod_path, mod_path, imps, sr_ctor.exprs, fd_ctor, fd.name, fr.sig, Vec(), Vec());
    if !rc.ok { return rc; }

    // Poll: `fn poll(x: &mut Frame, cx: &Context) -> Poll[Output] { ... }`
    let pr: tc.FindFuncResult = tc.find_func(rc.ctx, mod_path, ar.sig.poll_lowered);
    if !pr.found {
      return GenFuncResult { ok: false, err: "missing synthesized async poll sig", ctx: rc.ctx, f: rc.f, extras: Vec(), pending: Vec() };
    }
    let frame_var: String = "__frame";
    let sr_poll: SynthResult = synth_async_poll_body(rc.ctx, mod_path, sr_ctor.exprs, fd, frame_var, ar.sig.frame_name);
    if !sr_poll.ok {
      return GenFuncResult { ok: false, err: sr_poll.err, ctx: rc.ctx, f: rc.f, extras: Vec(), pending: Vec() };
    }
    let mut ps: Vec[ast.Param] = Vec();
    ps.push(ast.Param { name: frame_var, ty: dummy_type_name() });
    ps.push(ast.Param { name: "cx", ty: dummy_type_name() });
    let fd_poll: ast.FuncDecl = ast.FuncDecl {
      file: fd.file,
      sp: fd.sp,
      vis: ast.vis_private(),
      is_pub: false,
      is_async: true, // allow lowering `.await` scaffolds within the poll body
      name: ar.sig.poll_lowered,
      type_params: Vec(),
      type_param_packs: Vec(),
      const_params: Vec(),
      type_param_bounds: Vec(),
      const_where_bounds: Vec(),
      params: ps,
      ret: dummy_type_name(),
      ffi_imports: Vec(),
      ffi_exports: Vec(),
      body: sr_poll.body,
    };
    let rp: GenFuncResult = gen_func_impl(rc.ctx, w, mod_path, mod_path, imps, sr_poll.exprs, fd_poll, ar.sig.poll_lowered, pr.sig, Vec(), Vec());
    if !rp.ok { return rp; }

    // Merge pending instantiations from both bodies.
    let mut pend: Vec[PendingInst] = Vec();
    let mut i: i32 = 0;
    while i < rc.pending.len() { pend.push(rc.pending.get(i)); i = i + 1; }
    i = 0;
    while i < rp.pending.len() { pend.push(rp.pending.get(i)); i = i + 1; }
    let mut extras: Vec[ir.Func] = Vec();
    extras.push(rp.f);
    return GenFuncResult { ok: true, err: "", ctx: rp.ctx, f: rc.f, extras: extras, pending: pend };
  }

  return gen_func_impl(ctx, w, mod_path, mod_path, imps, exprs, fd, fd.name, fr.sig, Vec(), Vec());
}

fn gen_func_inst(
  ctx: tc.Ctx,
  w: tc.World,
  body_mod_path: String,
  target_mod_path: String,
  imps: tc.Imports,
  exprs: ast.ExprPool,
  fd: ast.FuncDecl,
  inst_name: String,
  inst_sig: tc.FuncSig,
  subs: Vec[tc.TySub],
  const_subs: Vec[tc.ConstSub]
) -> GenFuncResult {
  if fd.is_async {
    let ar: tc.FindAsyncFnResult = tc.find_async_fn(ctx, target_mod_path, inst_name);
    if !ar.found {
      return GenFuncResult { ok: false, err: "missing async lowering metadata for inst", ctx: ctx, f: ir.Func { name: "", params: Vec(), ret: ctx.ty_bad, blocks: Vec() }, extras: Vec(), pending: Vec() };
    }

    // Constructor: `fn f$inst(args) -> Frame$inst { ... }`
    let sr_ctor: SynthResult = synth_async_ctor_body(exprs, fd, ar.sig.frame_name);
    if !sr_ctor.ok {
      return GenFuncResult { ok: false, err: sr_ctor.err, ctx: ctx, f: ir.Func { name: "", params: Vec(), ret: ctx.ty_bad, blocks: Vec() }, extras: Vec(), pending: Vec() };
    }
    let fd_ctor: ast.FuncDecl = ast.FuncDecl {
      file: fd.file,
      sp: fd.sp,
      vis: fd.vis,
      is_pub: fd.is_pub,
      is_async: false,
      name: inst_name,
      type_params: Vec(),
      type_param_packs: Vec(),
      const_params: Vec(),
      type_param_bounds: Vec(),
      const_where_bounds: Vec(),
      params: fd.params,
      ret: fd.ret,
      ffi_imports: Vec(),
      ffi_exports: Vec(),
      body: sr_ctor.body,
    };
    let rc: GenFuncResult = gen_func_impl(ctx, w, body_mod_path, target_mod_path, imps, sr_ctor.exprs, fd_ctor, inst_name, inst_sig, subs, const_subs);
    if !rc.ok { return rc; }

    // Poll: `fn poll$inst(&mut Frame$inst, &Context) -> Poll[Output] { ... }`
    let pr: tc.FindFuncResult = tc.find_func(rc.ctx, target_mod_path, ar.sig.poll_lowered);
    if !pr.found {
      return GenFuncResult { ok: false, err: "missing synthesized async poll sig for inst", ctx: rc.ctx, f: rc.f, extras: Vec(), pending: Vec() };
    }
    let frame_var: String = "__frame";
    let sr_poll: SynthResult = synth_async_poll_body(rc.ctx, target_mod_path, sr_ctor.exprs, fd, frame_var, ar.sig.frame_name);
    if !sr_poll.ok {
      return GenFuncResult { ok: false, err: sr_poll.err, ctx: rc.ctx, f: rc.f, extras: Vec(), pending: Vec() };
    }
    let mut ps: Vec[ast.Param] = Vec();
    ps.push(ast.Param { name: frame_var, ty: dummy_type_name() });
    ps.push(ast.Param { name: "cx", ty: dummy_type_name() });
    let fd_poll: ast.FuncDecl = ast.FuncDecl {
      file: fd.file,
      sp: fd.sp,
      vis: ast.vis_private(),
      is_pub: false,
      is_async: true, // allow lowering `.await` scaffolds within the poll body
      name: ar.sig.poll_lowered,
      type_params: Vec(),
      type_param_packs: Vec(),
      const_params: Vec(),
      type_param_bounds: Vec(),
      const_where_bounds: Vec(),
      params: ps,
      ret: dummy_type_name(),
      ffi_imports: Vec(),
      ffi_exports: Vec(),
      body: sr_poll.body,
    };
    let rp: GenFuncResult = gen_func_impl(rc.ctx, w, body_mod_path, target_mod_path, imps, sr_poll.exprs, fd_poll, ar.sig.poll_lowered, pr.sig, subs, const_subs);
    if !rp.ok { return rp; }

    // Merge pending instantiations from both bodies.
    let mut pend: Vec[PendingInst] = Vec();
    let mut i: i32 = 0;
    while i < rc.pending.len() { pend.push(rc.pending.get(i)); i = i + 1; }
    i = 0;
    while i < rp.pending.len() { pend.push(rp.pending.get(i)); i = i + 1; }
    let mut extras: Vec[ir.Func] = Vec();
    extras.push(rp.f);
    return GenFuncResult { ok: true, err: "", ctx: rp.ctx, f: rc.f, extras: extras, pending: pend };
  }

  return gen_func_impl(ctx, w, body_mod_path, target_mod_path, imps, exprs, fd, inst_name, inst_sig, subs, const_subs);
}

struct GenStmtResult { ok: bool, err: String, g: Gen }

fn is_diag_prefix(s: String) -> bool {
  // Heuristic: `<file>:<line>:<col>:` where line/col are decimal digits.
  // Stage1 v0 file paths are posix-like and do not contain ':'.
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == 58 { break; } // ':'
    i = i + 1;
  }
  if i == 0 || i >= s.len() { return false; }
  // parse line digits
  i = i + 1;
  let mut has_line: bool = false;
  while i < s.len() {
    let b: i32 = s.byte_at(i);
    if b >= 48 && b <= 57 { has_line = true; i = i + 1; continue; }
    break;
  }
  if !has_line { return false; }
  if i >= s.len() { return false; }
  if s.byte_at(i) != 58 { return false; }
  // parse col digits
  i = i + 1;
  let mut has_col: bool = false;
  while i < s.len() {
    let b: i32 = s.byte_at(i);
    if b >= 48 && b <= 57 { has_col = true; i = i + 1; continue; }
    break;
  }
  if !has_col { return false; }
  if i >= s.len() { return false; }
  if s.byte_at(i) != 58 { return false; }
  return true;
}

fn stmt_err_at(sp: ast.Span, r: GenStmtResult) -> GenStmtResult {
  if r.ok { return r; }
  // If the inner error already has a `file:line:col:` prefix (e.g. a type error),
  // don't wrap it again as an irgen error.
  if is_diag_prefix(r.err) { return r; }
  return GenStmtResult { ok: false, err: tc.irgen_error_at(sp, r.err), g: r.g };
}

fn gen_block(g0: Gen, b: ast.Block) -> GenStmtResult {
  let mut g: Gen = g0;
  g.slots = slots_enter(g.slots);
  g.locals = tc.locals_enter(g.locals);
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let r: GenStmtResult = gen_stmt(g, b.stmts.get(i));
    if !r.ok { return r; }
    g = r.g;
    let blk: ir.Block = g.blocks.get(g.cur);
    if blk.has_term { break; }
    i = i + 1;
  }
  g.locals = tc.locals_exit(g.locals);
  g.slots = slots_exit(g.slots);
  return GenStmtResult { ok: true, err: "", g: g };
}

fn gen_stmt(g0: Gen, st: ast.Stmt) -> GenStmtResult {
  let mut g: Gen = g0;
  return match st {
    ast.Stmt.Let(sp, mutable, name, has_ann, ann, init) => stmt_err_at(sp, gen_stmt_let(g, mutable, name, has_ann, ann, init)),
    ast.Stmt.Assign(sp, name, rhs) => stmt_err_at(sp, gen_stmt_assign(g, name, rhs)),
    ast.Stmt.AssignField(sp, recv, field, rhs) => stmt_err_at(sp, gen_stmt_assign_field(g, recv, field, rhs)),
    ast.Stmt.ExprStmt(sp, eid) => stmt_err_at(sp, gen_stmt_expr(g, eid)),
    ast.Stmt.IfStmt(sp, cond, then_b, has_else, else_b) => stmt_err_at(sp, gen_stmt_if(g, cond, then_b, has_else, else_b)),
    ast.Stmt.WhileStmt(sp, cond, body) => stmt_err_at(sp, gen_stmt_while(g, cond, body)),
    ast.Stmt.Break(sp) => stmt_err_at(sp, gen_stmt_break(g)),
    ast.Stmt.Continue(sp) => stmt_err_at(sp, gen_stmt_continue(g)),
    ast.Stmt.ReturnStmt(sp, has, eid) => stmt_err_at(sp, gen_stmt_return(g, has, eid)),
  };
}
