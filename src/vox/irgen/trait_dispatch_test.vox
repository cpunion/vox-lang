import "std/testing" as t
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_trait_static_call_lowers_to_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    struct I { v: i32 }
    impl Show for I {
      fn show(x: I) -> String { return "ok"; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let s: String = Show.show(x);
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show$0"));
}
fn test_irgen_generic_impl_trait_static_call_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    impl[T] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(7);
      let s: String = Show.show(v);
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show$"));
}
fn test_irgen_generic_impl_trait_method_sugar_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    impl[T] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(7);
      let s: String = v.show();
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show$"));
}
fn test_irgen_impl_specialization_prefers_more_specific_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Tag { fn tag(x: Self) -> i32; }
    impl[T] Tag for Vec[T] { fn tag(x: Vec[T]) -> i32 { return 1; } }
    impl Tag for Vec[i32] { fn tag(x: Vec[i32]) -> i32 { return 2; } }
    fn main() -> i32 {
      let mut vi: Vec[i32] = Vec();
      let mut vs: Vec[String] = Vec();
      vi.push(7);
      vs.push("x");
      return Tag.tag(vi) + Tag.tag(vs);
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Tag$tag$1"));
  t.assert(contains(s, "impl$main$Tag$tag$0$gT_3dString"));
  t.assert(!contains(s, "impl$main$Tag$tag$0$gT_3di32"));
}
fn test_irgen_generic_impl_bound_rejected_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Mark { fn mark(x: Self) -> bool; }
    trait Show { fn show(x: Self) -> String; }
    impl[T: Mark] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(7);
      let s: String = Show.show(v);
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  let bound_msg: bool = contains(r.err, "does not satisfy trait bound");
  let no_impl_msg: bool = contains(r.err, "no impl for trait call");
  t.assert(bound_msg || no_impl_msg);
}
fn test_irgen_trait_method_sugar_lowers_to_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    struct I { v: i32 }
    impl Show for I {
      fn show(x: I) -> String { return "ok"; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let s: String = x.show();
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show$0"));
}
fn test_irgen_trait_default_method_lowers_to_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String { return "ok"; } }
    struct I { v: i32 }
    impl Show for I {}
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let s: String = x.show();
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show"));
}
fn test_irgen_trait_default_method_external_trait_uses_trait_module_scope() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", """
    fn dep_tag() -> String { return "dep"; }
    pub trait Show { fn show(x: Self) -> String { return dep_tag(); } }
  """);
  w = add_mod(w, "main", """
    import "dep" as d
    struct I { v: i32 }
    impl d.Show for I {}
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let s: String = x.show();
      return s.len();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "dep::dep_tag"));
  t.assert(contains(s, "impl$dep$Show$show"));
}
