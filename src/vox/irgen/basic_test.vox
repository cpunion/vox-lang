import "std/testing" as t
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_smoke_return_const() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> i32 { return 0; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  t.assert_eq(r.prog.funcs.len(), 1);
  let f = r.prog.funcs.get(0);
  t.assert_eq(f.blocks.len(), 1);
}
fn test_irgen_variadic_call_pack_args_lowers_vec_build() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn sum(xs: i32...) -> i32 { return xs.len(); }\nfn main() -> i32 { return sum(1, 2, 3); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_new"));
  t.assert(contains(s, "vec_push"));
}
fn test_irgen_variadic_call_generic_pack_args_lowers_vec_build() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn first[T](head: T, tail: T...) -> T { return head; }\nfn main() -> i32 { return first(7, 8, 9); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_new"));
  t.assert(contains(s, "vec_push"));
}
fn test_irgen_variadic_call_explicit_vec_arg_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn sum(xs: i32...) -> i32 { return xs.len(); }\nfn main() -> i32 { let xs: Vec[i32] = Vec(); return sum(xs); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
