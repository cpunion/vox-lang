import "std/testing" as t
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_generic_struct_comptime_where_type_layout_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct Small[T] where comptime @size_of(T) <= 8, comptime @align_of(T) <= 8 { v: T }\nfn main() -> i32 { let s: Small[i32] = Small[i32] { v: 7 }; return s.v; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_irgen_generic_struct_comptime_where_type_layout_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct Big { a: i64, b: i64 }
    struct Small[T] where comptime @size_of(T) <= 8 { v: T }
    const V: i32 = 0
    fn main() -> i32 { let b: Big = Big { a: 1, b: 2 }; let s: Small[Big] = Small[Big] { v: b }; return V; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "type resolve failed in let annotation"), r.err);
}
fn test_irgen_generic_enum_comptime_where_type_layout_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "enum Tiny[T] where comptime @size_of(T) <= 8 { V(T) }\nfn main() -> i32 { let x: Tiny[i32] = Tiny[i32].V(7); return match x { Tiny.V(v) => v }; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_irgen_generic_enum_comptime_where_type_layout_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct Big { a: i64, b: i64 }\nenum Tiny[T] where comptime @size_of(T) <= 8 { V(T) }\nfn main() -> i32 { let b: Big = Big { a: 1, b: 2 }; let x: Tiny[Big] = Tiny[Big].V(b); return 0; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "type resolve failed in let annotation"), r.err);
}
fn test_irgen_monomorphizes_generic_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn id[T](x: T) -> T { return x; } fn main() -> i32 { return id(1); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  // Emit main + the instantiated `id[T=i32]`.
  t.assert_eq(r.prog.funcs.len(), 2);
  t.assert(prog_has_func(r.prog, "main"));
  t.assert(prog_has_func(r.prog, "id$gT_3di32"));
  t.assert(!prog_has_func(r.prog, "id"));
}
fn test_irgen_monomorphizes_multiple_instantiations() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn id[T](x: T) -> T { return x; }\nfn main() -> i32 {\n  let a: i32 = id(1);\n  let b: i64 = id[i64](1);\n  return a;\n}\n");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  t.assert_eq(r.prog.funcs.len(), 3);
  t.assert(prog_has_func(r.prog, "main"));
  t.assert(prog_has_func(r.prog, "id$gT_3di32"));
  t.assert(prog_has_func(r.prog, "id$gT_3di64"));
}
fn test_irgen_monomorphizes_generic_body_with_type_params() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn mk[T](x: T) -> Vec[T] {\n  let mut v: Vec[T] = Vec();\n  v.push(x);\n  return v;\n}\nfn main() -> i32 {\n  let v = mk(1);\n  return v.len();\n}\n");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "mk$gT_3di32"));
}
fn test_irgen_monomorphizes_const_generic_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn addn[const N: i32](x: i32) -> i32 { return x + N; }
    fn main() -> i32 { return addn[3](1); }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert_eq(r.prog.funcs.len(), 2);
  t.assert(prog_has_func(r.prog, "main"));
  t.assert(prog_has_func(r.prog, "addn$gN_3d3_3ai32"));
  t.assert(!prog_has_func(r.prog, "addn"));
}
fn test_irgen_monomorphizes_const_generic_default_arg_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; }
    fn main() -> i32 { return addn(1); }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "addn$gN_3d3_3ai32"));
}
fn test_irgen_monomorphizes_const_generic_default_arg_override() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; }
    fn main() -> i32 {
      let a: i32 = addn(1);
      let b: i32 = addn[9](1);
      return a + b;
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "addn$gN_3d3_3ai32"));
  t.assert(prog_has_func(r.prog, "addn$gN_3d9_3ai32"));
}
fn test_irgen_monomorphizes_const_generic_multiple_instantiations() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn addn[const N: i32](x: i32) -> i32 { return x + N; }
    fn main() -> i32 {
      let a: i32 = addn[1](1);
      let b: i32 = addn[2](1);
      return a + b;
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "addn$gN_3d1_3ai32"));
  t.assert(prog_has_func(r.prog, "addn$gN_3d2_3ai32"));
}
fn test_irgen_monomorphizes_generic_nominal_types() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Pair[T] { a: T, b: T }
    enum Option[T] { Some(T), None }
    fn main() -> i32 {
      let p: Pair[i32] = Pair { a: 1, b: 2 };
      let o: Option[i32] = Option.Some(p.a + p.b);
      return match o { Option.Some(v) => v, Option.None => 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(prog_has_struct(r.prog, "Pair$gT_3di32"));
  t.assert(prog_has_enum(r.prog, "Option$gT_3di32"));
}
fn test_irgen_monomorphizes_typed_path_generic_nominal_types() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct Pair[T] { a: T, b: T }
    enum Option[T] { Some(T), None }
    fn main() -> i32 {
      let p = Pair[i32] { a: 1, b: 2 };
      let o = Option[i32].Some(p.a + p.b);
      let n = Option[i32].None;
      let y: i32 = match n { Option.Some(v) => v, Option.None => 0 };
      return match o { Option.Some(v) => v + y, Option.None => 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(prog_has_struct(r.prog, "Pair$gT_3di32"));
  t.assert(prog_has_enum(r.prog, "Option$gT_3di32"));
}
fn test_irgen_generic_trait_bound_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    fn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }
    fn main() -> i32 { return if same("a", "b") { 1 } else { 0 }; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
}
fn test_irgen_trait_static_call_lowers_to_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    struct I { v: i32 }
    impl Show for I {
      fn show(x: I) -> String { return "ok"; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let s: String = Show.show(x);
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show$0"));
}
fn test_irgen_generic_impl_trait_static_call_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    impl[T] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(7);
      let s: String = Show.show(v);
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show$"));
}
fn test_irgen_generic_impl_trait_method_sugar_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    impl[T] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(7);
      let s: String = v.show();
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show$"));
}
fn test_irgen_impl_specialization_prefers_more_specific_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Tag { fn tag(x: Self) -> i32; }
    impl[T] Tag for Vec[T] { fn tag(x: Vec[T]) -> i32 { return 1; } }
    impl Tag for Vec[i32] { fn tag(x: Vec[i32]) -> i32 { return 2; } }
    fn main() -> i32 {
      let mut vi: Vec[i32] = Vec();
      let mut vs: Vec[String] = Vec();
      vi.push(7);
      vs.push("x");
      return Tag.tag(vi) + Tag.tag(vs);
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Tag$tag$1"));
  t.assert(contains(s, "impl$main$Tag$tag$0$gT_3dString"));
  t.assert(!contains(s, "impl$main$Tag$tag$0$gT_3di32"));
}
fn test_irgen_generic_impl_bound_rejected_smoke() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Mark { fn mark(x: Self) -> bool; }
    trait Show { fn show(x: Self) -> String; }
    impl[T: Mark] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(7);
      let s: String = Show.show(v);
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  let bound_msg: bool = contains(r.err, "does not satisfy trait bound");
  let no_impl_msg: bool = contains(r.err, "no impl for trait call");
  t.assert(bound_msg || no_impl_msg);
}
fn test_irgen_trait_method_sugar_lowers_to_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String; }
    struct I { v: i32 }
    impl Show for I {
      fn show(x: I) -> String { return "ok"; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let s: String = x.show();
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show$0"));
}
fn test_irgen_trait_default_method_lowers_to_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait Show { fn show(x: Self) -> String { return "ok"; } }
    struct I { v: i32 }
    impl Show for I {}
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let s: String = x.show();
      return s.len();
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show"));
}
fn test_irgen_trait_default_method_external_trait_uses_trait_module_scope() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "dep", """
    fn dep_tag() -> String { return "dep"; }
    pub trait Show { fn show(x: Self) -> String { return dep_tag(); } }
  """);
  w = add_mod(w, "main", """
    import "dep" as d
    struct I { v: i32 }
    impl d.Show for I {}
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let s: String = x.show();
      return s.len();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "dep::dep_tag"));
  t.assert(contains(s, "impl$dep$Show$show"));
}
fn test_irgen_trait_generic_method_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
  """);
  w = add_mod(w, "main", """
    trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T; }
    struct I { v: i32 }
    impl Wrap for I { fn wrap[T: Eq](x: I, v: T) -> T { return v; } }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let a: i32 = Wrap.wrap[i32](x, 7);
      let b: i32 = I { v: 2 }.wrap[i32](9);
      return a + b;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Wrap$wrap$"));
  t.assert(contains(s, "$gT_3di32"));
}
fn test_irgen_trait_const_generic_method_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }
    struct I { v: i32 }
    impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return AddN.addn[3](x, 4);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$AddN$addn$"));
  t.assert(contains(s, "$gN_3d3_3ai32"));
}
fn test_irgen_trait_const_generic_method_comptime_where_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }
    struct I { v: i32 }
    impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N > 0 { return v + N; } }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return AddN.addn[3](x, 4);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$AddN$addn$"));
  t.assert(contains(s, "$gN_3d3_3ai32"));
}
fn test_irgen_trait_const_generic_method_comptime_where_impl_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }
    struct I { v: i32 }
    impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N >= 0 { return v + N; } }
    fn main() -> i32 { return 0; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}
fn test_irgen_trait_const_generic_method_comptime_where_rhs_reflect_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait FitRU {
      fn fit[T, U](x: Self, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U);
    }
    struct I { v: i32 }
    impl FitRU for I {
      fn fit[T, U](x: I, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U) { return 1; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let y: i64 = 0;
      return FitRU.fit(x, 3, y);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$FitRU$fit$"));
}
fn test_irgen_trait_const_generic_method_comptime_where_rhs_reflect_impl_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait FitRU {
      fn fit[T, U](x: Self, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U);
    }
    struct I { v: i32 }
    impl FitRU for I {
      fn fit[T, U](x: I, a: T, b: U) -> i32 where comptime @size_of(T) < @align_of(U) { return 1; }
    }
    fn main() -> i32 { return 0; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}
fn test_irgen_trait_generic_default_method_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
  """);
  w = add_mod(w, "main", """
    trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T { return v; } }
    struct I { v: i32 }
    impl Wrap for I {}
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let a: i32 = Wrap.wrap[i32](x, 7);
      let b: i32 = I { v: 2 }.wrap[i32](9);
      return a + b;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Wrap$wrap$"));
  t.assert(contains(s, "$gT_3di32"));
}
fn test_irgen_generic_bound_trait_method_sugar_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait Show { fn show(x: Self) -> String; }
    impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
    fn f[T: Show](x: T) -> String { return x.show(); }
    fn main() -> i32 {
      let s: String = f(7);
      return s.len();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show"));
  t.assert(contains(s, "f$gT_3di32"));
}
fn test_irgen_trait_static_call_lowers_impl_method_body() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait AddOne { fn add_one(x: Self) -> i32; }
    struct I { v: i32 }
    impl AddOne for I {
      fn add_one(x: I) -> i32 { return x.v + 1; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return AddOne.add_one(x);
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "impl$main$AddOne$add_one$0"));
}
fn test_irgen_prelude_trait_fallback_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
  """);
  w = add_mod(w, "main", "fn main() -> i32 { return if Eq.eq(1, 1) { 1 } else { 0 }; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "std.prelude::impl$std.prelude$Eq$eq"));
}
fn test_irgen_prelude_trait_default_method_fallback_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    fn tag() -> String { return "pre"; }
    pub trait Show { fn show(x: Self) -> String { return tag(); } }
  """);
  w = add_mod(w, "main", """
    struct I { v: i32 }
    impl Show for I {}
    fn main() -> i32 { let s: String = I { v: 1 }.show(); return s.len(); }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "std.prelude::tag"));
  t.assert(contains(s, "impl$std.prelude$Show$show"));
}
fn test_irgen_inherent_impl_method_call_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct I { v: i32 }
    impl I { fn inc(x: I) -> i32 { return x.v + 1; } }
    fn main() -> i32 { return I { v: 1 }.inc(); }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$inherent$inc$"));
}
