import "vox/ast" as ast
import "vox/ir" as ir
import "vox/typecheck" as tc

fn starts_with(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

struct VecRecvSlotResult { ok: bool, err: String, g: Gen, slot: i32 }

struct GenPatResult { ok: bool, err: String, g: Gen }
struct VecPushParentSlot {
  parent_slot: i32,
  field: String,
  child_slot: i32,
  child_ty: i32,
}
struct MemberChainResult { ok: bool, err: String, base: String, fields: Vec[String] }

fn gen_pat_ok(g: Gen) -> GenPatResult { return GenPatResult { ok: true, err: "", g: g }; }
fn gen_pat_err(g: Gen, msg: String) -> GenPatResult { return GenPatResult { ok: false, err: msg, g: g }; }

struct EnumSigResult { ok: bool, err: String, sig: tc.EnumSig }
struct FindVariantResult { found: bool, idx: i32, sig: tc.EnumVariantSig }

fn empty_enum_sig() -> tc.EnumSig { return tc.EnumSig { mod_path: "", name: "", base_name: "", vis: ast.vis_private(), is_pub: false, vars: Vec() }; }
fn empty_variant_sig() -> tc.EnumVariantSig { return tc.EnumVariantSig { name: "", fields: Vec() }; }

fn enum_sig_for_ty(ctx: tc.Ctx, ty: i32) -> EnumSigResult {
  let base: i32 = tc.strip_range(ctx, ty);
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, base);
  if t.kind != ir.TyKind.Enum { return EnumSigResult { ok: false, err: "expected enum type", sig: empty_enum_sig() }; }
  let fe: tc.FindEnumResult = tc.find_enum(ctx, tc.ty_mod(t), tc.ty_name(t));
  if !fe.found { return EnumSigResult { ok: false, err: "unknown enum", sig: empty_enum_sig() }; }
  return EnumSigResult { ok: true, err: "", sig: fe.sig };
}

fn find_enum_variant(es: tc.EnumSig, vname: String) -> FindVariantResult {
  let mut i: i32 = 0;
  while i < es.vars.len() {
    let v: tc.EnumVariantSig = es.vars.get(i);
    if v.name == vname { return FindVariantResult { found: true, idx: i, sig: v }; }
    i = i + 1;
  }
  return FindVariantResult { found: false, idx: -1, sig: empty_variant_sig() };
}

fn find_named_func_import(named: Vec[tc.NamedFuncImport], local: String) -> tc.NamedFuncImport {
  let mut i: i32 = 0;
  while i < named.len() {
    let it: tc.NamedFuncImport = named.get(i);
    if it.local == local { return it; }
    i = i + 1;
  }
  return tc.NamedFuncImport { local: "", mod_path: "", name: "" };
}

fn find_named_type_import(named: Vec[tc.NamedTypeImport], local: String) -> tc.NamedTypeImport {
  let mut i: i32 = 0;
  while i < named.len() {
    let it: tc.NamedTypeImport = named.get(i);
    if it.local == local { return it; }
    i = i + 1;
  }
  return tc.NamedTypeImport { local: "", mod_path: "", name: "", kind: 0 };
}

fn is_vec_builtin_method(name: String) -> bool {
  return name == "push" || name == "insert" || name == "set" || name == "clear" || name == "extend" || name == "pop" || name == "remove" || name == "len" || name == "is_empty" || name == "get" || name == "join";
}

fn is_string_builtin_method(name: String) -> bool {
  return name == "len" ||
    name == "is_empty" ||
    name == "byte_at" ||
    name == "slice" ||
    name == "concat" ||
    name == "escape_c" ||
    name == "to_string" ||
    name == "starts_with" ||
    name == "ends_with" ||
    name == "contains" ||
    name == "index_of" ||
    name == "last_index_of";
}

fn rev_strings(xs: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = xs.len() - 1;
  while i >= 0 {
    out.push(xs.get(i));
    i = i - 1;
  }
  return out;
}

fn member_chain(exprs: ast.ExprPool, recv_id: i32) -> MemberChainResult {
  let mut cur: i32 = recv_id;
  let mut rev: Vec[String] = Vec();
  while true {
    let n: ast.ExprNode = ast.expr_pool_get(exprs, cur);
    if match n { ast.ExprNode.Ident(_x) => true, _ => false } {
      let base: String = match n { ast.ExprNode.Ident(s) => s, _ => "" };
      return MemberChainResult { ok: true, err: "", base: base, fields: rev_strings(rev) };
    }
    if match n { ast.ExprNode.Member(_r, _n) => true, _ => false } {
      let r: i32 = match n { ast.ExprNode.Member(x, _n) => x, _ => -1 };
      let f: String = match n { ast.ExprNode.Member(_r, x) => x, _ => "" };
      rev.push(f);
      cur = r;
      continue;
    }
    return MemberChainResult { ok: false, err: "Vec.push recv must be place", base: "", fields: Vec() };
  }
  return MemberChainResult { ok: false, err: "Vec.push recv must be place", base: "", fields: Vec() };
}

fn place_chain(exprs: ast.ExprPool, recv_id: i32) -> MemberChainResult {
  let mut cur: i32 = recv_id;
  let mut rev: Vec[String] = Vec();
  while true {
    let n: ast.ExprNode = ast.expr_pool_get(exprs, cur);
    if match n { ast.ExprNode.Ident(_x) => true, _ => false } {
      let base: String = match n { ast.ExprNode.Ident(s) => s, _ => "" };
      return MemberChainResult { ok: true, err: "", base: base, fields: rev_strings(rev) };
    }
    if match n { ast.ExprNode.Member(_r, _n) => true, _ => false } {
      let r: i32 = match n { ast.ExprNode.Member(x, _n) => x, _ => -1 };
      let f: String = match n { ast.ExprNode.Member(_r, x) => x, _ => "" };
      rev.push(f);
      cur = r;
      continue;
    }
    return MemberChainResult { ok: false, err: "inout argument must be a place", base: "", fields: Vec() };
  }
  return MemberChainResult { ok: false, err: "inout argument must be a place", base: "", fields: Vec() };
}

fn gen_vec_push_member_place(g0: Gen, recv_id: i32, recv_ty: i32, elem: i32, val: ir.Value, out_ty: i32) -> GenExprResult {
  let mc: MemberChainResult = member_chain(g0.exprs, recv_id);
  if !mc.ok { return GenExprResult { ok: false, err: mc.err, g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if mc.fields.len() == 0 { return GenExprResult { ok: false, err: "Vec.push recv must be place", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let br: LookupSlotResult = slots_lookup(g0.slots, mc.base);
  if !br.found { return GenExprResult { ok: false, err: "unknown base var", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if !br.mutable { return GenExprResult { ok: false, err: "Vec.push recv is immutable", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let mut g: Gen = g0;
  let mut cur_slot: i32 = br.slot;
  let mut cur_ty: i32 = br.ty;
  let mut parents: Vec[VecPushParentSlot] = Vec();

  let mut fi: i32 = 0;
  while fi < mc.fields.len() - 1 {
    let rt: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
    if rt.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.push recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let fs: tc.FindStructResult = tc.find_struct(g.ctx, rt.mod_path, rt.name);
    if !fs.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fs.sig.vis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let fname: String = mc.fields.get(fi);
    let mut found: bool = false;
    let mut next_ty: i32 = g.ctx.ty_bad;
    let mut fvis: i32 = ast.vis_private();
    let mut si: i32 = 0;
    while si < fs.sig.fields.len() {
      let sf: tc.StructFieldSig = fs.sig.fields.get(si);
      if sf.name == fname {
        found = true;
        next_ty = sf.ty;
        fvis = sf.vis;
        break;
      }
      si = si + 1;
    }
    if !found { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fvis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.FieldGet(tid, cur_ty, ir.v_slot(cur_slot), fname));
    let ns: GenNewIdResult = gen_new_slot(g);
    g = ns.g;
    let sid: i32 = ns.id;
    g = gen_emit(g, ir.Instr.SlotDecl(sid, next_ty));
    g = gen_emit(g, ir.Instr.Store(sid, ir.v_temp(tid)));
    parents.push(VecPushParentSlot { parent_slot: cur_slot, field: fname, child_slot: sid, child_ty: next_ty });
    cur_slot = sid;
    cur_ty = next_ty;
    fi = fi + 1;
  }

  let rt_last: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
  if rt_last.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.push recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  let fs_last: tc.FindStructResult = tc.find_struct(g.ctx, rt_last.mod_path, rt_last.name);
  if !fs_last.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(fs_last.sig.vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let leaf: String = mc.fields.get(mc.fields.len() - 1);
  let mut leaf_ok: bool = false;
  let mut leaf_ty: i32 = g.ctx.ty_bad;
  let mut leaf_vis: i32 = ast.vis_private();
  let mut li: i32 = 0;
  while li < fs_last.sig.fields.len() {
    let lf: tc.StructFieldSig = fs_last.sig.fields.get(li);
    if lf.name == leaf {
      leaf_ok = true;
      leaf_ty = lf.ty;
      leaf_vis = lf.vis;
      break;
    }
    li = li + 1;
  }
  if !leaf_ok { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(leaf_vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  // Leaf field is the actual Vec place we mutate.
  let t_vec: GenNewIdResult = gen_new_temp(g);
  g = t_vec.g;
  let tid_v: i32 = t_vec.id;
  g = gen_emit(g, ir.Instr.FieldGet(tid_v, leaf_ty, ir.v_slot(cur_slot), leaf));
  let sl: GenNewIdResult = gen_new_slot(g);
  g = sl.g;
  let vec_slot: i32 = sl.id;
  g = gen_emit(g, ir.Instr.SlotDecl(vec_slot, leaf_ty));
  g = gen_emit(g, ir.Instr.Store(vec_slot, ir.v_temp(tid_v)));
  g = gen_emit(g, ir.Instr.VecPush(vec_slot, elem, val));

  let t_vec2: GenNewIdResult = gen_new_temp(g);
  g = t_vec2.g;
  let tid_v2: i32 = t_vec2.id;
  g = gen_emit(g, ir.Instr.Load(tid_v2, leaf_ty, vec_slot));
  g = gen_emit(g, ir.Instr.StoreField(cur_slot, leaf, ir.v_temp(tid_v2)));

  let mut ri: i32 = parents.len() - 1;
  while ri >= 0 {
    let ps: VecPushParentSlot = parents.get(ri);
    let nt2: GenNewIdResult = gen_new_temp(g);
    g = nt2.g;
    let tid2: i32 = nt2.id;
    g = gen_emit(g, ir.Instr.Load(tid2, ps.child_ty, ps.child_slot));
    g = gen_emit(g, ir.Instr.StoreField(ps.parent_slot, ps.field, ir.v_temp(tid2)));
    ri = ri - 1;
  }

  return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
}

fn gen_vec_insert_member_place(g0: Gen, recv_id: i32, recv_ty: i32, elem: i32, idx: ir.Value, val: ir.Value, out_ty: i32) -> GenExprResult {
  let mc: MemberChainResult = member_chain(g0.exprs, recv_id);
  if !mc.ok { return GenExprResult { ok: false, err: mc.err, g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if mc.fields.len() == 0 { return GenExprResult { ok: false, err: "Vec.insert recv must be place", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let br: LookupSlotResult = slots_lookup(g0.slots, mc.base);
  if !br.found { return GenExprResult { ok: false, err: "unknown base var", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if !br.mutable { return GenExprResult { ok: false, err: "Vec.insert recv is immutable", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let mut g: Gen = g0;
  let mut cur_slot: i32 = br.slot;
  let mut cur_ty: i32 = br.ty;
  let mut parents: Vec[VecPushParentSlot] = Vec();

  let mut fi: i32 = 0;
  while fi < mc.fields.len() - 1 {
    let rt: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
    if rt.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.insert recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let fs: tc.FindStructResult = tc.find_struct(g.ctx, rt.mod_path, rt.name);
    if !fs.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fs.sig.vis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let fname: String = mc.fields.get(fi);
    let mut found: bool = false;
    let mut next_ty: i32 = g.ctx.ty_bad;
    let mut fvis: i32 = ast.vis_private();
    let mut si: i32 = 0;
    while si < fs.sig.fields.len() {
      let sf: tc.StructFieldSig = fs.sig.fields.get(si);
      if sf.name == fname {
        found = true;
        next_ty = sf.ty;
        fvis = sf.vis;
        break;
      }
      si = si + 1;
    }
    if !found { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fvis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.FieldGet(tid, cur_ty, ir.v_slot(cur_slot), fname));
    let ns: GenNewIdResult = gen_new_slot(g);
    g = ns.g;
    let sid: i32 = ns.id;
    g = gen_emit(g, ir.Instr.SlotDecl(sid, next_ty));
    g = gen_emit(g, ir.Instr.Store(sid, ir.v_temp(tid)));
    parents.push(VecPushParentSlot { parent_slot: cur_slot, field: fname, child_slot: sid, child_ty: next_ty });
    cur_slot = sid;
    cur_ty = next_ty;
    fi = fi + 1;
  }

  let rt_last: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
  if rt_last.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.insert recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  let fs_last: tc.FindStructResult = tc.find_struct(g.ctx, rt_last.mod_path, rt_last.name);
  if !fs_last.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(fs_last.sig.vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let leaf: String = mc.fields.get(mc.fields.len() - 1);
  let mut leaf_ok: bool = false;
  let mut leaf_ty: i32 = g.ctx.ty_bad;
  let mut leaf_vis: i32 = ast.vis_private();
  let mut li: i32 = 0;
  while li < fs_last.sig.fields.len() {
    let lf: tc.StructFieldSig = fs_last.sig.fields.get(li);
    if lf.name == leaf {
      leaf_ok = true;
      leaf_ty = lf.ty;
      leaf_vis = lf.vis;
      break;
    }
    li = li + 1;
  }
  if !leaf_ok { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(leaf_vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let t_vec: GenNewIdResult = gen_new_temp(g);
  g = t_vec.g;
  let tid_v: i32 = t_vec.id;
  g = gen_emit(g, ir.Instr.FieldGet(tid_v, leaf_ty, ir.v_slot(cur_slot), leaf));
  let sl: GenNewIdResult = gen_new_slot(g);
  g = sl.g;
  let vec_slot: i32 = sl.id;
  g = gen_emit(g, ir.Instr.SlotDecl(vec_slot, leaf_ty));
  g = gen_emit(g, ir.Instr.Store(vec_slot, ir.v_temp(tid_v)));
  g = gen_emit(g, ir.Instr.VecInsert(vec_slot, elem, idx, val));

  let t_vec2: GenNewIdResult = gen_new_temp(g);
  g = t_vec2.g;
  let tid_v2: i32 = t_vec2.id;
  g = gen_emit(g, ir.Instr.Load(tid_v2, leaf_ty, vec_slot));
  g = gen_emit(g, ir.Instr.StoreField(cur_slot, leaf, ir.v_temp(tid_v2)));

  let mut ri: i32 = parents.len() - 1;
  while ri >= 0 {
    let ps: VecPushParentSlot = parents.get(ri);
    let nt2: GenNewIdResult = gen_new_temp(g);
    g = nt2.g;
    let tid2: i32 = nt2.id;
    g = gen_emit(g, ir.Instr.Load(tid2, ps.child_ty, ps.child_slot));
    g = gen_emit(g, ir.Instr.StoreField(ps.parent_slot, ps.field, ir.v_temp(tid2)));
    ri = ri - 1;
  }

  return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
}

fn gen_vec_set_member_place(g0: Gen, recv_id: i32, _recv_ty: i32, elem: i32, idx: ir.Value, val: ir.Value, out_ty: i32) -> GenExprResult {
  let mc: MemberChainResult = member_chain(g0.exprs, recv_id);
  if !mc.ok { return GenExprResult { ok: false, err: mc.err, g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if mc.fields.len() == 0 { return GenExprResult { ok: false, err: "Vec.set recv must be place", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let br: LookupSlotResult = slots_lookup(g0.slots, mc.base);
  if !br.found { return GenExprResult { ok: false, err: "unknown base var", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if !br.mutable { return GenExprResult { ok: false, err: "Vec.set recv is immutable", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let mut g: Gen = g0;
  let mut cur_slot: i32 = br.slot;
  let mut cur_ty: i32 = br.ty;
  let mut parents: Vec[VecPushParentSlot] = Vec();

  let mut fi: i32 = 0;
  while fi < mc.fields.len() - 1 {
    let rt: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
    if rt.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.set recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let fs: tc.FindStructResult = tc.find_struct(g.ctx, rt.mod_path, rt.name);
    if !fs.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fs.sig.vis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let fname: String = mc.fields.get(fi);
    let mut found: bool = false;
    let mut next_ty: i32 = g.ctx.ty_bad;
    let mut fvis: i32 = ast.vis_private();
    let mut si: i32 = 0;
    while si < fs.sig.fields.len() {
      let sf: tc.StructFieldSig = fs.sig.fields.get(si);
      if sf.name == fname {
        found = true;
        next_ty = sf.ty;
        fvis = sf.vis;
        break;
      }
      si = si + 1;
    }
    if !found { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fvis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.FieldGet(tid, cur_ty, ir.v_slot(cur_slot), fname));
    let ns: GenNewIdResult = gen_new_slot(g);
    g = ns.g;
    let sid: i32 = ns.id;
    g = gen_emit(g, ir.Instr.SlotDecl(sid, next_ty));
    g = gen_emit(g, ir.Instr.Store(sid, ir.v_temp(tid)));
    parents.push(VecPushParentSlot { parent_slot: cur_slot, field: fname, child_slot: sid, child_ty: next_ty });
    cur_slot = sid;
    cur_ty = next_ty;
    fi = fi + 1;
  }

  let rt_last: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
  if rt_last.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.set recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  let fs_last: tc.FindStructResult = tc.find_struct(g.ctx, rt_last.mod_path, rt_last.name);
  if !fs_last.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(fs_last.sig.vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let leaf: String = mc.fields.get(mc.fields.len() - 1);
  let mut leaf_ok: bool = false;
  let mut leaf_ty: i32 = g.ctx.ty_bad;
  let mut leaf_vis: i32 = ast.vis_private();
  let mut li: i32 = 0;
  while li < fs_last.sig.fields.len() {
    let lf: tc.StructFieldSig = fs_last.sig.fields.get(li);
    if lf.name == leaf {
      leaf_ok = true;
      leaf_ty = lf.ty;
      leaf_vis = lf.vis;
      break;
    }
    li = li + 1;
  }
  if !leaf_ok { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(leaf_vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let t_vec: GenNewIdResult = gen_new_temp(g);
  g = t_vec.g;
  let tid_v: i32 = t_vec.id;
  g = gen_emit(g, ir.Instr.FieldGet(tid_v, leaf_ty, ir.v_slot(cur_slot), leaf));
  let sl: GenNewIdResult = gen_new_slot(g);
  g = sl.g;
  let vec_slot: i32 = sl.id;
  g = gen_emit(g, ir.Instr.SlotDecl(vec_slot, leaf_ty));
  g = gen_emit(g, ir.Instr.Store(vec_slot, ir.v_temp(tid_v)));
  g = gen_emit(g, ir.Instr.VecSet(vec_slot, elem, idx, val));

  let t_vec2: GenNewIdResult = gen_new_temp(g);
  g = t_vec2.g;
  let tid_v2: i32 = t_vec2.id;
  g = gen_emit(g, ir.Instr.Load(tid_v2, leaf_ty, vec_slot));
  g = gen_emit(g, ir.Instr.StoreField(cur_slot, leaf, ir.v_temp(tid_v2)));

  let mut ri: i32 = parents.len() - 1;
  while ri >= 0 {
    let ps: VecPushParentSlot = parents.get(ri);
    let nt2: GenNewIdResult = gen_new_temp(g);
    g = nt2.g;
    let tid2: i32 = nt2.id;
    g = gen_emit(g, ir.Instr.Load(tid2, ps.child_ty, ps.child_slot));
    g = gen_emit(g, ir.Instr.StoreField(ps.parent_slot, ps.field, ir.v_temp(tid2)));
    ri = ri - 1;
  }

  return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
}

fn gen_vec_clear_member_place(g0: Gen, recv_id: i32, _recv_ty: i32, out_ty: i32) -> GenExprResult {
  let mc: MemberChainResult = member_chain(g0.exprs, recv_id);
  if !mc.ok { return GenExprResult { ok: false, err: "Vec.clear recv must be place", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if mc.fields.len() == 0 { return GenExprResult { ok: false, err: "Vec.clear recv must be place", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let br: LookupSlotResult = slots_lookup(g0.slots, mc.base);
  if !br.found { return GenExprResult { ok: false, err: "unknown base var", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if !br.mutable { return GenExprResult { ok: false, err: "Vec.clear recv is immutable", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let mut g: Gen = g0;
  let mut cur_slot: i32 = br.slot;
  let mut cur_ty: i32 = br.ty;
  let mut parents: Vec[VecPushParentSlot] = Vec();

  let mut fi: i32 = 0;
  while fi < mc.fields.len() - 1 {
    let rt: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
    if rt.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.clear recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let fs: tc.FindStructResult = tc.find_struct(g.ctx, rt.mod_path, rt.name);
    if !fs.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fs.sig.vis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let fname: String = mc.fields.get(fi);
    let mut found: bool = false;
    let mut next_ty: i32 = g.ctx.ty_bad;
    let mut fvis: i32 = ast.vis_private();
    let mut si: i32 = 0;
    while si < fs.sig.fields.len() {
      let sf: tc.StructFieldSig = fs.sig.fields.get(si);
      if sf.name == fname {
        found = true;
        next_ty = sf.ty;
        fvis = sf.vis;
        break;
      }
      si = si + 1;
    }
    if !found { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fvis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.FieldGet(tid, cur_ty, ir.v_slot(cur_slot), fname));
    let ns: GenNewIdResult = gen_new_slot(g);
    g = ns.g;
    let sid: i32 = ns.id;
    g = gen_emit(g, ir.Instr.SlotDecl(sid, next_ty));
    g = gen_emit(g, ir.Instr.Store(sid, ir.v_temp(tid)));
    parents.push(VecPushParentSlot { parent_slot: cur_slot, field: fname, child_slot: sid, child_ty: next_ty });
    cur_slot = sid;
    cur_ty = next_ty;
    fi = fi + 1;
  }

  let rt_last: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
  if rt_last.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.clear recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  let fs_last: tc.FindStructResult = tc.find_struct(g.ctx, rt_last.mod_path, rt_last.name);
  if !fs_last.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(fs_last.sig.vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let leaf: String = mc.fields.get(mc.fields.len() - 1);
  let mut leaf_ok: bool = false;
  let mut leaf_ty: i32 = g.ctx.ty_bad;
  let mut leaf_vis: i32 = ast.vis_private();
  let mut li: i32 = 0;
  while li < fs_last.sig.fields.len() {
    let lf: tc.StructFieldSig = fs_last.sig.fields.get(li);
    if lf.name == leaf {
      leaf_ok = true;
      leaf_ty = lf.ty;
      leaf_vis = lf.vis;
      break;
    }
    li = li + 1;
  }
  if !leaf_ok { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(leaf_vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  // Leaf field is the actual Vec place we mutate.
  let t_vec: GenNewIdResult = gen_new_temp(g);
  g = t_vec.g;
  let tid_v: i32 = t_vec.id;
  g = gen_emit(g, ir.Instr.FieldGet(tid_v, leaf_ty, ir.v_slot(cur_slot), leaf));
  let sl: GenNewIdResult = gen_new_slot(g);
  g = sl.g;
  let vec_slot: i32 = sl.id;
  g = gen_emit(g, ir.Instr.SlotDecl(vec_slot, leaf_ty));
  g = gen_emit(g, ir.Instr.Store(vec_slot, ir.v_temp(tid_v)));
  g = gen_emit(g, ir.Instr.VecClear(vec_slot));

  let t_vec2: GenNewIdResult = gen_new_temp(g);
  g = t_vec2.g;
  let tid_v2: i32 = t_vec2.id;
  g = gen_emit(g, ir.Instr.Load(tid_v2, leaf_ty, vec_slot));
  g = gen_emit(g, ir.Instr.StoreField(cur_slot, leaf, ir.v_temp(tid_v2)));

  let mut ri: i32 = parents.len() - 1;
  while ri >= 0 {
    let ps: VecPushParentSlot = parents.get(ri);
    let nt2: GenNewIdResult = gen_new_temp(g);
    g = nt2.g;
    let tid2: i32 = nt2.id;
    g = gen_emit(g, ir.Instr.Load(tid2, ps.child_ty, ps.child_slot));
    g = gen_emit(g, ir.Instr.StoreField(ps.parent_slot, ps.field, ir.v_temp(tid2)));
    ri = ri - 1;
  }

  return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
}

fn gen_vec_extend_member_place(g0: Gen, recv_id: i32, src_slot: i32, out_ty: i32) -> GenExprResult {
  let mc: MemberChainResult = member_chain(g0.exprs, recv_id);
  if !mc.ok { return GenExprResult { ok: false, err: "Vec.extend recv must be place", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if mc.fields.len() == 0 { return GenExprResult { ok: false, err: "Vec.extend recv must be place", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let br: LookupSlotResult = slots_lookup(g0.slots, mc.base);
  if !br.found { return GenExprResult { ok: false, err: "unknown base var", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if !br.mutable { return GenExprResult { ok: false, err: "Vec.extend recv is immutable", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let mut g: Gen = g0;
  let mut cur_slot: i32 = br.slot;
  let mut cur_ty: i32 = br.ty;
  let mut parents: Vec[VecPushParentSlot] = Vec();

  let mut fi: i32 = 0;
  while fi < mc.fields.len() - 1 {
    let rt: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
    if rt.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.extend recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let fs: tc.FindStructResult = tc.find_struct(g.ctx, rt.mod_path, rt.name);
    if !fs.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fs.sig.vis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let fname: String = mc.fields.get(fi);
    let mut found: bool = false;
    let mut next_ty: i32 = g.ctx.ty_bad;
    let mut fvis: i32 = ast.vis_private();
    let mut si: i32 = 0;
    while si < fs.sig.fields.len() {
      let sf: tc.StructFieldSig = fs.sig.fields.get(si);
      if sf.name == fname {
        found = true;
        next_ty = sf.ty;
        fvis = sf.vis;
        break;
      }
      si = si + 1;
    }
    if !found { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fvis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.FieldGet(tid, cur_ty, ir.v_slot(cur_slot), fname));
    let ns: GenNewIdResult = gen_new_slot(g);
    g = ns.g;
    let sid: i32 = ns.id;
    g = gen_emit(g, ir.Instr.SlotDecl(sid, next_ty));
    g = gen_emit(g, ir.Instr.Store(sid, ir.v_temp(tid)));
    parents.push(VecPushParentSlot { parent_slot: cur_slot, field: fname, child_slot: sid, child_ty: next_ty });
    cur_slot = sid;
    cur_ty = next_ty;
    fi = fi + 1;
  }

  let rt_last: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
  if rt_last.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.extend recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  let fs_last: tc.FindStructResult = tc.find_struct(g.ctx, rt_last.mod_path, rt_last.name);
  if !fs_last.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(fs_last.sig.vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let leaf: String = mc.fields.get(mc.fields.len() - 1);
  let mut leaf_ok: bool = false;
  let mut leaf_ty: i32 = g.ctx.ty_bad;
  let mut leaf_vis: i32 = ast.vis_private();
  let mut li: i32 = 0;
  while li < fs_last.sig.fields.len() {
    let lf: tc.StructFieldSig = fs_last.sig.fields.get(li);
    if lf.name == leaf {
      leaf_ok = true;
      leaf_ty = lf.ty;
      leaf_vis = lf.vis;
      break;
    }
    li = li + 1;
  }
  if !leaf_ok { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(leaf_vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  // Leaf field is the actual Vec place we mutate.
  let t_vec: GenNewIdResult = gen_new_temp(g);
  g = t_vec.g;
  let tid_v: i32 = t_vec.id;
  g = gen_emit(g, ir.Instr.FieldGet(tid_v, leaf_ty, ir.v_slot(cur_slot), leaf));
  let sl: GenNewIdResult = gen_new_slot(g);
  g = sl.g;
  let vec_slot: i32 = sl.id;
  g = gen_emit(g, ir.Instr.SlotDecl(vec_slot, leaf_ty));
  g = gen_emit(g, ir.Instr.Store(vec_slot, ir.v_temp(tid_v)));
  g = gen_emit(g, ir.Instr.VecExtend(vec_slot, src_slot));

  let t_vec2: GenNewIdResult = gen_new_temp(g);
  g = t_vec2.g;
  let tid_v2: i32 = t_vec2.id;
  g = gen_emit(g, ir.Instr.Load(tid_v2, leaf_ty, vec_slot));
  g = gen_emit(g, ir.Instr.StoreField(cur_slot, leaf, ir.v_temp(tid_v2)));

  let mut ri: i32 = parents.len() - 1;
  while ri >= 0 {
    let ps: VecPushParentSlot = parents.get(ri);
    let nt2: GenNewIdResult = gen_new_temp(g);
    g = nt2.g;
    let tid2: i32 = nt2.id;
    g = gen_emit(g, ir.Instr.Load(tid2, ps.child_ty, ps.child_slot));
    g = gen_emit(g, ir.Instr.StoreField(ps.parent_slot, ps.field, ir.v_temp(tid2)));
    ri = ri - 1;
  }

  return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
}

fn gen_vec_pop_member_place(g0: Gen, recv_id: i32, elem: i32, out_ty: i32) -> GenExprResult {
  let mc: MemberChainResult = member_chain(g0.exprs, recv_id);
  if !mc.ok { return GenExprResult { ok: false, err: "Vec.pop recv must be place", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if mc.fields.len() == 0 { return GenExprResult { ok: false, err: "Vec.pop recv must be place", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let br: LookupSlotResult = slots_lookup(g0.slots, mc.base);
  if !br.found { return GenExprResult { ok: false, err: "unknown base var", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if !br.mutable { return GenExprResult { ok: false, err: "Vec.pop recv is immutable", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let mut g: Gen = g0;
  let mut cur_slot: i32 = br.slot;
  let mut cur_ty: i32 = br.ty;
  let mut parents: Vec[VecPushParentSlot] = Vec();

  let mut fi: i32 = 0;
  while fi < mc.fields.len() - 1 {
    let rt: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
    if rt.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.pop recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let fs: tc.FindStructResult = tc.find_struct(g.ctx, rt.mod_path, rt.name);
    if !fs.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fs.sig.vis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let fname: String = mc.fields.get(fi);
    let mut found: bool = false;
    let mut next_ty: i32 = g.ctx.ty_bad;
    let mut fvis: i32 = ast.vis_private();
    let mut si: i32 = 0;
    while si < fs.sig.fields.len() {
      let sf: tc.StructFieldSig = fs.sig.fields.get(si);
      if sf.name == fname {
        found = true;
        next_ty = sf.ty;
        fvis = sf.vis;
        break;
      }
      si = si + 1;
    }
    if !found { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fvis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.FieldGet(tid, cur_ty, ir.v_slot(cur_slot), fname));
    let ns: GenNewIdResult = gen_new_slot(g);
    g = ns.g;
    let sid: i32 = ns.id;
    g = gen_emit(g, ir.Instr.SlotDecl(sid, next_ty));
    g = gen_emit(g, ir.Instr.Store(sid, ir.v_temp(tid)));
    parents.push(VecPushParentSlot { parent_slot: cur_slot, field: fname, child_slot: sid, child_ty: next_ty });
    cur_slot = sid;
    cur_ty = next_ty;
    fi = fi + 1;
  }

  let rt_last: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
  if rt_last.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.pop recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  let fs_last: tc.FindStructResult = tc.find_struct(g.ctx, rt_last.mod_path, rt_last.name);
  if !fs_last.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(fs_last.sig.vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let leaf: String = mc.fields.get(mc.fields.len() - 1);
  let mut leaf_ok: bool = false;
  let mut leaf_ty: i32 = g.ctx.ty_bad;
  let mut leaf_vis: i32 = ast.vis_private();
  let mut li: i32 = 0;
  while li < fs_last.sig.fields.len() {
    let lf: tc.StructFieldSig = fs_last.sig.fields.get(li);
    if lf.name == leaf {
      leaf_ok = true;
      leaf_ty = lf.ty;
      leaf_vis = lf.vis;
      break;
    }
    li = li + 1;
  }
  if !leaf_ok { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(leaf_vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let t_vec: GenNewIdResult = gen_new_temp(g);
  g = t_vec.g;
  let tid_v: i32 = t_vec.id;
  g = gen_emit(g, ir.Instr.FieldGet(tid_v, leaf_ty, ir.v_slot(cur_slot), leaf));
  let sl: GenNewIdResult = gen_new_slot(g);
  g = sl.g;
  let vec_slot: i32 = sl.id;
  g = gen_emit(g, ir.Instr.SlotDecl(vec_slot, leaf_ty));
  g = gen_emit(g, ir.Instr.Store(vec_slot, ir.v_temp(tid_v)));

  let ntp: GenNewIdResult = gen_new_temp(g);
  g = ntp.g;
  let pop_tid: i32 = ntp.id;
  g = gen_emit(g, ir.Instr.VecPop(pop_tid, elem, vec_slot));

  let t_vec2: GenNewIdResult = gen_new_temp(g);
  g = t_vec2.g;
  let tid_v2: i32 = t_vec2.id;
  g = gen_emit(g, ir.Instr.Load(tid_v2, leaf_ty, vec_slot));
  g = gen_emit(g, ir.Instr.StoreField(cur_slot, leaf, ir.v_temp(tid_v2)));

  let mut ri: i32 = parents.len() - 1;
  while ri >= 0 {
    let ps: VecPushParentSlot = parents.get(ri);
    let nt2: GenNewIdResult = gen_new_temp(g);
    g = nt2.g;
    let tid2: i32 = nt2.id;
    g = gen_emit(g, ir.Instr.Load(tid2, ps.child_ty, ps.child_slot));
    g = gen_emit(g, ir.Instr.StoreField(ps.parent_slot, ps.field, ir.v_temp(tid2)));
    ri = ri - 1;
  }

  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(pop_tid), ty: out_ty };
}

fn gen_vec_remove_member_place(g0: Gen, recv_id: i32, elem: i32, idx: ir.Value, out_ty: i32) -> GenExprResult {
  let mc: MemberChainResult = member_chain(g0.exprs, recv_id);
  if !mc.ok { return GenExprResult { ok: false, err: "Vec.remove recv must be place", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if mc.fields.len() == 0 { return GenExprResult { ok: false, err: "Vec.remove recv must be place", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let br: LookupSlotResult = slots_lookup(g0.slots, mc.base);
  if !br.found { return GenExprResult { ok: false, err: "unknown base var", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  if !br.mutable { return GenExprResult { ok: false, err: "Vec.remove recv is immutable", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }

  let mut g: Gen = g0;
  let mut cur_slot: i32 = br.slot;
  let mut cur_ty: i32 = br.ty;
  let mut parents: Vec[VecPushParentSlot] = Vec();

  let mut fi: i32 = 0;
  while fi < mc.fields.len() - 1 {
    let rt: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
    if rt.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.remove recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let fs: tc.FindStructResult = tc.find_struct(g.ctx, rt.mod_path, rt.name);
    if !fs.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fs.sig.vis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let fname: String = mc.fields.get(fi);
    let mut found: bool = false;
    let mut next_ty: i32 = g.ctx.ty_bad;
    let mut fvis: i32 = ast.vis_private();
    let mut si: i32 = 0;
    while si < fs.sig.fields.len() {
      let sf: tc.StructFieldSig = fs.sig.fields.get(si);
      if sf.name == fname {
        found = true;
        next_ty = sf.ty;
        fvis = sf.vis;
        break;
      }
      si = si + 1;
    }
    if !found { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    if !tc.vis_allows(fvis, fs.sig.mod_path, g.mod_path) {
      return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.FieldGet(tid, cur_ty, ir.v_slot(cur_slot), fname));
    let ns: GenNewIdResult = gen_new_slot(g);
    g = ns.g;
    let sid: i32 = ns.id;
    g = gen_emit(g, ir.Instr.SlotDecl(sid, next_ty));
    g = gen_emit(g, ir.Instr.Store(sid, ir.v_temp(tid)));
    parents.push(VecPushParentSlot { parent_slot: cur_slot, field: fname, child_slot: sid, child_ty: next_ty });
    cur_slot = sid;
    cur_ty = next_ty;
    fi = fi + 1;
  }

  let rt_last: ir.Ty = ir.ty_pool_get(g.ctx.pool, cur_ty);
  if rt_last.kind != ir.TyKind.Struct { return GenExprResult { ok: false, err: "Vec.remove recv must be struct", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  let fs_last: tc.FindStructResult = tc.find_struct(g.ctx, rt_last.mod_path, rt_last.name);
  if !fs_last.found { return GenExprResult { ok: false, err: "unknown struct type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(fs_last.sig.vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "type is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let leaf: String = mc.fields.get(mc.fields.len() - 1);
  let mut leaf_ok: bool = false;
  let mut leaf_ty: i32 = g.ctx.ty_bad;
  let mut leaf_vis: i32 = ast.vis_private();
  let mut li: i32 = 0;
  while li < fs_last.sig.fields.len() {
    let lf: tc.StructFieldSig = fs_last.sig.fields.get(li);
    if lf.name == leaf {
      leaf_ok = true;
      leaf_ty = lf.ty;
      leaf_vis = lf.vis;
      break;
    }
    li = li + 1;
  }
  if !leaf_ok { return GenExprResult { ok: false, err: "unknown field", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  if !tc.vis_allows(leaf_vis, fs_last.sig.mod_path, g.mod_path) {
    return GenExprResult { ok: false, err: "field is private", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let t_vec: GenNewIdResult = gen_new_temp(g);
  g = t_vec.g;
  let tid_v: i32 = t_vec.id;
  g = gen_emit(g, ir.Instr.FieldGet(tid_v, leaf_ty, ir.v_slot(cur_slot), leaf));
  let sl: GenNewIdResult = gen_new_slot(g);
  g = sl.g;
  let vec_slot: i32 = sl.id;
  g = gen_emit(g, ir.Instr.SlotDecl(vec_slot, leaf_ty));
  g = gen_emit(g, ir.Instr.Store(vec_slot, ir.v_temp(tid_v)));

  let ntp: GenNewIdResult = gen_new_temp(g);
  g = ntp.g;
  let remove_tid: i32 = ntp.id;
  g = gen_emit(g, ir.Instr.VecRemove(remove_tid, elem, vec_slot, idx));

  let t_vec2: GenNewIdResult = gen_new_temp(g);
  g = t_vec2.g;
  let tid_v2: i32 = t_vec2.id;
  g = gen_emit(g, ir.Instr.Load(tid_v2, leaf_ty, vec_slot));
  g = gen_emit(g, ir.Instr.StoreField(cur_slot, leaf, ir.v_temp(tid_v2)));

  let mut ri: i32 = parents.len() - 1;
  while ri >= 0 {
    let ps: VecPushParentSlot = parents.get(ri);
    let nt2: GenNewIdResult = gen_new_temp(g);
    g = nt2.g;
    let tid2: i32 = nt2.id;
    g = gen_emit(g, ir.Instr.Load(tid2, ps.child_ty, ps.child_slot));
    g = gen_emit(g, ir.Instr.StoreField(ps.parent_slot, ps.field, ir.v_temp(tid2)));
    ri = ri - 1;
  }

  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(remove_tid), ty: out_ty };
}

fn gen_call_reflect_intrinsic(g0: Gen, name: String, type_args: Vec[ast.TypeName], args: Vec[i32], out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  if args.len() != 0 {
    return GenExprResult { ok: false, err: "intrinsic call arity mismatch", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }
  if name == "@field_name" || name == "@field_type" || name == "@field_type_id" {
    if type_args.len() != 2 {
      return GenExprResult { ok: false, err: "intrinsic requires type and const index", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    let tr0: tc.ResolveTyResult = tc.resolve_type(g.ctx, g.w, g.mod_path, g.imps, g.locals.type_params, type_args.get(0));
    g.ctx = tr0.ctx;
    if !tr0.ok {
      return GenExprResult { ok: false, err: "intrinsic type arg resolve failed", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    let pr: tc.ParseConstGenericArgResult = tc.parse_const_generic_arg(g.ctx, type_args.get(1), g.ctx.ty_usize);
    if !pr.ok {
      return GenExprResult { ok: false, err: "intrinsic index out of range", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    if name == "@field_type_id" {
      let trt: tc.ReflectIntResult = tc.intrinsic_field_type_id_of(g.ctx, tr0.idx, pr.iv);
      if !trt.ok { return GenExprResult { ok: false, err: trt.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      let nti: GenNewIdResult = gen_new_temp(g);
      g = nti.g;
      let tidi: i32 = nti.id;
      g = gen_emit(g, ir.Instr.Const(tidi, out_ty, ir.v_i64(trt.iv)));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tidi), ty: out_ty };
    }
    let nr0: tc.ReflectTextResult =
      if name == "@field_name" {
        tc.intrinsic_field_name_of(g.ctx, tr0.idx, pr.iv)
      } else {
        tc.intrinsic_field_type_of(g.ctx, tr0.idx, pr.iv)
      };
    if !nr0.ok { return GenExprResult { ok: false, err: nr0.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt0: GenNewIdResult = gen_new_temp(g);
    g = nt0.g;
    let tid0: i32 = nt0.id;
    g = gen_emit(g, ir.Instr.Const(tid0, out_ty, ir.v_str(nr0.text)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid0), ty: out_ty };
  }
  if name == "@same_type" || name == "@assignable_to" || name == "@castable_to" || name == "@eq_comparable_with" || name == "@ordered_with" || name == "@same_layout" || name == "@bitcastable" {
    if type_args.len() != 2 {
      return GenExprResult { ok: false, err: "intrinsic requires two type args", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    let tra: tc.ResolveTyResult = tc.resolve_type(g.ctx, g.w, g.mod_path, g.imps, g.locals.type_params, type_args.get(0));
    g.ctx = tra.ctx;
    if !tra.ok {
      return GenExprResult { ok: false, err: "intrinsic type arg resolve failed", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    let trb: tc.ResolveTyResult = tc.resolve_type(g.ctx, g.w, g.mod_path, g.imps, g.locals.type_params, type_args.get(1));
    g.ctx = trb.ctx;
    if !trb.ok {
      return GenExprResult { ok: false, err: "intrinsic type arg resolve failed", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    let brt: tc.ReflectBoolResult =
      if name == "@same_type" {
        tc.intrinsic_same_type_of(g.ctx, tra.idx, trb.idx)
      } else if name == "@assignable_to" {
        tc.intrinsic_assignable_to_of(g.ctx, tra.idx, trb.idx)
      } else if name == "@castable_to" {
        tc.intrinsic_castable_to_of(g.ctx, tra.idx, trb.idx)
      } else if name == "@eq_comparable_with" {
        tc.intrinsic_eq_comparable_with_of(g.ctx, tra.idx, trb.idx)
      } else if name == "@same_layout" {
        tc.intrinsic_same_layout_of(g.ctx, tra.idx, trb.idx)
      } else if name == "@bitcastable" {
        tc.intrinsic_bitcastable_of(g.ctx, tra.idx, trb.idx)
      } else {
        tc.intrinsic_ordered_with_of(g.ctx, tra.idx, trb.idx)
      };
    if !brt.ok { return GenExprResult { ok: false, err: brt.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt0: GenNewIdResult = gen_new_temp(g);
    g = nt0.g;
    let tid0: i32 = nt0.id;
    g = gen_emit(g, ir.Instr.Const(tid0, out_ty, ir.v_bool(brt.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid0), ty: out_ty };
  }
  if type_args.len() != 1 {
    return GenExprResult { ok: false, err: "intrinsic requires one type arg", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let tr: tc.ResolveTyResult = tc.resolve_type(g.ctx, g.w, g.mod_path, g.imps, g.locals.type_params, type_args.get(0));
  g.ctx = tr.ctx;
  if !tr.ok {
    return GenExprResult { ok: false, err: "intrinsic type arg resolve failed", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  if name == "@size_of" {
    let sr: tc.ReflectIntResult = tc.intrinsic_size_of(g.ctx, tr.idx);
    if !sr.ok { return GenExprResult { ok: false, err: sr.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_i64(sr.iv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@align_of" {
    let ar: tc.ReflectIntResult = tc.intrinsic_align_of(g.ctx, tr.idx);
    if !ar.ok { return GenExprResult { ok: false, err: ar.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_i64(ar.iv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@field_count" {
    let fr: tc.ReflectIntResult = tc.intrinsic_field_count_of(g.ctx, tr.idx);
    if !fr.ok { return GenExprResult { ok: false, err: fr.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_i64(fr.iv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@type" {
    let trr: tc.ReflectIntResult = tc.intrinsic_type_id_of(g.ctx, tr.idx);
    if !trr.ok { return GenExprResult { ok: false, err: trr.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_i64(trr.iv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@type_name" {
    let nr: tc.ReflectTextResult = tc.intrinsic_type_name_of(g.ctx, tr.idx);
    if !nr.ok { return GenExprResult { ok: false, err: nr.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_str(nr.text)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_integer" {
    let br0: tc.ReflectBoolResult = tc.intrinsic_is_integer_of(g.ctx, tr.idx);
    if !br0.ok { return GenExprResult { ok: false, err: br0.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(br0.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_signed_int" {
    let brs: tc.ReflectBoolResult = tc.intrinsic_is_signed_int_of(g.ctx, tr.idx);
    if !brs.ok { return GenExprResult { ok: false, err: brs.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(brs.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_unsigned_int" {
    let bru: tc.ReflectBoolResult = tc.intrinsic_is_unsigned_int_of(g.ctx, tr.idx);
    if !bru.ok { return GenExprResult { ok: false, err: bru.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(bru.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_float" {
    let br1: tc.ReflectBoolResult = tc.intrinsic_is_float_of(g.ctx, tr.idx);
    if !br1.ok { return GenExprResult { ok: false, err: br1.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(br1.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_bool" {
    let brb: tc.ReflectBoolResult = tc.intrinsic_is_bool_of(g.ctx, tr.idx);
    if !brb.ok { return GenExprResult { ok: false, err: brb.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(brb.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_string" {
    let brs0: tc.ReflectBoolResult = tc.intrinsic_is_string_of(g.ctx, tr.idx);
    if !brs0.ok { return GenExprResult { ok: false, err: brs0.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(brs0.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_struct" {
    let br2: tc.ReflectBoolResult = tc.intrinsic_is_struct_of(g.ctx, tr.idx);
    if !br2.ok { return GenExprResult { ok: false, err: br2.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(br2.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_enum" {
    let br3: tc.ReflectBoolResult = tc.intrinsic_is_enum_of(g.ctx, tr.idx);
    if !br3.ok { return GenExprResult { ok: false, err: br3.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(br3.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_vec" {
    let br4: tc.ReflectBoolResult = tc.intrinsic_is_vec_of(g.ctx, tr.idx);
    if !br4.ok { return GenExprResult { ok: false, err: br4.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(br4.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_range" {
    let br5: tc.ReflectBoolResult = tc.intrinsic_is_range_of(g.ctx, tr.idx);
    if !br5.ok { return GenExprResult { ok: false, err: br5.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(br5.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_eq_comparable" {
    let breq: tc.ReflectBoolResult = tc.intrinsic_is_eq_comparable_of(g.ctx, tr.idx);
    if !breq.ok { return GenExprResult { ok: false, err: breq.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(breq.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_ordered" {
    let brord: tc.ReflectBoolResult = tc.intrinsic_is_ordered_of(g.ctx, tr.idx);
    if !brord.ok { return GenExprResult { ok: false, err: brord.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(brord.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_unit" {
    let brunit: tc.ReflectBoolResult = tc.intrinsic_is_unit_of(g.ctx, tr.idx);
    if !brunit.ok { return GenExprResult { ok: false, err: brunit.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(brunit.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_numeric" {
    let brnum: tc.ReflectBoolResult = tc.intrinsic_is_numeric_of(g.ctx, tr.idx);
    if !brnum.ok { return GenExprResult { ok: false, err: brnum.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(brnum.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if name == "@is_zero_sized" {
    let brz: tc.ReflectBoolResult = tc.intrinsic_is_zero_sized_of(g.ctx, tr.idx);
    if !brz.ok { return GenExprResult { ok: false, err: brz.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Const(tid, out_ty, ir.v_bool(brz.bv)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }

  return GenExprResult { ok: false, err: "unknown intrinsic", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
}

fn intrinsic_arg_str_lit(exprs: ast.ExprPool, id: i32) -> String {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);
  return match n { ast.ExprNode.Str(s) => s, _ => "" };
}

fn intrinsic_arg_int_lit(exprs: ast.ExprPool, id: i32) -> i32 {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, id);
  if !match n { ast.ExprNode.Int(_s) => true, _ => false } { return -1; }
  let s: String = match n { ast.ExprNode.Int(x) => x, _ => "" };
  let pr: tc.ParseI32DecResult = tc.parse_i32_dec(s);
  if !pr.ok { return -1; }
  return pr.val;
}

fn gen_call_enum_value_intrinsic(g0: Gen, name: String, args: Vec[i32], out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  if name == "@enum_is" {
    if args.len() != 2 { return GenExprResult { ok: false, err: "intrinsic call arity mismatch", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  } else if name == "@enum_payload" {
    if args.len() != 3 { return GenExprResult { ok: false, err: "intrinsic call arity mismatch", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  } else {
    return GenExprResult { ok: false, err: "unknown intrinsic", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  // Operands are always generated with literal variant/index in our lowering.
  let vname: String = intrinsic_arg_str_lit(g.exprs, args.get(1));
  if vname == "" { return GenExprResult { ok: false, err: "intrinsic expects string literal variant name", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

  let ar: GenExprResult = gen_expr(g, args.get(0), -1);
  if !ar.ok { return ar; }
  g = ar.g;
  let esr: EnumSigResult = enum_sig_for_ty(g.ctx, ar.ty);
  if !esr.ok { return GenExprResult { ok: false, err: esr.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  let fv: FindVariantResult = find_enum_variant(esr.sig, vname);
  if !fv.found { return GenExprResult { ok: false, err: "unknown enum variant", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

  let nt_tag: GenNewIdResult = gen_new_temp(g);
  g = nt_tag.g;
  let tag_tid: i32 = nt_tag.id;
  g = gen_emit(g, ir.Instr.EnumTag(tag_tid, ar.val));

  let nt_w: GenNewIdResult = gen_new_temp(g);
  g = nt_w.g;
  let want_tid: i32 = nt_w.id;
  g = gen_emit(g, ir.Instr.Const(want_tid, g.ctx.ty_i32, ir.v_int(fv.idx)));

  let nt_eq: GenNewIdResult = gen_new_temp(g);
  g = nt_eq.g;
  let eq_tid: i32 = nt_eq.id;
  g = gen_emit(g, ir.Instr.Cmp(eq_tid, ir.CmpKind.Eq, g.ctx.ty_i32, ir.v_temp(tag_tid), ir.v_temp(want_tid)));

  if name == "@enum_is" {
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(eq_tid), ty: g.ctx.ty_bool };
  }

  let idx: i32 = intrinsic_arg_int_lit(g.exprs, args.get(2));
  if idx < 0 { return GenExprResult { ok: false, err: "intrinsic expects integer literal index", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

  // Emit a checked payload extract:
  // if tag != want { panic(...) } else { out = enum_payload(recv, variant, idx) }
  let sl: GenNewIdResult = gen_new_slot(g);
  g = sl.g;
  let out_slot: i32 = sl.id;
  g = gen_emit(g, ir.Instr.SlotDecl(out_slot, out_ty));

  let base: i32 = g.blocks.len();
  let bok: GenNewIdResult = gen_new_block(g, "enum_payload_ok_".concat(base.to_string()));
  g = bok.g;
  let ok_idx: i32 = bok.id;
  let ok_name: String = g.blocks.get(ok_idx).name;
  let bbad: GenNewIdResult = gen_new_block(g, "enum_payload_bad_".concat(base.to_string()));
  g = bbad.g;
  let bad_idx: i32 = bbad.id;
  let bad_name: String = g.blocks.get(bad_idx).name;
  let bend: GenNewIdResult = gen_new_block(g, "enum_payload_end_".concat(base.to_string()));
  g = bend.g;
  let end_idx: i32 = bend.id;
  let end_name: String = g.blocks.get(end_idx).name;

  g = gen_term(g, ir.Term.CondBr(ir.v_temp(eq_tid), ok_name, bad_name));

  g = gen_set_block(g, ok_idx);
  let nt_p: GenNewIdResult = gen_new_temp(g);
  g = nt_p.g;
  let payload_tid: i32 = nt_p.id;
  g = gen_emit(g, ir.Instr.EnumPayload(payload_tid, out_ty, ar.val, vname, idx));
  g = gen_emit(g, ir.Instr.Store(out_slot, ir.v_temp(payload_tid)));
  g = gen_term(g, ir.Term.Br(end_name));

  g = gen_set_block(g, bad_idx);
  g = gen_term(g, ir.Term.Panic(ir.v_str("@enum_payload on non-matching variant")));

  g = gen_set_block(g, end_idx);
  let nt_out: GenNewIdResult = gen_new_temp(g);
  g = nt_out.g;
  let out_tid: i32 = nt_out.id;
  g = gen_emit(g, ir.Instr.Load(out_tid, out_ty, out_slot));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(out_tid), ty: out_ty };
}

fn gen_call_trait_static(g0: Gen, trait_mod: String, trait_name: String, method: String, type_args: Vec[ast.TypeName], args: Vec[i32], out_ty: i32) -> GenExprResult {
  if args.len() == 0 {
    return GenExprResult { ok: false, err: "trait static call requires receiver arg", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
  }
  let ar0: tc.ExprTyResult = tc.tc_expr(g0.ctx, g0.w, g0.mod_path, g0.imps, g0.exprs, g0.locals, args.get(0), -1);
  if !ar0.ok { return GenExprResult { ok: false, err: tc.tc_error_to_string(ar0.err), g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  let recv_ty: i32 = tc.strip_range(g0.ctx, ar0.ty);

  let fi: tc.FindImplForTyResult = tc.find_impl_for_ty(g0.ctx, trait_mod, trait_name, recv_ty);
  if fi.ambiguous {
    let recv0: String = tc.ty_inst_str(g0.ctx, recv_ty);
    let msg0: String = "ambiguous impl for trait call: ".concat(trait_name).concat(" for ").concat(recv0).concat(" (candidates: ").concat(fi.candidates).concat(")");
    return GenExprResult { ok: false, err: msg0, g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
  }
  if !fi.found {
    let recv: String = tc.ty_inst_str(g0.ctx, recv_ty);
    let cands: String = tc.trait_impl_candidates_text(g0.ctx, trait_mod, trait_name);
    let msg: String = "no impl for trait call: ".concat(trait_name).concat(" for ").concat(recv).concat(" (available impls: ").concat(cands).concat(")");
    return GenExprResult { ok: false, err: msg, g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
  }
  let im: tc.FindImplMethodResult = tc.find_impl_method(fi.sig, method);
  if !im.found {
    return GenExprResult { ok: false, err: "impl missing trait method", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
  }
  return gen_call_func(g0, fi.sig.mod_path, im.m.lowered_name, im.m.sig, type_args, args, out_ty);
}

fn vec_recv_slot(g0: Gen, recv_id: i32, recv_ty: i32) -> VecRecvSlotResult {
  let n: ast.ExprNode = ast.expr_pool_get(g0.exprs, recv_id);
  if match n { ast.ExprNode.Ident(_x) => true, _ => false } {
    let name: String = match n { ast.ExprNode.Ident(s) => s, _ => "" };
    let sr: LookupSlotResult = slots_lookup(g0.slots, name);
    if sr.found { return VecRecvSlotResult { ok: true, err: "", g: g0, slot: sr.slot }; }
  }

  // materialize: eval receiver and store to temp slot
  let er: GenExprResult = gen_expr(g0, recv_id, recv_ty);
  if !er.ok { return VecRecvSlotResult { ok: false, err: er.err, g: er.g, slot: -1 }; }
  let mut g: Gen = er.g;
  let ns: GenNewIdResult = gen_new_slot(g);
  g = ns.g;
  let sid: i32 = ns.id;
  g = gen_emit(g, ir.Instr.SlotDecl(sid, recv_ty));
  g = gen_emit(g, ir.Instr.Store(sid, er.val));
  return VecRecvSlotResult { ok: true, err: "", g: g, slot: sid };
}

fn gen_expr_call(g0: Gen, callee: i32, type_args: Vec[ast.TypeName], args: Vec[i32], out_ty: i32, expected: i32) -> GenExprResult {
  let cn: ast.ExprNode = ast.expr_pool_get(g0.exprs, callee);
  let is_member: bool = match cn { ast.ExprNode.Member(_r, _n) => true, _ => false };
  let ta: Vec[ast.TypeName] = type_args;

  if is_member {
    let recv_id: i32 = match cn { ast.ExprNode.Member(r, _n) => r, _ => -1 };
    let mname: String = match cn { ast.ExprNode.Member(_r, n) => n, _ => "" };
    let rr: tc.ExprTyResult = tc.tc_expr(g0.ctx, g0.w, g0.mod_path, g0.imps, g0.exprs, g0.locals, recv_id, -1);
    if rr.ok && tc.is_vec_ty(g0.ctx, rr.ty) && is_vec_builtin_method(mname) {
      return gen_call_vec_method(g0, recv_id, rr.ty, mname, args, out_ty);
    }
    // Allow `&str` to use String builtin methods (transition model: `&str` lowers
    // to `Ref(String, ...)`).
    if rr.ok && tc.strip_range(g0.ctx, rr.ty) == g0.ctx.ty_string && is_string_builtin_method(mname) {
      return gen_call_string_method(g0, recv_id, mname, args, out_ty);
    }
    if rr.ok && mname == "to_string" {
      let rb: i32 = tc.strip_range(g0.ctx, rr.ty);
      if rb == g0.ctx.ty_bool || rb == g0.ctx.ty_string || tc.is_int_like_ty(g0.ctx, rb) || tc.is_float_ty(g0.ctx, rb) {
        return gen_call_prim_method(g0, recv_id, rb, mname, out_ty);
      }
    }
    if rr.ok {
      let inh: tc.FindInherentDispatchMethodResult = tc.find_inherent_dispatch_method(g0.ctx, tc.strip_range(g0.ctx, rr.ty), mname);
      if inh.ambiguous {
        let msg_inh: String = "ambiguous inherent method call (candidates: ".concat(inh.candidates).concat(")");
        return GenExprResult { ok: false, err: msg_inh, g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
      }
      if inh.found {
        let mut all_args_inh: Vec[i32] = Vec();
        all_args_inh.push(recv_id);
        let mut ai_inh: i32 = 0;
        while ai_inh < args.len() { all_args_inh.push(args.get(ai_inh)); ai_inh = ai_inh + 1; }
        return gen_call_func(g0, inh.impl_mod_path, inh.m.lowered_name, inh.m.sig, ta, all_args_inh, out_ty);
      }

      let dm: tc.FindTraitDispatchMethodResult = tc.find_trait_dispatch_method(g0.ctx, g0.mod_path, tc.strip_range(g0.ctx, rr.ty), mname);
      if dm.ambiguous {
        let msg: String = "ambiguous trait method call (candidates: ".concat(dm.candidates).concat(")");
        return GenExprResult { ok: false, err: msg, g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
      }
      if dm.found {
        let mut all_args: Vec[i32] = Vec();
        all_args.push(recv_id);
        let mut ai: i32 = 0;
        while ai < args.len() { all_args.push(args.get(ai)); ai = ai + 1; }
        return gen_call_func(g0, dm.impl_mod_path, dm.m.lowered_name, dm.m.sig, ta, all_args, out_ty);
      }
    }
  }

  // Enum ctor shorthand: `.Variant(...)`
  if match cn { ast.ExprNode.DotIdent(_x) => true, _ => false } {
    if ta.len() != 0 { return GenExprResult { ok: false, err: "enum shorthand does not accept type args", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let vname: String = match cn { ast.ExprNode.DotIdent(s) => s, _ => "" };
    return gen_call_enum_ctor_shorthand(g0, vname, args, out_ty);
  }

  // Path calls: function / enum ctor / Vec()
  let pr: tc.ExprPartsResult = tc.expr_parts(g0.exprs, callee);
  if !pr.ok { return GenExprResult { ok: false, err: "bad callee", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  let parts: Vec[String] = pr.parts;

  // Vec()
  if parts.len() == 1 && parts.get(0) == "Vec" {
    if expected == -1 { return GenExprResult { ok: false, err: "Vec() needs expected type", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    if !tc.is_vec_ty(g0.ctx, expected) { return GenExprResult { ok: false, err: "Vec() expected Vec[T]", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let elem: i32 = tc.vec_elem(g0.ctx, expected);
    let mut g: Gen = g0;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.VecNew(tid, expected, elem));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: expected };
  }

  // Unqualified function call (with prelude fallback).
  if parts.len() == 1 {
    let name: String = parts.get(0);
    if tc.is_reflect_intrinsic_name(name) {
      return gen_call_reflect_intrinsic(g0, name, ta, args, out_ty);
    }
    if name == "@enum_is" || name == "@enum_payload" {
      if ta.len() != 0 { return GenExprResult { ok: false, err: "intrinsic does not accept type args", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
      return gen_call_enum_value_intrinsic(g0, name, args, out_ty);
    }
    let nf: tc.NamedFuncImport = find_named_func_import(g0.imps.named_funcs, name);
    if nf.local != "" {
      let frx: tc.FindFuncResult = tc.find_func(g0.ctx, nf.mod_path, nf.name);
      if frx.found { return gen_call_func(g0, nf.mod_path, nf.name, frx.sig, ta, args, out_ty); }
      return GenExprResult { ok: false, err: "unknown fn", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
    }
    let fr0: tc.FindFuncResult = tc.find_func(g0.ctx, g0.mod_path, name);
    if fr0.found { return gen_call_func(g0, g0.mod_path, name, fr0.sig, ta, args, out_ty); }
    let prelude: String = "std/prelude";
    let fr1: tc.FindFuncResult = tc.find_func(g0.ctx, prelude, name);
    if fr1.found { return gen_call_func(g0, prelude, name, fr1.sig, ta, args, out_ty); }
    let fr2: tc.FindFuncResult = tc.find_func(g0.ctx, "", name);
    if fr2.found { return gen_call_func(g0, "", name, fr2.sig, ta, args, out_ty); }
    return GenExprResult { ok: false, err: "unknown fn", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
  }

  // Qualified calls.
  if parts.len() == 2 {
    let mp: String = tc.find_alias(g0.imps.aliases, parts.get(0));
    if mp != "" {
      let fr: tc.FindFuncResult = tc.find_func(g0.ctx, mp, parts.get(1));
      if !fr.found { return GenExprResult { ok: false, err: "unknown fn", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
      return gen_call_func(g0, mp, parts.get(1), fr.sig, ta, args, out_ty);
    }
    // Otherwise: `Trait.method(...)` or `Enum.Variant(...)` in current module,
    // or via a named imported type.
    let nt: tc.NamedTypeImport = find_named_type_import(g0.imps.named_types, parts.get(0));
    if nt.local != "" {
      if nt.kind == tc.named_type_kind_trait() {
        return gen_call_trait_static(g0, nt.mod_path, nt.name, parts.get(1), ta, args, out_ty);
      }
      if nt.kind != tc.named_type_kind_enum() {
        return GenExprResult { ok: false, err: "not an enum type", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
      }
      return gen_call_enum_ctor(g0, nt.mod_path, nt.name, parts.get(1), args, out_ty);
    }

    let ft: tc.FindTraitResult = tc.find_trait(g0.ctx, g0.mod_path, parts.get(0));
    let fe: tc.FindEnumResult = tc.find_enum(g0.ctx, g0.mod_path, parts.get(0));
    if ft.found && fe.found {
      return GenExprResult { ok: false, err: "ambiguous call target", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
    }
    if ft.found {
      return gen_call_trait_static(g0, g0.mod_path, parts.get(0), parts.get(1), ta, args, out_ty);
    }
    if !fe.found {
      let prelude: String = "std/prelude";
      let fp: tc.FindTraitResult = tc.find_trait(g0.ctx, prelude, parts.get(0));
      if fp.found && tc.vis_allows(fp.sig.vis, prelude, g0.mod_path) {
        return gen_call_trait_static(g0, prelude, parts.get(0), parts.get(1), ta, args, out_ty);
      }
    }
    return gen_call_enum_ctor(g0, g0.mod_path, parts.get(0), parts.get(1), args, out_ty);
  }
  if parts.len() == 3 {
    let mp: String = tc.find_alias(g0.imps.aliases, parts.get(0));
    if mp == "" { return GenExprResult { ok: false, err: "unknown module alias", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let ft2: tc.FindTraitResult = tc.find_trait(g0.ctx, mp, parts.get(1));
    let fe2: tc.FindEnumResult = tc.find_enum(g0.ctx, mp, parts.get(1));
    if ft2.found && fe2.found {
      return GenExprResult { ok: false, err: "ambiguous call target", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
    }
    if ft2.found {
      return gen_call_trait_static(g0, mp, parts.get(1), parts.get(2), ta, args, out_ty);
    }
    return gen_call_enum_ctor(g0, mp, parts.get(1), parts.get(2), args, out_ty);
  }

  return GenExprResult { ok: false, err: "unsupported call path", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
}

fn subs_lookup(subs: Vec[tc.TySub], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < subs.len() {
    let s: tc.TySub = subs.get(i);
    if s.name == name { return s.ty; }
    i = i + 1;
  }
  return -1;
}

fn pending_has(p: Vec[PendingInst], qn: String) -> bool {
  let mut i: i32 = 0;
  while i < p.len() {
    if p.get(i).qname == qn { return true; }
    i = i + 1;
  }
  return false;
}

fn pending_add(p0: Vec[PendingInst], pi: PendingInst) -> Vec[PendingInst] {
  if pending_has(p0, pi.qname) { return p0; }
  let mut p: Vec[PendingInst] = p0;
  p.push(pi);
  return p;
}

fn gen_pack_arity_error(sig: tc.FuncSig, got: i32) -> String {
  return "wrong number of type args: expected at most "
    .concat(sig.type_params.len().to_string())
    .concat(", got ")
    .concat(got.to_string());
}

fn gen_has_type_param_pack(sig: tc.FuncSig) -> bool {
  return sig.type_param_packs.len() == 1;
}

fn gen_type_param_fixed_prefix_len(sig: tc.FuncSig) -> i32 {
  if gen_has_type_param_pack(sig) { return sig.type_params.len() - 1; }
  return sig.type_params.len();
}

fn gen_explicit_type_arg_arity_ok(sig: tc.FuncSig, explicit_targ_n: i32) -> bool {
  if !gen_has_type_param_pack(sig) { return explicit_targ_n <= sig.type_params.len(); }
  return explicit_targ_n >= 0;
}

fn gen_explicit_type_arg_bind_name(sig: tc.FuncSig, idx: i32) -> String {
  if !gen_has_type_param_pack(sig) { return sig.type_params.get(idx); }
  let fixed_n: i32 = gen_type_param_fixed_prefix_len(sig);
  if idx < fixed_n { return sig.type_params.get(idx); }
  return sig.type_param_packs.get(0);
}

fn gen_type_name_is_pack_member(name: String, pack: String) -> bool {
  if name == pack { return true; }
  return starts_with(name, pack.concat("."));
}

fn gen_ty_contains_pack_param(ctx: tc.Ctx, ty: i32, pack: String) -> bool {
  let t: ir.Ty = ir.ty_pool_get(ctx.pool, ty);
  if t.kind == ir.TyKind.Param { return gen_type_name_is_pack_member(t.name, pack); }
  if t.kind == ir.TyKind.Vec || t.kind == ir.TyKind.Range || t.kind == ir.TyKind.Verified { return gen_ty_contains_pack_param(ctx, t.elem, pack); }
  return false;
}

fn gen_sig_allows_heterogeneous_pack_args(ctx: tc.Ctx, sig: tc.FuncSig, pack: String) -> bool {
  let mut i: i32 = 0;
  while i < sig.params.len() {
    if gen_ty_contains_pack_param(ctx, sig.params.get(i), pack) { return false; }
    i = i + 1;
  }
  if gen_ty_contains_pack_param(ctx, sig.ret, pack) { return false; }
  if sig.has_variadic && gen_ty_contains_pack_param(ctx, sig.variadic_elem, pack) { return false; }

  let mut bi: i32 = 0;
  while bi < sig.type_param_bounds.len() {
    let b: tc.TypeParamBoundSig = sig.type_param_bounds.get(bi);
    if gen_type_name_is_pack_member(b.type_param, pack) { return false; }
    bi = bi + 1;
  }

  let mut ci: i32 = 0;
  while ci < sig.const_where_bounds.len() {
    let b2: tc.ConstWhereBoundSig = sig.const_where_bounds.get(ci);
    if gen_type_name_is_pack_member(b2.name, pack) { return false; }
    ci = ci + 1;
  }

  return true;
}

struct GenVariadicPackResult { ok: bool, err: String, g: Gen, val: ir.Value }

fn gen_pack_variadic_values(g0: Gen, vec_ty: i32, elem_ty: i32, vals: Vec[ir.Value]) -> GenVariadicPackResult {
  let mut g: Gen = g0;

  let nt0: GenNewIdResult = gen_new_temp(g);
  g = nt0.g;
  let vec_tid: i32 = nt0.id;
  g = gen_emit(g, ir.Instr.VecNew(vec_tid, vec_ty, elem_ty));

  let ns: GenNewIdResult = gen_new_slot(g);
  g = ns.g;
  let vec_slot: i32 = ns.id;
  g = gen_emit(g, ir.Instr.SlotDecl(vec_slot, vec_ty));
  g = gen_emit(g, ir.Instr.Store(vec_slot, ir.v_temp(vec_tid)));

  let mut i: i32 = 0;
  while i < vals.len() {
    g = gen_emit(g, ir.Instr.VecPush(vec_slot, elem_ty, vals.get(i)));
    i = i + 1;
  }

  let nt1: GenNewIdResult = gen_new_temp(g);
  g = nt1.g;
  let out_tid: i32 = nt1.id;
  g = gen_emit(g, ir.Instr.Load(out_tid, vec_ty, vec_slot));
  return GenVariadicPackResult { ok: true, err: "", g: g, val: ir.v_temp(out_tid) };
}

fn gen_call_func(g0: Gen, target_mod: String, name: String, sig: tc.FuncSig, type_args: Vec[ast.TypeName], args: Vec[i32], out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let mut pack_mode: bool = false;
  let mut fixed_n: i32 = sig.params.len();

  if sig.has_variadic {
    if sig.params.len() == 0 {
      return GenExprResult { ok: false, err: "invalid variadic signature", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    fixed_n = sig.params.len() - 1;
    if args.len() < fixed_n {
      return GenExprResult { ok: false, err: "arity mismatch", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    if args.len() > sig.params.len() || args.len() == fixed_n {
      pack_mode = true;
    } else {
      let variadic_vec_ty: i32 = sig.params.get(fixed_n);
      // Mirror typecheck's pack-vs-vec decision without emitting IR:
      // If the last argument is a Vec, treat it as explicit-Vec mode; otherwise
      // fall back to pack-mode.
      let probe_last: tc.ExprTyResult =
        tc.tc_expr(g.ctx, g.w, g.mod_path, g.imps, g.exprs, g.locals, args.get(fixed_n), -1);
      if probe_last.ok {
        if tc.is_vec_ty(g.ctx, tc.strip_range(g.ctx, probe_last.ty)) {
          pack_mode = false;
        } else {
          let ur_probe: tc.UnifyResult = tc.unify_ty(g.ctx, variadic_vec_ty, probe_last.ty, Vec());
          pack_mode = !ur_probe.ok;
        }
      } else {
        pack_mode = true;
      }
    }
  } else {
    if args.len() != sig.params.len() { return GenExprResult { ok: false, err: "arity mismatch", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  }

  if sig.type_params.len() == 0 && sig.const_params.len() == 0 {
    if type_args.len() != 0 { return GenExprResult { ok: false, err: "non-generic fn with type args", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

    let mut vs: Vec[ir.Value] = Vec();
    if !pack_mode {
      let mut i: i32 = 0;
      while i < args.len() {
        let want: i32 = sig.params.get(i);
        let er: GenExprResult = gen_expr(g, args.get(i), want);
        if !er.ok { return er; }
        g = er.g;
        let pbk: i32 = if i < sig.param_borrow_kinds.len() { sig.param_borrow_kinds.get(i) } else { tc.param_borrow_none() };
        if tc.param_borrow_is_mut(pbk) {
          let mc: MemberChainResult = place_chain(g.exprs, args.get(i));
          if !mc.ok { return GenExprResult { ok: false, err: mc.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
          let br: LookupSlotResult = slots_lookup(g.slots, mc.base);
          if !br.found { return GenExprResult { ok: false, err: "unknown base var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
          if !br.mutable { return GenExprResult { ok: false, err: "inout argument root is immutable", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

          let elem_ty: i32 = tc.strip_range_only(g.ctx, want);
          let static0: bool = pbk == tc.param_borrow_ref_static_mut();
          let rr: tc.ResolveTyResult = tc.intern_ref(g.ctx, elem_ty, true, static0);
          g.ctx = rr.ctx;
          if !rr.ok { return GenExprResult { ok: false, err: "failed to intern &mut arg ref type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
          let ref_ty: i32 = rr.idx;
          let nt: GenNewIdResult = gen_new_temp(g);
          g = nt.g;
          let tid: i32 = nt.id;
          if mc.fields.len() == 0 {
            g = gen_emit(g, ir.Instr.AddrOfSlot(tid, ref_ty, br.slot));
          } else {
            g = gen_emit(g, ir.Instr.AddrOfFieldChain(tid, ref_ty, br.slot, mc.fields));
          }
          vs.push(ir.v_temp(tid));
        } else {
          vs.push(er.val);
        }
        i = i + 1;
      }
    } else {
      let mut i: i32 = 0;
      while i < fixed_n {
        let want_fixed: i32 = sig.params.get(i);
        let erf: GenExprResult = gen_expr(g, args.get(i), want_fixed);
        if !erf.ok { return erf; }
        g = erf.g;
        let pbk: i32 = if i < sig.param_borrow_kinds.len() { sig.param_borrow_kinds.get(i) } else { tc.param_borrow_none() };
        if tc.param_borrow_is_mut(pbk) {
          let mc: MemberChainResult = place_chain(g.exprs, args.get(i));
          if !mc.ok { return GenExprResult { ok: false, err: mc.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
          let br: LookupSlotResult = slots_lookup(g.slots, mc.base);
          if !br.found { return GenExprResult { ok: false, err: "unknown base var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
          if !br.mutable { return GenExprResult { ok: false, err: "inout argument root is immutable", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

          let elem_ty: i32 = tc.strip_range_only(g.ctx, want_fixed);
          let static0: bool = pbk == tc.param_borrow_ref_static_mut();
          let rr: tc.ResolveTyResult = tc.intern_ref(g.ctx, elem_ty, true, static0);
          g.ctx = rr.ctx;
          if !rr.ok { return GenExprResult { ok: false, err: "failed to intern &mut arg ref type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
          let ref_ty: i32 = rr.idx;
          let nt: GenNewIdResult = gen_new_temp(g);
          g = nt.g;
          let tid: i32 = nt.id;
          if mc.fields.len() == 0 {
            g = gen_emit(g, ir.Instr.AddrOfSlot(tid, ref_ty, br.slot));
          } else {
            g = gen_emit(g, ir.Instr.AddrOfFieldChain(tid, ref_ty, br.slot, mc.fields));
          }
          vs.push(ir.v_temp(tid));
        } else {
          vs.push(erf.val);
        }
        i = i + 1;
      }

      let mut tail_vals: Vec[ir.Value] = Vec();
      let mut j: i32 = fixed_n;
      while j < args.len() {
        let erv: GenExprResult = gen_expr(g, args.get(j), sig.variadic_elem);
        if !erv.ok { return erv; }
        g = erv.g;
        tail_vals.push(erv.val);
        j = j + 1;
      }

      let variadic_vec_ty2: i32 = sig.params.get(fixed_n);
      let pkr: GenVariadicPackResult = gen_pack_variadic_values(g, variadic_vec_ty2, sig.variadic_elem, tail_vals);
      if !pkr.ok { return GenExprResult { ok: false, err: pkr.err, g: pkr.g, val: ir.v_int(0), ty: pkr.g.ctx.ty_bad }; }
      g = pkr.g;
      vs.push(pkr.val);
    }

    let qn: String = qname(target_mod, name);
    if out_ty == g.ctx.ty_unit {
      g = gen_emit(g, ir.Instr.Call(false, 0, out_ty, qn, vs));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
    }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.Call(true, tid, out_ty, qn, vs));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }

  // Generic call args:
  // - type args prefix
  // - const args suffix (missing values can use defaults)
  let mut explicit_targ_n: i32 = type_args.len();
  let mut first_const: i32 = -1;
  let mut xi: i32 = 0;
  while xi < type_args.len() {
    if tc.is_const_generic_arg_tn_or_local(g.locals, type_args.get(xi)) {
      first_const = xi;
      xi = type_args.len();
    } else {
      xi = xi + 1;
    }
  }
  if first_const != -1 {
    explicit_targ_n = first_const;
    let mut xj: i32 = first_const;
    while xj < type_args.len() {
      if !tc.is_const_generic_arg_tn_or_local(g.locals, type_args.get(xj)) {
        return GenExprResult { ok: false, err: "generic arg order error: type args must come before const args", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
      }
      xj = xj + 1;
    }
  }
  if !gen_explicit_type_arg_arity_ok(sig, explicit_targ_n) {
    return GenExprResult { ok: false, err: gen_pack_arity_error(sig, explicit_targ_n), g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }
  let explicit_const_n: i32 = type_args.len() - explicit_targ_n;
  if explicit_const_n > sig.const_params.len() {
    let msgc: String = "wrong number of const args: expected at most "
      .concat(sig.const_params.len().to_string())
      .concat(", got ")
      .concat(explicit_const_n.to_string());
    return GenExprResult { ok: false, err: msgc, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }
  let mut explicit_targs: Vec[ast.TypeName] = Vec();
  let mut ti0: i32 = 0;
  while ti0 < explicit_targ_n {
    let ta0: ast.TypeName = type_args.get(ti0);
    if tc.is_const_generic_arg_tn_or_local(g.locals, ta0) {
      return GenExprResult { ok: false, err: "generic arg order error: type args must come before const args", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    explicit_targs.push(ta0);
    ti0 = ti0 + 1;
  }

  let mut csubs: Vec[tc.ConstSub] = Vec();
  let mut ci: i32 = 0;
  while ci < sig.const_params.len() {
    let cp: tc.ConstParamSig = sig.const_params.get(ci);
    if ci < explicit_const_n {
      let atn: ast.TypeName = type_args.get(explicit_targ_n + ci);
      let pr: tc.ParseConstGenericArgWithLocalsResult = tc.parse_const_generic_arg_with_locals(g.ctx, g.locals, atn, cp.ty);
      if !pr.ok {
        return GenExprResult { ok: false, err: "bad const generic arg", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
      }
      if pr.unresolved {
        return GenExprResult { ok: false, err: "unresolved const generic arg", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
      }
      csubs.push(tc.ConstSub { name: cp.name, ty: cp.ty, iv: pr.iv, text: pr.text });
    } else {
      if !cp.has_default {
        return GenExprResult { ok: false, err: "missing const generic arg", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
      }
      csubs.push(tc.ConstSub { name: cp.name, ty: cp.ty, iv: cp.default_iv, text: cp.default_text });
    }
    ci = ci + 1;
  }

  let mut subs: Vec[tc.TySub] = Vec();
  // Return type is known at IRGen time; use it as a constraint.
  let ur0: tc.UnifyResult = tc.unify_ty(g.ctx, sig.ret, out_ty, subs);
  if !ur0.ok { return GenExprResult { ok: false, err: "cannot infer generic return", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  subs = ur0.subs;

  // Explicit type args. For a trailing type-parameter pack, extra explicit
  // type args bind to the pack name.
  let has_pack: bool = gen_has_type_param_pack(sig);
  let pack_name: String = if has_pack { sig.type_param_packs.get(0) } else { "" };
  let mut pack_explicit_tys: Vec[i32] = Vec();

  let mut ti: i32 = 0;
  while ti < explicit_targs.len() {
    let tr: tc.ResolveTyResult = tc.resolve_type(g.ctx, g.w, g.mod_path, g.imps, Vec(), explicit_targs.get(ti));
    g.ctx = tr.ctx;
    if !tr.ok { return GenExprResult { ok: false, err: "bad type arg", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let tp: String = gen_explicit_type_arg_bind_name(sig, ti);
    let is_pack_bind: bool = has_pack && tp == pack_name;
    if is_pack_bind {
      pack_explicit_tys.push(tr.idx);
      let cur_pack: i32 = subs_lookup(subs, tp);
      if cur_pack == -1 { subs.push(tc.TySub { name: tp, ty: tr.idx }); }
      ti = ti + 1;
      continue;
    }

    let cur: i32 = subs_lookup(subs, tp);
    if cur != -1 && cur != tr.idx {
      return GenExprResult { ok: false, err: "explicit type argument conflicts with inferred type parameter", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    if cur == -1 { subs.push(tc.TySub { name: tp, ty: tr.idx }); }
    ti = ti + 1;
  }

  let mut sig_use: tc.FuncSig = sig;
  let mut materialized_pack_hetero: bool = false;
  if has_pack && pack_explicit_tys.len() > 0 {
    if pack_explicit_tys.len() > tc.materialized_pack_arity_limit() {
      let msg_pack: String = tc.materialized_pack_arity_err(pack_explicit_tys.len());
      return GenExprResult { ok: false, err: msg_pack, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    let mut all_same: bool = true;
    let mut pi0: i32 = 1;
    while pi0 < pack_explicit_tys.len() {
      if pack_explicit_tys.get(pi0) != pack_explicit_tys.get(0) {
        all_same = false;
        pi0 = pack_explicit_tys.len();
      } else {
        pi0 = pi0 + 1;
      }
    }

    let cur_pack0: i32 = subs_lookup(subs, pack_name);
    if cur_pack0 == -1 {
      subs.push(tc.TySub { name: pack_name, ty: pack_explicit_tys.get(0) });
    } else if cur_pack0 != pack_explicit_tys.get(0) {
      return GenExprResult { ok: false, err: "explicit pack head type conflicts with inferred return constraint", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }

    subs = tc.append_pack_alias_subs(subs, pack_name, pack_explicit_tys);

    if !all_same {
      if gen_sig_allows_heterogeneous_pack_args(g.ctx, sig, pack_name) {
        // Placeholder-only pack usage (A01-2a): keep as-is.
      } else {
        let mr: tc.MaterializePackSigResult = tc.materialize_pack_sig_types(g.ctx, sig, pack_name, pack_explicit_tys);
        if !mr.ok { return GenExprResult { ok: false, err: mr.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
        sig_use = mr.sig;
        materialized_pack_hetero = true;
      }
    }
  }

  // Infer from args while generating their IR values.
  let mut vs2: Vec[ir.Value] = Vec();
  let mut variadic_tail_vals: Vec[ir.Value] = Vec();
  if !pack_mode {
    let mut i2: i32 = 0;
    while i2 < args.len() {
      let want0: i32 = tc.subst_ty(g.ctx, sig_use.params.get(i2), subs);
      if want0 == g.ctx.ty_bad { return GenExprResult { ok: false, err: "bad generic arg type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      let want_t: ir.Ty = ir.ty_pool_get(g.ctx.pool, want0);
      let want: i32 = if want_t.kind == ir.TyKind.Param || tc.ty_has_param(g.ctx, want0) { -1 } else { want0 };
      let er2: GenExprResult = gen_expr(g, args.get(i2), want);
      if !er2.ok { return er2; }
      g = er2.g;
      let pbk: i32 = if i2 < sig_use.param_borrow_kinds.len() { sig_use.param_borrow_kinds.get(i2) } else { tc.param_borrow_none() };
      if tc.param_borrow_is_mut(pbk) {
        let mc: MemberChainResult = place_chain(g.exprs, args.get(i2));
        if !mc.ok { return GenExprResult { ok: false, err: mc.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
        let br: LookupSlotResult = slots_lookup(g.slots, mc.base);
        if !br.found { return GenExprResult { ok: false, err: "unknown base var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
        if !br.mutable { return GenExprResult { ok: false, err: "inout argument root is immutable", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

        let elem_ty: i32 = tc.strip_range_only(g.ctx, want0);
        let static0: bool = pbk == tc.param_borrow_ref_static_mut();
        let rr: tc.ResolveTyResult = tc.intern_ref(g.ctx, elem_ty, true, static0);
        g.ctx = rr.ctx;
        if !rr.ok { return GenExprResult { ok: false, err: "failed to intern &mut arg ref type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
        let ref_ty: i32 = rr.idx;
        let nt: GenNewIdResult = gen_new_temp(g);
        g = nt.g;
        let tid: i32 = nt.id;
        if mc.fields.len() == 0 {
          g = gen_emit(g, ir.Instr.AddrOfSlot(tid, ref_ty, br.slot));
        } else {
          g = gen_emit(g, ir.Instr.AddrOfFieldChain(tid, ref_ty, br.slot, mc.fields));
        }
        vs2.push(ir.v_temp(tid));
      } else {
        vs2.push(er2.val);
      }
      let ur2: tc.UnifyResult = tc.unify_ty(g.ctx, sig_use.params.get(i2), er2.ty, subs);
      if !ur2.ok { return GenExprResult { ok: false, err: "cannot infer generic arg", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      subs = ur2.subs;
      i2 = i2 + 1;
    }
  } else {
    let mut i2: i32 = 0;
    while i2 < fixed_n {
      let want0_fixed: i32 = tc.subst_ty(g.ctx, sig_use.params.get(i2), subs);
      if want0_fixed == g.ctx.ty_bad { return GenExprResult { ok: false, err: "bad generic arg type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      let want_t_fixed: ir.Ty = ir.ty_pool_get(g.ctx.pool, want0_fixed);
      let want_fixed: i32 = if want_t_fixed.kind == ir.TyKind.Param || tc.ty_has_param(g.ctx, want0_fixed) { -1 } else { want0_fixed };
      let erf: GenExprResult = gen_expr(g, args.get(i2), want_fixed);
      if !erf.ok { return erf; }
      g = erf.g;
      let pbk: i32 = if i2 < sig_use.param_borrow_kinds.len() { sig_use.param_borrow_kinds.get(i2) } else { tc.param_borrow_none() };
      if tc.param_borrow_is_mut(pbk) {
        let mc: MemberChainResult = place_chain(g.exprs, args.get(i2));
        if !mc.ok { return GenExprResult { ok: false, err: mc.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
        let br: LookupSlotResult = slots_lookup(g.slots, mc.base);
        if !br.found { return GenExprResult { ok: false, err: "unknown base var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
        if !br.mutable { return GenExprResult { ok: false, err: "inout argument root is immutable", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

        let elem_ty: i32 = tc.strip_range_only(g.ctx, want0_fixed);
        let static0: bool = pbk == tc.param_borrow_ref_static_mut();
        let rr: tc.ResolveTyResult = tc.intern_ref(g.ctx, elem_ty, true, static0);
        g.ctx = rr.ctx;
        if !rr.ok { return GenExprResult { ok: false, err: "failed to intern &mut arg ref type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
        let ref_ty: i32 = rr.idx;
        let nt: GenNewIdResult = gen_new_temp(g);
        g = nt.g;
        let tid: i32 = nt.id;
        if mc.fields.len() == 0 {
          g = gen_emit(g, ir.Instr.AddrOfSlot(tid, ref_ty, br.slot));
        } else {
          g = gen_emit(g, ir.Instr.AddrOfFieldChain(tid, ref_ty, br.slot, mc.fields));
        }
        vs2.push(ir.v_temp(tid));
      } else {
        vs2.push(erf.val);
      }
      let urf: tc.UnifyResult = tc.unify_ty(g.ctx, sig_use.params.get(i2), erf.ty, subs);
      if !urf.ok { return GenExprResult { ok: false, err: "cannot infer generic arg", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      subs = urf.subs;
      i2 = i2 + 1;
    }

    let mut j2: i32 = fixed_n;
    while j2 < args.len() {
      let want0_var: i32 = tc.subst_ty(g.ctx, sig_use.variadic_elem, subs);
      if want0_var == g.ctx.ty_bad { return GenExprResult { ok: false, err: "bad generic arg type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      let want_t_var: ir.Ty = ir.ty_pool_get(g.ctx.pool, want0_var);
      let want_var: i32 = if want_t_var.kind == ir.TyKind.Param || tc.ty_has_param(g.ctx, want0_var) { -1 } else { want0_var };
      let erv: GenExprResult = gen_expr(g, args.get(j2), want_var);
      if !erv.ok { return erv; }
      g = erv.g;
      variadic_tail_vals.push(erv.val);
      let urv: tc.UnifyResult = tc.unify_ty(g.ctx, sig_use.variadic_elem, erv.ty, subs);
      if !urv.ok { return GenExprResult { ok: false, err: "cannot infer generic arg", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      subs = urv.subs;
      j2 = j2 + 1;
    }
  }

  // Ensure all type params are bound.
  let mut j: i32 = 0;
  while j < sig_use.type_params.len() {
    let tp2: String = sig_use.type_params.get(j);
    if subs_lookup(subs, tp2) == -1 { return GenExprResult { ok: false, err: "unbound type param", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    j = j + 1;
  }

  // Const-generic constraints are checked after substitutions become concrete.
  let cwr: tc.ConstWhereCheckResult = tc.check_const_where_bounds(g.ctx, sig_use.const_where_bounds, subs, csubs);
  if !cwr.ok { return GenExprResult { ok: false, err: cwr.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

  // Check trait bounds for inferred/explicit type args.
  let mut bi: i32 = 0;
  while bi < sig_use.type_param_bounds.len() {
    let b: tc.TypeParamBoundSig = sig_use.type_param_bounds.get(bi);
    let ty0: i32 = subs_lookup(subs, b.type_param);
    if ty0 == -1 { return GenExprResult { ok: false, err: "unbound type param in trait bound", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    let ty1: i32 = tc.strip_range(g.ctx, ty0);
    let fi: tc.FindImplForTyResult = tc.find_impl_for_ty(g.ctx, b.trait_mod_path, b.trait_name, ty1);
    if fi.ambiguous {
      let msg0: String = "type argument ".concat(tc.ty_inst_str(g.ctx, ty1)).concat(" has ambiguous impls for trait ").concat(b.trait_name).concat(" (candidates: ").concat(fi.candidates).concat(")");
      return GenExprResult { ok: false, err: msg0, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    if !fi.found {
      let cands2: String = tc.trait_impl_candidates_text(g.ctx, b.trait_mod_path, b.trait_name);
      let msg: String = "type argument "
        .concat(tc.ty_inst_str(g.ctx, ty1))
        .concat(" does not satisfy trait bound ")
        .concat(b.type_param)
        .concat(": ")
        .concat(b.trait_name)
        .concat(" (available impls: ")
        .concat(cands2)
        .concat(")");
      return GenExprResult { ok: false, err: msg, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    bi = bi + 1;
  }

  // Concrete signature.
  let mut ps: Vec[i32] = Vec();
  let mut pi: i32 = 0;
  while pi < sig_use.params.len() {
    let pty: i32 = tc.subst_ty(g.ctx, sig_use.params.get(pi), subs);
    if pty == g.ctx.ty_bad { return GenExprResult { ok: false, err: "bad substituted param type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    ps.push(tc.strip_range_only(g.ctx, pty));
    pi = pi + 1;
  }
  let rty: i32 = tc.strip_range_only(g.ctx, tc.subst_ty(g.ctx, sig_use.ret, subs));
  if rty == g.ctx.ty_bad { return GenExprResult { ok: false, err: "bad substituted ret type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  let mut inst_sig: tc.FuncSig = tc.FuncSig {
    params: ps,
    param_borrow_kinds: sig_use.param_borrow_kinds,
    ret: rty,
    has_variadic: false,
    variadic_elem: -1,
    vis: sig_use.vis,
    is_pub: sig_use.is_pub,
    type_params: Vec(),
    type_param_packs: Vec(),
    const_params: sig_use.const_params,
    type_param_bounds: Vec(),
    effects: sig_use.effects,
    resource_reads: sig_use.resource_reads,
    resource_writes: sig_use.resource_writes,
    const_where_bounds: sig_use.const_where_bounds,
  };

  let mut inst_type_params: Vec[String] = sig_use.type_params;
  let mut inst_subs: Vec[tc.TySub] = subs;
  if materialized_pack_hetero {
    let fixed_n2: i32 = gen_type_param_fixed_prefix_len(sig_use);
    let mut tps2: Vec[String] = Vec();
    let mut i3: i32 = 0;
    while i3 < fixed_n2 {
      tps2.push(sig_use.type_params.get(i3));
      i3 = i3 + 1;
    }
    let mut pi2: i32 = 0;
    while pi2 < pack_explicit_tys.len() {
      let nm: String = if pi2 == 0 { pack_name } else { pack_name.concat("__").concat(pi2.to_string()) };
      tps2.push(nm);
      if subs_lookup(inst_subs, nm) == -1 {
        inst_subs.push(tc.TySub { name: nm, ty: pack_explicit_tys.get(pi2) });
      }
      pi2 = pi2 + 1;
    }
    inst_type_params = tps2;
  }

  // Ensure async generic instantiation has lowering metadata (frame + poll symbol).
  let ar_async: tc.FindAsyncFnResult = tc.find_async_fn(g.ctx, target_mod, name);
  if ar_async.found {
    let er_async: tc.EnsureAsyncInstResult = tc.ensure_async_inst_for_generic_call(g.ctx, g.w, g.mod_path, target_mod, name, sig_use, inst_subs, csubs);
    if !er_async.ok {
      return GenExprResult { ok: false, err: tc.tc_error_to_string(er_async.err), g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    g.ctx = er_async.ctx;
    // Generic async instantiations return their instantiated frame type.
    inst_sig.ret = tc.strip_range_only(g.ctx, er_async.frame_ty);
  }

  let inst: String = tc.inst_name_ex(g.ctx, name, inst_type_params, sig_use.const_params, inst_subs, csubs);
  let inst_qn: String = qname(target_mod, inst);
  g.pending = pending_add(g.pending, PendingInst { qname: inst_qn, mod_path: target_mod, base_name: name, inst_name: inst, sig: inst_sig, subs: inst_subs, const_subs: csubs });

  if pack_mode {
    let variadic_vec_ty3: i32 = ps.get(ps.len() - 1);
    let variadic_elem_ty3: i32 = tc.subst_ty(g.ctx, sig_use.variadic_elem, subs);
    if variadic_elem_ty3 == g.ctx.ty_bad {
      return GenExprResult { ok: false, err: "bad substituted variadic elem type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
    let pkr2: GenVariadicPackResult = gen_pack_variadic_values(g, variadic_vec_ty3, variadic_elem_ty3, variadic_tail_vals);
    if !pkr2.ok {
      return GenExprResult { ok: false, err: pkr2.err, g: pkr2.g, val: ir.v_int(0), ty: pkr2.g.ctx.ty_bad };
    }
    g = pkr2.g;
    vs2.push(pkr2.val);
  }

  if out_ty == g.ctx.ty_unit {
    g = gen_emit(g, ir.Instr.Call(false, 0, out_ty, inst_qn, vs2));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
  }
  let nt2: GenNewIdResult = gen_new_temp(g);
  g = nt2.g;
  let tid2: i32 = nt2.id;
  g = gen_emit(g, ir.Instr.Call(true, tid2, out_ty, inst_qn, vs2));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid2), ty: out_ty };
}

fn gen_call_enum_ctor(g0: Gen, enum_mod: String, enum_name: String, var_name: String, args: Vec[i32], out_ty: i32) -> GenExprResult {
  let mut fe: tc.FindEnumResult = tc.find_enum(g0.ctx, enum_mod, enum_name);
  if !fe.found && out_ty != -1 {
    let bt: i32 = tc.strip_range(g0.ctx, out_ty);
    let et: ir.Ty = ir.ty_pool_get(g0.ctx.pool, bt);
    if et.kind == ir.TyKind.Enum && tc.ty_mod(et) == enum_mod {
      let fe2: tc.FindEnumResult = tc.find_enum(g0.ctx, enum_mod, tc.ty_name(et));
      if fe2.found && (fe2.sig.base_name == enum_name || fe2.sig.name == enum_name) {
        fe = fe2;
      }
    }
  }
  if !fe.found { return GenExprResult { ok: false, err: "unknown enum", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  let es: tc.EnumSig = fe.sig;
  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: tc.EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != args.len() { return GenExprResult { ok: false, err: "ctor arity mismatch", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
      let mut g: Gen = g0;
      let mut payload: Vec[ir.Value] = Vec();
      let mut ai: i32 = 0;
      while ai < args.len() {
        let want: i32 = v.fields.get(ai);
        let er: GenExprResult = gen_expr(g, args.get(ai), want);
        if !er.ok { return er; }
        g = er.g;
        payload.push(er.val);
        ai = ai + 1;
      }
      let nt: GenNewIdResult = gen_new_temp(g);
      g = nt.g;
      let tid: i32 = nt.id;
      g = gen_emit(g, ir.Instr.EnumInit(tid, out_ty, var_name, payload));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
    }
    vi = vi + 1;
  }
  return GenExprResult { ok: false, err: "unknown enum variant", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
}

fn gen_call_enum_ctor_shorthand(g0: Gen, var_name: String, args: Vec[i32], out_ty: i32) -> GenExprResult {
  let et: ir.Ty = ir.ty_pool_get(g0.ctx.pool, out_ty);
  if et.kind != ir.TyKind.Enum { return GenExprResult { ok: false, err: "enum shorthand needs enum expected type", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  return gen_call_enum_ctor(g0, tc.ty_mod(et), tc.ty_name(et), var_name, args, out_ty);
}

fn gen_expr_dot_ident(g0: Gen, name: String, out_ty: i32) -> GenExprResult {
  // `.Variant` value (unit variant only).
  return gen_call_enum_ctor_shorthand(g0, name, Vec(), out_ty);
}

fn gen_call_vec_method(g0: Gen, recv_id: i32, recv_ty: i32, mname: String, args: Vec[i32], out_ty: i32) -> GenExprResult {
  let elem: i32 = tc.vec_elem(g0.ctx, recv_ty);

  if mname == "push" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "Vec.push arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let valr: GenExprResult = gen_expr(g0, args.get(0), elem);
    if !valr.ok { return valr; }
    let mut g: Gen = valr.g;

    // Receiver must be a place: local var or direct struct field.
    let rn: ast.ExprNode = ast.expr_pool_get(g.exprs, recv_id);
    if match rn { ast.ExprNode.Ident(_x) => true, _ => false } {
      let nm: String = match rn { ast.ExprNode.Ident(s) => s, _ => "" };
      let sr: LookupSlotResult = slots_lookup(g.slots, nm);
      if !sr.found { return GenExprResult { ok: false, err: "unknown vec var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      if !sr.mutable { return GenExprResult { ok: false, err: "Vec.push recv is immutable", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      g = gen_emit(g, ir.Instr.VecPush(sr.slot, elem, valr.val));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
    }

    if match rn { ast.ExprNode.Member(_r, _n) => true, _ => false } {
      return gen_vec_push_member_place(g, recv_id, recv_ty, elem, valr.val, out_ty);
    }

    return GenExprResult { ok: false, err: "Vec.push recv must be place", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  if mname == "insert" {
    if args.len() != 2 { return GenExprResult { ok: false, err: "Vec.insert arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let idxr: GenExprResult = gen_expr(g0, args.get(0), g0.ctx.ty_i32);
    if !idxr.ok { return idxr; }
    let valr: GenExprResult = gen_expr(idxr.g, args.get(1), elem);
    if !valr.ok { return valr; }
    let mut g: Gen = valr.g;

    let rn: ast.ExprNode = ast.expr_pool_get(g.exprs, recv_id);
    if match rn { ast.ExprNode.Ident(_x) => true, _ => false } {
      let nm: String = match rn { ast.ExprNode.Ident(s) => s, _ => "" };
      let sr: LookupSlotResult = slots_lookup(g.slots, nm);
      if !sr.found { return GenExprResult { ok: false, err: "unknown vec var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      if !sr.mutable { return GenExprResult { ok: false, err: "Vec.insert recv is immutable", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      g = gen_emit(g, ir.Instr.VecInsert(sr.slot, elem, idxr.val, valr.val));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
    }

    if match rn { ast.ExprNode.Member(_r, _n) => true, _ => false } {
      return gen_vec_insert_member_place(g, recv_id, recv_ty, elem, idxr.val, valr.val, out_ty);
    }

    return GenExprResult { ok: false, err: "Vec.insert recv must be place", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  if mname == "set" {
    if args.len() != 2 { return GenExprResult { ok: false, err: "Vec.set arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let idxr: GenExprResult = gen_expr(g0, args.get(0), g0.ctx.ty_i32);
    if !idxr.ok { return idxr; }
    let valr: GenExprResult = gen_expr(idxr.g, args.get(1), elem);
    if !valr.ok { return valr; }
    let mut g: Gen = valr.g;

    let rn: ast.ExprNode = ast.expr_pool_get(g.exprs, recv_id);
    if match rn { ast.ExprNode.Ident(_x) => true, _ => false } {
      let nm: String = match rn { ast.ExprNode.Ident(s) => s, _ => "" };
      let sr: LookupSlotResult = slots_lookup(g.slots, nm);
      if !sr.found { return GenExprResult { ok: false, err: "unknown vec var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      if !sr.mutable { return GenExprResult { ok: false, err: "Vec.set recv is immutable", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      g = gen_emit(g, ir.Instr.VecSet(sr.slot, elem, idxr.val, valr.val));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
    }

    if match rn { ast.ExprNode.Member(_r, _n) => true, _ => false } {
      return gen_vec_set_member_place(g, recv_id, recv_ty, elem, idxr.val, valr.val, out_ty);
    }

    return GenExprResult { ok: false, err: "Vec.set recv must be place", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  if mname == "clear" {
    if args.len() != 0 { return GenExprResult { ok: false, err: "Vec.clear arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let mut g: Gen = g0;
    let rn: ast.ExprNode = ast.expr_pool_get(g.exprs, recv_id);
    if match rn { ast.ExprNode.Ident(_x) => true, _ => false } {
      let nm: String = match rn { ast.ExprNode.Ident(s) => s, _ => "" };
      let sr: LookupSlotResult = slots_lookup(g.slots, nm);
      if !sr.found { return GenExprResult { ok: false, err: "unknown vec var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      if !sr.mutable { return GenExprResult { ok: false, err: "Vec.clear recv is immutable", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      g = gen_emit(g, ir.Instr.VecClear(sr.slot));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
    }
    if match rn { ast.ExprNode.Member(_r, _n) => true, _ => false } {
      return gen_vec_clear_member_place(g, recv_id, recv_ty, out_ty);
    }
    return GenExprResult { ok: false, err: "Vec.clear recv must be place", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  if mname == "extend" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "Vec.extend arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let mut g: Gen = g0;
    let other_rr: VecRecvSlotResult = vec_recv_slot(g, args.get(0), recv_ty);
    if !other_rr.ok { return GenExprResult { ok: false, err: other_rr.err, g: other_rr.g, val: ir.v_int(0), ty: other_rr.g.ctx.ty_bad }; }
    g = other_rr.g;

    let rn: ast.ExprNode = ast.expr_pool_get(g.exprs, recv_id);
    if match rn { ast.ExprNode.Ident(_x) => true, _ => false } {
      let nm: String = match rn { ast.ExprNode.Ident(s) => s, _ => "" };
      let sr: LookupSlotResult = slots_lookup(g.slots, nm);
      if !sr.found { return GenExprResult { ok: false, err: "unknown vec var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      if !sr.mutable { return GenExprResult { ok: false, err: "Vec.extend recv is immutable", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      g = gen_emit(g, ir.Instr.VecExtend(sr.slot, other_rr.slot));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty };
    }
    if match rn { ast.ExprNode.Member(_r, _n) => true, _ => false } {
      return gen_vec_extend_member_place(g, recv_id, other_rr.slot, out_ty);
    }
    return GenExprResult { ok: false, err: "Vec.extend recv must be place", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  if mname == "pop" {
    if args.len() != 0 { return GenExprResult { ok: false, err: "Vec.pop arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let mut g: Gen = g0;
    let rn: ast.ExprNode = ast.expr_pool_get(g.exprs, recv_id);
    if match rn { ast.ExprNode.Ident(_x) => true, _ => false } {
      let nm: String = match rn { ast.ExprNode.Ident(s) => s, _ => "" };
      let sr: LookupSlotResult = slots_lookup(g.slots, nm);
      if !sr.found { return GenExprResult { ok: false, err: "unknown vec var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      if !sr.mutable { return GenExprResult { ok: false, err: "Vec.pop recv is immutable", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      let nt: GenNewIdResult = gen_new_temp(g);
      g = nt.g;
      let tid: i32 = nt.id;
      g = gen_emit(g, ir.Instr.VecPop(tid, elem, sr.slot));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
    }
    if match rn { ast.ExprNode.Member(_r, _n) => true, _ => false } {
      return gen_vec_pop_member_place(g, recv_id, elem, out_ty);
    }
    return GenExprResult { ok: false, err: "Vec.pop recv must be place", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  if mname == "remove" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "Vec.remove arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let mut g: Gen = g0;
    let idxr: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_i32);
    if !idxr.ok { return idxr; }
    g = idxr.g;
    let rn: ast.ExprNode = ast.expr_pool_get(g.exprs, recv_id);
    if match rn { ast.ExprNode.Ident(_x) => true, _ => false } {
      let nm: String = match rn { ast.ExprNode.Ident(s) => s, _ => "" };
      let sr: LookupSlotResult = slots_lookup(g.slots, nm);
      if !sr.found { return GenExprResult { ok: false, err: "unknown vec var", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      if !sr.mutable { return GenExprResult { ok: false, err: "Vec.remove recv is immutable", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
      let nt: GenNewIdResult = gen_new_temp(g);
      g = nt.g;
      let tid: i32 = nt.id;
      g = gen_emit(g, ir.Instr.VecRemove(tid, elem, sr.slot, idxr.val));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
    }
    if match rn { ast.ExprNode.Member(_r, _n) => true, _ => false } {
      return gen_vec_remove_member_place(g, recv_id, elem, idxr.val, out_ty);
    }
    return GenExprResult { ok: false, err: "Vec.remove recv must be place", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  if mname == "len" {
    if args.len() != 0 { return GenExprResult { ok: false, err: "Vec.len arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let rr: VecRecvSlotResult = vec_recv_slot(g0, recv_id, recv_ty);
    if !rr.ok { return GenExprResult { ok: false, err: rr.err, g: rr.g, val: ir.v_int(0), ty: rr.g.ctx.ty_bad }; }
    let mut g: Gen = rr.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.VecLen(tid, rr.slot));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }

  if mname == "is_empty" {
    if args.len() != 0 { return GenExprResult { ok: false, err: "Vec.is_empty arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let rr0: VecRecvSlotResult = vec_recv_slot(g0, recv_id, recv_ty);
    if !rr0.ok { return GenExprResult { ok: false, err: rr0.err, g: rr0.g, val: ir.v_int(0), ty: rr0.g.ctx.ty_bad }; }
    let mut g: Gen = rr0.g;
    let nt0: GenNewIdResult = gen_new_temp(g);
    g = nt0.g;
    let len_tid: i32 = nt0.id;
    g = gen_emit(g, ir.Instr.VecLen(len_tid, rr0.slot));
    let nt1: GenNewIdResult = gen_new_temp(g);
    g = nt1.g;
    let cmp_tid: i32 = nt1.id;
    g = gen_emit(g, ir.Instr.Cmp(cmp_tid, ir.CmpKind.Eq, g.ctx.ty_i32, ir.v_temp(len_tid), ir.v_int(0)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(cmp_tid), ty: out_ty };
  }

  if mname == "get" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "Vec.get arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let rr: VecRecvSlotResult = vec_recv_slot(g0, recv_id, recv_ty);
    if !rr.ok { return GenExprResult { ok: false, err: rr.err, g: rr.g, val: ir.v_int(0), ty: rr.g.ctx.ty_bad }; }
    let mut g: Gen = rr.g;
    let idxr: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_i32);
    if !idxr.ok { return idxr; }
    g = idxr.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.VecGet(tid, elem, rr.slot, idxr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }

  if mname == "join" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "Vec.join arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let rr: VecRecvSlotResult = vec_recv_slot(g0, recv_id, recv_ty);
    if !rr.ok { return GenExprResult { ok: false, err: rr.err, g: rr.g, val: ir.v_int(0), ty: rr.g.ctx.ty_bad }; }
    let mut g: Gen = rr.g;
    let sepr: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_string);
    if !sepr.ok { return sepr; }
    g = sepr.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.VecStrJoin(tid, rr.slot, sepr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }

  return GenExprResult { ok: false, err: "unsupported Vec method", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
}

struct GenStringConcatChain { base_recv_id: i32, parts: Vec[i32] }

fn gen_collect_string_concat_chain(exprs: ast.ExprPool, recv_id0: i32, args0: Vec[i32]) -> GenStringConcatChain {
  let mut rev_parts: Vec[i32] = Vec();
  if args0.len() == 1 {
    rev_parts.push(args0.get(0));
  }

  let mut cur_recv: i32 = recv_id0;
  while true {
    let n: ast.ExprNode = ast.expr_pool_get(exprs, cur_recv);
    let is_call: bool = match n { ast.ExprNode.Call(_callee, _type_args, _args) => true, _ => false };
    if !is_call { break; }
    let callee: i32 = match n { ast.ExprNode.Call(callee0, _type_args, _args) => callee0, _ => -1 };
    let type_args: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_callee, type_args0, _args) => type_args0, _ => Vec() };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_callee, _type_args, args1) => args1, _ => Vec() };
    if type_args.len() != 0 || args.len() != 1 { break; }

    let cn: ast.ExprNode = ast.expr_pool_get(exprs, callee);
    let is_member: bool = match cn { ast.ExprNode.Member(_recv, _name) => true, _ => false };
    if !is_member { break; }
    let mname: String = match cn { ast.ExprNode.Member(_recv, name0) => name0, _ => "" };
    if mname != "concat" { break; }
    let inner_recv: i32 = match cn { ast.ExprNode.Member(recv1, _name) => recv1, _ => -1 };

    rev_parts.push(args.get(0));
    cur_recv = inner_recv;
  }

  let mut parts: Vec[i32] = Vec();
  let mut i: i32 = rev_parts.len() - 1;
  while i >= 0 {
    parts.push(rev_parts.get(i));
    i = i - 1;
  }
  return GenStringConcatChain { base_recv_id: cur_recv, parts: parts };
}

fn gen_call_string_method(g0: Gen, recv_id: i32, mname: String, args: Vec[i32], out_ty: i32) -> GenExprResult {
  if mname == "concat" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "String.concat arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let ch: GenStringConcatChain = gen_collect_string_concat_chain(g0.exprs, recv_id, args);
    let base: GenExprResult = gen_expr(g0, ch.base_recv_id, g0.ctx.ty_string);
    if !base.ok { return base; }

    let mut g: Gen = base.g;
    let mut cur: ir.Value = base.val;
    let mut i: i32 = 0;
    while i < ch.parts.len() {
      let ar: GenExprResult = gen_expr(g, ch.parts.get(i), g.ctx.ty_string);
      if !ar.ok { return ar; }
      g = ar.g;
      let nt: GenNewIdResult = gen_new_temp(g);
      g = nt.g;
      let tid: i32 = nt.id;
      g = gen_emit(g, ir.Instr.StrConcat(tid, cur, ar.val));
      cur = ir.v_temp(tid);
      i = i + 1;
    }
    return GenExprResult { ok: true, err: "", g: g, val: cur, ty: out_ty };
  }

  let mut g: Gen = g0;
  let rr: GenExprResult = gen_expr(g, recv_id, g.ctx.ty_string);
  if !rr.ok { return rr; }
  g = rr.g;

  if mname == "len" {
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrLen(tid, rr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "is_empty" {
    if args.len() != 0 { return GenExprResult { ok: false, err: "String.is_empty arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let nt0: GenNewIdResult = gen_new_temp(g);
    g = nt0.g;
    let len_tid: i32 = nt0.id;
    g = gen_emit(g, ir.Instr.StrLen(len_tid, rr.val));
    let nt1: GenNewIdResult = gen_new_temp(g);
    g = nt1.g;
    let cmp_tid: i32 = nt1.id;
    g = gen_emit(g, ir.Instr.Cmp(cmp_tid, ir.CmpKind.Eq, g.ctx.ty_i32, ir.v_temp(len_tid), ir.v_int(0)));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(cmp_tid), ty: out_ty };
  }
  if mname == "byte_at" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "String.byte_at arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let idxr: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_i32);
    if !idxr.ok { return idxr; }
    g = idxr.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrByteAt(tid, rr.val, idxr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "slice" {
    if args.len() != 2 { return GenExprResult { ok: false, err: "String.slice arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let sr: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_i32);
    if !sr.ok { return sr; }
    g = sr.g;
    let er: GenExprResult = gen_expr(g, args.get(1), g.ctx.ty_i32);
    if !er.ok { return er; }
    g = er.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrSlice(tid, rr.val, sr.val, er.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "escape_c" {
    if args.len() != 0 { return GenExprResult { ok: false, err: "String.escape_c arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrEscapeC(tid, rr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "starts_with" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "String.starts_with arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let pr: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_string);
    if !pr.ok { return pr; }
    g = pr.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrStartsWith(tid, rr.val, pr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "ends_with" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "String.ends_with arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let sr: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_string);
    if !sr.ok { return sr; }
    g = sr.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrEndsWith(tid, rr.val, sr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "contains" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "String.contains arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let nr: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_string);
    if !nr.ok { return nr; }
    g = nr.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrContains(tid, rr.val, nr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "index_of" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "String.index_of arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let nr0: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_string);
    if !nr0.ok { return nr0; }
    g = nr0.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrIndexOf(tid, rr.val, nr0.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "last_index_of" {
    if args.len() != 1 { return GenExprResult { ok: false, err: "String.last_index_of arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let nr1: GenExprResult = gen_expr(g, args.get(0), g.ctx.ty_string);
    if !nr1.ok { return nr1; }
    g = nr1.g;
    let nt: GenNewIdResult = gen_new_temp(g);
    g = nt.g;
    let tid: i32 = nt.id;
    g = gen_emit(g, ir.Instr.StrLastIndexOf(tid, rr.val, nr1.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }
  if mname == "to_string" {
    if args.len() != 0 { return GenExprResult { ok: false, err: "String.to_string arity", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    return GenExprResult { ok: true, err: "", g: g, val: rr.val, ty: out_ty };
  }
  return GenExprResult { ok: false, err: "unsupported String method", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
}

fn gen_call_prim_method(g0: Gen, recv_id: i32, recv_ty: i32, mname: String, out_ty: i32) -> GenExprResult {
  if mname != "to_string" { return GenExprResult { ok: false, err: "unsupported prim method", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
  let mut g: Gen = g0;
  let rr: GenExprResult = gen_expr(g, recv_id, recv_ty);
  if !rr.ok { return rr; }
  g = rr.g;
  let nt: GenNewIdResult = gen_new_temp(g);
  g = nt.g;
  let tid: i32 = nt.id;
  let base: i32 = tc.strip_range(g.ctx, recv_ty);
  let bt: ir.Ty = ir.ty_pool_get(g.ctx.pool, base);
  if bt.kind == ir.TyKind.Bool { g = gen_emit(g, ir.Instr.BoolToStr(tid, rr.val)); }
  else if bt.kind == ir.TyKind.I64 || bt.kind == ir.TyKind.ISize { g = gen_emit(g, ir.Instr.I64ToStr(tid, rr.val)); }
  else if bt.kind == ir.TyKind.I8 || bt.kind == ir.TyKind.I16 || bt.kind == ir.TyKind.I32 { g = gen_emit(g, ir.Instr.I32ToStr(tid, rr.val)); }
  else if bt.kind == ir.TyKind.U8 || bt.kind == ir.TyKind.U16 || bt.kind == ir.TyKind.U32 || bt.kind == ir.TyKind.U64 || bt.kind == ir.TyKind.USize {
    g = gen_emit(g, ir.Instr.U64ToStr(tid, rr.val));
  } else if bt.kind == ir.TyKind.F32 {
    g = gen_emit(g, ir.Instr.F32ToStr(tid, rr.val));
  } else if bt.kind == ir.TyKind.F64 {
    g = gen_emit(g, ir.Instr.F64ToStr(tid, rr.val));
  } else {
    return GenExprResult { ok: false, err: "unsupported prim method recv type", g: g, val: ir.v_int(0), ty: g0.ctx.ty_bad };
  }
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
}

fn gen_pat_test(g0: Gen, pat: ast.Pat, v: ir.Value, ty: i32, ok_blk: String, fail_blk: String) -> GenPatResult {
  let mut g: Gen = g0;
  return match pat {
    ast.Pat.Wild(_sp) => gen_pat_ok(gen_term(g, ir.Term.Br(ok_blk))),
    ast.Pat.Bind(_sp, _name) => gen_pat_ok(gen_term(g, ir.Term.Br(ok_blk))),
    ast.Pat.Bool(_sp, b) => {
      let base: i32 = tc.strip_range(g.ctx, ty);
      if base != g.ctx.ty_bool {
        gen_pat_err(g, "bool pattern on non-bool type")
      } else {
        let nt: GenNewIdResult = gen_new_temp(g);
        let g1: Gen = nt.g;
        let cid: i32 = nt.id;
        let g2: Gen = gen_emit(g1, ir.Instr.Cmp(cid, ir.CmpKind.Eq, g.ctx.ty_bool, v, ir.v_bool(b)));
        let g3: Gen = gen_term(g2, ir.Term.CondBr(ir.v_temp(cid), ok_blk, fail_blk));
        gen_pat_ok(g3)
      }
    },

    ast.Pat.Int(_sp, text) => {
      let base: i32 = tc.strip_range(g.ctx, ty);
      if !tc.is_int_like_ty(g.ctx, base) {
        gen_pat_err(g, "int pattern on non-int type")
      } else {
        let bt: ir.Ty = ir.ty_pool_get(g.ctx.pool, base);
        let is_u64_like: bool = match bt.kind { ir.TyKind.U64 => true, ir.TyKind.USize => true, _ => false };
        let mut lit_bits: i64 = 0;
        let mut ok_lit: bool = false;
        if is_u64_like {
          let pru: tc.ParseU64DecResult = tc.parse_u64_dec(text);
          ok_lit = pru.ok;
          if ok_lit { lit_bits = pru.val; }
        } else {
          let pr: tc.ParseI64DecResult = tc.parse_i64_dec(text);
          ok_lit = pr.ok;
          if ok_lit { lit_bits = pr.val; }
        };
        let mut out: GenPatResult = gen_pat_err(g, "invalid int pattern");
        if ok_lit {
          let nt: GenNewIdResult = gen_new_temp(g);
          let g1: Gen = nt.g;
          let cid: i32 = nt.id;
          let g2: Gen = gen_emit(g1, ir.Instr.Cmp(cid, ir.CmpKind.Eq, base, v, ir.v_i64(lit_bits)));
          let g3: Gen = gen_term(g2, ir.Term.CondBr(ir.v_temp(cid), ok_blk, fail_blk));
          out = gen_pat_ok(g3);
        }
        out
      }
    },

    ast.Pat.Str(_sp, s) => {
      let base: i32 = tc.strip_range(g.ctx, ty);
      if base != g.ctx.ty_string {
        gen_pat_err(g, "string pattern on non-string type")
      } else {
        let nt: GenNewIdResult = gen_new_temp(g);
        let g1: Gen = nt.g;
        let cid: i32 = nt.id;
        let g2: Gen = gen_emit(g1, ir.Instr.Cmp(cid, ir.CmpKind.Eq, g.ctx.ty_string, v, ir.v_str(s)));
        let g3: Gen = gen_term(g2, ir.Term.CondBr(ir.v_temp(cid), ok_blk, fail_blk));
        gen_pat_ok(g3)
      }
    },

    ast.Pat.EnumVariant(_sp, _ep, vname, args) => {
      let esr: EnumSigResult = enum_sig_for_ty(g.ctx, ty);
      if !esr.ok {
        gen_pat_err(g, esr.err)
      } else {
        let fv: FindVariantResult = find_enum_variant(esr.sig, vname);
        if !fv.found {
          gen_pat_err(g, "unknown enum variant")
        } else if fv.sig.fields.len() != args.len() {
          gen_pat_err(g, "wrong enum pattern arity")
        } else {
          let mut g2: Gen = g;

          // tag check
          let nt_tag: GenNewIdResult = gen_new_temp(g2);
          g2 = nt_tag.g;
          let tag_id: i32 = nt_tag.id;
          g2 = gen_emit(g2, ir.Instr.EnumTag(tag_id, v));

          let nt_cmp: GenNewIdResult = gen_new_temp(g2);
          g2 = nt_cmp.g;
          let cmp_id: i32 = nt_cmp.id;
          g2 = gen_emit(g2, ir.Instr.Cmp(cmp_id, ir.CmpKind.Eq, g2.ctx.ty_i32, ir.v_temp(tag_id), ir.v_int(fv.idx)));

          let nb_ok: GenNewIdResult = gen_new_block(g2, "pat_enum_ok_".concat(g2.blocks.len().to_string()));
          g2 = nb_ok.g;
          let ok_idx: i32 = nb_ok.id;
          g2 = gen_term(g2, ir.Term.CondBr(ir.v_temp(cmp_id), g2.blocks.get(ok_idx).name, fail_blk));
          g2 = gen_set_block(g2, ok_idx);

          if args.len() == 0 {
            gen_pat_ok(gen_term(g2, ir.Term.Br(ok_blk)))
          } else {
            let mut ok: bool = true;
            let mut msg: String = "";
            let mut i: i32 = 0;
            while i < args.len() {
              if ok {
                let fty: i32 = fv.sig.fields.get(i);
                let nt_p: GenNewIdResult = gen_new_temp(g2);
                g2 = nt_p.g;
                let pid: i32 = nt_p.id;
                g2 = gen_emit(g2, ir.Instr.EnumPayload(pid, fty, v, vname, i));

                let mut cont_blk: String = ok_blk;
                let mut cont_idx: i32 = -1;
                if i < args.len() - 1 {
                  let nb_cont: GenNewIdResult = gen_new_block(g2, "pat_cont_".concat(g2.blocks.len().to_string()));
                  g2 = nb_cont.g;
                  cont_idx = nb_cont.id;
                  cont_blk = g2.blocks.get(cont_idx).name;
                }

                let pr: GenPatResult = gen_pat_test(g2, args.get(i), ir.v_temp(pid), fty, cont_blk, fail_blk);
                if !pr.ok {
                  ok = false;
                  msg = pr.err;
                  g2 = pr.g;
                } else {
                  g2 = pr.g;
                  if cont_idx != -1 { g2 = gen_set_block(g2, cont_idx); }
                }
              }
              i = i + 1;
            }

            if ok { gen_pat_ok(g2) } else { gen_pat_err(g2, msg) }
          }
        }
      }
    },
  };
}

fn gen_pat_binds(g0: Gen, pat: ast.Pat, v: ir.Value, ty: i32) -> GenPatResult {
  let mut g: Gen = g0;
  return match pat {
    ast.Pat.Wild(_sp) => gen_pat_ok(g),
    ast.Pat.Bool(_sp, _b) => gen_pat_ok(g),
    ast.Pat.Int(_sp, _t) => gen_pat_ok(g),
    ast.Pat.Str(_sp, _s) => gen_pat_ok(g),

    ast.Pat.Bind(_sp, name) => {
      let ns: GenNewIdResult = gen_new_slot(g);
      g = ns.g;
      let sid: i32 = ns.id;
      g = gen_emit(g, ir.Instr.SlotDecl(sid, ty));
      g = gen_emit(g, ir.Instr.Store(sid, v));
      g.slots = slots_decl(g.slots, name, sid, ty, false);
      g.locals = tc.locals_decl(g.locals, name, ty, false);
      gen_pat_ok(g)
    },

    ast.Pat.EnumVariant(_sp, _ep, vname, args) => {
      let esr: EnumSigResult = enum_sig_for_ty(g.ctx, ty);
      if !esr.ok {
        gen_pat_err(g, esr.err)
      } else {
        let fv: FindVariantResult = find_enum_variant(esr.sig, vname);
        if !fv.found {
          gen_pat_err(g, "unknown enum variant")
        } else if fv.sig.fields.len() != args.len() {
          gen_pat_err(g, "wrong enum pattern arity")
        } else {
          let mut g2: Gen = g;
          let mut ok: bool = true;
          let mut msg: String = "";
          let mut i: i32 = 0;
          while i < args.len() {
            if ok {
              let fty: i32 = fv.sig.fields.get(i);
              let nt_p: GenNewIdResult = gen_new_temp(g2);
              g2 = nt_p.g;
              let pid: i32 = nt_p.id;
              g2 = gen_emit(g2, ir.Instr.EnumPayload(pid, fty, v, vname, i));
              let pr: GenPatResult = gen_pat_binds(g2, args.get(i), ir.v_temp(pid), fty);
              if !pr.ok {
                ok = false;
                msg = pr.err;
                g2 = pr.g;
              } else {
                g2 = pr.g;
              }
            }
            i = i + 1;
          }
          if ok { gen_pat_ok(g2) } else { gen_pat_err(g2, msg) }
        }
      }
    },
  };
}

fn gen_expr_match(g0: Gen, scrut: i32, arms: Vec[ast.MatchArm], out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let sr: GenExprResult = gen_expr(g, scrut, -1);
  if !sr.ok { return sr; }
  g = sr.g;

  let sty: tc.ExprTyResult = tc.tc_expr(g.ctx, g.w, g.mod_path, g.imps, g.exprs, g.locals, scrut, -1);
  if !sty.ok { return GenExprResult { ok: false, err: "bad match scrut", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

  let scrut_base: i32 = tc.strip_range(g.ctx, sty.ty);
  let st: ir.Ty = ir.ty_pool_get(g.ctx.pool, scrut_base);
  let is_enum: bool = st.kind == ir.TyKind.Enum;
  let is_int: bool = tc.is_int_like_ty(g.ctx, scrut_base);
  let is_str: bool = scrut_base == g.ctx.ty_string;
  let is_bool: bool = scrut_base == g.ctx.ty_bool;
  if !is_enum && !is_int && !is_str && !is_bool { return GenExprResult { ok: false, err: "match scrut must be enum/<int>/String/bool", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

  let mut res_slot: i32 = -1;
  if out_ty != g.ctx.ty_unit {
    let ns: GenNewIdResult = gen_new_slot(g);
    g = ns.g;
    res_slot = ns.id;
    g = gen_emit(g, ir.Instr.SlotDecl(res_slot, out_ty));
    let zr: GenExprResult = gen_zero_value(g, out_ty);
    if !zr.ok { return zr; }
    g = zr.g;
    g = gen_emit(g, ir.Instr.Store(res_slot, zr.val));
  }

  let base: i32 = g.blocks.len();
  let endr: GenNewIdResult = gen_new_block(g, "match_end_".concat(base.to_string()));
  g = endr.g;
  let end_idx: i32 = endr.id;
  let end_name: String = g.blocks.get(end_idx).name;

  // Decision chain in source order.
  let mut arm_blks: Vec[i32] = Vec();
  let mut cur_decide: i32 = g.cur;
  let mut ai: i32 = 0;
  while ai < arms.len() {
    let a: ast.MatchArm = arms.get(ai);
    let nb_arm: GenNewIdResult = gen_new_block(g, "match_arm_".concat((base + ai).to_string()));
    g = nb_arm.g;
    let arm_idx: i32 = nb_arm.id;
    arm_blks.push(arm_idx);

    let nb_next: GenNewIdResult = gen_new_block(g, "match_decide_".concat((base + ai).to_string()));
    g = nb_next.g;
    let next_idx: i32 = nb_next.id;

    let arm_name: String = g.blocks.get(arm_idx).name;
    let next_name: String = g.blocks.get(next_idx).name;

    g = gen_set_block(g, cur_decide);
    let pr: GenPatResult = gen_pat_test(g, a.pat, sr.val, sty.ty, arm_name, next_name);
    if !pr.ok { return GenExprResult { ok: false, err: pr.err, g: pr.g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    g = pr.g;
    cur_decide = next_idx;
    ai = ai + 1;
  }

  // Fallthrough (unreachable for exhaustive matches).
  g = gen_set_block(g, cur_decide);
  g = gen_term(g, ir.Term.Br(end_name));

  // Arms.
  ai = 0;
  while ai < arms.len() {
    let a: ast.MatchArm = arms.get(ai);
    let arm_idx: i32 = arm_blks.get(ai);
    g = gen_set_block(g, arm_idx);
    g.slots = slots_enter(g.slots);
    g.locals = tc.locals_enter(g.locals);

    let br: GenPatResult = gen_pat_binds(g, a.pat, sr.val, sty.ty);
    if !br.ok { return GenExprResult { ok: false, err: br.err, g: br.g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    g = br.g;

    let vr: GenExprResult = gen_expr(g, a.expr, out_ty);
    if !vr.ok { return vr; }
    g = vr.g;
    if res_slot != -1 && !g.blocks.get(g.cur).has_term {
      g = gen_emit(g, ir.Instr.Store(res_slot, vr.val));
    }

    g.locals = tc.locals_exit(g.locals);
    g.slots = slots_exit(g.slots);
    if !g.blocks.get(g.cur).has_term {
      g = gen_term(g, ir.Term.Br(end_name));
    }
    ai = ai + 1;
  }

  g = gen_set_block(g, end_idx);
  if res_slot == -1 { return GenExprResult { ok: true, err: "", g: g, val: ir.v_int(0), ty: out_ty }; }
  let nt2: GenNewIdResult = gen_new_temp(g);
  g = nt2.g;
  let tid2: i32 = nt2.id;
  g = gen_emit(g, ir.Instr.Load(tid2, out_ty, res_slot));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid2), ty: out_ty };
}
