import "std/testing" as t
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_const_float_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const A: f64 = 1.5\nfn main() -> f64 { return A; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const f64 1.5"));
}

fn test_irgen_const_float_arith_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const A: f64 = 1.0 + 2.0\nfn main() -> f64 { return A; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const f64 3.0"));
}

fn test_irgen_const_float_mod_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const A: f64 = 5.5 % 2.0\nfn main() -> f64 { return A; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const f64 1.5"));
}

fn test_irgen_const_float_eq_ne_folds() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    const A: f64 = 3.0 + 4.0
    const EQ: bool = A == 7.0
    const NE: bool = A != 8.0
    fn main() -> i32 { return if EQ && NE { 1 } else { 0 }; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const bool true"));
}

fn test_irgen_const_reflect_intrinsics_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", string_prelude());
  w = add_mod(w, "main", """
    type R = @range(0..=7) i32
    struct S { a: i32, b: i64 }
    enum E { A(i32), B }
    const SZ: usize = @size_of(S)
    const AL: usize = @align_of(S)
    const FC_S: usize = @field_count(S)
    const FC_E: usize = @field_count(E)
    const FN0: String = @field_name(S, 0)
    const VN1: String = @field_name(E, 1)
    const FT1: String = @field_type(S, 1)
    const ET0: String = @field_type(E, 0)
    const ET1: String = @field_type(E, 1)
    const FTY1: TypeId = @field_type_id(S, 1)
    const ETY0: TypeId = @field_type_id(E, 0)
    const ETY1: TypeId = @field_type_id(E, 1)
    const TY_S: TypeId = @type(S)
    const TY_I32: TypeId = @type(i32)
    const TY_I64: TypeId = @type(i64)
    const TN: String = @type_name(S)
    const EQTY: bool = @same_type(i32, i32)
    const NETY: bool = @same_type(i32, i64)
    const A0: bool = @assignable_to(R, i32)
    const A1: bool = @assignable_to(i32, R)
    const A2: bool = @assignable_to(i32, i32)
    const C0: bool = @castable_to(i32, f64)
    const C1: bool = @castable_to(String, i32)
    const E2E0: bool = @eq_comparable_with(S, S)
    const E2E1: bool = @eq_comparable_with(Vec[i32], Vec[i32])
    const O2O0: bool = @ordered_with(String, String)
    const O2O1: bool = @ordered_with(S, S)
    const I0: bool = @is_integer(i32)
    const I1: bool = @is_integer(S)
    const SI: bool = @is_signed_int(i64)
    const SU: bool = @is_unsigned_int(u64)
    const F0: bool = @is_float(f64)
    const B0: bool = @is_bool(bool)
    const S0: bool = @is_string(String)
    const ST: bool = @is_struct(S)
    const EN: bool = @is_enum(E)
    const V0: bool = @is_vec(Vec[i32])
    const R0: bool = @is_range(R)
    const EQC0: bool = @is_eq_comparable(S)
    const EQC1: bool = @is_eq_comparable(Vec[i32])
    const ORD0: bool = @is_ordered(String)
    const ORD1: bool = @is_ordered(S)
    const U0: bool = @is_unit(())
    const U1: bool = @is_unit(i32)
    const N0: bool = @is_numeric(i32)
    const N1: bool = @is_numeric(String)
    fn main() -> usize {
      return SZ + AL + FC_S + FC_E + TN.len() as usize + FN0.len() as usize +
          VN1.len() as usize + FT1.len() as usize + ET0.len() as usize + ET1.len() as usize +
          FTY1 + ETY0 + ETY1 + TY_S + TY_I32 + TY_I64 +
          if EQTY && !NETY && A0 && !A1 && A2 && C0 && !C1 && E2E0 && !E2E1 &&
              O2O0 && !O2O1 && I0 && !I1 && SI && SU && F0 && B0 && S0 && ST && EN &&
              V0 && R0 && EQC0 && !EQC1 && ORD0 && !ORD1 && U0 && !U1 && N0 && !N1 {
            1
          } else {
            0
          } as usize;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const usize 16"));
  t.assert(contains(s, "const usize 8"));
  t.assert(contains(s, "const usize 2"));
  t.assert(contains(s, "const str \"S\""));
  t.assert(contains(s, "const str \"a\""));
  t.assert(contains(s, "const str \"B\""));
  t.assert(contains(s, "const str \"i64\""));
  t.assert(contains(s, "const str \"i32\""));
  t.assert(contains(s, "const str \"()\""));
  t.assert(contains(s, "const bool true"));
  t.assert(contains(s, "const bool false"));
}

fn test_irgen_const_reflect_layout_intrinsics_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    const Z0: bool = @is_zero_sized(())
    const Z1: bool = @is_zero_sized(i32)
    const L0: bool = @same_layout(i32, u32)
    const L1: bool = @same_layout(i32, i64)
    const B0: bool = @bitcastable(i32, u32)
    const B1: bool = @bitcastable(i32, i64)
    fn main() -> i32 { return if Z0 && !Z1 && L0 && !L1 && B0 && !B1 { 1 } else { 0 }; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const bool true"));
  t.assert(contains(s, "const bool false"));
}

fn test_irgen_const_compile_error_rejected_with_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const X: i32 = @compile_error(\"const-boom\")\nfn main() -> i32 { return 0; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "compile_error: const-boom"));
}

fn test_irgen_const_int_float_cast_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const A: f64 = 7 as f64\nconst B: i32 = 7.9 as i32\nfn main() -> i32 { return A as i32 + B; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const f64 7.0"));
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_unary_not_int_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "const N: i32 = !0\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 -1"));
}

fn test_irgen_const_logic_short_circuit_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    const A: bool = false && (1 / 0 == 0)
    const B: bool = true || (1 / 0 == 0)
    fn main() -> i32 { return if A || B { 1 } else { 0 }; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 1"));
}

fn test_irgen_const_struct_member_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct P { x: i32, y: i32 }
    const P0: P = P { x: 3, y: 4 }
    const N: i32 = P0.x + P0.y
    fn main() -> i32 { return N; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32"));
}

fn test_irgen_const_typed_path_generic_struct_lit_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct Pair[T] { a: T, b: T }
    const P0: Pair[i32] = Pair[i32] { a: 3, b: 4 }
    const N: i32 = P0.a + P0.b
    fn main() -> i32 { return N; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_generic_struct_lit_uses_expected_type_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct Pair[T] { a: T, b: T }
    const P0: Pair[i32] = Pair { a: 3, b: 4 }
    const N: i32 = P0.a + P0.b
    fn main() -> i32 { return N; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_enum_unit_match_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    enum E { A, B }
    const X: E = .A
    const N: i32 = match X { .A => 1, .B => 0 }
    fn main() -> i32 { return N; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 1"));
}

fn test_irgen_const_enum_payload_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    enum E { A(i32), B }
    const X: E = .A(7)
    fn main() -> i32 { let y: E = X; return match y { E.A(v) => v, E.B => 0 }; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "enum_init"));
  t.assert(contains(s, "7"));
}

fn test_irgen_const_typed_path_generic_enum_ctor_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    enum Option[T] { Some(T), None }
    const A: Option[i32] = Option[i32].Some(7)
    const B: Option[i32] = Option[i32].None
    fn main() -> i32 { let _a: Option[i32] = A; let _b: Option[i32] = B; return 0; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "enum_init"));
}

fn test_irgen_const_generic_enum_ctor_uses_expected_type_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "enum Option[T] { Some(T), None }\nconst A: Option[i32] = Option.Some(7)\nconst B: Option[i32] = Option.None\nfn main() -> i32 { let _a: Option[i32] = A; let _b: Option[i32] = B; return 0; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "enum_init"));
}

fn test_irgen_const_enum_payload_multi_bind_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "enum E { A(i32, i32), B }\nconst X: E = .A(7, 2)\nconst N: i32 = match X { .A(a, b) => a - b, .B => 0 }\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 5"));
}

fn test_irgen_const_enum_ctor_qualified_path_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "enum E { A(i32), B }\nconst X: E = E.A(7)\nfn main() -> i32 { return match X { .A(v) => v, .B => 0 }; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "enum_init"));
  t.assert(contains(s, "7"));
}

fn test_irgen_const_union_match_inlined() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Value = I32: i32 | Str: String\nconst X: Value = Value.I32(7)\nconst N: i32 = match X { .I32(v) => v, .Str(_s) => 0 }\nfn main() -> i32 { return N; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const i32 7"));
}

fn test_irgen_const_struct_equality_folds() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    struct S { a: i32, b: String }
    const X: S = S { a: 1, b: "x" }
    const Y: S = S { a: 1, b: "x" }
    const B: bool = X == Y
    fn main() -> i32 { return if B { 1 } else { 0 }; }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(!contains(s, "cmp_eq struct(main::S)"));
}

fn test_irgen_const_enum_payload_equality_folds() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    enum E { A(i32, String), None }
    const X: E = E.A(7, "x")
    const Y: E = E.A(7, "x")
    const B: bool = X == Y
    fn main() -> i32 { return if B { 1 } else { 0 }; }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(!contains(s, "cmp_eq enum(main::E)"));
}
