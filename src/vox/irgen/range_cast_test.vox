import "std/testing" as t
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_as_range_i32_emits_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) i32\nfn main(x: i32) -> i32 { let y: Tiny = x as Tiny; return y as i32; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "range_check i32 0 3"));
}

fn test_irgen_as_i64_to_range_i32_emits_checked_cast_and_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) i32\nfn main(x: i64) -> i32 { let y: Tiny = x as Tiny; return y as i32; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, " = int_cast_checked i32 i64 "));
  t.assert(contains(s, "range_check i32 0 3"));
}

fn test_irgen_as_range_i8_emits_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) i8\nfn main(x: i8) -> i8 { let y: Tiny = x as Tiny; return y as i8; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "range_check i8 0 3"));
}

fn test_irgen_as_range_u32_emits_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) u32\nfn main(x: u32) -> u32 { let y: Tiny = x as Tiny; return y as u32; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "range_check u32 0 3"));
}

fn test_irgen_as_i64_to_range_u32_emits_checked_cast_and_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) u32\nfn main(x: i64) -> u32 { let y: Tiny = x as Tiny; return y as u32; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, " = int_cast_checked u32 i64 "));
  t.assert(contains(s, "range_check u32 0 3"));
}

fn test_irgen_as_range_u8_emits_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) u8\nfn main(x: u8) -> u8 { let y: Tiny = x as Tiny; return y as u8; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "range_check u8 0 3"));
}

fn test_irgen_as_range_u64_emits_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) u64\nfn main(x: u64) -> u64 { let y: Tiny = x as Tiny; return y as u64; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "range_check u64 0 3"));
}

fn test_irgen_as_range_usize_emits_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) usize\nfn main(x: usize) -> usize { let y: Tiny = x as Tiny; return y as usize; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "range_check usize 0 3"));
}
