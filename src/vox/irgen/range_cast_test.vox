import "std/testing" as t
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_as_range_i32_emits_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) i32\nfn main(x: i32) -> i32 { let y: Tiny = x as Tiny; return y as i32; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "range_check i32 0 3"));
}

fn test_irgen_as_i64_to_range_i32_emits_checked_cast_and_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) i32\nfn main(x: i64) -> i32 { let y: Tiny = x as Tiny; return y as i32; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, " = int_cast_checked i32 i64 "));
  t.assert(contains(s, "range_check i32 0 3"));
}

fn test_irgen_as_range_i8_emits_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) i8\nfn main(x: i8) -> i8 { let y: Tiny = x as Tiny; return y as i8; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "range_check i8 0 3"));
}

fn test_irgen_as_range_u32_emits_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) u32\nfn main(x: u32) -> u32 { let y: Tiny = x as Tiny; return y as u32; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "range_check u32 0 3"));
}

fn test_irgen_as_i64_to_range_u32_emits_checked_cast_and_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) u32\nfn main(x: i64) -> u32 { let y: Tiny = x as Tiny; return y as u32; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, " = int_cast_checked u32 i64 "));
  t.assert(contains(s, "range_check u32 0 3"));
}

fn test_irgen_as_range_u8_emits_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) u8\nfn main(x: u8) -> u8 { let y: Tiny = x as Tiny; return y as u8; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "range_check u8 0 3"));
}

fn test_irgen_as_range_u64_emits_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) u64\nfn main(x: u64) -> u64 { let y: Tiny = x as Tiny; return y as u64; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "range_check u64 0 3"));
}

fn test_irgen_as_range_usize_emits_range_check() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "type Tiny = @range(0..=3) usize\nfn main(x: usize) -> usize { let y: Tiny = x as Tiny; return y as usize; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "range_check usize 0 3"));
}

fn test_irgen_as_verified_i32_emits_predicate_call_and_panic_branch() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn in_small(x: i32) -> bool { return x >= 0 && x <= 3; }\ntype Small = @verified(in_small) i32\nfn main(x: i32) -> i32 { let y: Small = x as Small; return y as i32; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "call bool in_small(") || contains(s, "call bool main::in_small("));
  t.assert(contains(s, "panic \"verified check failed\""));
}

fn test_irgen_as_verified_module_alias_emits_qualified_predicate_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "util", "pub fn nonneg(x: i32) -> bool { return x >= 0; }");
  w = add_mod(w, "main", "import \"util\" as u\ntype NonNeg = @verified(u.nonneg) i32\nfn main(x: i32) -> i32 { let y: NonNeg = x as NonNeg; return y as i32; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "call bool util::nonneg("));
}
