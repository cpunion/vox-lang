import "std/testing" as t
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_nested_field_assign_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "struct I { x: i32 }\nstruct O { i: I }\nfn main() -> i32 { let mut o: O = O { i: I { x: 1 } }; o.i.x = 2; o.i.x += 3; return o.i.x; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "store_field"));
}

fn test_irgen_vec_nested_field_push_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      o.inner.items.push(1);
      o.inner.items.push(2);
      return o.inner.items.len();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_push"));
  t.assert(contains(s, "store_field"));
}

fn test_irgen_vec_nested_field_insert_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      o.inner.items.push(1);
      o.inner.items.insert(0, 9);
      return o.inner.items.get(0);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_insert"));
  t.assert(contains(s, "store_field"));
}

fn test_irgen_vec_push_rejects_immutable_receiver() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      v.push(1);
      return 0;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.push receiver is immutable"));
}

fn test_irgen_vec_insert_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.insert(0, 9);
      return v.get(0);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_insert"));
}

fn test_irgen_vec_set_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.set(0, 9);
      return v.get(0);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_set"));
}

fn test_irgen_vec_is_empty_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      if v.is_empty() { return 1; }
      return 0;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_len"));
  t.assert(contains(s, "cmp_eq i32"));
}

fn test_irgen_vec_clear_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.clear();
      return v.len();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_clear"));
}

fn test_irgen_vec_extend_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let mut a: Vec[i32] = Vec();
      a.push(1);
      let mut b: Vec[i32] = Vec();
      b.push(2);
      a.extend(b);
      return a.len();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_extend"));
}

fn test_irgen_vec_pop_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      return v.pop();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_pop"));
}

fn test_irgen_vec_remove_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.push(2);
      return v.remove(0) + v.len();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_remove"));
}

fn test_irgen_vec_nested_field_clear_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      o.inner.items.push(1);
      o.inner.items.clear();
      return o.inner.items.len();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_clear"));
  t.assert(contains(s, "store_field"));
}

fn test_irgen_vec_nested_field_extend_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      let mut extra: Vec[i32] = Vec();
      extra.push(1);
      o.inner.items.extend(extra);
      return o.inner.items.len();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_extend"));
  t.assert(contains(s, "store_field"));
}

fn test_irgen_vec_nested_field_pop_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      o.inner.items.push(1);
      return o.inner.items.pop();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_pop"));
  t.assert(contains(s, "store_field"));
}

fn test_irgen_vec_nested_field_remove_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      o.inner.items.push(1);
      o.inner.items.push(2);
      return o.inner.items.remove(0);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_remove"));
  t.assert(contains(s, "store_field"));
}

fn test_irgen_vec_nested_field_set_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct Inner { items: Vec[i32] }
    struct Outer { inner: Inner }
    fn main() -> i32 {
      let mut o: Outer = Outer { inner: Inner { items: Vec() } };
      o.inner.items.push(1);
      o.inner.items.set(0, 9);
      return o.inner.items.get(0);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "vec_set"));
  t.assert(contains(s, "store_field"));
}

fn test_irgen_vec_pop_rejects_immutable_receiver() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      return v.pop();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.pop receiver is immutable"));
}

fn test_irgen_vec_remove_rejects_immutable_receiver() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      return v.remove(0);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.remove receiver is immutable"));
}

fn test_irgen_vec_insert_rejects_immutable_receiver() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      v.insert(0, 1);
      return 0;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.insert receiver is immutable"));
}

fn test_irgen_vec_set_rejects_immutable_receiver() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    fn main() -> i32 {
      let v: Vec[i32] = Vec();
      v.set(0, 1);
      return 0;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.set receiver is immutable"));
}

fn test_irgen_nested_field_compound_assign_all_ops_lowers() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct I { x: i32 }
    struct O { i: I }
    fn main() -> i32 {
      let mut o: O = O { i: I { x: 255 } };
      o.i.x += 1;
      o.i.x -= 2;
      o.i.x *= 3;
      o.i.x /= 4;
      o.i.x %= 5;
      o.i.x &= 6;
      o.i.x |= 7;
      o.i.x ^= 8;
      o.i.x <<= 1;
      o.i.x >>= 2;
      return o.i.x;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "store_field"));
}
