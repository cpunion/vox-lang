import "vox/ast" as ast
import "vox/typecheck" as tc
import "vox/async_cfg" as ac

struct SynthResult {
  ok: bool,
  err: String,
  exprs: ast.ExprPool,
  body: ast.Block,
}

fn stmt_span(st: ast.Stmt) -> ast.Span {
  return match st {
    ast.Stmt.Let(sp, _m, _n, _ha, _ann, _e) => sp,
    ast.Stmt.Assign(sp, _n, _e) => sp,
    ast.Stmt.AssignField(sp, _r, _f, _e) => sp,
    ast.Stmt.ExprStmt(sp, _e) => sp,
    ast.Stmt.IfStmt(sp, _c, _t, _h, _e) => sp,
    ast.Stmt.WhileStmt(sp, _c, _b) => sp,
    ast.Stmt.TryBegin(sp, _out) => sp,
    ast.Stmt.TryEnd(sp) => sp,
    ast.Stmt.Break(sp) => sp,
    ast.Stmt.Continue(sp) => sp,
    ast.Stmt.ReturnStmt(sp, _h, _e) => sp,
  };
}

fn add_expr(p0: ast.ExprPool, n: ast.ExprNode, sp: ast.Span) -> ast.AddExprResult {
  return ast.expr_pool_add(p0, n, sp);
}

fn add_ident(p0: ast.ExprPool, sp: ast.Span, name: String) -> ast.AddExprResult {
  return add_expr(p0, ast.ExprNode.Ident(name), sp);
}

fn add_int(p0: ast.ExprPool, sp: ast.Span, text: String) -> ast.AddExprResult {
  return add_expr(p0, ast.ExprNode.Int(text), sp);
}

fn add_bool(p0: ast.ExprPool, sp: ast.Span, v: bool) -> ast.AddExprResult {
  return add_expr(p0, ast.ExprNode.Bool(v), sp);
}

fn add_str(p0: ast.ExprPool, sp: ast.Span, text: String) -> ast.AddExprResult {
  return add_expr(p0, ast.ExprNode.Str(text), sp);
}

fn add_member(p0: ast.ExprPool, sp: ast.Span, recv: i32, field: String) -> ast.AddExprResult {
  return add_expr(p0, ast.ExprNode.Member(recv, field), sp);
}

fn add_binary(p0: ast.ExprPool, sp: ast.Span, op: ast.BinaryOp, a: i32, b: i32) -> ast.AddExprResult {
  return add_expr(p0, ast.ExprNode.Binary(op, a, b), sp);
}

fn add_call(p0: ast.ExprPool, sp: ast.Span, callee: i32, args: Vec[i32]) -> ast.AddExprResult {
  return add_expr(p0, ast.ExprNode.Call(callee, Vec(), args), sp);
}

fn add_dot_call1(p0: ast.ExprPool, sp: ast.Span, name: String, arg0: i32) -> ast.AddExprResult {
  let r0: ast.AddExprResult = add_expr(p0, ast.ExprNode.DotIdent(name), sp);
  let mut as0: Vec[i32] = Vec();
  as0.push(arg0);
  return add_call(r0.pool, sp, r0.id, as0);
}

fn has_return_stmt(ss: Vec[ast.Stmt]) -> bool {
  let mut i: i32 = 0;
  while i < ss.len() {
    if match ss.get(i) { ast.Stmt.ReturnStmt(_sp, _h, _e) => true, _ => false } { return true; }
    i = i + 1;
  }
  return false;
}

fn string_vec_contains(xs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn str_starts_with(s: String, prefix: String) -> bool {
  if s.len() < prefix.len() { return false; }
  let mut i: i32 = 0;
  while i < prefix.len() {
    if s.byte_at(i) != prefix.byte_at(i) { return false; }
    i = i + 1;
  }
  return true;
}

struct RewriteExprResult { ok: bool, err: String, exprs: ast.ExprPool, id: i32 }

fn async_rewrite_expr_capture(p0: ast.ExprPool, frame_var: String, captures: Vec[String], ret_ann: ast.TypeName, eid: i32) -> RewriteExprResult {
  let n: ast.ExprNode = ast.expr_pool_get(p0, eid);
  if match n { ast.ExprNode.Ident(_x) => true, _ => false } {
    let name: String = match n { ast.ExprNode.Ident(x) => x, _ => "" };
    if string_vec_contains(captures, name) {
      let sp: ast.Span = ast.expr_pool_span(p0, eid);
      let r_f: ast.AddExprResult = add_ident(p0, sp, frame_var);
      let r_m: ast.AddExprResult = add_member(r_f.pool, sp, r_f.id, "l_".concat(name));
      return RewriteExprResult { ok: true, err: "", exprs: r_m.pool, id: r_m.id };
    }
    return RewriteExprResult { ok: true, err: "", exprs: p0, id: eid };
  }

  if match n { ast.ExprNode.Int(_v) => true, ast.ExprNode.Float(_v) => true, ast.ExprNode.Bool(_b) => true, ast.ExprNode.Str(_s) => true, ast.ExprNode.DotIdent(_s) => true, _ => false } {
    return RewriteExprResult { ok: true, err: "", exprs: p0, id: eid };
  }

  let sp: ast.Span = ast.expr_pool_span(p0, eid);

  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let op: ast.UnaryOp = match n { ast.ExprNode.Unary(x, _a) => x, _ => ast.UnaryOp.Pos };
    let a: i32 = match n { ast.ExprNode.Unary(_op, x) => x, _ => -1 };
    let ra: RewriteExprResult = async_rewrite_expr_capture(p0, frame_var, captures, ret_ann, a);
    if !ra.ok { return ra; }
    if ra.id == a { return RewriteExprResult { ok: true, err: "", exprs: ra.exprs, id: eid }; }
    let r: ast.AddExprResult = add_expr(ra.exprs, ast.ExprNode.Unary(op, ra.id), sp);
    return RewriteExprResult { ok: true, err: "", exprs: r.pool, id: r.id };
  }

  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(x, _tn) => x, _ => -1 };
    let tn: ast.TypeName = match n { ast.ExprNode.As(_a, x) => x, _ => ast.TypeName { parts: Vec(), args: Vec() } };
    let ra: RewriteExprResult = async_rewrite_expr_capture(p0, frame_var, captures, ret_ann, a);
    if !ra.ok { return ra; }
    if ra.id == a { return RewriteExprResult { ok: true, err: "", exprs: ra.exprs, id: eid }; }
    let r: ast.AddExprResult = add_expr(ra.exprs, ast.ExprNode.As(ra.id, tn), sp);
    return RewriteExprResult { ok: true, err: "", exprs: r.pool, id: r.id };
  }

  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let op: ast.BinaryOp = match n { ast.ExprNode.Binary(x, _l, _r) => x, _ => ast.BinaryOp.Add };
    let l: i32 = match n { ast.ExprNode.Binary(_op, x, _r) => x, _ => -1 };
    let r0: i32 = match n { ast.ExprNode.Binary(_op, _l, x) => x, _ => -1 };
    let rl: RewriteExprResult = async_rewrite_expr_capture(p0, frame_var, captures, ret_ann, l);
    if !rl.ok { return rl; }
    let rr: RewriteExprResult = async_rewrite_expr_capture(rl.exprs, frame_var, captures, ret_ann, r0);
    if !rr.ok { return rr; }
    if rl.id == l && rr.id == r0 { return RewriteExprResult { ok: true, err: "", exprs: rr.exprs, id: eid }; }
    let r1: ast.AddExprResult = add_expr(rr.exprs, ast.ExprNode.Binary(op, rl.id, rr.id), sp);
    return RewriteExprResult { ok: true, err: "", exprs: r1.pool, id: r1.id };
  }

  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } {
    let c: i32 = match n { ast.ExprNode.If(x, _t, _e) => x, _ => -1 };
    let t: i32 = match n { ast.ExprNode.If(_c, x, _e) => x, _ => -1 };
    let e: i32 = match n { ast.ExprNode.If(_c, _t, x) => x, _ => -1 };
    let rc: RewriteExprResult = async_rewrite_expr_capture(p0, frame_var, captures, ret_ann, c);
    if !rc.ok { return rc; }
    let rt: RewriteExprResult = async_rewrite_expr_capture(rc.exprs, frame_var, captures, ret_ann, t);
    if !rt.ok { return rt; }
    let re: RewriteExprResult = async_rewrite_expr_capture(rt.exprs, frame_var, captures, ret_ann, e);
    if !re.ok { return re; }
    if rc.id == c && rt.id == t && re.id == e { return RewriteExprResult { ok: true, err: "", exprs: re.exprs, id: eid }; }
    let r1: ast.AddExprResult = add_expr(re.exprs, ast.ExprNode.If(rc.id, rt.id, re.id), sp);
    return RewriteExprResult { ok: true, err: "", exprs: r1.pool, id: r1.id };
  }

  if match n { ast.ExprNode.Member(_r, _f) => true, _ => false } {
    let rcv: i32 = match n { ast.ExprNode.Member(x, _f) => x, _ => -1 };
    let f: String = match n { ast.ExprNode.Member(_r, x) => x, _ => "" };
    let rr: RewriteExprResult = async_rewrite_expr_capture(p0, frame_var, captures, ret_ann, rcv);
    if !rr.ok { return rr; }
    if rr.id == rcv { return RewriteExprResult { ok: true, err: "", exprs: rr.exprs, id: eid }; }
    let r1: ast.AddExprResult = add_expr(rr.exprs, ast.ExprNode.Member(rr.id, f), sp);
    return RewriteExprResult { ok: true, err: "", exprs: r1.pool, id: r1.id };
  }

  if match n { ast.ExprNode.Call(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(x, _t, _a) => x, _ => -1 };
    let targs: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_c, x, _a) => x, _ => Vec() };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _t, x) => x, _ => Vec() };
    let rc: RewriteExprResult = async_rewrite_expr_capture(p0, frame_var, captures, ret_ann, callee);
    if !rc.ok { return rc; }
    let mut out_args: Vec[i32] = Vec();
    let mut changed: bool = rc.id != callee;
    let mut i: i32 = 0;
    let mut p: ast.ExprPool = rc.exprs;
    while i < args.len() {
      let ri: RewriteExprResult = async_rewrite_expr_capture(p, frame_var, captures, ret_ann, args.get(i));
      if !ri.ok { return ri; }
      p = ri.exprs;
      out_args.push(ri.id);
      if ri.id != args.get(i) { changed = true; }
      i = i + 1;
    }
    if !changed { return RewriteExprResult { ok: true, err: "", exprs: p, id: eid }; }
    let r1: ast.AddExprResult = add_expr(p, ast.ExprNode.Call(rc.id, targs, out_args), sp);
    return RewriteExprResult { ok: true, err: "", exprs: r1.pool, id: r1.id };
  }

  if match n { ast.ExprNode.StructLit(_t, _fs) => true, _ => false } {
    let ty_expr: i32 = match n { ast.ExprNode.StructLit(x, _fs) => x, _ => -1 };
    let fs: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_t, x) => x, _ => Vec() };
    let rt: RewriteExprResult = async_rewrite_expr_capture(p0, frame_var, captures, ret_ann, ty_expr);
    if !rt.ok { return rt; }
    let mut p: ast.ExprPool = rt.exprs;
    let mut out_fs: Vec[ast.StructLitField] = Vec();
    let mut changed: bool = rt.id != ty_expr;
    let mut i: i32 = 0;
    while i < fs.len() {
      let f0: ast.StructLitField = fs.get(i);
      let re: RewriteExprResult = async_rewrite_expr_capture(p, frame_var, captures, ret_ann, f0.expr);
      if !re.ok { return re; }
      p = re.exprs;
      out_fs.push(ast.StructLitField { name: f0.name, expr: re.id });
      if re.id != f0.expr { changed = true; }
      i = i + 1;
    }
    if !changed { return RewriteExprResult { ok: true, err: "", exprs: p, id: eid }; }
    let r1: ast.AddExprResult = add_expr(p, ast.ExprNode.StructLit(rt.id, out_fs), sp);
    return RewriteExprResult { ok: true, err: "", exprs: r1.pool, id: r1.id };
  }

  if match n { ast.ExprNode.Match(_s, _as) => true, _ => false } {
    let scrut: i32 = match n { ast.ExprNode.Match(x, _as) => x, _ => -1 };
    let arms: Vec[ast.MatchArm] = match n { ast.ExprNode.Match(_s, x) => x, _ => Vec() };
    let rs: RewriteExprResult = async_rewrite_expr_capture(p0, frame_var, captures, ret_ann, scrut);
    if !rs.ok { return rs; }
    let mut p: ast.ExprPool = rs.exprs;
    let mut out_arms: Vec[ast.MatchArm] = Vec();
    let mut changed: bool = rs.id != scrut;
    let mut i: i32 = 0;
    while i < arms.len() {
      let a0: ast.MatchArm = arms.get(i);
      let re: RewriteExprResult = async_rewrite_expr_capture(p, frame_var, captures, ret_ann, a0.expr);
      if !re.ok { return re; }
      p = re.exprs;
      out_arms.push(ast.MatchArm { pat: a0.pat, expr: re.id });
      if re.id != a0.expr { changed = true; }
      i = i + 1;
    }
    if !changed { return RewriteExprResult { ok: true, err: "", exprs: p, id: eid }; }
    let r1: ast.AddExprResult = add_expr(p, ast.ExprNode.Match(rs.id, out_arms), sp);
    return RewriteExprResult { ok: true, err: "", exprs: r1.pool, id: r1.id };
  }

  if match n { ast.ExprNode.Try(x) => true, _ => false } {
    let x: i32 = match n { ast.ExprNode.Try(y) => y, _ => -1 };
    let rx: RewriteExprResult = async_rewrite_expr_capture(p0, frame_var, captures, ret_ann, x);
    if !rx.ok { return rx; }
    if rx.id == x { return RewriteExprResult { ok: true, err: "", exprs: rx.exprs, id: eid }; }
    let r1: ast.AddExprResult = add_expr(rx.exprs, ast.ExprNode.Try(rx.id), sp);
    return RewriteExprResult { ok: true, err: "", exprs: r1.pool, id: r1.id };
  }
  if match n { ast.ExprNode.Await(x) => true, _ => false } {
    let x: i32 = match n { ast.ExprNode.Await(y) => y, _ => -1 };
    let rx: RewriteExprResult = async_rewrite_expr_capture(p0, frame_var, captures, ret_ann, x);
    if !rx.ok { return rx; }
    if rx.id == x { return RewriteExprResult { ok: true, err: "", exprs: rx.exprs, id: eid }; }
    let r1: ast.AddExprResult = add_expr(rx.exprs, ast.ExprNode.Await(rx.id), sp);
    return RewriteExprResult { ok: true, err: "", exprs: r1.pool, id: r1.id };
  }
  if match n { ast.ExprNode.TryBlock(x) => true, _ => false } {
    let x: i32 = match n { ast.ExprNode.TryBlock(y) => y, _ => -1 };
    let rx: RewriteExprResult = async_rewrite_expr_capture(p0, frame_var, captures, ret_ann, x);
    if !rx.ok { return rx; }
    if rx.id == x { return RewriteExprResult { ok: true, err: "", exprs: rx.exprs, id: eid }; }
    let r1: ast.AddExprResult = add_expr(rx.exprs, ast.ExprNode.TryBlock(rx.id), sp);
    return RewriteExprResult { ok: true, err: "", exprs: r1.pool, id: r1.id };
  }

  // D03: keep this conservative; treat block expr as a container for stmt rewriting.
  if match n { ast.ExprNode.Block(_b) => true, _ => false } {
    let b0: ast.ExprBlock = match n { ast.ExprNode.Block(x) => x, _ => ast.ExprBlock { stmts: Vec(), has_tail: false, tail: -1 } };
    let rr: SynthResult = async_rewrite_stmt_list(p0, frame_var, captures, ret_ann, b0.stmts);
    if !rr.ok { return RewriteExprResult { ok: false, err: rr.err, exprs: rr.exprs, id: -1 }; }
    let mut p: ast.ExprPool = rr.exprs;
    let mut tail_id: i32 = b0.tail;
    if b0.has_tail && b0.tail != -1 {
      let rt: RewriteExprResult = async_rewrite_expr_capture(p, frame_var, captures, ret_ann, b0.tail);
      if !rt.ok { return rt; }
      p = rt.exprs;
      tail_id = rt.id;
    }
    let b1: ast.ExprBlock = ast.ExprBlock { stmts: rr.body.stmts, has_tail: b0.has_tail, tail: tail_id };
    let r1: ast.AddExprResult = add_expr(p, ast.ExprNode.Block(b1), sp);
    return RewriteExprResult { ok: true, err: "", exprs: r1.pool, id: r1.id };
  }

  return RewriteExprResult { ok: false, err: "internal: async capture rewrite missing expr case", exprs: p0, id: -1 };
}

fn async_rewrite_stmt_list(p0: ast.ExprPool, frame_var: String, captures: Vec[String], ret_ann: ast.TypeName, ss: Vec[ast.Stmt]) -> SynthResult {
  let mut p: ast.ExprPool = p0;
  let mut out: Vec[ast.Stmt] = Vec();
  let mut i: i32 = 0;
  while i < ss.len() {
    let st: ast.Stmt = ss.get(i);
    if match st { ast.Stmt.IfStmt(_sp, _cond, _then_b, _has_else, _else_b) => true, _ => false } {
      let sp: ast.Span = match st { ast.Stmt.IfStmt(x, _c, _t, _h, _e) => x, _ => ast.span0() };
      let cond: i32 = match st { ast.Stmt.IfStmt(_sp, c, _t, _h, _e) => c, _ => -1 };
      let then_b: ast.Block = match st { ast.Stmt.IfStmt(_sp, _c, t, _h, _e) => t, _ => ast.Block { stmts: Vec() } };
      let has_else: bool = match st { ast.Stmt.IfStmt(_sp, _c, _t, h, _e) => h, _ => false };
      let else_b: ast.Block = match st { ast.Stmt.IfStmt(_sp, _c, _t, _h, e) => e, _ => ast.Block { stmts: Vec() } };

      let rc: RewriteExprResult = async_rewrite_expr_capture(p, frame_var, captures, ret_ann, cond);
      if !rc.ok { return SynthResult { ok: false, err: rc.err, exprs: rc.exprs, body: ast.Block { stmts: Vec() } }; }
      p = rc.exprs;
      let r_then: SynthResult = async_rewrite_stmt_list(p, frame_var, captures, ret_ann, then_b.stmts);
      if !r_then.ok { return r_then; }
      p = r_then.exprs;
      let r_else: SynthResult =
        if has_else { async_rewrite_stmt_list(p, frame_var, captures, ret_ann, else_b.stmts) }
        else { SynthResult { ok: true, err: "", exprs: p, body: ast.Block { stmts: Vec() } } };
      if !r_else.ok { return r_else; }
      p = r_else.exprs;
      out.push(ast.Stmt.IfStmt(sp, rc.id, ast.Block { stmts: r_then.body.stmts }, has_else, ast.Block { stmts: r_else.body.stmts }));
    } else if match st { ast.Stmt.WhileStmt(_sp, _cond, _body) => true, _ => false } {
      let sp: ast.Span = match st { ast.Stmt.WhileStmt(x, _c, _b) => x, _ => ast.span0() };
      let cond: i32 = match st { ast.Stmt.WhileStmt(_sp, c, _b) => c, _ => -1 };
      let body: ast.Block = match st { ast.Stmt.WhileStmt(_sp, _c, b) => b, _ => ast.Block { stmts: Vec() } };
      let rc: RewriteExprResult = async_rewrite_expr_capture(p, frame_var, captures, ret_ann, cond);
      if !rc.ok { return SynthResult { ok: false, err: rc.err, exprs: rc.exprs, body: ast.Block { stmts: Vec() } }; }
      p = rc.exprs;
      let r_body: SynthResult = async_rewrite_stmt_list(p, frame_var, captures, ret_ann, body.stmts);
      if !r_body.ok { return r_body; }
      p = r_body.exprs;
      out.push(ast.Stmt.WhileStmt(sp, rc.id, ast.Block { stmts: r_body.body.stmts }));
    } else if match st { ast.Stmt.ReturnStmt(_sp, _has, _eid) => true, _ => false } {
      let sp: ast.Span = match st { ast.Stmt.ReturnStmt(x, _h, _e) => x, _ => ast.span0() };
      let has: bool = match st { ast.Stmt.ReturnStmt(_sp, h, _e) => h, _ => false };
      let eid: i32 = match st { ast.Stmt.ReturnStmt(_sp, _h, e) => e, _ => -1 };

      // Evaluate expression first (may suspend/return Pending), then mark done and return Ready.
      let mut rhs_id: i32 = eid;
      if !has {
        let r0: ast.AddExprResult = add_expr(
          p,
          ast.ExprNode.Block(ast.ExprBlock { stmts: Vec(), has_tail: false, tail: -1 }),
          sp,
        );
        p = r0.pool;
        rhs_id = r0.id;
      } else {
        let rr: RewriteExprResult = async_rewrite_expr_capture(p, frame_var, captures, ret_ann, rhs_id);
        if !rr.ok { return SynthResult { ok: false, err: rr.err, exprs: rr.exprs, body: ast.Block { stmts: Vec() } }; }
        p = rr.exprs;
        rhs_id = rr.id;
      }

      let tmp_name: String = "__async$ret$".concat(i.to_string());
      // Keep return expression type context so `.Ok(...)` style constructors remain inferrable.
      out.push(ast.Stmt.Let(sp, false, tmp_name, true, ret_ann, rhs_id));
      let r_tmp: ast.AddExprResult = add_ident(p, sp, tmp_name);
      p = r_tmp.pool;
      let r_ready: ast.AddExprResult = add_dot_call1(p, sp, "Ready", r_tmp.id);
      p = r_ready.pool;

      let r_zero2: ast.AddExprResult = add_int(p, sp, "0");
      p = r_zero2.pool;
      let r_one2: ast.AddExprResult = add_int(p, sp, "1");
      p = r_one2.pool;
      let r_done: ast.AddExprResult = add_binary(p, sp, ast.BinaryOp.Sub, r_zero2.id, r_one2.id);
      p = r_done.pool;
      out.push(ast.Stmt.AssignField(sp, frame_var, "state", r_done.id));
      out.push(ast.Stmt.ReturnStmt(sp, true, r_ready.id));
    } else if match st { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, _e) => true, _ => false } {
      let sp: ast.Span = match st { ast.Stmt.Let(x, _m, _n, _ha, _ann, _e) => x, _ => ast.span0() };
      let is_mut: bool = match st { ast.Stmt.Let(_sp, m0, _n, _ha, _ann, _e) => m0, _ => false };
      let name0: String = match st { ast.Stmt.Let(_sp, _m, n0, _ha, _ann, _e) => n0, _ => "" };
      let has_ann: bool = match st { ast.Stmt.Let(_sp, _m, _n, ha0, _ann, _e) => ha0, _ => false };
      let ann0: ast.TypeName = match st { ast.Stmt.Let(_sp, _m, _n, _ha, an0, _e) => an0, _ => ast.TypeName { parts: Vec(), args: Vec() } };
      let e0: i32 = match st { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, e0) => e0, _ => -1 };
      let re: RewriteExprResult = async_rewrite_expr_capture(p, frame_var, captures, ret_ann, e0);
      if !re.ok { return SynthResult { ok: false, err: re.err, exprs: re.exprs, body: ast.Block { stmts: Vec() } }; }
      p = re.exprs;
      out.push(ast.Stmt.Let(sp, is_mut, name0, has_ann, ann0, re.id));
    } else if match st { ast.Stmt.Assign(_sp, _n, _e) => true, _ => false } {
      let sp: ast.Span = match st { ast.Stmt.Assign(x, _n, _e) => x, _ => ast.span0() };
      let name0: String = match st { ast.Stmt.Assign(_sp, n0, _e) => n0, _ => "" };
      let e0: i32 = match st { ast.Stmt.Assign(_sp, _n, e0) => e0, _ => -1 };
      let re: RewriteExprResult = async_rewrite_expr_capture(p, frame_var, captures, ret_ann, e0);
      if !re.ok { return SynthResult { ok: false, err: re.err, exprs: re.exprs, body: ast.Block { stmts: Vec() } }; }
      p = re.exprs;
      if string_vec_contains(captures, name0) {
        out.push(ast.Stmt.AssignField(sp, frame_var, "l_".concat(name0), re.id));
      } else {
        out.push(ast.Stmt.Assign(sp, name0, re.id));
      }
    } else if match st { ast.Stmt.AssignField(_sp, _r, _f, _e) => true, _ => false } {
      let sp: ast.Span = match st { ast.Stmt.AssignField(x, _r, _f, _e) => x, _ => ast.span0() };
      let recv: String = match st { ast.Stmt.AssignField(_sp, r0, _f, _e) => r0, _ => "" };
      let f: String = match st { ast.Stmt.AssignField(_sp, _r, f0, _e) => f0, _ => "" };
      let e0: i32 = match st { ast.Stmt.AssignField(_sp, _r, _f, e0) => e0, _ => -1 };
      let re: RewriteExprResult = async_rewrite_expr_capture(p, frame_var, captures, ret_ann, e0);
      if !re.ok { return SynthResult { ok: false, err: re.err, exprs: re.exprs, body: ast.Block { stmts: Vec() } }; }
      p = re.exprs;
      out.push(ast.Stmt.AssignField(sp, recv, f, re.id));
    } else if match st { ast.Stmt.ExprStmt(_sp, _e) => true, _ => false } {
      let sp: ast.Span = match st { ast.Stmt.ExprStmt(x, _e) => x, _ => ast.span0() };
      let e0: i32 = match st { ast.Stmt.ExprStmt(_sp, e0) => e0, _ => -1 };
      let re: RewriteExprResult = async_rewrite_expr_capture(p, frame_var, captures, ret_ann, e0);
      if !re.ok { return SynthResult { ok: false, err: re.err, exprs: re.exprs, body: ast.Block { stmts: Vec() } }; }
      p = re.exprs;
      out.push(ast.Stmt.ExprStmt(sp, re.id));
    } else {
      out.push(st);
    }
    i = i + 1;
  }
  return SynthResult { ok: true, err: "", exprs: p, body: ast.Block { stmts: out } };
}

fn synth_async_ctor_body(exprs0: ast.ExprPool, fd: ast.FuncDecl, frame_name: String) -> SynthResult {
  let mut p: ast.ExprPool = exprs0;
  let sp: ast.Span = fd.sp;

  let r_ty: ast.AddExprResult = add_ident(p, sp, frame_name);
  p = r_ty.pool;
  let ty_eid: i32 = r_ty.id;

  let r_state: ast.AddExprResult = add_int(p, sp, "0");
  p = r_state.pool;

  let mut fs: Vec[ast.StructLitField] = Vec();
  fs.push(ast.StructLitField { name: "state", expr: r_state.id });

  let mut i: i32 = 0;
  while i < fd.params.len() {
    let prm: ast.Param = fd.params.get(i);
    let r_id: ast.AddExprResult = add_ident(p, sp, prm.name);
    p = r_id.pool;
    fs.push(ast.StructLitField { name: "p_".concat(prm.name), expr: r_id.id });
    i = i + 1;
  }

  let r_lit: ast.AddExprResult = add_expr(p, ast.ExprNode.StructLit(ty_eid, fs), sp);
  p = r_lit.pool;

  let mut ss: Vec[ast.Stmt] = Vec();
  ss.push(ast.Stmt.ReturnStmt(sp, true, r_lit.id));
  return SynthResult { ok: true, err: "", exprs: p, body: ast.Block { stmts: ss } };
}

struct AwaitPoint { stmt_idx: i32, operand: i32, is_try: bool }

fn stmt_expr_id(st: ast.Stmt) -> i32 {
  if match st { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, _e) => true, _ => false } {
    return match st { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, e) => e, _ => -1 };
  }
  if match st { ast.Stmt.ExprStmt(_sp, _e) => true, _ => false } {
    return match st { ast.Stmt.ExprStmt(_sp, e) => e, _ => -1 };
  }
  if match st { ast.Stmt.ReturnStmt(_sp, h, _e) => true, _ => false } {
    let has0: bool = match st { ast.Stmt.ReturnStmt(_sp, h, _e) => h, _ => false };
    if has0 { return match st { ast.Stmt.ReturnStmt(_sp, _h, e) => e, _ => -1 }; }
  }
  return -1;
}

fn find_await_points(exprs: ast.ExprPool, ss: Vec[ast.Stmt]) -> Vec[AwaitPoint] {
  let mut out: Vec[AwaitPoint] = Vec();
  let mut i: i32 = 0;
  while i < ss.len() {
    let st: ast.Stmt = ss.get(i);
    let eid: i32 = stmt_expr_id(st);
    if eid != -1 {
      let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);
      if match n { ast.ExprNode.Await(_x) => true, _ => false } {
        out.push(AwaitPoint { stmt_idx: i, operand: match n { ast.ExprNode.Await(x) => x, _ => -1 }, is_try: false });
      } else if match n { ast.ExprNode.Try(_x) => true, _ => false } {
        let x: i32 = match n { ast.ExprNode.Try(y) => y, _ => -1 };
        let nx: ast.ExprNode = ast.expr_pool_get(exprs, x);
        if match nx { ast.ExprNode.Await(_y) => true, _ => false } {
          out.push(AwaitPoint { stmt_idx: i, operand: match nx { ast.ExprNode.Await(y) => y, _ => -1 }, is_try: true });
        }
      }
    }
    i = i + 1;
  }
  return out;
}

fn inject_capture_stores(p0: ast.ExprPool, frame_var: String, captures: Vec[String], ss0: Vec[ast.Stmt]) -> SynthResult {
  let mut p: ast.ExprPool = p0;
  let mut out: Vec[ast.Stmt] = Vec();
  let mut i: i32 = 0;
  while i < ss0.len() {
    let st: ast.Stmt = ss0.get(i);
    out.push(st);
    if match st { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, _e) => true, _ => false } {
      let sp: ast.Span = stmt_span(st);
      let name0: String = match st { ast.Stmt.Let(_sp, _m, n0, _ha, _ann, _e) => n0, _ => "" };
      if string_vec_contains(captures, name0) {
        let r_id: ast.AddExprResult = add_ident(p, sp, name0);
        p = r_id.pool;
        out.push(ast.Stmt.AssignField(sp, frame_var, "l_".concat(name0), r_id.id));
      }
    }
    i = i + 1;
  }
  return SynthResult { ok: true, err: "", exprs: p, body: ast.Block { stmts: out } };
}

fn synth_async_poll_body(
  ctx: tc.Ctx,
  w: tc.World,
  mod_path: String,
  imps: tc.Imports,
  exprs0: ast.ExprPool,
  fd: ast.FuncDecl,
  frame_var: String,
  frame_name: String,
  allow_fallthrough_return: bool,
) -> SynthResult {
  let mut p: ast.ExprPool = exprs0;
  let sp: ast.Span = fd.sp;

  // if x.state < 0 { panic("polled after ready"); }
  let r_x: ast.AddExprResult = add_ident(p, sp, frame_var);
  p = r_x.pool;
  let r_state: ast.AddExprResult = add_member(p, sp, r_x.id, "state");
  p = r_state.pool;
  let r_zero: ast.AddExprResult = add_int(p, sp, "0");
  p = r_zero.pool;
  let r_cond: ast.AddExprResult = add_binary(p, sp, ast.BinaryOp.Lt, r_state.id, r_zero.id);
  p = r_cond.pool;
  let r_panic: ast.AddExprResult = add_ident(p, sp, "panic");
  p = r_panic.pool;
  let r_msg: ast.AddExprResult = add_str(p, sp, "polled after ready");
  p = r_msg.pool;
  let mut pargs: Vec[i32] = Vec();
  pargs.push(r_msg.id);
  let r_call: ast.AddExprResult = add_call(p, sp, r_panic.id, pargs);
  p = r_call.pool;
  let mut then_ss: Vec[ast.Stmt] = Vec();
  then_ss.push(ast.Stmt.ExprStmt(sp, r_call.id));
  let guard: ast.Stmt = ast.Stmt.IfStmt(sp, r_cond.id, ast.Block { stmts: then_ss }, false, ast.Block { stmts: Vec() });

  // Bind original params from frame fields: let p = x.p_p;
  let mut pre: Vec[ast.Stmt] = Vec();
  pre.push(guard);
  let mut i: i32 = 0;
  while i < fd.params.len() {
    let prm: ast.Param = fd.params.get(i);
    let r_x2: ast.AddExprResult = add_ident(p, sp, frame_var);
    p = r_x2.pool;
    let r_m: ast.AddExprResult = add_member(p, sp, r_x2.id, "p_".concat(prm.name));
    p = r_m.pool;
    pre.push(ast.Stmt.Let(sp, false, prm.name, false, ast.TypeName { parts: Vec(), args: Vec() }, r_m.id));
    i = i + 1;
  }

  // Captured locals are stored in frame fields `l_<name>`.
  let mut captures: Vec[String] = Vec();
  let fr: tc.FindStructResult = tc.find_struct(ctx, mod_path, frame_name);
  if fr.found {
    let mut fi: i32 = 0;
    while fi < fr.sig.fields.len() {
      let f: tc.StructFieldSig = fr.sig.fields.get(fi);
      if str_starts_with(f.name, "l_") {
        captures.push(f.name.slice(2, f.name.len()));
      }
      fi = fi + 1;
    }
  }

  // Normalize: lift nested awaits into standalone statements so await points are discoverable
  // by the simple statement-level state machine builder.
  let mut l_norm: tc.Locals = tc.locals_new();
  l_norm.fn_is_async = true;
  let af: tc.FindAsyncFnResult = tc.find_async_fn(ctx, mod_path, fd.name);
  if af.found { l_norm.fn_ret_ty = af.sig.output_ty; }
  let ff: tc.FindFuncResult = tc.find_func(ctx, mod_path, fd.name);
  if ff.found {
    l_norm.type_params = ff.sig.type_params;
    l_norm.type_param_bounds = ff.sig.type_param_bounds;
    let mut pi: i32 = 0;
    while pi < fd.params.len() && pi < ff.sig.params.len() {
      l_norm = tc.locals_decl(l_norm, fd.params.get(pi).name, tc.strip_range(ctx, ff.sig.params.get(pi)), false);
      pi = pi + 1;
    }
  }
  let nr: tc.NormalizeResult = tc.normalize_async_block(ctx, w, mod_path, imps, p, fd.body, l_norm);
  if !nr.ok {
    return SynthResult { ok: false, err: nr.err, exprs: nr.exprs, body: ast.Block { stmts: Vec() } };
  }
  p = nr.exprs;
  let body0: ast.Block = nr.body;

  let cfg: ac.BuildResult = ac.build(p, body0, allow_fallthrough_return);
  if !cfg.ok {
    return SynthResult { ok: false, err: cfg.err, exprs: p, body: ast.Block { stmts: Vec() } };
  }

  let r_true: ast.AddExprResult = add_bool(p, sp, true);
  p = r_true.pool;
  let mut loop_body: Vec[ast.Stmt] = Vec();

  let mut bi: i32 = 0;
  while bi < cfg.blocks.len() {
    let blk: ac.Block = cfg.blocks.get(bi);

    // if __frame.state == <id> { ... }
    let r_fx0: ast.AddExprResult = add_ident(p, sp, frame_var);
    p = r_fx0.pool;
    let r_state0: ast.AddExprResult = add_member(p, sp, r_fx0.id, "state");
    p = r_state0.pool;
    let r_k: ast.AddExprResult = add_int(p, sp, blk.id.to_string());
    p = r_k.pool;
    let r_eq: ast.AddExprResult = add_binary(p, sp, ast.BinaryOp.Eq, r_state0.id, r_k.id);
    p = r_eq.pool;

    let mut raw: Vec[ast.Stmt] = Vec();

    // Block body.
    let mut si: i32 = 0;
    while si < blk.stmts.len() { raw.push(blk.stmts.get(si)); si = si + 1; }

    // Payload lowering.
    if match blk.payload { ac.Payload.AwaitInit(_k, _op, _poll) => true, _ => false } {
      let await_idx: i32 = match blk.payload { ac.Payload.AwaitInit(k0, _op0, _p0) => k0, _ => -1 };
      let operand: i32 = match blk.payload { ac.Payload.AwaitInit(_k0, op0, _p0) => op0, _ => -1 };
      raw.push(ast.Stmt.AssignField(sp, frame_var, "a".concat(await_idx.to_string()), operand));
    } else if match blk.payload { ac.Payload.AwaitPoll(_k, _st, _is_try, _n, _h) => true, _ => false } {
      let await_idx: i32 = match blk.payload { ac.Payload.AwaitPoll(k0, _st0, _t0, _n0, _h0) => k0, _ => -1 };
      let st0: ast.Stmt = match blk.payload { ac.Payload.AwaitPoll(_k0, s0, _t0, _n0, _h0) => s0, _ => ast.Stmt.Break(sp) };
      let is_try: bool = match blk.payload { ac.Payload.AwaitPoll(_k0, _s0, t0, _n0, _h0) => t0, _ => false };
      let sp1: ast.Span = stmt_span(st0);

      let r_fx: ast.AddExprResult = add_ident(p, sp1, frame_var);
      p = r_fx.pool;
      let r_a: ast.AddExprResult = add_member(p, sp1, r_fx.id, "a".concat(await_idx.to_string()));
      p = r_a.pool;
      let r_aw: ast.AddExprResult = add_expr(p, ast.ExprNode.Await(r_a.id), sp1);
      p = r_aw.pool;
      let new_eid: i32 =
        if is_try {
          let r_tr: ast.AddExprResult = add_expr(p, ast.ExprNode.Try(r_aw.id), sp1);
          p = r_tr.pool;
          r_tr.id
        } else { r_aw.id };

      let mut await_stmt: ast.Stmt = st0;
      if match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, _e) => true, _ => false } {
        let is_mut: bool = match st0 { ast.Stmt.Let(_sp, m0, _n, _ha, _ann, _e) => m0, _ => false };
        let name0: String = match st0 { ast.Stmt.Let(_sp, _m, n0, _ha, _ann, _e) => n0, _ => "" };
        let has_ann: bool = match st0 { ast.Stmt.Let(_sp, _m, _n, ha0, _ann, _e) => ha0, _ => false };
        let ann0: ast.TypeName = match st0 { ast.Stmt.Let(_sp, _m, _n, _ha, an0, _e) => an0, _ => ast.TypeName { parts: Vec(), args: Vec() } };
        await_stmt = ast.Stmt.Let(sp1, is_mut, name0, has_ann, ann0, new_eid);
      } else if match st0 { ast.Stmt.ExprStmt(_sp, _e) => true, _ => false } {
        await_stmt = ast.Stmt.ExprStmt(sp1, new_eid);
      } else if match st0 { ast.Stmt.ReturnStmt(_sp, h0, _e) => true, _ => false } {
        let has0: bool = match st0 { ast.Stmt.ReturnStmt(_sp, h0, _e) => h0, _ => false };
        await_stmt = ast.Stmt.ReturnStmt(sp1, has0, new_eid);
      }
      raw.push(await_stmt);
    }

    // Term lowering.
    if match blk.term { ac.Term.Goto(_t) => true, _ => false } {
      let tgt: i32 = match blk.term { ac.Term.Goto(t0) => t0, _ => -1 };
      let r_t: ast.AddExprResult = add_int(p, sp, tgt.to_string());
      p = r_t.pool;
      raw.push(ast.Stmt.AssignField(sp, frame_var, "state", r_t.id));
      raw.push(ast.Stmt.Continue(sp));
    } else if match blk.term { ac.Term.If(_c, _t, _e) => true, _ => false } {
      let cond: i32 = match blk.term { ac.Term.If(c0, _t0, _e0) => c0, _ => -1 };
      let then_id: i32 = match blk.term { ac.Term.If(_c0, t0, _e0) => t0, _ => -1 };
      let else_id: i32 = match blk.term { ac.Term.If(_c0, _t0, e0) => e0, _ => -1 };

      let r_t1: ast.AddExprResult = add_int(p, sp, then_id.to_string());
      p = r_t1.pool;
      let r_t2: ast.AddExprResult = add_int(p, sp, else_id.to_string());
      p = r_t2.pool;
      let mut then_ss: Vec[ast.Stmt] = Vec();
      then_ss.push(ast.Stmt.AssignField(sp, frame_var, "state", r_t1.id));
      then_ss.push(ast.Stmt.Continue(sp));
      let mut else_ss: Vec[ast.Stmt] = Vec();
      else_ss.push(ast.Stmt.AssignField(sp, frame_var, "state", r_t2.id));
      else_ss.push(ast.Stmt.Continue(sp));
      raw.push(ast.Stmt.IfStmt(sp, cond, ast.Block { stmts: then_ss }, true, ast.Block { stmts: else_ss }));
    } else if match blk.term { ac.Term.Panic => true, _ => false } {
      let r_panic2: ast.AddExprResult = add_ident(p, sp, "panic");
      p = r_panic2.pool;
      let r_msg2: ast.AddExprResult = add_str(p, sp, "unreachable async state");
      p = r_msg2.pool;
      let mut pargs2: Vec[i32] = Vec();
      pargs2.push(r_msg2.id);
      let r_call2: ast.AddExprResult = add_call(p, sp, r_panic2.id, pargs2);
      p = r_call2.pool;
      raw.push(ast.Stmt.ExprStmt(sp, r_call2.id));
      raw.push(ast.Stmt.Continue(sp));
    } else {
      // Return: usually the return statement is part of raw stmts (normal return, or await poll return).
      // For unit async fns, fallthrough may become Term.Return with no explicit return stmt.
      if allow_fallthrough_return && !has_return_stmt(raw) {
        raw.push(ast.Stmt.ReturnStmt(sp, false, -1));
      }
    }

    let r_body: SynthResult = async_rewrite_stmt_list(p, frame_var, captures, fd.ret, raw);
    if !r_body.ok { return r_body; }
    p = r_body.exprs;
    let r_caps: SynthResult = inject_capture_stores(p, frame_var, captures, r_body.body.stmts);
    if !r_caps.ok { return r_caps; }
    p = r_caps.exprs;
    loop_body.push(ast.Stmt.IfStmt(sp, r_eq.id, ast.Block { stmts: r_caps.body.stmts }, false, ast.Block { stmts: Vec() }));

    bi = bi + 1;
  }

  // invalid state => panic
  let r_panic2: ast.AddExprResult = add_ident(p, sp, "panic");
  p = r_panic2.pool;
  let r_msg2: ast.AddExprResult = add_str(p, sp, "invalid async state");
  p = r_msg2.pool;
  let mut pargs2: Vec[i32] = Vec();
  pargs2.push(r_msg2.id);
  let r_call2: ast.AddExprResult = add_call(p, sp, r_panic2.id, pargs2);
  p = r_call2.pool;
  loop_body.push(ast.Stmt.ExprStmt(sp, r_call2.id));

  let loop_stmt: ast.Stmt = ast.Stmt.WhileStmt(sp, r_true.id, ast.Block { stmts: loop_body });

  let mut out: Vec[ast.Stmt] = Vec();
  i = 0;
  while i < pre.len() { out.push(pre.get(i)); i = i + 1; }
  out.push(loop_stmt);

  // Satisfy the IRGen "missing return" check: the loop above is infinite by construction,
  // but the current IRGen does not prove it. This path is unreachable.
  let r_pending4: ast.AddExprResult = add_expr(p, ast.ExprNode.DotIdent("Pending"), sp);
  p = r_pending4.pool;
  out.push(ast.Stmt.ReturnStmt(sp, true, r_pending4.id));

  return SynthResult { ok: true, err: "", exprs: p, body: ast.Block { stmts: out } };
}
