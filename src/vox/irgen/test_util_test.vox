import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc
import "vox/ir" as ir

// Shared helpers for vox/irgen tests.

fn add_mod(w: tc.World, path: String, src: String) -> tc.World {
  // Keep file paths consistent with real package layout so diagnostics are stable.
  // Most irgen tests add module "main" which corresponds to "src/main.vox".
  let file: String =
    if path == "main" {
      "src/main.vox"
    } else {
      "src/".concat(path).concat(".vox")
    };
  let r: p.ParseResult = p.parse_text_with_path(file, src);
  t.assert_with(r.err == p.ParseError.None, p.parse_error_to_string_with_source(file, src, r.err));
  return tc.world_add(w, path, r.prog);
}

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn starts_with(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

fn prog_has_func(p: ir.Program, name: String) -> bool {
  let mut i: i32 = 0;
  while i < p.funcs.len() {
    if p.funcs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn prog_has_struct(p: ir.Program, name: String) -> bool {
  let mut i: i32 = 0;
  while i < p.structs.len() {
    if p.structs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn prog_has_enum(p: ir.Program, name: String) -> bool {
  let mut i: i32 = 0;
  while i < p.enums.len() {
    if p.enums.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}
