import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc
import "vox/ir" as ir

// Shared helpers for vox/irgen tests.

fn add_mod(w: tc.World, path: String, src: String) -> tc.World {
  // Keep file paths consistent with real package layout so diagnostics are stable.
  // Most irgen tests add module "main" which corresponds to "src/main.vox".
  let file: String =
    if path == "main" {
      "src/main.vox"
    } else {
      "src/".concat(path).concat(".vox")
    };
  let r: p.ParseResult = p.parse_text_with_path(file, src);
  t.assert_with(r.err == p.ParseError.None, p.parse_error_to_string_with_source(file, src, r.err));
  return tc.world_add(w, path, r.prog);
}

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn starts_with(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

fn prog_has_func(p: ir.Program, name: String) -> bool {
  let mut i: i32 = 0;
  while i < p.funcs.len() {
    if p.funcs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn prog_has_struct(p: ir.Program, name: String) -> bool {
  let mut i: i32 = 0;
  while i < p.structs.len() {
    if p.structs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn prog_has_enum(p: ir.Program, name: String) -> bool {
  let mut i: i32 = 0;
  while i < p.enums.len() {
    if p.enums.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn string_prelude() -> String {
  return "\nimpl String { fn len(s: String) -> i32 { return 0; } fn is_empty(s: String) -> bool { return true; } fn byte_at(s: String, idx: i32) -> i32 { return 0; } fn slice(s: String, start: i32, end: i32) -> String { return \"\"; } fn concat(s: String, other: String) -> String { return \"\"; } fn starts_with(s: String, pre: String) -> bool { return false; } fn ends_with(s: String, suf: String) -> bool { return false; } fn contains(s: String, needle: String) -> bool { return false; } fn index_of(s: String, needle: String) -> i32 { return 0; } fn last_index_of(s: String, needle: String) -> i32 { return 0; } fn escape_c(s: String) -> String { return \"\"; } fn to_string(s: String) -> String { return s; } }\nimpl bool { fn to_string(v: bool) -> String { return \"\"; } }\nimpl i8 { fn to_string(v: i8) -> String { return \"\"; } }\nimpl u8 { fn to_string(v: u8) -> String { return \"\"; } }\nimpl i16 { fn to_string(v: i16) -> String { return \"\"; } }\nimpl u16 { fn to_string(v: u16) -> String { return \"\"; } }\nimpl i32 { fn to_string(v: i32) -> String { return \"\"; } }\nimpl u32 { fn to_string(v: u32) -> String { return \"\"; } }\nimpl i64 { fn to_string(v: i64) -> String { return \"\"; } }\nimpl u64 { fn to_string(v: u64) -> String { return \"\"; } }\nimpl isize { fn to_string(v: isize) -> String { return \"\"; } }\nimpl usize { fn to_string(v: usize) -> String { return \"\"; } }\nimpl f32 { fn to_string(v: f32) -> String { return \"\"; } }\nimpl f64 { fn to_string(v: f64) -> String { return \"\"; } }";
}
