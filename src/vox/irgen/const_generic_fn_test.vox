import "std/testing" as t
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_const_generic_fn_forwards_const_param() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn addn[const N: i32](x: i32) -> i32 { return x + N; }
    fn wrap[const N: i32](x: i32) -> i32 { return addn[N](x); }
    fn main() -> i32 { return wrap[3](4); }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "wrap$gN_3d3_3ai32"));
  t.assert(prog_has_func(r.prog, "addn$gN_3d3_3ai32"));
}

fn test_irgen_const_generic_fn_forwards_const_param_with_comptime_where() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn addn[const N: i32](x: i32) -> i32 where comptime N > 0 { return x + N; }
    fn wrap[const N: i32](x: i32) -> i32 { return addn[N](x); }
    fn main() -> i32 { return wrap[3](4); }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "wrap$gN_3d3_3ai32"));
  t.assert(prog_has_func(r.prog, "addn$gN_3d3_3ai32"));
}

fn test_irgen_const_generic_fn_forwards_const_param_with_comptime_where_rejected() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn addn[const N: i32](x: i32) -> i32 where comptime N > 0 { return x + N; }
    fn wrap[const N: i32](x: i32) -> i32 { return addn[N](x); }
    fn main() -> i32 { return wrap[0](4); }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "constraint failed"));
}
