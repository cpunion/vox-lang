import "vox/ast" as ast
import "vox/ir" as ir
import "vox/typecheck" as tc

struct GenExprResult { ok: bool, err: String, g: Gen, val: ir.Value, ty: i32 }
struct TryEnumInfo { ok: bool, is_result: bool, ok_name: String, ok_idx: i32, ok_ty: i32, residual_name: String, residual_idx: i32, residual_ty: i32 }
struct CurrentTryResult { found: bool, t: TryCtx }
struct TryErrConvResult { ok: bool, err: String, need_call: bool, mod_path: String, fn_name: String, ret_ty: i32, g: Gen }
struct AwaitPollInfo { ok: bool, ready_name: String, ready_idx: i32, ready_ty: i32 }
struct StructFieldPick { ok: bool, name: String, ty: i32 }
struct AwaitFuturePollResult { ok: bool, err: String, g: Gen, poll_val: ir.Value, poll_ty: i32, out_ty: i32 }

fn gen_expr(g0: Gen, id: i32, expected: i32) -> GenExprResult {
  let tr: tc.ExprTyResult = tc.tc_expr(g0.ctx, g0.w, g0.mod_path, g0.imps, g0.exprs, g0.locals, id, expected);
  if !tr.ok {
    return GenExprResult { ok: false, err: tc.tc_error_to_string(tr.err), g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad };
  }

  let n: ast.ExprNode = ast.expr_pool_get(g0.exprs, id);
  return match n {
    ast.ExprNode.Int(v) => gen_expr_int(g0, v, tr.ty, expected),
    ast.ExprNode.Float(v) => gen_expr_float(g0, v, tr.ty, expected),
    ast.ExprNode.Bool(b) => gen_expr_bool(g0, b, tr.ty),
    ast.ExprNode.Str(s) => gen_expr_str(g0, s, tr.ty),
    ast.ExprNode.Ident(name) => gen_expr_ident(g0, name, tr.ty),
    ast.ExprNode.DotIdent(name) => gen_expr_dot_ident(g0, name, tr.ty),
    ast.ExprNode.Block(b) => gen_expr_block(g0, b, tr.ty),
    ast.ExprNode.Unary(op, a) => gen_expr_unary(g0, op, a, tr.ty),
    ast.ExprNode.As(a, tn) => gen_expr_as(g0, a, tn, tr.ty),
    ast.ExprNode.Binary(op, l, r) => gen_expr_binary(g0, op, l, r, tr.ty),
    // Preserve call-site expected type (e.g. refined `@range` aliases) for
    // if-expression result slots, even if tc_expr normalizes the inferred type.
    ast.ExprNode.If(c, t, e) => gen_expr_if(g0, c, t, e, if expected != -1 { expected } else { tr.ty }),
    ast.ExprNode.Member(recv, name) => gen_expr_member(g0, recv, name, tr.ty),
    ast.ExprNode.Call(callee, type_args, args) => gen_expr_call(g0, callee, type_args, args, tr.ty, expected),
    ast.ExprNode.MacroCall(_callee, _targs, _args) =>
      GenExprResult { ok: false, err: "internal: unexpanded macro call reached irgen", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad },
    ast.ExprNode.TryBlock(bid) => gen_expr_try_block(g0, bid, tr.ty),
    ast.ExprNode.Try(a) => gen_expr_try(g0, a, tr.ty),
    ast.ExprNode.Await(a) => gen_expr_await(g0, a, tr.ty),
    ast.ExprNode.StructLit(ty_expr, fields) => gen_expr_struct_lit(g0, ty_expr, fields, tr.ty),
    ast.ExprNode.Match(scrut, arms) => gen_expr_match(g0, scrut, arms, tr.ty),
  };
}

fn current_try(g0: Gen) -> CurrentTryResult {
  if g0.tries.len() == 0 { return CurrentTryResult { found: false, t: TryCtx { ret_slot: -1, end_blk: "", ret_ty: -1 } }; }
  return CurrentTryResult { found: true, t: g0.tries.get(g0.tries.len() - 1) };
}

fn try_stack_pop(v: Vec[TryCtx]) -> Vec[TryCtx] {
  if v.len() == 0 { return v; }
  let mut out: Vec[TryCtx] = Vec();
  let mut i: i32 = 0;
  while i < v.len() - 1 {
    out.push(v.get(i));
    i = i + 1;
  }
  return out;
}

fn find_variant_index(es: tc.EnumSig, name: String) -> i32 {
  let mut i: i32 = 0;
  while i < es.vars.len() {
    if es.vars.get(i).name == name { return i; }
    i = i + 1;
  }
  return -1;
}

fn try_enum_info(g0: Gen, ty0: i32) -> TryEnumInfo {
  let ty: i32 = tc.strip_range(g0.ctx, ty0);
  if ty < 0 || ty >= g0.ctx.pool.tys.len() {
    return TryEnumInfo { ok: false, is_result: false, ok_name: "", ok_idx: -1, ok_ty: g0.ctx.ty_bad, residual_name: "", residual_idx: -1, residual_ty: g0.ctx.ty_bad };
  }
  let t: ir.Ty = ir.ty_pool_get(g0.ctx.pool, ty);
  if t.kind != ir.TyKind.Enum {
    return TryEnumInfo { ok: false, is_result: false, ok_name: "", ok_idx: -1, ok_ty: g0.ctx.ty_bad, residual_name: "", residual_idx: -1, residual_ty: g0.ctx.ty_bad };
  }
  let fe: tc.FindEnumResult = tc.find_enum(g0.ctx, tc.ty_mod(t), tc.ty_name(t));
  if !fe.found {
    return TryEnumInfo { ok: false, is_result: false, ok_name: "", ok_idx: -1, ok_ty: g0.ctx.ty_bad, residual_name: "", residual_idx: -1, residual_ty: g0.ctx.ty_bad };
  }
  let es: tc.EnumSig = fe.sig;

  let ok_idx: i32 = find_variant_index(es, "Ok");
  let err_idx: i32 = find_variant_index(es, "Err");
  if ok_idx != -1 && err_idx != -1 {
    let okv: tc.EnumVariantSig = es.vars.get(ok_idx);
    let errv: tc.EnumVariantSig = es.vars.get(err_idx);
    if okv.fields.len() == 1 && errv.fields.len() == 1 {
      return TryEnumInfo {
        ok: true,
        is_result: true,
        ok_name: "Ok",
        ok_idx: ok_idx,
        ok_ty: okv.fields.get(0),
        residual_name: "Err",
        residual_idx: err_idx,
        residual_ty: errv.fields.get(0),
      };
    }
  }

  let some_idx: i32 = find_variant_index(es, "Some");
  let none_idx: i32 = find_variant_index(es, "None");
  if some_idx != -1 && none_idx != -1 {
    let somev: tc.EnumVariantSig = es.vars.get(some_idx);
    let nonev: tc.EnumVariantSig = es.vars.get(none_idx);
    if somev.fields.len() == 1 && nonev.fields.len() == 0 {
      return TryEnumInfo {
        ok: true,
        is_result: false,
        ok_name: "Some",
        ok_idx: some_idx,
        ok_ty: somev.fields.get(0),
        residual_name: "None",
        residual_idx: none_idx,
        residual_ty: g0.ctx.ty_unit,
      };
    }
  }

  return TryEnumInfo { ok: false, is_result: false, ok_name: "", ok_idx: -1, ok_ty: g0.ctx.ty_bad, residual_name: "", residual_idx: -1, residual_ty: g0.ctx.ty_bad };
}


fn await_poll_info(g0: Gen, ty0: i32) -> AwaitPollInfo {
  let ty: i32 = tc.strip_range(g0.ctx, ty0);
  if ty < 0 || ty >= g0.ctx.pool.tys.len() {
    return AwaitPollInfo { ok: false, ready_name: "", ready_idx: -1, ready_ty: g0.ctx.ty_bad };
  }
  let t: ir.Ty = ir.ty_pool_get(g0.ctx.pool, ty);
  if t.kind != ir.TyKind.Enum {
    return AwaitPollInfo { ok: false, ready_name: "", ready_idx: -1, ready_ty: g0.ctx.ty_bad };
  }
  let fe: tc.FindEnumResult = tc.find_enum(g0.ctx, tc.ty_mod(t), tc.ty_name(t));
  if !fe.found {
    return AwaitPollInfo { ok: false, ready_name: "", ready_idx: -1, ready_ty: g0.ctx.ty_bad };
  }
  let es: tc.EnumSig = fe.sig;

  let pending_idx: i32 = find_variant_index(es, "Pending");
  let ready_idx: i32 = find_variant_index(es, "Ready");
  if pending_idx == -1 || ready_idx == -1 {
    return AwaitPollInfo { ok: false, ready_name: "", ready_idx: -1, ready_ty: g0.ctx.ty_bad };
  }

  let pending: tc.EnumVariantSig = es.vars.get(pending_idx);
  let ready: tc.EnumVariantSig = es.vars.get(ready_idx);
  if pending.fields.len() != 0 || ready.fields.len() != 1 {
    return AwaitPollInfo { ok: false, ready_name: "", ready_idx: -1, ready_ty: g0.ctx.ty_bad };
  }

  return AwaitPollInfo {
    ok: true,
    ready_name: "Ready",
    ready_idx: ready_idx,
    ready_ty: ready.fields.get(0),
  };
}

fn pick_struct_field(fs: tc.StructSig, preferred: String) -> StructFieldPick {
  let mut i: i32 = 0;
  while i < fs.fields.len() {
    let f: tc.StructFieldSig = fs.fields.get(i);
    if f.name == preferred {
      return StructFieldPick { ok: true, name: f.name, ty: f.ty };
    }
    i = i + 1;
  }
  if fs.fields.len() == 0 {
    return StructFieldPick { ok: false, name: "", ty: -1 };
  }
  let f0: tc.StructFieldSig = fs.fields.get(0);
  return StructFieldPick { ok: true, name: f0.name, ty: f0.ty };
}

// Lower `Future::poll` call for an awaited operand that implements std/async::Future.
// If recv_slot != -1, recv is treated as a place rooted at that slot (optionally with fields),
// and poll is invoked in-place (mutations persist). Otherwise, recv is treated as a value and
// is copied into a temporary slot for the duration of the call.
fn gen_await_poll_from_future(g0: Gen, recv: ir.Value, recv_slot: i32, recv_fields: Vec[String], recv_ty0: i32) -> AwaitFuturePollResult {
  let recv_ty: i32 = tc.strip_range(g0.ctx, recv_ty0);
  let fi: tc.FindImplForTyResult = tc.find_impl_for_ty(g0.ctx, "std/async", "Future", recv_ty);
  if fi.ambiguous {
    return AwaitFuturePollResult { ok: false, err: "await Future impl is ambiguous", g: g0, poll_val: ir.v_int(0), poll_ty: g0.ctx.ty_bad, out_ty: g0.ctx.ty_bad };
  }
  if !fi.found {
    return AwaitFuturePollResult { ok: false, err: "await operand does not implement std/async::Future", g: g0, poll_val: ir.v_int(0), poll_ty: g0.ctx.ty_bad, out_ty: g0.ctx.ty_bad };
  }

  let ur: tc.UnifyResult = tc.unify_ty(g0.ctx, fi.sig.for_ty, recv_ty, Vec());
  if !ur.ok {
    return AwaitFuturePollResult { ok: false, err: "await Future impl unification failed", g: g0, poll_val: ir.v_int(0), poll_ty: g0.ctx.ty_bad, out_ty: g0.ctx.ty_bad };
  }
  let subs: Vec[tc.TySub] = ur.subs;

  let out0: i32 = try_impl_assoc_ty_ir(fi.sig, "Output");
  if out0 == -1 {
    return AwaitFuturePollResult { ok: false, err: "await Future impl missing assoc type Output", g: g0, poll_val: ir.v_int(0), poll_ty: g0.ctx.ty_bad, out_ty: g0.ctx.ty_bad };
  }
  let out_ty: i32 = tc.subst_ty(g0.ctx, out0, subs);

  let im: tc.FindImplMethodResult = tc.find_impl_method(fi.sig, "poll");
  if !im.found {
    return AwaitFuturePollResult { ok: false, err: "await Future impl missing method poll", g: g0, poll_val: ir.v_int(0), poll_ty: g0.ctx.ty_bad, out_ty: g0.ctx.ty_bad };
  }
  if im.m.sig.params.len() != 2 {
    return AwaitFuturePollResult { ok: false, err: "await Future::poll arity mismatch", g: g0, poll_val: ir.v_int(0), poll_ty: g0.ctx.ty_bad, out_ty: g0.ctx.ty_bad };
  }

  let mut g: Gen = g0;
  let cx_slot: LookupSlotResult = slots_lookup(g.slots, "cx");
  if !cx_slot.found {
    return AwaitFuturePollResult { ok: false, err: "await Future::poll requires `cx` in scope", g: g, poll_val: ir.v_int(0), poll_ty: g.ctx.ty_bad, out_ty: g.ctx.ty_bad };
  }
  let cx_ty: i32 = tc.strip_range_only(g.ctx, cx_slot.ty);

  // `Future::poll` takes `&mut Self`; lower as inout. Build the receiver ref
  // type first so generic method params can be inferred from call argument
  // types before we emit the call.
  let rr: tc.ResolveTyResult = tc.intern_ref(g.ctx, recv_ty, true, false);
  g.ctx = rr.ctx;
  if !rr.ok {
    return AwaitFuturePollResult { ok: false, err: "await failed to intern poll recv ref type", g: g, poll_val: ir.v_int(0), poll_ty: g.ctx.ty_bad, out_ty: g.ctx.ty_bad };
  }
  let ref_ty: i32 = rr.idx;

  let mut subs_m: Vec[tc.TySub] = subs;
  let mut csubs: Vec[tc.ConstSub] = Vec();
  if im.m.sig.type_params.len() != 0 || im.m.sig.const_params.len() != 0 {
    let ur0: tc.UnifyResult = tc.unify_ty(g.ctx, im.m.sig.params.get(0), ref_ty, subs_m);
    if !ur0.ok {
      return AwaitFuturePollResult { ok: false, err: "await Future::poll recv type mismatch", g: g, poll_val: ir.v_int(0), poll_ty: g.ctx.ty_bad, out_ty: g.ctx.ty_bad };
    }
    subs_m = ur0.subs;
    let ur1: tc.UnifyResult = tc.unify_ty(g.ctx, im.m.sig.params.get(1), cx_ty, subs_m);
    if !ur1.ok {
      return AwaitFuturePollResult { ok: false, err: "await Future::poll cx type mismatch", g: g, poll_val: ir.v_int(0), poll_ty: g.ctx.ty_bad, out_ty: g.ctx.ty_bad };
    }
    subs_m = ur1.subs;

    // If generic params remain unconstrained by the call shape, default to the
    // awaited output type to keep monomorphization deterministic.
    let mut ti: i32 = 0;
    while ti < im.m.sig.type_params.len() {
      let tp: String = im.m.sig.type_params.get(ti);
      if try_subs_lookup_ir(subs_m, tp) == -1 {
        subs_m.push(tc.TySub { name: tp, ty: out_ty });
      }
      ti = ti + 1;
    }

    let mut bi: i32 = 0;
    while bi < im.m.sig.type_param_bounds.len() {
      let b: tc.TypeParamBoundSig = im.m.sig.type_param_bounds.get(bi);
      let ty0: i32 = try_subs_lookup_ir(subs_m, b.type_param);
      if ty0 == -1 {
        return AwaitFuturePollResult { ok: false, err: "await Future::poll has unbound type param", g: g, poll_val: ir.v_int(0), poll_ty: g.ctx.ty_bad, out_ty: g.ctx.ty_bad };
      }
      let fi2: tc.FindImplForTyResult = tc.find_impl_for_ty(g.ctx, b.trait_mod_path, b.trait_name, tc.strip_range(g.ctx, ty0));
      if fi2.ambiguous || !fi2.found {
        return AwaitFuturePollResult { ok: false, err: "await Future::poll type param bound unsatisfied", g: g, poll_val: ir.v_int(0), poll_ty: g.ctx.ty_bad, out_ty: g.ctx.ty_bad };
      }
      bi = bi + 1;
    }

    let mut ci: i32 = 0;
    while ci < im.m.sig.const_params.len() {
      let cp: tc.ConstParamSig = im.m.sig.const_params.get(ci);
      if !cp.has_default {
        return AwaitFuturePollResult { ok: false, err: "await Future::poll requires const args without defaults", g: g, poll_val: ir.v_int(0), poll_ty: g.ctx.ty_bad, out_ty: g.ctx.ty_bad };
      }
      csubs.push(tc.ConstSub { name: cp.name, ty: cp.ty, iv: cp.default_iv, text: cp.default_text });
      ci = ci + 1;
    }
    let cwr: tc.ConstWhereCheckResult = tc.check_const_where_bounds(g.ctx, im.m.sig.const_where_bounds, subs_m, csubs);
    if !cwr.ok {
      return AwaitFuturePollResult { ok: false, err: cwr.err, g: g, poll_val: ir.v_int(0), poll_ty: g.ctx.ty_bad, out_ty: g.ctx.ty_bad };
    }
  }

  let poll_ret0: i32 = tc.subst_ty(g.ctx, im.m.sig.ret, subs_m);
  let poll_ret: i32 = tc.strip_range_only(g.ctx, poll_ret0);
  let ai: AwaitPollInfo = await_poll_info(g, poll_ret);
  if !ai.ok {
    return AwaitFuturePollResult { ok: false, err: "await Future::poll must return Poll-like enum", g: g, poll_val: ir.v_int(0), poll_ty: g.ctx.ty_bad, out_ty: g.ctx.ty_bad };
  }
  if !tc.assignable_to(g.ctx, out_ty, ai.ready_ty) || !tc.assignable_to(g.ctx, ai.ready_ty, out_ty) {
    return AwaitFuturePollResult { ok: false, err: "await Future::Output does not match poll Ready payload", g: g, poll_val: ir.v_int(0), poll_ty: g.ctx.ty_bad, out_ty: g.ctx.ty_bad };
  }

  let mut call_name: String = im.m.lowered_name;
  if im.m.sig.type_params.len() != 0 || im.m.sig.const_params.len() != 0 {
    let mut ps: Vec[i32] = Vec();
    let mut pi: i32 = 0;
    while pi < im.m.sig.params.len() {
      let pty: i32 = tc.subst_ty(g.ctx, im.m.sig.params.get(pi), subs_m);
      if pty == g.ctx.ty_bad {
        return AwaitFuturePollResult { ok: false, err: "await Future::poll param type substitution failed", g: g, poll_val: ir.v_int(0), poll_ty: g.ctx.ty_bad, out_ty: g.ctx.ty_bad };
      }
      ps.push(tc.strip_range_only(g.ctx, pty));
      pi = pi + 1;
    }

    let inst_sig: tc.FuncSig = tc.FuncSig {
      params: ps,
      param_borrow_kinds: im.m.sig.param_borrow_kinds,
      ret: poll_ret,
      has_variadic: false,
      variadic_elem: -1,
      vis: im.m.sig.vis,
      is_pub: im.m.sig.is_pub,
      type_params: Vec(),
      type_param_packs: Vec(),
      const_params: im.m.sig.const_params,
      type_param_bounds: Vec(),
      effects: im.m.sig.effects,
      resource_reads: im.m.sig.resource_reads,
      resource_writes: im.m.sig.resource_writes,
      const_where_bounds: im.m.sig.const_where_bounds,
    };
    let inst: String = tc.inst_name_ex(g.ctx, im.m.lowered_name, im.m.sig.type_params, im.m.sig.const_params, subs_m, csubs);
    g.pending = pending_add(g.pending, PendingInst {
      qname: qname(fi.sig.mod_path, inst),
      mod_path: fi.sig.mod_path,
      base_name: im.m.lowered_name,
      inst_name: inst,
      sig: inst_sig,
      subs: subs_m,
      const_subs: csubs,
    });
    call_name = inst;
  }

  let cr: GenNewIdResult = gen_new_temp(g);
  g = cr.g;
  let cx_tid: i32 = cr.id;
  g = gen_emit(g, ir.Instr.Load(cx_tid, cx_ty, cx_slot.slot));

  let pr: GenNewIdResult = gen_new_temp(g);
  g = pr.g;
  let p_tid: i32 = pr.id;
  let mut args: Vec[ir.Value] = Vec();
  let na: GenNewIdResult = gen_new_temp(g);
  g = na.g;
  let recv_ptr: i32 = na.id;
  if recv_slot != -1 {
    if recv_fields.len() == 0 {
      g = gen_emit(g, ir.Instr.AddrOfSlot(recv_ptr, ref_ty, recv_slot));
    } else {
      g = gen_emit(g, ir.Instr.AddrOfFieldChain(recv_ptr, ref_ty, recv_slot, recv_fields));
    }
  } else {
    let ns: GenNewIdResult = gen_new_slot(g);
    g = ns.g;
    let tmp_slot: i32 = ns.id;
    g = gen_emit(g, ir.Instr.SlotDecl(tmp_slot, recv_ty));
    g = gen_emit(g, ir.Instr.Store(tmp_slot, recv));
    g = gen_emit(g, ir.Instr.AddrOfSlot(recv_ptr, ref_ty, tmp_slot));
  }
  args.push(ir.v_temp(recv_ptr));
  args.push(ir.v_temp(cx_tid));
  g = gen_emit(g, ir.Instr.Call(true, p_tid, poll_ret, qname(fi.sig.mod_path, call_name), args));

  return AwaitFuturePollResult {
    ok: true,
    err: "",
    g: g,
    poll_val: ir.v_temp(p_tid),
    poll_ty: poll_ret,
    out_ty: out_ty,
  };
}
fn try_impl_assoc_ty_ir(sig: tc.ImplSig, assoc: String) -> i32 {
  let mut i: i32 = 0;
  while i < sig.assoc_types.len() {
    let a: tc.ImplAssocTypeSig = sig.assoc_types.get(i);
    if a.name == assoc { return a.ty; }
    i = i + 1;
  }
  return -1;
}

fn try_subs_lookup_ir(subs: Vec[tc.TySub], name: String) -> i32 {
  let mut i: i32 = 0;
  while i < subs.len() {
    let s: tc.TySub = subs.get(i);
    if s.name == name { return s.ty; }
    i = i + 1;
  }
  return -1;
}

fn try_resolve_err_conv(g0: Gen, src_err_ty: i32, dst_err_ty: i32) -> TryErrConvResult {
  if tc.assignable_to(g0.ctx, dst_err_ty, src_err_ty) {
    return TryErrConvResult { ok: true, err: "", need_call: false, mod_path: "", fn_name: "", ret_ty: src_err_ty, g: g0 };
  }

  let prelude: String = "std/prelude";
  let tf: tc.FindTraitResult = tc.find_trait(g0.ctx, prelude, "Into");
  if !tf.found || !tc.vis_allows(tf.sig.vis, prelude, g0.mod_path) {
    return TryErrConvResult { ok: false, err: "cannot propagate error: Err type mismatch", need_call: false, mod_path: "", fn_name: "", ret_ty: g0.ctx.ty_bad, g: g0 };
  }

  let fi: tc.FindImplForTyResult = tc.find_impl_for_ty(g0.ctx, prelude, "Into", tc.strip_range(g0.ctx, src_err_ty));
  if fi.ambiguous {
    let msg0: String = "cannot propagate error: Err type mismatch (ambiguous Into impls: ".concat(fi.candidates).concat(")");
    return TryErrConvResult { ok: false, err: msg0, need_call: false, mod_path: "", fn_name: "", ret_ty: g0.ctx.ty_bad, g: g0 };
  }
  if !fi.found {
    return TryErrConvResult { ok: false, err: "cannot propagate error: Err type mismatch", need_call: false, mod_path: "", fn_name: "", ret_ty: g0.ctx.ty_bad, g: g0 };
  }

  let im: tc.FindImplMethodResult = tc.find_impl_method(fi.sig, "into");
  if !im.found {
    return TryErrConvResult { ok: false, err: "cannot propagate error: Err type mismatch", need_call: false, mod_path: "", fn_name: "", ret_ty: g0.ctx.ty_bad, g: g0 };
  }
  if im.m.sig.params.len() != 1 {
    return TryErrConvResult { ok: false, err: "cannot propagate error: Err type mismatch", need_call: false, mod_path: "", fn_name: "", ret_ty: g0.ctx.ty_bad, g: g0 };
  }
  if im.m.sig.const_params.len() != 0 {
    return TryErrConvResult { ok: false, err: "cannot propagate error: Err type mismatch", need_call: false, mod_path: "", fn_name: "", ret_ty: g0.ctx.ty_bad, g: g0 };
  }

  let mut subs: Vec[tc.TySub] = Vec();
  let ur0: tc.UnifyResult = tc.unify_ty(g0.ctx, im.m.sig.ret, dst_err_ty, subs);
  if !ur0.ok {
    return TryErrConvResult { ok: false, err: "cannot propagate error: Err type mismatch", need_call: false, mod_path: "", fn_name: "", ret_ty: g0.ctx.ty_bad, g: g0 };
  }
  subs = ur0.subs;
  let ur1: tc.UnifyResult = tc.unify_ty(g0.ctx, im.m.sig.params.get(0), src_err_ty, subs);
  if !ur1.ok {
    return TryErrConvResult { ok: false, err: "cannot propagate error: Err type mismatch", need_call: false, mod_path: "", fn_name: "", ret_ty: g0.ctx.ty_bad, g: g0 };
  }
  subs = ur1.subs;
  let mut ti: i32 = 0;
  while ti < im.m.sig.type_params.len() {
    let tp: String = im.m.sig.type_params.get(ti);
    if try_subs_lookup_ir(subs, tp) == -1 {
      subs.push(tc.TySub { name: tp, ty: dst_err_ty });
    }
    ti = ti + 1;
  }
  let mut bi: i32 = 0;
  while bi < im.m.sig.type_param_bounds.len() {
    let b: tc.TypeParamBoundSig = im.m.sig.type_param_bounds.get(bi);
    let ty0: i32 = try_subs_lookup_ir(subs, b.type_param);
    if ty0 == -1 {
      return TryErrConvResult { ok: false, err: "cannot propagate error: Err type mismatch", need_call: false, mod_path: "", fn_name: "", ret_ty: g0.ctx.ty_bad, g: g0 };
    }
    let fi2: tc.FindImplForTyResult = tc.find_impl_for_ty(g0.ctx, b.trait_mod_path, b.trait_name, tc.strip_range(g0.ctx, ty0));
    if fi2.ambiguous || !fi2.found {
      return TryErrConvResult { ok: false, err: "cannot propagate error: Err type mismatch", need_call: false, mod_path: "", fn_name: "", ret_ty: g0.ctx.ty_bad, g: g0 };
    }
    bi = bi + 1;
  }

  let assoc_target: i32 = try_impl_assoc_ty_ir(fi.sig, "Target");
  let via_ty0: i32 = if assoc_target != -1 { assoc_target } else { im.m.sig.ret };
  let via_ty: i32 = tc.subst_ty(g0.ctx, via_ty0, subs);
  if !tc.assignable_to(g0.ctx, dst_err_ty, via_ty) {
    return TryErrConvResult { ok: false, err: "cannot propagate error: Err type mismatch", need_call: false, mod_path: "", fn_name: "", ret_ty: g0.ctx.ty_bad, g: g0 };
  }

  if im.m.sig.type_params.len() == 0 {
    return TryErrConvResult {
      ok: true,
      err: "",
      need_call: true,
      mod_path: fi.sig.mod_path,
      fn_name: im.m.lowered_name,
      ret_ty: tc.strip_range_only(g0.ctx, via_ty),
      g: g0,
    };
  }

  let mut ps: Vec[i32] = Vec();
  ps.push(tc.strip_range_only(g0.ctx, tc.subst_ty(g0.ctx, im.m.sig.params.get(0), subs)));
  let inst_sig: tc.FuncSig = tc.FuncSig {
    params: ps,
    param_borrow_kinds: im.m.sig.param_borrow_kinds,
    ret: tc.strip_range_only(g0.ctx, via_ty),
    has_variadic: false,
    variadic_elem: -1,
    vis: im.m.sig.vis,
    is_pub: im.m.sig.is_pub,
    type_params: Vec(),
    type_param_packs: Vec(),
    const_params: im.m.sig.const_params,
    type_param_bounds: Vec(),
    effects: im.m.sig.effects,
    resource_reads: im.m.sig.resource_reads,
    resource_writes: im.m.sig.resource_writes,
    const_where_bounds: im.m.sig.const_where_bounds,
  };
  let inst: String = tc.inst_name_ex(g0.ctx, im.m.lowered_name, im.m.sig.type_params, im.m.sig.const_params, subs, Vec());
  let inst_qn: String = qname(fi.sig.mod_path, inst);
  let mut g1: Gen = g0;
  g1.pending = pending_add(g1.pending, PendingInst {
    qname: inst_qn,
    mod_path: fi.sig.mod_path,
    base_name: im.m.lowered_name,
    inst_name: inst,
    sig: inst_sig,
    subs: subs,
    const_subs: Vec(),
  });

  return TryErrConvResult {
    ok: true,
    err: "",
    need_call: true,
    mod_path: fi.sig.mod_path,
    fn_name: inst,
    ret_ty: tc.strip_range_only(g0.ctx, via_ty),
    g: g1,
  };
}


fn gen_expr_await(g0: Gen, a: i32, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  // If the await operand is a place, prefer in-place poll lowering so the Future
  // can mutate itself across polls (used by async frame fields).
  let mc: MemberChainResult = place_chain(g.exprs, a);
  let mut recv_slot: i32 = -1;
  let mut recv_fields: Vec[String] = Vec();
  if mc.ok {
    let br: LookupSlotResult = slots_lookup(g.slots, mc.base);
    if br.found && br.mutable {
      recv_slot = br.slot;
      recv_fields = mc.fields;
    }
  }
  let ar: GenExprResult = gen_expr(g, a, -1);
  if !ar.ok { return ar; }
  g = ar.g;

  let mut poll_val: ir.Value = ar.val;
  let mut poll_ty: i32 = ar.ty;
  let mut await_out_ty: i32 = -1;
  let mut ai: AwaitPollInfo = await_poll_info(g, poll_ty);
  if !ai.ok {
    let fr: AwaitFuturePollResult = gen_await_poll_from_future(g, poll_val, recv_slot, recv_fields, poll_ty);
    if !fr.ok {
      return GenExprResult { ok: false, err: fr.err, g: fr.g, val: ir.v_int(0), ty: fr.g.ctx.ty_bad };
    }
    g = fr.g;
    poll_val = fr.poll_val;
    poll_ty = fr.poll_ty;
    await_out_ty = fr.out_ty;

    ai = await_poll_info(g, poll_ty);
    if !ai.ok {
      return GenExprResult { ok: false, err: "internal: await Future::poll did not produce Poll-like enum", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
    }
  } else {
    await_out_ty = ai.ready_ty;
  }

  if !tc.assignable_to(g.ctx, out_ty, await_out_ty) || !tc.assignable_to(g.ctx, await_out_ty, out_ty) {
    return GenExprResult { ok: false, err: "internal: await result type mismatch", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let rs: GenNewIdResult = gen_new_slot(g);
  g = rs.g;
  let out_slot: i32 = rs.id;
  g = gen_emit(g, ir.Instr.SlotDecl(out_slot, out_ty));

  let base: i32 = g.blocks.len();
  let br: GenNewIdResult = gen_new_block(g, "await_ready_".concat(base.to_string()));
  g = br.g;
  let ready_idx_block: i32 = br.id;
  let bp: GenNewIdResult = gen_new_block(g, "await_pending_".concat(base.to_string()));
  g = bp.g;
  let pending_idx_block: i32 = bp.id;
  let be: GenNewIdResult = gen_new_block(g, "await_end_".concat(base.to_string()));
  g = be.g;
  let end_idx_block: i32 = be.id;

  let tr0: GenNewIdResult = gen_new_temp(g);
  g = tr0.g;
  let tag_tid: i32 = tr0.id;
  g = gen_emit(g, ir.Instr.EnumTag(tag_tid, poll_val));

  let tr1: GenNewIdResult = gen_new_temp(g);
  g = tr1.g;
  let is_ready_tid: i32 = tr1.id;
  g = gen_emit(g, ir.Instr.Cmp(is_ready_tid, ir.CmpKind.Eq, g.ctx.ty_i32, ir.v_temp(tag_tid), ir.v_int(ai.ready_idx)));
  g = gen_term(g, ir.Term.CondBr(ir.v_temp(is_ready_tid), g.blocks.get(ready_idx_block).name, g.blocks.get(pending_idx_block).name));

  g = gen_set_block(g, ready_idx_block);
  let tr2: GenNewIdResult = gen_new_temp(g);
  g = tr2.g;
  let ready_tid: i32 = tr2.id;
  g = gen_emit(g, ir.Instr.EnumPayload(ready_tid, out_ty, poll_val, ai.ready_name, 0));
  g = gen_emit(g, ir.Instr.Store(out_slot, ir.v_temp(ready_tid)));
  g = gen_term(g, ir.Term.Br(g.blocks.get(end_idx_block).name));

  g = gen_set_block(g, pending_idx_block);
  // Scaffold: return `Pending` from the enclosing poll-like function.
  // This is still "restartable" lowering: we don't preserve progress across polls yet.
  let ri: AwaitPollInfo = await_poll_info(g, g.ret_ty);
  if !ri.ok {
    g = gen_term(g, ir.Term.Panic(ir.v_str("await pending requires poll-like function return type")));
  } else {
    let trp: GenNewIdResult = gen_new_temp(g);
    g = trp.g;
    let p_tid: i32 = trp.id;
    g = gen_emit(g, ir.Instr.EnumInit(p_tid, g.ret_ty, "Pending", Vec()));
    g = gen_term(g, ir.Term.Ret(true, ir.v_temp(p_tid)));
  }

  g = gen_set_block(g, end_idx_block);
  let tr3: GenNewIdResult = gen_new_temp(g);
  g = tr3.g;
  let out_tid: i32 = tr3.id;
  g = gen_emit(g, ir.Instr.Load(out_tid, out_ty, out_slot));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(out_tid), ty: out_ty };
}
fn gen_expr_try(g0: Gen, a: i32, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let ar: GenExprResult = gen_expr(g, a, -1);
  if !ar.ok { return ar; }
  g = ar.g;

  let src: TryEnumInfo = try_enum_info(g, ar.ty);
  if !src.ok { return GenExprResult { ok: false, err: "`?` requires Result[T, E] or Option[T]", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
  let ct: CurrentTryResult = current_try(g);
  let target_ret_ty: i32 = if ct.found { ct.t.ret_ty } else { g.ret_ty };
  let mut dst: TryEnumInfo = try_enum_info(g, target_ret_ty);
  let mut wrap_poll: bool = false;
  let mut poll_ai: AwaitPollInfo = AwaitPollInfo { ok: false, ready_name: "", ready_idx: -1, ready_ty: g.ctx.ty_bad };
  let mut container_ret_ty: i32 = target_ret_ty;
  if !dst.ok {
    // Allow `?` inside poll-like wrapper fns: `fn ... -> Poll[Result[T,E]] { x? }`.
    poll_ai = await_poll_info(g, target_ret_ty);
    if poll_ai.ok {
      container_ret_ty = poll_ai.ready_ty;
      let d2: TryEnumInfo = try_enum_info(g, container_ret_ty);
      if d2.ok {
        dst = d2;
        wrap_poll = true;
      }
    }
  }
  if !dst.ok || src.is_result != dst.is_result {
    return GenExprResult { ok: false, err: "function return type incompatible with `?`", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }

  let rs: GenNewIdResult = gen_new_slot(g);
  g = rs.g;
  let out_slot: i32 = rs.id;
  g = gen_emit(g, ir.Instr.SlotDecl(out_slot, out_ty));

  let base: i32 = g.blocks.len();
  let bok: GenNewIdResult = gen_new_block(g, "try_ok_".concat(base.to_string()));
  g = bok.g;
  let ok_idx_block: i32 = bok.id;
  let bres: GenNewIdResult = gen_new_block(g, "try_res_".concat(base.to_string()));
  g = bres.g;
  let res_idx_block: i32 = bres.id;
  let bend: GenNewIdResult = gen_new_block(g, "try_end_".concat(base.to_string()));
  g = bend.g;
  let end_idx_block: i32 = bend.id;

  let tr0: GenNewIdResult = gen_new_temp(g);
  g = tr0.g;
  let tag_tid: i32 = tr0.id;
  g = gen_emit(g, ir.Instr.EnumTag(tag_tid, ar.val));

  let tr1: GenNewIdResult = gen_new_temp(g);
  g = tr1.g;
  let is_ok_tid: i32 = tr1.id;
  g = gen_emit(g, ir.Instr.Cmp(is_ok_tid, ir.CmpKind.Eq, g.ctx.ty_i32, ir.v_temp(tag_tid), ir.v_int(src.ok_idx)));
  g = gen_term(g, ir.Term.CondBr(ir.v_temp(is_ok_tid), g.blocks.get(ok_idx_block).name, g.blocks.get(res_idx_block).name));

  g = gen_set_block(g, ok_idx_block);
  let tr2: GenNewIdResult = gen_new_temp(g);
  g = tr2.g;
  let ok_tid: i32 = tr2.id;
  g = gen_emit(g, ir.Instr.EnumPayload(ok_tid, out_ty, ar.val, src.ok_name, 0));
  g = gen_emit(g, ir.Instr.Store(out_slot, ir.v_temp(ok_tid)));
  if !g.blocks.get(g.cur).has_term {
    g = gen_term(g, ir.Term.Br(g.blocks.get(end_idx_block).name));
  }

  g = gen_set_block(g, res_idx_block);
  let mut rv: ir.Value = ir.v_int(0);
  if src.is_result {
    let tr3: GenNewIdResult = gen_new_temp(g);
    g = tr3.g;
    let err_tid: i32 = tr3.id;
    g = gen_emit(g, ir.Instr.EnumPayload(err_tid, src.residual_ty, ar.val, src.residual_name, 0));
    let mut err_v: ir.Value = ir.v_temp(err_tid);
    let cv: TryErrConvResult = try_resolve_err_conv(g, src.residual_ty, dst.residual_ty);
    if !cv.ok { return GenExprResult { ok: false, err: cv.err, g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    g = cv.g;
    if cv.need_call {
      let trc: GenNewIdResult = gen_new_temp(g);
      g = trc.g;
      let cv_tid: i32 = trc.id;
      let mut cv_args: Vec[ir.Value] = Vec();
      cv_args.push(err_v);
      g = gen_emit(g, ir.Instr.Call(true, cv_tid, cv.ret_ty, qname(cv.mod_path, cv.fn_name), cv_args));
      err_v = ir.v_temp(cv_tid);
    }
    let tr4: GenNewIdResult = gen_new_temp(g);
    g = tr4.g;
    let ret_tid: i32 = tr4.id;
    let mut ps: Vec[ir.Value] = Vec();
    ps.push(err_v);
    g = gen_emit(g, ir.Instr.EnumInit(ret_tid, container_ret_ty, dst.residual_name, ps));
    rv = ir.v_temp(ret_tid);
  } else {
    let tr5: GenNewIdResult = gen_new_temp(g);
    g = tr5.g;
    let ret_tid2: i32 = tr5.id;
    g = gen_emit(g, ir.Instr.EnumInit(ret_tid2, container_ret_ty, dst.residual_name, Vec()));
    rv = ir.v_temp(ret_tid2);
  }

  if wrap_poll {
    let trw: GenNewIdResult = gen_new_temp(g);
    g = trw.g;
    let w_tid: i32 = trw.id;
    let mut psw: Vec[ir.Value] = Vec();
    psw.push(rv);
    g = gen_emit(g, ir.Instr.EnumInit(w_tid, target_ret_ty, poll_ai.ready_name, psw));
    rv = ir.v_temp(w_tid);
  }
  if ct.found {
    g = gen_emit(g, ir.Instr.Store(ct.t.ret_slot, rv));
    g = gen_term(g, ir.Term.Br(ct.t.end_blk));
  } else {
    // In async poll functions, `?` can complete the future early. Mark the async
    // frame as done so subsequent polls panic instead of re-running.
    if g.locals.fn_is_async {
      let br: LookupSlotResult = slots_lookup(g.slots, "__frame");
      if br.found {
        g = gen_emit(g, ir.Instr.StoreField(br.slot, "state", ir.v_int(-1)));
      }
    }
    g = gen_term(g, ir.Term.Ret(true, rv));
  }

  g = gen_set_block(g, end_idx_block);
  let tr6: GenNewIdResult = gen_new_temp(g);
  g = tr6.g;
  let out_tid: i32 = tr6.id;
  g = gen_emit(g, ir.Instr.Load(out_tid, out_ty, out_slot));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(out_tid), ty: out_ty };
}

fn gen_expr_try_block(g0: Gen, bid: i32, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let dst: TryEnumInfo = try_enum_info(g, out_ty);
  if !dst.ok { return GenExprResult { ok: false, err: "`try {}` requires Result/Option output type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

  let rs: GenNewIdResult = gen_new_slot(g);
  g = rs.g;
  let out_slot: i32 = rs.id;
  g = gen_emit(g, ir.Instr.SlotDecl(out_slot, out_ty));

  let base: i32 = g.blocks.len();
  let bend: GenNewIdResult = gen_new_block(g, "tryblk_end_".concat(base.to_string()));
  g = bend.g;
  let end_idx: i32 = bend.id;
  let end_name: String = g.blocks.get(end_idx).name;

  let mut tries: Vec[TryCtx] = g.tries;
  tries.push(TryCtx { ret_slot: out_slot, end_blk: end_name, ret_ty: out_ty });
  g.tries = tries;
  let br: GenExprResult = gen_expr(g, bid, -1);
  if !br.ok { return br; }
  g = br.g;
  g.tries = try_stack_pop(g.tries);

  if !g.blocks.get(g.cur).has_term {
    if br.ty == out_ty {
      g = gen_emit(g, ir.Instr.Store(out_slot, br.val));
    } else {
      let rt: GenNewIdResult = gen_new_temp(g);
      g = rt.g;
      let tid: i32 = rt.id;
      let mut ps: Vec[ir.Value] = Vec();
      ps.push(br.val);
      g = gen_emit(g, ir.Instr.EnumInit(tid, out_ty, dst.ok_name, ps));
      g = gen_emit(g, ir.Instr.Store(out_slot, ir.v_temp(tid)));
    }
    g = gen_term(g, ir.Term.Br(end_name));
  }

  g = gen_set_block(g, end_idx);
  let rt2: GenNewIdResult = gen_new_temp(g);
  g = rt2.g;
  let out_tid: i32 = rt2.id;
  g = gen_emit(g, ir.Instr.Load(out_tid, out_ty, out_slot));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(out_tid), ty: out_ty };
}

fn gen_expr_as(g0: Gen, a: i32, _tn: ast.TypeName, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let ar: GenExprResult = gen_expr(g, a, -1);
  if !ar.ok { return ar; }
  g = ar.g;

  let from_base: i32 = tc.strip_range(g.ctx, ar.ty);
  let to_base: i32 = tc.strip_range(g.ctx, out_ty);

  // 1) Base cast (i32<->i64). Range types are represented as their base in IR.
  let mut v: ir.Value = ar.val;
  if from_base != to_base {
    let rt: GenNewIdResult = gen_new_temp(g);
    g = rt.g;
    let tid: i32 = rt.id;

    let from_float: bool = tc.is_float_ty(g.ctx, from_base);
    let to_float: bool = tc.is_float_ty(g.ctx, to_base);
    if to_float {
      // int->float and float->float
      g = gen_emit(g, ir.Instr.FloatCast(tid, to_base, from_base, ar.val));
    } else if from_float {
      // float->int (checked at runtime)
      g = gen_emit(g, ir.Instr.IntCastChecked(tid, to_base, from_base, ar.val));
    } else {
      // int->int
      g = gen_emit(g, ir.Instr.IntCastChecked(tid, to_base, from_base, ar.val));
    }
    v = ir.v_temp(tid);
  }

  // 2) Refined cast: add a runtime range check for `@range(..)` targets.
  if tc.is_range_ty(g.ctx, out_ty) {
    let rt2: ir.Ty = ir.ty_pool_get(g.ctx.pool, out_ty);
    g = gen_emit(g, ir.Instr.RangeCheck(to_base, v, rt2.lo, rt2.hi));
  }

  return GenExprResult { ok: true, err: "", g: g, val: v, ty: out_ty };
}

fn gen_expr_block(g0: Gen, b: ast.ExprBlock, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  g.slots = slots_enter(g.slots);
  g.locals = tc.locals_enter(g.locals);
  let mut diverges: bool = false;

  let mut i: i32 = 0;
  while i < b.stmts.len() {
    let r: GenStmtResult = gen_stmt(g, b.stmts.get(i));
    if !r.ok { return GenExprResult { ok: false, err: r.err, g: r.g, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    g = r.g;
    let blk: ir.Block = g.blocks.get(g.cur);
    if blk.has_term {
      diverges = true;
      i = b.stmts.len();
    } else {
      i = i + 1;
    }
  }

  let mut val: ir.Value = ir.v_int(0);
  if !diverges && b.has_tail {
    let er: GenExprResult = gen_expr(g, b.tail, out_ty);
    if !er.ok { return er; }
    g = er.g;
    val = er.val;
  }

  g.locals = tc.locals_exit(g.locals);
  g.slots = slots_exit(g.slots);
  return GenExprResult { ok: true, err: "", g: g, val: val, ty: out_ty };
}

fn gen_expr_int(g0: Gen, text: String, ty: i32, expected: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let rt: GenNewIdResult = gen_new_temp(g);
  g = rt.g;
  let tid: i32 = rt.id;
  let use_ty: i32 = if expected != -1 { expected } else { ty };
  let base: i32 = tc.strip_range(g.ctx, use_ty);
  let bt: ir.Ty = ir.ty_pool_get(g.ctx.pool, base);
  let is_u64_like: bool = match bt.kind { ir.TyKind.U64 => true, ir.TyKind.USize => true, _ => false };
  let mut lit_bits: i64 = 0;
  if is_u64_like {
    let pru: tc.ParseU64DecResult = tc.parse_u64_dec(text);
    if !pru.ok { return GenExprResult { ok: false, err: "integer literal out of range", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    lit_bits = pru.val;
  } else {
    let pr: tc.ParseI64DecResult = tc.parse_i64_dec(text);
    if !pr.ok { return GenExprResult { ok: false, err: "integer literal out of range", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }
    lit_bits = pr.val;
  }
  let vv: ir.Value = ir.v_i64(lit_bits);
  g = gen_emit(g, ir.Instr.Const(tid, use_ty, vv));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: use_ty };
}

fn gen_expr_float(g0: Gen, text: String, ty: i32, expected: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let rt: GenNewIdResult = gen_new_temp(g);
  g = rt.g;
  let tid: i32 = rt.id;
  let use_ty: i32 = if expected != -1 { expected } else { ty };
  let mut lit: String = tc.float_strip_suffix_text(text);
  if use_ty == g.ctx.ty_f32 { lit = lit.concat("f"); }
  g = gen_emit(g, ir.Instr.Const(tid, use_ty, ir.v_float(lit)));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: use_ty };
}

fn gen_expr_bool(g0: Gen, b: bool, ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let rt: GenNewIdResult = gen_new_temp(g);
  g = rt.g;
  let tid: i32 = rt.id;
  g = gen_emit(g, ir.Instr.Const(tid, ty, ir.v_bool(b)));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: ty };
}

fn gen_expr_str(g0: Gen, s: String, ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let rt: GenNewIdResult = gen_new_temp(g);
  g = rt.g;
  let tid: i32 = rt.id;
  g = gen_emit(g, ir.Instr.Const(tid, ty, ir.v_str(s)));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: ty };
}

fn gen_expr_ident(g0: Gen, name: String, ty: i32) -> GenExprResult {
  let sr: LookupSlotResult = slots_lookup(g0.slots, name);
  if !sr.found {
    let lcr: tc.LookupConstResult = tc.locals_lookup_const(g0.locals, name);
    if lcr.found {
      if !lcr.has_val { return GenExprResult { ok: false, err: "unbound const param", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
      let mut g1: Gen = g0;
      let rt0: GenNewIdResult = gen_new_temp(g1);
      g1 = rt0.g;
      let tid0: i32 = rt0.id;
      g1 = gen_emit(g1, ir.Instr.Const(tid0, lcr.ty, ir.v_i64(lcr.iv)));
      return GenExprResult { ok: true, err: "", g: g1, val: ir.v_temp(tid0), ty: lcr.ty };
    }
    // Const reference (inlined; no globals in v0).
    let ni: tc.NamedConstImport = tc.find_named_const(g0.imps.named_consts, name);
    let want_mod: String = if ni.local != "" { ni.mod_path } else { g0.mod_path };
    let want_name: String = if ni.local != "" { ni.name } else { name };
    let cs: tc.ConstSig = tc.find_const(g0.ctx, want_mod, want_name);
    if cs.name == "" { return GenExprResult { ok: false, err: "unknown var/const", g: g0, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    let inl: GenInlineConstResult = gen_inline_const_sig(g0, cs);
    if !inl.ok { return GenExprResult { ok: false, err: inl.err, g: inl.g, val: ir.v_int(0), ty: g0.ctx.ty_bad }; }
    return GenExprResult { ok: true, err: "", g: inl.g, val: inl.val, ty: inl.ty };
  }
  let mut g: Gen = g0;
  let rt: GenNewIdResult = gen_new_temp(g);
  g = rt.g;
  let tid: i32 = rt.id;
  g = gen_emit(g, ir.Instr.Load(tid, ty, sr.slot));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: ty };
}

fn gen_expr_unary(g0: Gen, op: ast.UnaryOp, a: i32, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let ar: GenExprResult = gen_expr(g, a, -1);
  if !ar.ok { return ar; }
  g = ar.g;
  let is_not: bool = match op { ast.UnaryOp.Not => true, _ => false };
  let is_pos: bool = match op { ast.UnaryOp.Pos => true, _ => false };
  if is_pos {
    return GenExprResult { ok: true, err: "", g: g, val: ar.val, ty: out_ty };
  }
  if is_not {
    if out_ty == g.ctx.ty_bool {
      let rt: GenNewIdResult = gen_new_temp(g);
      g = rt.g;
      let tid: i32 = rt.id;
      g = gen_emit(g, ir.Instr.Not(tid, ar.val));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
    }
    if tc.is_int_like_ty(g.ctx, out_ty) {
      let mt: GenNewIdResult = gen_new_temp(g);
      g = mt.g;
      let mid: i32 = mt.id;
      g = gen_emit(g, ir.Instr.Const(mid, out_ty, ir.v_i64(-1)));

      let rt2: GenNewIdResult = gen_new_temp(g);
      g = rt2.g;
      let tid2: i32 = rt2.id;
      g = gen_emit(g, ir.Instr.BinOp(tid2, ir.BinOpKind.BitXor, out_ty, ar.val, ir.v_temp(mid)));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid2), ty: out_ty };
    }
    return GenExprResult { ok: false, err: "unsupported unary ! type", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad };
  }
  // Neg: 0 - x
  let zt: GenNewIdResult = gen_new_temp(g);
  g = zt.g;
  let z: i32 = zt.id;
  let z0: ir.Value = if tc.is_float_ty(g.ctx, out_ty) { ir.v_float("0.0") } else { ir.v_i64(0) };
  g = gen_emit(g, ir.Instr.Const(z, out_ty, z0));
  let rt2: GenNewIdResult = gen_new_temp(g);
  g = rt2.g;
  let tid2: i32 = rt2.id;
  g = gen_emit(g, ir.Instr.BinOp(tid2, ir.BinOpKind.Sub, out_ty, ir.v_temp(z), ar.val));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid2), ty: out_ty };
}

fn gen_expr_binary(g0: Gen, op: ast.BinaryOp, l: i32, r: i32, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  let lr: GenExprResult = gen_expr(g, l, -1);
  if !lr.ok { return lr; }
  g = lr.g;

  // Short-circuit logical ops: do not evaluate RHS eagerly.
  let is_logic: bool = match op { ast.BinaryOp.AndAnd => true, ast.BinaryOp.OrOr => true, _ => false };
  if is_logic {
    return gen_expr_short_circuit_logic(g, op, lr.val, r, out_ty);
  }

  let rr: GenExprResult = gen_expr(g, r, lr.ty);
  if !rr.ok { return rr; }
  g = rr.g;

  // Special-case: enum equality against unit variants lowers to tag comparison.
  let is_eqop: bool = match op { ast.BinaryOp.Eq => true, ast.BinaryOp.Ne => true, _ => false };
  if is_eqop && tc.is_enum_ty(g.ctx, lr.ty) {
    let lt: i32 = enum_unit_tag(g, l, lr.ty);
    let rt: i32 = enum_unit_tag(g, r, lr.ty);
    if lt != -1 || rt != -1 {
      let unit_tag: i32 = if lt != -1 { lt } else { rt };
      let other: ir.Value = if lt != -1 { rr.val } else { lr.val };

      let nt: GenNewIdResult = gen_new_temp(g);
      g = nt.g;
      let tag_id: i32 = nt.id;
      g = gen_emit(g, ir.Instr.EnumTag(tag_id, other));

      let cmp: GenNewIdResult = gen_new_temp(g);
      g = cmp.g;
      let cmp_id: i32 = cmp.id;
      let ck: ir.CmpKind = if match op { ast.BinaryOp.Eq => true, _ => false } { ir.CmpKind.Eq } else { ir.CmpKind.Ne };
      g = gen_emit(g, ir.Instr.Cmp(cmp_id, ck, g.ctx.ty_i32, ir.v_temp(tag_id), ir.v_int(unit_tag)));
      return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(cmp_id), ty: out_ty };
    }
  }

  let is_cmp: bool = match op { ast.BinaryOp.Lt => true, ast.BinaryOp.Le => true, ast.BinaryOp.Gt => true, ast.BinaryOp.Ge => true, ast.BinaryOp.Eq => true, ast.BinaryOp.Ne => true, _ => false };
  if is_cmp {
    let rt: GenNewIdResult = gen_new_temp(g);
    g = rt.g;
    let tid: i32 = rt.id;
    let ck: ir.CmpKind = match op {
      ast.BinaryOp.Lt => ir.CmpKind.Lt,
      ast.BinaryOp.Le => ir.CmpKind.Le,
      ast.BinaryOp.Gt => ir.CmpKind.Gt,
      ast.BinaryOp.Ge => ir.CmpKind.Ge,
      ast.BinaryOp.Eq => ir.CmpKind.Eq,
      _ => ir.CmpKind.Ne,
    };
    g = gen_emit(g, ir.Instr.Cmp(tid, ck, lr.ty, lr.val, rr.val));
    return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
  }

  let rt2: GenNewIdResult = gen_new_temp(g);
  g = rt2.g;
  let tid2: i32 = rt2.id;
  let bk: ir.BinOpKind = match op {
    ast.BinaryOp.Add => ir.BinOpKind.Add,
    ast.BinaryOp.Sub => ir.BinOpKind.Sub,
    ast.BinaryOp.Mul => ir.BinOpKind.Mul,
    ast.BinaryOp.Div => ir.BinOpKind.Div,
    ast.BinaryOp.Mod => ir.BinOpKind.Mod,
    ast.BinaryOp.BitAnd => ir.BinOpKind.BitAnd,
    ast.BinaryOp.BitOr => ir.BinOpKind.BitOr,
    ast.BinaryOp.BitXor => ir.BinOpKind.BitXor,
    ast.BinaryOp.Shl => ir.BinOpKind.Shl,
    _ => ir.BinOpKind.Shr,
  };
  g = gen_emit(g, ir.Instr.BinOp(tid2, bk, out_ty, lr.val, rr.val));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid2), ty: out_ty };
}

fn gen_expr_short_circuit_logic(g0: Gen, op: ast.BinaryOp, lhs: ir.Value, rhs_id: i32, out_ty: i32) -> GenExprResult {
  let mut g: Gen = g0;
  if out_ty != g.ctx.ty_bool { return GenExprResult { ok: false, err: "logical op must be bool", g: g, val: ir.v_int(0), ty: g.ctx.ty_bad }; }

  // Use a slot for the result (matches if-expr lowering pattern).
  let rs: GenNewIdResult = gen_new_slot(g);
  g = rs.g;
  let res_slot: i32 = rs.id;
  g = gen_emit(g, ir.Instr.SlotDecl(res_slot, out_ty));
  g = gen_emit(g, ir.Instr.Store(res_slot, ir.v_bool(false)));

  let base: i32 = g.blocks.len();
  let r_rhs: GenNewIdResult = gen_new_block(g, "logic_rhs_".concat(base.to_string()));
  g = r_rhs.g;
  let rhs_idx: i32 = r_rhs.id;
  let r_sc: GenNewIdResult = gen_new_block(g, "logic_sc_".concat(base.to_string()));
  g = r_sc.g;
  let sc_idx: i32 = r_sc.id;
  let r_end: GenNewIdResult = gen_new_block(g, "logic_end_".concat(base.to_string()));
  g = r_end.g;
  let end_idx: i32 = r_end.id;

  let is_and: bool = match op { ast.BinaryOp.AndAnd => true, _ => false };
  if is_and {
    g = gen_term(g, ir.Term.CondBr(lhs, g.blocks.get(rhs_idx).name, g.blocks.get(sc_idx).name));
  } else {
    g = gen_term(g, ir.Term.CondBr(lhs, g.blocks.get(sc_idx).name, g.blocks.get(rhs_idx).name));
  }

  // Short-circuit block.
  g = gen_set_block(g, sc_idx);
  if is_and {
    g = gen_emit(g, ir.Instr.Store(res_slot, ir.v_bool(false)));
  } else {
    g = gen_emit(g, ir.Instr.Store(res_slot, ir.v_bool(true)));
  }
  g = gen_term(g, ir.Term.Br(g.blocks.get(end_idx).name));

  // RHS block.
  g = gen_set_block(g, rhs_idx);
  let rr: GenExprResult = gen_expr(g, rhs_id, g.ctx.ty_bool);
  if !rr.ok { return rr; }
  g = rr.g;
  g = gen_emit(g, ir.Instr.Store(res_slot, rr.val));
  if !g.blocks.get(g.cur).has_term {
    g = gen_term(g, ir.Term.Br(g.blocks.get(end_idx).name));
  }

  // End block.
  g = gen_set_block(g, end_idx);
  let rt: GenNewIdResult = gen_new_temp(g);
  g = rt.g;
  let tid: i32 = rt.id;
  g = gen_emit(g, ir.Instr.Load(tid, out_ty, res_slot));
  return GenExprResult { ok: true, err: "", g: g, val: ir.v_temp(tid), ty: out_ty };
}

fn enum_unit_tag(g0: Gen, id: i32, enum_ty: i32) -> i32 {
  if !tc.is_enum_ty(g0.ctx, enum_ty) { return -1; }
  let n: ast.ExprNode = ast.expr_pool_get(g0.exprs, id);

  if match n { ast.ExprNode.Call(_c, _ta, _args) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(c, _ta, _args) => c, _ => -1 };
    let targs: Vec[ast.TypeName] = match n { ast.ExprNode.Call(_c, ta, _args) => ta, _ => Vec() };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _ta, a) => a, _ => Vec() };
    if targs.len() == 0 && args.len() == 0 { return enum_unit_tag(g0, callee, enum_ty); }
    return -1;
  }

  let var_name: String = match n {
    ast.ExprNode.DotIdent(s) => s,
    ast.ExprNode.Member(_recv, s) => s,
    _ => "",
  };
  if var_name == "" { return -1; }

  let et: ir.Ty = ir.ty_pool_get(g0.ctx.pool, enum_ty);
  if et.kind != ir.TyKind.Enum { return -1; }
  let fe: tc.FindEnumResult = tc.find_enum(g0.ctx, tc.ty_mod(et), tc.ty_name(et));
  if !fe.found { return -1; }
  let es: tc.EnumSig = fe.sig;
  let mut vi: i32 = 0;
  while vi < es.vars.len() {
    let v: tc.EnumVariantSig = es.vars.get(vi);
    if v.name == var_name {
      if v.fields.len() != 0 { return -1; }
      return vi;
    }
    vi = vi + 1;
  }
  return -1;
}

// Implementations live in gen_cf.vox / gen_member_struct.vox / gen_call_match.vox.
