import "std/testing" as t
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_trait_generic_method_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
  """);
  w = add_mod(w, "main", """
    trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T; }
    struct I { v: i32 }
    impl Wrap for I { fn wrap[T: Eq](x: I, v: T) -> T { return v; } }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let a: i32 = Wrap.wrap[i32](x, 7);
      let b: i32 = I { v: 2 }.wrap[i32](9);
      return a + b;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Wrap$wrap$"));
  t.assert(contains(s, "$gT_3di32"));
}

fn test_irgen_trait_const_generic_method_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }
    struct I { v: i32 }
    impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return AddN.addn[3](x, 4);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$AddN$addn$"));
  t.assert(contains(s, "$gN_3d3_3ai32"));
}

fn test_irgen_trait_const_generic_method_comptime_where_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }
    struct I { v: i32 }
    impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N > 0 { return v + N; } }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return AddN.addn[3](x, 4);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$AddN$addn$"));
  t.assert(contains(s, "$gN_3d3_3ai32"));
}

fn test_irgen_trait_const_generic_method_comptime_where_impl_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }
    struct I { v: i32 }
    impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N >= 0 { return v + N; } }
    fn main() -> i32 { return 0; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}

fn test_irgen_trait_const_generic_method_comptime_where_rhs_reflect_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait FitRU {
      fn fit[T, U](x: Self, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U);
    }
    struct I { v: i32 }
    impl FitRU for I {
      fn fit[T, U](x: I, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U) { return 1; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let y: i64 = 0;
      return FitRU.fit(x, 3, y);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$FitRU$fit$"));
}

fn test_irgen_trait_const_generic_method_comptime_where_rhs_reflect_impl_mismatch_rejected() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait FitRU {
      fn fit[T, U](x: Self, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U);
    }
    struct I { v: i32 }
    impl FitRU for I {
      fn fit[T, U](x: I, a: T, b: U) -> i32 where comptime @size_of(T) < @align_of(U) { return 1; }
    }
    fn main() -> i32 { return 0; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}

fn test_irgen_trait_generic_default_method_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/prelude", """
    pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
    impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
  """);
  w = add_mod(w, "main", """
    trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T { return v; } }
    struct I { v: i32 }
    impl Wrap for I {}
    fn main() -> i32 {
      let x: I = I { v: 1 };
      let a: i32 = Wrap.wrap[i32](x, 7);
      let b: i32 = I { v: 2 }.wrap[i32](9);
      return a + b;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Wrap$wrap$"));
  t.assert(contains(s, "$gT_3di32"));
}

fn test_irgen_generic_bound_trait_method_sugar_monomorphizes_impl_symbol() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    trait Show { fn show(x: Self) -> String; }
    impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
    fn f[T: Show](x: T) -> String { return x.show(); }
    fn main() -> i32 {
      let s: String = f(7);
      return s.len();
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$Show$show"));
  t.assert(contains(s, "f$gT_3di32"));
}

fn test_irgen_trait_static_call_lowers_impl_method_body() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    trait AddOne { fn add_one(x: Self) -> i32; }
    struct I { v: i32 }
    impl AddOne for I {
      fn add_one(x: I) -> i32 { return x.v + 1; }
    }
    fn main() -> i32 {
      let x: I = I { v: 1 };
      return AddOne.add_one(x);
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  t.assert(prog_has_func(r.prog, "impl$main$AddOne$add_one$0"));
}
