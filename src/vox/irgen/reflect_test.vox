import "std/testing" as t
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_type_alias_field_type_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct S { a: i32, b: String }
    enum E { A(i64), B }
    type B = @field_type(S, 1)
    type TA = @field_type(E, 0)
    type TB = @field_type(E, 1)
    fn touch(x: TB) -> i32 { return 0; }
    fn main() -> i32 {
      let x: B = "ok";
      let a: TA = 7;
      return x.len() + (a as i32);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_irgen_type_alias_field_type_generic_nominal_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    struct Pair[T] { a: T, b: T }
    enum Wrap[T] { One(T), None }
    type PA = @field_type(Pair[i32], 0)
    type WA = @field_type(Wrap[i64], 0)
    type WN = @field_type(Wrap[i64], 1)
    fn touch(x: WN) -> i32 { return 0; }
    fn main() -> i32 {
      let a: PA = 3;
      let b: WA = 4;
      return a + (b as i32);
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_irgen_reflect_intrinsic_field_type_id_multi_payload_enum_smoke() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    enum E { A(i32, i64), B(i32, i64), C(i32, i32), D }
    const T0: TypeId = @field_type_id(E, 0)
    const T1: TypeId = @field_type_id(E, 1)
    const T2: TypeId = @field_type_id(E, 2)
    const TD: TypeId = @field_type_id(E, 3)
    const OK0: bool = T0 == T1
    const OK1: bool = T0 != T2
    const OK2: bool = TD == @type(())
    fn main() -> i32 { return if OK0 && OK1 && OK2 { 1 } else { 0 }; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_irgen_reflect_intrinsic_call_lowers_to_const() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> usize { return @size_of(i64); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "const usize 8"));
}

fn test_irgen_reflect_target_intrinsics_lower_to_const() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", """
    const OS: String = @target_os()
    const ARCH: String = @target_arch()
    const PTR: usize = @target_ptr_bits()
    fn main() -> i32 {
      return if OS == "linux" && ARCH == "x86" && PTR == 32 { 1 } else { 0 };
    }
  """);
  let br: tc.BuildCtxResult = tc.build_ctx_with_target(w, 32, "linux", "x86");
  t.assert_with(br.ok, tc.tc_error_to_string(br.err));
  let r: g.GenResult = g.generate_world_with_ctx(w, br.ctx);
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "linux"));
  t.assert(contains(s, "x86"));
  t.assert(contains(s, "const usize 32"));
}

fn test_irgen_compile_error_rejected_with_message() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn main() -> i32 { @compile_error(\"boom\"); return 0; }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(!r.ok);
  t.assert(contains(r.err, "compile_error: boom"));
}
