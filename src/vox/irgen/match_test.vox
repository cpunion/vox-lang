import "std/testing" as t
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_match_bind_pattern_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    enum E { A(i32), None }
    fn main() -> i32 {
      let x: E = E.A(1);
      return match x {
        v => match v {
          E.A(n) => n,
          E.None => 0,
        },
      };
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}
fn test_irgen_match_int_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main(x: i32) -> i32 {
      return match x { 0 => 1, 1 => 2, _ => 3 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}
fn test_irgen_match_negative_int_pattern_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main(x: i32) -> i32 {
      return match x { -1 => 0, _ => 1 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "-1"));
}
fn test_irgen_match_nested_variant_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    enum O { Some(i32), None }
    enum R { Ok(O), Err(i32) }
    fn main(x: R) -> i32 {
      return match x {
        R.Ok(O.Some(v)) => v,
        R.Ok(O.None) => 0,
        R.Err(_) => -1,
      };
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "enum_tag"));
  t.assert(contains(s, "enum_payload"));
}
fn test_irgen_match_u32_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main(x: u32) -> i32 {
      return match x { 0 => 1, 1 => 2, _ => 3 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_eq u32"));
}
fn test_irgen_match_u8_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main(x: u8) -> i32 {
      return match x { 0 => 1, 1 => 2, _ => 3 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_eq u8"));
}
fn test_irgen_match_u64_max_pattern_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main(x: u64) -> i32 {
      return match x { 18446744073709551615 => 1, _ => 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_eq u64"));
}
fn test_irgen_match_i64_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main(x: i64) -> i32 {
      return match x { 3000000000 => 1, _ => 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}
fn test_irgen_match_string_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main(s: String) -> i32 {
      return match s { "a" => 1, _ => 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
}
fn test_irgen_match_bool_patterns_lowers() -> () {
  let mut w: tc.World = tc.world();
  let src: String = """
    fn main(b: bool) -> i32 {
      return match b { true => 1, false => 0 };
    }
  """;
  w = add_mod(w, "main", src);
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "cmp_eq bool"));
}
