import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_short_circuit_andand_lowers_to_cfg() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn rhs() -> bool { panic(\"rhs\"); return true; }\nfn main() -> bool { return false && rhs(); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "condbr "));
  // Source-level && must not lower to eager `and` with both sides evaluated.
  t.assert(!contains(s, " = and "));
}

fn test_irgen_short_circuit_oror_lowers_to_cfg() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn rhs() -> bool { panic(\"rhs\"); return true; }\nfn main() -> bool { return true || rhs(); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert(r.ok);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "condbr "));
  // Source-level || must not lower to eager `or` with both sides evaluated.
  t.assert(!contains(s, " = or "));
}
