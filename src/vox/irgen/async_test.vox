import "std/testing" as t
import "vox/typecheck" as tc
import "vox/irgen" as g
import "vox/ir" as ir

fn test_irgen_preserves_ref_types_in_func_signatures() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "main", "fn id(s: &'static str) -> &'static str { return s; }\nfn bump(x: &mut i32) -> i32 { return x + 1; }\nfn main() -> i32 { let mut v: i32 = 1; let s: &'static str = id(\"x\"); return bump(v) + s.len(); }");
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);

  let mut saw_id: bool = false;
  let mut saw_bump: bool = false;
  let mut i: i32 = 0;
  while i < r.prog.funcs.len() {
    let f: ir.Func = r.prog.funcs.get(i);
    if f.name == "id" {
      saw_id = true;
      t.assert_eq(f.params.len(), 1);
      let p0: ir.Ty = ir.ty_pool_get(r.prog.pool, f.params.get(0).ty);
      let rt: ir.Ty = ir.ty_pool_get(r.prog.pool, f.ret);
      t.assert(p0.kind == ir.TyKind.Ref);
      t.assert(rt.kind == ir.TyKind.Ref);
      t.assert(ir.ty_ref_is_static(p0));
      t.assert(!ir.ty_ref_is_mut(p0));
      t.assert(ir.ty_ref_is_static(rt));
      t.assert(!ir.ty_ref_is_mut(rt));
    }
    if f.name == "bump" {
      saw_bump = true;
      t.assert_eq(f.params.len(), 1);
      let p1: ir.Ty = ir.ty_pool_get(r.prog.pool, f.params.get(0).ty);
      t.assert(p1.kind == ir.TyKind.Ref);
      t.assert(ir.ty_ref_is_mut(p1));
      t.assert(!ir.ty_ref_is_static(p1));
    }
    i = i + 1;
  }

  t.assert(saw_id);
  t.assert(saw_bump);

  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "fn id(...) -> ref(static,str)"));
}
fn test_irgen_async_await_poll_ready_lowers_control_flow() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/async", """
    pub enum Poll[T] { Pending, Ready(T) }
    pub struct Waker { pub token: i64 }
    pub struct Context { pub waker: Waker }
    pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
  """);
  w = add_mod(w, "main", """
    enum Poll[T] { Pending, Ready(T) }
    async fn inc(x: i32) -> i32 {
      let p: Poll[i32] = .Ready(x);
      let y: i32 = p.await;
      return y + 1;
    }
    async fn main() -> i32 { return inc(1).await; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);

  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "enum_tag"));
  t.assert(contains(s, "enum_payload"));
  t.assert(contains(s, "await_pending_"));
  t.assert(contains(s, "Pending"));
  t.assert(!contains(s, "await on Pending is not supported"));
  // D03: await progress is preserved by storing the awaited operand into the async frame.
  t.assert(contains(s, ".a0"));
}
fn test_irgen_async_await_future_impl_lowers_poll_call() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/async", """
    pub enum Poll[T] { Pending, Ready(T) }
    pub struct Waker { pub token: i64 }
    pub struct Context { pub waker: Waker }
    pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
  """);
  w = add_mod(w, "main", """
    import "std/async" as a
    struct C { n: i32 }
    impl a.Future for C {
      type Output = i32;
      fn poll(x: &mut C, _cx: &a.Context) -> a.Poll[i32] { return .Ready(x.n); }
    }
    async fn main() -> i32 {
      let c: C = C { n: 1 };
      let x: i32 = c.await;
      return x + 1;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);

  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "struct_init"));
  t.assert(contains(s, "impl$std.async$Future$poll"));
  t.assert(contains(s, "await_pending_"));
  // D03: poll the stored frame field in-place so Future mutations persist across polls.
  t.assert(contains(s, "addr_of_field_chain"));
  t.assert(contains(s, ".a0"));
}

fn test_irgen_async_multi_await_and_captures_lower_to_frame_fields() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/async", """
    pub enum Poll[T] { Pending, Ready(T) }
    pub struct Waker { pub token: i64 }
    pub struct Context { pub waker: Waker }
    pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
  """);
  w = add_mod(w, "main", """
    enum Poll[T] { Pending, Ready(T) }
    async fn main() -> i32 {
      let x: i32 = 3;
      let p0: Poll[i32] = .Ready(x);
      let y: i32 = p0.await;
      let p1: Poll[i32] = .Ready(x + y);
      let z: i32 = p1.await;
      return z;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);

  let s: String = ir.format_program(r.prog);
  // D03: multiple await points => multiple stored operands.
  t.assert(contains(s, ".a0"));
  t.assert(contains(s, ".a1"));
  // D03: locals used after a suspension point are captured into the frame.
  t.assert(contains(s, ".l_x"));
}

fn test_irgen_async_await_in_if_and_while_body_is_supported() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/async", """
    pub enum Poll[T] { Pending, Ready(T) }
    pub struct Waker { pub token: i64 }
    pub struct Context { pub waker: Waker }
    pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
  """);
  w = add_mod(w, "main", """
    enum Poll[T] { Pending, Ready(T) }
    async fn main() -> i32 {
      let x: i32 = 1;
      let mut y: i32 = 0;
      while y < 2 {
        if y == 0 {
          let p: Poll[i32] = .Ready(x + y);
          y = p.await;
        } else {
          let p2: Poll[i32] = .Ready(x + y);
          y = p2.await;
        }
        let z: i32 = 1;
        y = y + z;
      }
      return y;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);

  let s: String = ir.format_program(r.prog);
  t.assert_with(contains(s, ".a0"), "missing frame field a0");
  t.assert_with(contains(s, ".a1"), "missing frame field a1");
  // D03: `x` crosses suspension and is captured.
  t.assert_with(contains(s, ".l_x"), "missing capture l_x");
  // `y` is redefined from await-ready value before it is read on resumed paths,
  // so capture is optional. `z` is definitely post-resume and must not be captured.
  t.assert_with(!contains(s, ".l_z"), "unexpected capture l_z");
}

fn test_irgen_async_generic_fn_with_explicit_type_arg_is_supported() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/async", """
    pub enum Poll[T] { Pending, Ready(T) }
    pub struct Waker { pub token: i64 }
    pub struct Context { pub waker: Waker }
    pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
  """);
  w = add_mod(w, "main", """
    async fn id[T](x: T) -> T { return x; }
    async fn main() -> i32 { return id[i32](1).await; }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);

  let s: String = ir.format_program(r.prog);
  // Generic instantiations use mangled `$g...` suffixes.
  t.assert(contains(s, "fn id$g"));
  // Async lowering should synthesize an instantiated poll function.
  t.assert(contains(s, "async$poll$"));
  t.assert(contains(s, "__async_frame$"));
}

fn test_irgen_async_trait_method_default_body_is_supported() -> () {
  let mut w: tc.World = tc.world();
  w = add_mod(w, "std/async", """
    pub enum Poll[T] { Pending, Ready(T) }
    pub struct Waker { pub token: i64 }
    pub struct Context { pub waker: Waker }
    pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
  """);
  w = add_mod(w, "main", """
    trait AddOne { async fn add_one(x: Self, v: i32) -> i32 { return v + 1; } }
    struct S { n: i32 }
    impl AddOne for S {}

    async fn main() -> i32 {
      let s: S = S { n: 0 };
      return s.add_one(1).await;
    }
  """);
  let r: g.GenResult = g.generate_world(w);
  t.assert_with(r.ok, r.err);
  let s: String = ir.format_program(r.prog);
  t.assert(contains(s, "impl$main$AddOne$add_one"));
  t.assert(contains(s, "async$poll$"));
  t.assert(contains(s, "__async_frame$"));
}
