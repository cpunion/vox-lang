import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_call_arg_type_mismatch_message() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn f(x: i32) -> i32 { return x; }\nfn main() -> i32 { return f(\"x\"); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "call arg #1 type mismatch"), r.err);
  t.assert_with(contains(r.err, "expected i32"), r.err);
  t.assert_with(contains(r.err, "got String"), r.err);
}

fn test_compile_call_arg_type_mismatch_message_shows_ref_expected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn f(x: &i32) -> i32 { return x + 1; }\nfn main() -> i32 { let s: String = \"x\"; return f(s); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "call arg #1 type mismatch"), r.err);
  t.assert_with(contains(r.err, "expected &i32"), r.err);
  t.assert_with(contains(r.err, "got String"), r.err);
}

fn test_compile_call_arg_type_mismatch_message_shows_ref_mut_expected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn f(x: &mut i32) -> i32 { return x + 1; }\nfn main() -> i32 { let mut s: String = \"x\"; return f(s); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "call arg #1 type mismatch"), r.err);
  t.assert_with(contains(r.err, "expected &mut i32"), r.err);
  t.assert_with(contains(r.err, "got String"), r.err);
}

fn test_compile_non_generic_fn_type_args_message() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn f(x: i32) -> i32 { return x; }\nfn main() -> i32 { return f[i32](1); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "non-generic function does not accept type args"), r.err);
}

fn test_compile_member_unknown_field_message() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct S { x: i32 }\nfn main() -> i32 { let s: S = S { x: 1 }; return s.y; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "unknown field: y"), r.err);
}

fn test_compile_struct_lit_field_type_mismatch_message() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct S { x: i32 }\nfn main() -> i32 { let s: S = S { x: \"x\" }; return s.x; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "struct field type mismatch: x"), r.err);
  t.assert_with(contains(r.err, "expected i32"), r.err);
  t.assert_with(contains(r.err, "got String"), r.err);
}

fn test_compile_enum_ctor_unknown_variant_message() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "enum E { A(i32), B }\nfn main() -> i32 { let e: E = E.C(7); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "unknown enum variant: E.C"), r.err);
}

fn test_compile_enum_ctor_arg_type_mismatch_message() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "enum E { A(i32) }\nfn main() -> i32 { let e: E = E.A(\"x\"); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "enum ctor E.A arg #1 type mismatch"), r.err);
  t.assert_with(contains(r.err, "expected i32"), r.err);
  t.assert_with(contains(r.err, "got String"), r.err);
}

fn test_compile_enum_payload_equality_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "enum E { A(i32), None }\nfn main() -> i32 { let a: E = E.A(1); let b: E = E.A(1); return if a == b { 1 } else { 0 }; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_enum_eq_"));
}

fn test_compile_struct_equality_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "struct S { a: i32, b: String }\nfn main() -> i32 { let x: S = S { a: 1, b: \"x\" }; let y: S = S { a: 1, b: \"x\" }; return if x == y { 1 } else { 0 }; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_struct_eq_"));
}
