import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg


fn test_compile_panic_bang_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 { if false { panic!(\"boom\"); } return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_assert_bang_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn assert(cond: bool) -> () { if !cond { panic(\"bad\"); } }\nfn main() -> i32 { assert!(true); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_assert_bang_with_msg_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn assert_with(cond: bool, msg: String) -> () { if !cond { panic(msg); } }\nfn main() -> i32 { assert!(true, \"ok\"); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_assert_bang_with_msg_member_callee_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/dep/dep.vox",
    text: "pub fn assert_with(cond: bool, msg: String) -> () { if !cond { panic(msg); } }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"dep\" as dep\nfn main() -> i32 { dep.assert!(true, \"ok\"); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_assert_bang_bad_arity_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 { assert!(); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(compile_contains(r.err, "assert! expects one or two value args"));
}

fn test_compile_assert_cmp_bang_calls_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn assert_eq(a: i32, b: i32) -> () {}
      fn assert_ne(a: i32, b: i32) -> () {}
      fn assert_lt(a: i32, b: i32) -> () {}
      fn assert_le(a: i32, b: i32) -> () {}
      fn assert_gt(a: i32, b: i32) -> () {}
      fn assert_ge(a: i32, b: i32) -> () {}
      fn main() -> i32 {
        assert_eq!(1, 1);
        assert_ne!(1, 2);
        assert_lt!(1, 2);
        assert_le!(1, 1);
        assert_gt!(2, 1);
        assert_ge!(2, 2);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_assert_cmp_bang_member_callee_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/dep/dep.vox",
    text: """
      pub fn assert_eq(a: i32, b: i32) -> () {}
      pub fn assert_ne(a: i32, b: i32) -> () {}
      pub fn assert_lt(a: i32, b: i32) -> () {}
      pub fn assert_le(a: i32, b: i32) -> () {}
      pub fn assert_gt(a: i32, b: i32) -> () {}
      pub fn assert_ge(a: i32, b: i32) -> () {}
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "dep" as dep
      fn main() -> i32 {
        dep.assert_eq!(1, 1);
        dep.assert_ne!(1, 2);
        dep.assert_lt!(1, 2);
        dep.assert_le!(1, 1);
        dep.assert_gt!(2, 1);
        dep.assert_ge!(2, 2);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_assert_eq_bang_bad_arity_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 { assert_eq!(1); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(compile_contains(r.err, "assert_eq! expects exactly two value args and no type args"));
}

fn test_compile_panic_bang_bad_arity_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 { panic!(\"a\", \"b\"); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(compile_contains(r.err, "panic! expects exactly one value arg"));
}

fn test_compile_compile_error_bang_reports_message() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 { compile_error!(\"boom\"); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(compile_contains(r.err, "boom"));
}

fn test_compile_compile_error_bang_bad_arity_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 { compile_error!(\"a\", \"b\"); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(compile_contains(r.err, "compile_error! expects exactly one value arg"));
}
