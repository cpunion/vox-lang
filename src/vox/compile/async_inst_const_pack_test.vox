import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn std_async_min_file() -> ld.SourceFile {
  return ld.SourceFile {
    path: "src/std/async/async.vox",
    text: """
      pub enum Poll[T] { Pending, Ready(T) }
      pub struct Waker { pub token: i64 }
      pub struct Context { pub waker: Waker }
      pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
      pub fn waker(token: i64) -> Waker { return Waker { token: token }; }
      pub fn context(w: Waker) -> Context { return Context { waker: w }; }
    """,
  };
}

fn test_compile_async_const_generic_fn_call_with_await_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_min_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn addn[const N: i32](x: i32) -> i32 { return x + N; }
      async fn main() -> i32 { return addn[2](40).await; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_async_type_pack_fn_call_with_await_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_min_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn keep[T...]() -> i32 { return 7; }
      async fn main() -> i32 { return keep[i32, String]().await; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert_with(r.ok, r.err);
}
