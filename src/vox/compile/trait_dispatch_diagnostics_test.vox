import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_trait_method_name_conflicts_assoc_type_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; fn Item(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn Item(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "trait method conflicts with associated type"));
  t.assert(contains(r.err, "Item"));
}

fn test_compile_trait_method_sugar_ambiguous_rejected_with_candidates() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { fn show(x: Self) -> String; }
      trait B { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl A for I { fn show(x: I) -> String { return "a"; } }
      impl B for I { fn show(x: I) -> String { return "b"; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let _s: String = x.show(); return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "ambiguous trait method call"));
  t.assert(contains(r.err, "A.show"));
  t.assert(contains(r.err, "B.show"));
}

fn test_compile_trait_call_unknown_method_rejected_with_candidates() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; fn debug(x: Self) -> String; }
      struct I { v: i32 }
      impl Show for I { fn show(x: I) -> String { return "ok"; } fn debug(x: I) -> String { return "dbg"; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let _s: String = Show.missing(x); return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "unknown trait method"));
  t.assert(contains(r.err, "available methods"));
  t.assert(contains(r.err, "show"));
  t.assert(contains(r.err, "debug"));
}

fn test_compile_impl_missing_required_method_reports_candidates() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Show { fn show(x: Self) -> String; fn debug(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I { fn show(x: I) -> String { return \"ok\"; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl missing trait method"));
  t.assert(contains(r.err, "required methods"));
  t.assert(contains(r.err, "show"));
  t.assert(contains(r.err, "debug"));
}

fn test_compile_impl_extra_method_reports_candidates() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Show { fn show(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I { fn show(x: I) -> String { return \"ok\"; } fn debug(x: I) -> String { return \"dbg\"; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl method not in trait"));
  t.assert(contains(r.err, "available methods"));
  t.assert(contains(r.err, "show"));
}
