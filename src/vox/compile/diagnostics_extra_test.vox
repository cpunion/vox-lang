import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_type_error_has_file_line_col_prefix() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  // Put the error at a stable location: line 2, col 1.
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 {\nnope();\nreturn 0;\n}" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "[E_TYPE_0001]"));
  t.assert(r.err_kind == c.compile_diag_kind_type());
  t.assert(r.err_code == "E_TYPE_0001");
  t.assert(contains(r.err_message, "unknown fn"));
}

fn test_compile_type_error_column_uses_rune_index() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 {\n\"ä½ \"; nope();\nreturn 0;\n}" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:6:"));
  t.assert(contains(r.err, "[E_TYPE_0001]"));
}

fn test_compile_duplicate_trait_reports_decl_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "trait A {}\ntrait A {}\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "duplicate trait"));
}

fn test_compile_type_error_message_includes_reason() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 {\nnope();\nreturn 0;\n}" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "unknown fn"));
  t.assert(contains(r.err, "nope"));
}

fn test_compile_collect_call_type_arg_error_reports_call_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn id[T](x: T) -> T { return x; }\nfn main() -> i32 {\nid[Missing](1);\nreturn 0;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    std_root: "src/std",
  });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:3:1:"));
  t.assert(contains(r.err, "type resolve failed in call type arg"));
}

fn test_compile_collect_resource_conflict_reports_attr_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "@resource(read, Fs)\n@resource(write, Fs)\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    std_root: "src/std",
  });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:1:1:"));
  t.assert(contains(r.err, "resource cannot be both read and write"));
}
