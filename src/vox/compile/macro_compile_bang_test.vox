import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn compile_contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn compile_deep_macro_expr(depth: i32) -> String {
  let mut out: String = "1";
  let mut i: i32 = 0;
  while i < depth {
    out = "id!(".concat(out).concat(")");
    i = i + 1;
  }
  return out;
}

fn test_compile_macro_call_reports_unimplemented_expand() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 { return add1!(41); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(compile_contains(r.err, "unknown fn"));
  t.assert(compile_contains(r.err, "add1"));
  t.assert(compile_contains(r.err, "[macroexpand]"));
  t.assert(compile_contains(r.err, "inline skipped"));
  t.assert(compile_contains(r.err, "callee function not found"));
}

fn test_compile_const_macro_call_reports_unimplemented_expand() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "const X: i32 = add1!(41)\nfn main() -> i32 { return X; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(compile_contains(r.err, "unknown fn"));
  t.assert(compile_contains(r.err, "add1"));
  t.assert(compile_contains(r.err, "[macroexpand]"));
  t.assert(compile_contains(r.err, "inline skipped"));
  t.assert(compile_contains(r.err, "callee function not found"));
}

fn test_compile_compile_bang_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 { return compile!(1 + 2); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_nested_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 { return compile!(compile!(1 + 2)); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_ast_expr_fn_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn add1(x: AstExpr) -> AstExpr { return x + 1; }\nfn main() -> i32 { return compile!(add1(41)); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_cross_module_ast_expr_fn_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn add1(x: AstExpr) -> AstExpr { return x + 1; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"dep\" as dep\nfn main() -> i32 { return compile!(dep.add1(41)); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_named_import_ast_expr_fn_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn add1(x: AstExpr) -> AstExpr { return x + 1; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { add1 as inc } from \"dep\"\nfn main() -> i32 { return compile!(inc(41)); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_named_import_ast_expr_fn_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn add1(x: AstExpr) -> AstExpr { return x + 1; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { add1 as inc } from \"dep\"\nfn main() -> i32 { return inc!(41); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_named_import_generic_macro_fn_type_args_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn id[T](x: T) -> T { return x; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { id as inc } from \"dep\"\nfn main() -> i32 { return inc[i32]!(7); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_named_import_generic_macro_fn_missing_type_args_fallback_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn id[T](x: T) -> T { return x; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { id as inc } from \"dep\"\nfn main() -> i32 { return inc!(7); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_member_generic_macro_fn_missing_type_args_fallback_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn id[T](x: T) -> T { return x; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"dep\" as dep\nfn main() -> i32 { return dep.id!(7); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_macro_fn_missing_type_args_fallback_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn addn[const N: i32 = 2](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn!(40); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_named_import_const_generic_macro_fn_missing_type_args_fallback_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn addn[const N: i32 = 2](x: i32) -> i32 { return x + N; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { addn as inc } from \"dep\"\nfn main() -> i32 { return inc!(40); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_member_const_generic_macro_fn_missing_type_args_fallback_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn addn[const N: i32 = 2](x: i32) -> i32 { return x + N; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"dep\" as dep\nfn main() -> i32 { return dep.addn!(40); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_named_import_const_generic_macro_fn_value_substitution_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn addn[const N: i32](x: i32) -> i32 { return x + N; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { addn as inc } from \"dep\"\nfn main() -> i32 { return inc[3]!(40); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_named_import_const_generic_ast_expr_fn_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn addn[const N: i32](x: AstExpr) -> AstExpr { return x + N; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { addn as inc } from \"dep\"\nfn main() -> i32 { return compile!(inc[3](40)); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_member_const_generic_ast_expr_fn_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn addn[const N: i32](x: AstExpr) -> AstExpr { return x + N; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"dep\" as dep\nfn main() -> i32 { return compile!(dep.addn[3](40)); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_const_generic_ast_expr_fn_call_default_arg_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn addn[const N: i32 = 2](x: AstExpr) -> AstExpr { return x + N; }\nfn main() -> i32 { return compile!(addn(40)); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_named_import_const_generic_ast_expr_fn_call_default_arg_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn addn[const N: i32 = 2](x: AstExpr) -> AstExpr { return x + N; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { addn as inc } from \"dep\"\nfn main() -> i32 { return compile!(inc(40)); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_member_const_generic_ast_expr_fn_call_default_arg_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn addn[const N: i32 = 2](x: AstExpr) -> AstExpr { return x + N; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"dep\" as dep\nfn main() -> i32 { return compile!(dep.addn(40)); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_ast_expr_fn_call_can_expand_nested_macros_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn add1(x: AstExpr) -> AstExpr { return x + 1; }\nfn add2(x: AstExpr) -> AstExpr { return add1!(add1!(x)); }\nfn main() -> i32 { return compile!(add2(40)); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_cross_module_ast_expr_fn_call_can_expand_nested_macros_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/dep/dep.vox",
    text: "pub fn add1(x: AstExpr) -> AstExpr { return x + 1; }\npub fn add2(x: AstExpr) -> AstExpr { return add1!(add1!(x)); }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"dep\" as dep\nfn main() -> i32 { return compile!(dep.add2(40)); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_const_init_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "const X: i32 = compile!(1 + 2)\nfn main() -> i32 { return X; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_macro_call_sugar_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn add1(x: i32) -> i32 { return x + 1; }\nconst X: i32 = add1!(41)\nfn main() -> i32 { return X; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_macro_call_sugar_and_compile_bang_compose_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn add1(x: i32) -> i32 { return compile!(x + 1); }\nfn main() -> i32 { return add1!(41); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ast_expr_macro_fn_exec_and_strip_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn add1(x: AstExpr) -> AstExpr { return x + 1; }\nfn main() -> i32 { return add1!(41); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_quote_unquote_mvp_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn add1(x: AstExpr) -> AstExpr { return quote!(unquote!(x) + 1); }\nfn main() -> i32 { return add1!(41); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_quote_bang_bad_arity_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 { return quote!(1, 2); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(compile_contains(r.err, "quote! expects exactly one value arg"));
}

fn test_compile_deep_user_macro_chain_smoke() -> () {
  let expr: String = compile_deep_macro_expr(80);
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn id(x: i32) -> i32 { return x; }\nfn main() -> i32 { return ".concat(expr).concat("; }"),
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_trait_default_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait A { fn a(x: Self) -> i32 { return compile!(1 + 2); } }\nimpl A for i32 {}\nfn main() -> i32 { return A.a(1); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_compile_bang_impl_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait A { fn a(x: Self) -> i32; }\nimpl A for i32 { fn a(x: i32) -> i32 { return compile!(x + 1); } }\nfn main() -> i32 { return A.a(1); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
