import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn count_substr(hay: String, needle: String) -> i32 {
  if needle.len() == 0 { return 0; }
  if hay.len() < needle.len() { return 0; }
  let mut n: i32 = 0;
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle {
      n = n + 1;
      i = i + needle.len();
    } else {
      i = i + 1;
    }
  }
  return n;
}

fn std_async_file() -> ld.SourceFile {
  return ld.SourceFile {
    path: "src/std/async/async.vox",
    text: """
      pub enum Poll[T] { Pending, Ready(T) }
      pub struct Waker { pub token: i64 }
      pub struct Context { pub waker: Waker }
      pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
      pub fn waker(token: i64) -> Waker { return Waker { token: token }; }
      pub fn context(w: Waker) -> Context { return Context { waker: w }; }
      pub fn spin_wait(i: i32) -> () { return; }
      pub fn pending_wait(i: i32, c: Context) -> () { spin_wait(i); return; }
    """,
  };
}

fn std_async_file_with_park() -> ld.SourceFile {
  return ld.SourceFile {
    path: "src/std/async/async.vox",
    text: """
      pub enum Poll[T] { Pending, Ready(T) }
      pub struct Waker { pub token: i64 }
      pub struct Context { pub waker: Waker }
      pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
      pub fn waker(token: i64) -> Waker { return Waker { token: token }; }
      pub fn context(w: Waker) -> Context { return Context { waker: w }; }
      pub fn spin_wait(i: i32) -> () { return; }
      pub fn park(i: i32, c: Context) -> () { return; }
    """,
  };
}

fn std_async_file_with_park_until_wake() -> ld.SourceFile {
  return ld.SourceFile {
    path: "src/std/async/async.vox",
    text: """
      pub enum Poll[T] { Pending, Ready(T) }
      pub struct Waker { pub token: i64 }
      pub struct Context { pub waker: Waker }
      pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
      pub fn waker(token: i64) -> Waker { return Waker { token: token }; }
      pub fn context(w: Waker) -> Context { return Context { waker: w }; }
      pub fn park_until_wake(i: i32, c: Context) -> bool { return false; }
    """,
  };
}

fn std_async_file_with_cancel_requested() -> ld.SourceFile {
  return ld.SourceFile {
    path: "src/std/async/async.vox",
    text: """
      pub enum Poll[T] { Pending, Ready(T) }
      pub struct Waker { pub token: i64 }
      pub struct Context { pub waker: Waker }
      pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
      pub fn waker(token: i64) -> Waker { return Waker { token: token }; }
      pub fn context(w: Waker) -> Context { return Context { waker: w }; }
      pub fn park(i: i32, c: Context) -> () { return; }
      pub fn cancel_requested(c: Context) -> bool { return false; }
    """,
  };
}

fn std_async_file_with_runtime_hooks() -> ld.SourceFile {
  return ld.SourceFile {
    path: "src/std/async/async.vox",
    text: """
      pub enum Poll[T] { Pending, Ready(T) }
      pub struct Waker { pub token: i64 }
      pub struct Context { pub waker: Waker }
      pub struct Rt { pub id: i32 }
      pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
      pub fn waker(token: i64) -> Waker { return Waker { token: token }; }
      pub fn context(w: Waker) -> Context { return Context { waker: w }; }
      pub fn default_runtime() -> Rt { return Rt { id: 1 }; }
      pub fn park_until_wake_with(rt: Rt, i: i32, c: Context) -> bool { rt; i; c; return false; }
      pub fn park_until_wake(i: i32, c: Context) -> bool { i; c; return false; }
      pub fn cancel_requested_with(rt: Rt, c: Context) -> bool { rt; c; return true; }
      pub fn cancel_requested(c: Context) -> bool { c; return true; }
    """,
  };
}

fn std_async_file_spin_only() -> ld.SourceFile {
  return ld.SourceFile {
    path: "src/std/async/async.vox",
    text: """
      pub enum Poll[T] { Pending, Ready(T) }
      pub struct Waker { pub token: i64 }
      pub struct Context { pub waker: Waker }
      pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
      pub fn waker(token: i64) -> Waker { return Waker { token: token }; }
      pub fn context(w: Waker) -> Context { return Context { waker: w }; }
      pub fn spin_wait(i: i32) -> () { return; }
    """,
  };
}

fn std_async_file_without_spin_wait() -> ld.SourceFile {
  return ld.SourceFile {
    path: "src/std/async/async.vox",
    text: """
      pub enum Poll[T] { Pending, Ready(T) }
      pub struct Waker { pub token: i64 }
      pub struct Context { pub waker: Waker }
      pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
      pub fn waker(token: i64) -> Waker { return Waker { token: token }; }
      pub fn context(w: Waker) -> Context { return Context { waker: w }; }
    """,
  };
}

fn test_compile_async_fn_without_await_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn inc(x: i32) -> i32 { return x + 1; }
      async fn main() -> i32 { return inc(41).await; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    // Driver main is sync wrapper over async main polling loop.
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}
fn test_compile_async_fn_with_await_poll_ready_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Poll[T] { Pending, Ready(T) }
      async fn inc(x: i32) -> i32 {
        let p: Poll[i32] = .Ready(x);
        let y: i32 = p.await;
        return y + 1;
      }
      async fn main() -> i32 { return inc(41).await; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_async_fn_with_nested_await_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Poll[T] { Pending, Ready(T) }
      async fn main() -> i32 {
        let pp: Poll[Poll[i32]] = .Ready(.Ready(7));
        let x: i32 = pp.await.await;
        return x;
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_async_fn_allows_let_shadowing_across_await_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/async" as a
      async fn main() -> i32 {
        let x: i32 = 1;
        let p0: a.Poll[i32] = .Ready(x);
        let y: i32 = p0.await;
        if true {
          let x: i32 = y + 1;
          let p1: a.Poll[i32] = .Ready(x);
          let z: i32 = p1.await;
          return z;
        }
        return x + y;
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_async_fn_with_await_future_impl_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/async" as a
      struct C { n: i32 }
      impl a.Future for C {
        type Output = i32;
        fn poll(x: &mut C, _cx: &a.Context) -> a.Poll[i32] { return .Ready(x.n); }
      }
      async fn main() -> i32 {
        let c: C = C { n: 1 };
        let x: i32 = c.await;
        return x + 1;
      }
  """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}
fn test_compile_async_fn_allows_postfix_await_then_try_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Result[T, E] { Ok(T), Err(E) }
      enum Poll[T] { Pending, Ready(T) }
      async fn main() -> Result[i32, i32] {
        let p: Poll[Result[i32, i32]] = .Ready(.Ok(1));
        let x: i32 = p.await?;
        return .Ok(x + 1);
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    // Driver main only supports primitive returns; we only need compile+typecheck here.
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_async_fn_allows_await_inside_try_block_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/async" as a
      enum Result[T, E] { Ok(T), Err(E) }

      async fn main() -> Result[i32, i32] {
        let r: Result[i32, i32] = try {
          let p: a.Poll[Result[i32, i32]] = .Ready(.Ok(1));
          let v: i32 = p.await?;
          v + 1
        };
        return r;
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_async_fn_allows_await_in_macro_arg_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/async" as a
      fn assert(cond: bool) -> () { if !cond { panic("bad"); } }
      async fn main() -> i32 {
        let p: a.Poll[i32] = .Ready(1);
        assert!(p.await == 1);
        return 0;
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_async_main_with_driver_main_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn main() -> i32 { return 7; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_async_main_driver_uses_pending_wait_hook_when_available() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn main() -> i32 { return 7; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
  t.assert(count_substr(r.c, "pending_5fwait(") >= 3);
}

fn test_compile_async_main_driver_uses_park_hook_when_available() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file_with_park());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn main() -> i32 { return 7; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
  t.assert(contains(r.c, "park("));
}

fn test_compile_async_main_driver_uses_park_until_wake_hook_when_available() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file_with_park_until_wake());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn main() -> i32 { return 7; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
  t.assert(contains(r.c, "park_5funtil_5fwake("));
}

fn test_compile_async_main_driver_prefers_runtime_with_hooks_when_available() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file_with_runtime_hooks());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn main() -> i32 { return 7; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
  t.assert(contains(r.c, "default_5fruntime("));
  t.assert(contains(r.c, "park_5funtil_5fwake_5fwith("));
}

fn test_compile_async_main_driver_keeps_compat_without_spin_wait() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file_without_spin_wait());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn main() -> i32 { return 7; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
  t.assert(!contains(r.c, "spin_wait"));
}

fn test_compile_async_main_driver_falls_back_to_spin_wait_when_pending_wait_absent() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file_spin_only());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn main() -> i32 { return 7; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
  t.assert(count_substr(r.c, "spin_5fwait(") >= 3);
}

fn test_compile_async_test_wrapper_uses_pending_wait_hook_when_available() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn test_async_smoke() -> () { return; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: true,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
  t.assert(count_substr(r.c, "pending_5fwait(") >= 3);
}

fn test_compile_async_test_wrapper_uses_park_hook_when_available() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file_with_park());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn test_async_smoke() -> () { return; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: true,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
  t.assert(contains(r.c, "park("));
}

fn test_compile_async_test_wrapper_uses_park_until_wake_hook_when_available() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file_with_park_until_wake());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn test_async_smoke() -> () { return; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: true,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
  t.assert(contains(r.c, "park_5funtil_5fwake("));
}

fn test_compile_async_test_wrapper_prefers_runtime_with_hooks_when_available() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file_with_runtime_hooks());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn test_async_smoke() -> () { return; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: true,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
  t.assert(contains(r.c, "default_5fruntime("));
  t.assert(contains(r.c, "park_5funtil_5fwake_5fwith("));
  t.assert(contains(r.c, "cancel_5frequested_5fwith("));
}

fn test_compile_async_main_driver_checks_cancel_hook_when_available() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file_with_cancel_requested());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn main() -> i32 { return 7; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
  t.assert(contains(r.c, "cancel_5frequested("));
  t.assert(!contains(r.c, "async cancelled"));
}

fn test_compile_async_main_driver_prefers_runtime_cancel_hook_when_available() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file_with_runtime_hooks());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      async fn main() -> i32 { return 7; }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
  t.assert(contains(r.c, "cancel_5frequested_5fwith("));
  t.assert(!contains(r.c, "async cancelled"));
}

fn test_compile_async_match_expr_with_await_in_arms_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/async" as a
      async fn main() -> i32 {
        let p: a.Poll[i32] = a.Poll.Ready(1);
        let x: i32 = match p {
          a.Poll.Ready(v) => {
            let q0: a.Poll[i32] = a.Poll.Ready(v + 1);
            q0.await
          },
          a.Poll.Pending => {
            let q1: a.Poll[i32] = a.Poll.Ready(0);
            q1.await
          },
        };
        return x;
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_async_nested_if_expr_with_await_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/async" as a

      async fn main() -> i32 {
        let p: a.Poll[i32] = .Ready(1);
        let x: i32 = 10 + (if true { p.await } else { 0 });
        return x;
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_async_nested_match_expr_with_await_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/async" as a

      async fn main() -> i32 {
        let p: a.Poll[i32] = .Ready(1);
        let x: i32 = 20 + (match p {
          a.Poll.Ready(v) => {
            let q: a.Poll[i32] = a.Poll.Ready(v + 1);
            q.await
          },
          a.Poll.Pending => 0,
        });
        return x;
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}
