import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_type_alias_field_type_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct S { a: i32, b: String }
      enum E { A(i64), B }
      type B = @field_type(S, 1)
      type TA = @field_type(E, 0)
      type TB = @field_type(E, 1)
      fn touch(x: TB) -> i32 { return 0; }
      fn main() -> i32 {
        let x: B = "ok";
        let a: TA = 7;
        return x.len() + (a as i32);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_type_alias_field_type_generic_nominal_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Pair[T] { a: T, b: T }
      enum Wrap[T] { One(T), None }
      type PA = @field_type(Pair[i32], 0)
      type WA = @field_type(Wrap[i64], 0)
      type WN = @field_type(Wrap[i64], 1)
      fn touch(x: WN) -> i32 { return 0; }
      fn main() -> i32 {
        let a: PA = 3;
        let b: WA = 4;
        return a + (b as i32);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_type_alias_field_type_multi_payload_enum_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum E { A(i32, i64), B }
      type T = @field_type(E, 0)
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
}

fn test_compile_union_type_alias_match_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "type Value = I32: i32 | Str: String\nfn main() -> i32 { let x: Value = Value.I32(7); return match x { .I32(v) => v, .Str(_s) => 0 }; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}
