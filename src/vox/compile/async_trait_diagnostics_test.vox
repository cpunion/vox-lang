import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn compile_main(src: String) -> c.CompileResult {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: src });
  return c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    std_root: "src/std",
  });
}

fn test_compile_async_trait_impl_requires_async_fn_keyword() -> () {
  let r: c.CompileResult = compile_main("""
    trait Work { async fn run(x: Self) -> i32; }
    struct S { v: i32 }
    impl Work for S {
      fn run(x: S) -> i32 { return x.v; }
    }
    fn main() -> i32 { return 0; }
  """);
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "impl must use async fn to implement async trait method"), r.err);
}

fn test_compile_async_trait_impl_output_type_mismatch_rejected() -> () {
  let r: c.CompileResult = compile_main("""
    trait Work { async fn run(x: Self) -> i32; }
    struct S { v: i32 }
    impl Work for S {
      async fn run(x: S) -> String { return "bad"; }
    }
    fn main() -> i32 { return 0; }
  """);
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "impl async method output type mismatch"), r.err);
}
