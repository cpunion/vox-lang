import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_variadic_call_pack_args_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn sum(xs: i32...) -> i32 { return xs.len(); }\nfn main() -> i32 { return sum(1, 2, 3); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_push("));
}

fn test_compile_variadic_call_generic_pack_args_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn first[T](head: T, tail: T...) -> T { return head; }\nfn main() -> i32 { return first(7, 8, 9); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_push("));
}

fn test_compile_variadic_call_explicit_vec_arg_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn sum(xs: i32...) -> i32 { return xs.len(); }
      fn main() -> i32 {
        let xs: Vec[i32] = Vec();
        return sum(xs);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_variadic_generic_with_explicit_type_and_const_pack_vs_vec_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  let src: String = """
    fn take[T, const N: i32](head: T, tail: T...) -> T { return head; }
    fn main() -> i32 {
      let mut xs: Vec[i32] = Vec();
      xs.push(8);
      xs.push(9);
      let a: i32 = take[i32, 3](7, 8, 9);
      let b: i32 = take[i32, 3](7, xs);
      return a + b;
    }
  """;
  fs.push(ld.SourceFile { path: "src/main.vox", text: src });

  let r0: c.CompileResult = c.compile_main_text_to_c(src, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r0.ok, "compile_main_text_to_c failed:\n".concat(r0.err));

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, "compile_files_to_c failed:\n".concat(r.err));
  t.assert(contains(r.c, "vox_vec_push("));
}
