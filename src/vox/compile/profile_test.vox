import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn contains_profile(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn test_compile_files_to_c_profile_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return 0; }" });

  let pr: c.CompileProfileResult =
    c.compile_files_to_c_profile(
      fs,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() },
    );
  t.assert(pr.r.ok);
  t.assert(pr.p.load_ns >= 0);
  t.assert(pr.p.macroexpand_ns >= 0);
  t.assert(pr.p.rewrite_async_ns >= 0);
  t.assert(pr.p.typecheck_ns >= 0);
  t.assert(pr.p.irgen_ns >= 0);
  t.assert(pr.p.ir_verify_ns >= 0);
  t.assert(pr.p.codegen_ns >= 0);
}

fn test_compile_files_to_c_profile_ptr_bits_32_enforced() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> usize { let x: usize = 4294967296; return x; }" });

  let pr: c.CompileProfileResult =
    c.compile_files_to_c_profile_for_ptr_bits(
      fs,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() },
      32,
    );
  t.assert(!pr.r.ok);
  t.assert(contains_profile(pr.r.err, "usize literal out of range"));
}
