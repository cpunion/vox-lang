import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_trait_static_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl Show for I { fn show(x: I) -> String { return "ok"; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = Show.show(x); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Show$show$0")));
}
fn test_compile_impl_specialization_prefers_more_specific_impl_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T] Tag for Vec[T] { fn tag(x: Vec[T]) -> i32 { return 1; } }
      impl Tag for Vec[i32] { fn tag(x: Vec[i32]) -> i32 { return 2; } }
      fn main() -> i32 { let mut vi: Vec[i32] = Vec(); let mut vs: Vec[String] = Vec(); vi.push(7); vs.push("x"); return Tag.tag(vi) + Tag.tag(vs); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Tag$tag$1")));
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Tag$tag$0$gT_3dString")));
}
fn test_compile_impl_specialization_requires_strict_order_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T] Tag for Vec[T] { fn tag(x: Vec[T]) -> i32 { return 1; } }
      impl[U] Tag for Vec[U] { fn tag(x: Vec[U]) -> i32 { return 2; } }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); return Tag.tag(v); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "overlapping impl without strict specialization"));
  t.assert(contains(r.err, "rank_trace:"));
}
fn test_compile_impl_specialization_prefers_stronger_bounds_and_filters_non_matching_bounds_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T] Tag for T { fn tag(x: T) -> i32 { return 1; } }
      impl[T: Eq] Tag for T { fn tag(x: T) -> i32 { return 2; } }
      fn main() -> i32 { return Tag.tag(7) + Tag.tag("x"); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_impl_specialization_incomparable_bounds_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { fn a(x: Self) -> i32; }
      trait B { fn b(x: Self) -> i32; }
      impl A for i32 { fn a(x: i32) -> i32 { return x; } }
      impl B for i32 { fn b(x: i32) -> i32 { return x; } }
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T: A] Tag for T { fn tag(x: T) -> i32 { return 1; } }
      impl[T: B] Tag for T { fn tag(x: T) -> i32 { return 2; } }
      fn main() -> i32 { return Tag.tag(1); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "overlapping impl without strict specialization"));
  t.assert(contains(r.err, "rank_trace:"));
}
fn test_compile_impl_unconstrained_head_type_param_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T, U: Eq] Tag for T { fn tag(x: T) -> i32 { return 1; } }
      fn main() -> i32 { return Tag.tag(7); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl type param is unconstrained by impl target type: U"));
}

fn test_compile_impl_specialization_prefers_head_where_comptime_superset_bounds_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T] Tag for Vec[T] where comptime @size_of(T) <= 16 {
        fn tag(x: Vec[T]) -> i32 { return 1; }
      }
      impl[T] Tag for Vec[T] where comptime @size_of(T) <= 16, comptime @align_of(T) <= 8 {
        fn tag(x: Vec[T]) -> i32 { return 2; }
      }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); return Tag.tag(v); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_impl_specialization_incomparable_head_where_comptime_bounds_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T] Tag for Vec[T] where comptime @size_of(T) <= 16 {
        fn tag(x: Vec[T]) -> i32 { return 1; }
      }
      impl[T] Tag for Vec[T] where comptime @align_of(T) <= 8 {
        fn tag(x: Vec[T]) -> i32 { return 2; }
      }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); return Tag.tag(v); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "overlapping impl without strict specialization"));
  t.assert(contains(r.err, "rank_trace:"));
}
