import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_const_compile_error_rejected_with_message() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const X: i32 = @compile_error(\"const-boom\")\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "compile_error: const-boom"));
}

fn test_compile_const_unary_not_int_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = !0\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_logic_short_circuit_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      const A: bool = false && (1 / 0 == 0)
      const B: bool = true || (1 / 0 == 0)
      fn main() -> i32 { return if A || B { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_struct_member_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct P { x: i32, y: i32 }
      const P0: P = P { x: 3, y: 4 }
      const N: i32 = P0.x + P0.y
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_typed_path_generic_struct_lit_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Pair[T] { a: T, b: T }
      const P0: Pair[i32] = Pair[i32] { a: 3, b: 4 }
      const N: i32 = P0.a + P0.b
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_generic_struct_lit_uses_expected_type_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Pair[T] { a: T, b: T }
      const P0: Pair[i32] = Pair { a: 3, b: 4 }
      const N: i32 = P0.a + P0.b
      fn main() -> i32 { return N; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_match_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = match 2 { 1 => 10, 2 => 20, _ => 0 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_match_bind_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = match 2 { x => x + 1 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_match_bool_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const N: i32 = match true { true => 1, false => 0 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_enum_unit_match_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "enum E { A, B }\nconst X: E = .A\nconst N: i32 = match X { .A => 1, .B => 0 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_enum_payload_match_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "enum E { A(i32), B }\nconst X: E = .A(7)\nconst N: i32 = match X { .A(v) => v + 1, .B => 0 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_enum_payload_match_multiple_binds_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "enum E { A(i32, i32), B }\nconst X: E = .A(7, 2)\nconst N: i32 = match X { .A(a, b) => a - b, .B => 0 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_enum_ctor_qualified_path_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum E { A(i32), B }
      const X: E = E.A(7)
      const Y: E = E.B
      const N: i32 = match X { .A(v) => v, .B => 0 }
      fn main() -> i32 { return if Y == E.B { N } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_enum_ctor_alias_path_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "dep/src/dep.vox", text: "pub enum E { A(i32), B }" });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "dep" as dep
      const X: dep.E = dep.E.A(7)
      const Y: dep.E = dep.E.B
      const N: i32 = match X { .A(v) => v, .B => 0 }
      fn main() -> i32 { return if Y == dep.E.B { N } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_typed_path_generic_enum_ctor_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Option[T] { Some(T), None }
      const A: Option[i32] = Option[i32].Some(7)
      const B: Option[i32] = Option[i32].None
      fn main() -> i32 { let _a: Option[i32] = A; let _b: Option[i32] = B; return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_generic_enum_ctor_uses_expected_type_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Option[T] { Some(T), None }
      const A: Option[i32] = Option.Some(7)
      const B: Option[i32] = Option.None
      fn main() -> i32 { let _a: Option[i32] = A; let _b: Option[i32] = B; return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_enum_ctor_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "enum Option[T] { Some(T), None }\nenum Maybe[T] { Some(T), None }\nconst A: Option[i32] = Maybe.Some(7)\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "enum ctor result type mismatch"), r.err);
  t.assert_with(contains(r.err, "expected Option[i32]"), r.err);
  t.assert_with(contains(r.err, "got Maybe[i32]"), r.err);
}

fn test_compile_const_union_match_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "type Value = I32: i32 | Str: String\nconst X: Value = Value.I32(7)\nconst N: i32 = match X { .I32(v) => v, .Str(_s) => 0 }\nfn main() -> i32 { return N; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_int_float_cast_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const A: f64 = 7 as f64\nconst B: i32 = 3.9 as i32\nfn main() -> i32 { return A as i32 + B; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "7.0"));
}

fn test_compile_const_struct_equality_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct S { a: i32, b: String }
      const X: S = S { a: 1, b: "x" }
      const Y: S = S { a: 1, b: "x" }
      const B: bool = X == Y
      fn main() -> i32 { return if B { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_enum_payload_equality_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum E { A(i32, String), None }
      const X: E = E.A(7, "x")
      const Y: E = E.A(7, "x")
      const B: bool = X == Y
      fn main() -> i32 { return if B { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_const_error_uses_expr_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "\n\nconst N: i32 = 1 / 0\nfn main() -> i32 { return N; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:3:"));
  t.assert(contains(r.err, "const division by zero"));
  t.assert(contains(r.err, "[E_TYPE_0001]"));
}

fn test_compile_const_reflect_intrinsic_error_uses_call_span_and_code() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "\n\nconst BAD: usize = @size_of(UnknownType)\nfn main() -> i32 { return BAD as i32; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(starts_with(r.err, "src/main.vox:3:20:"), r.err);
  t.assert_with(contains(r.err, "const intrinsic type arg resolve failed"), r.err);
  t.assert_with(contains(r.err, "[E_TYPE_0001]"), r.err);
  t.assert(r.err_kind == c.compile_diag_kind_type());
  t.assert(r.err_code == "E_TYPE_0001");
}
