import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_trait_const_generic_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = AddN.addn[3](x, 4); let b: i32 = I { v: 2 }.addn[5](6); return a + b; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$AddN$addn$0$gN_3d3_3ai32")));
  t.assert(contains(r.c, cg.c_fn_name("impl$main$AddN$addn$0$gN_3d5_3ai32")));
}

fn test_compile_trait_const_generic_method_default_const_arg_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32 = 3](x: Self, v: i32) -> i32; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = AddN.addn(x, 4); let b: i32 = I { v: 2 }.addn(6); return a + b; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$AddN$addn$0$gN_3d3_3ai32")));
}

fn test_compile_trait_const_generic_method_comptime_where_rhs_unknown_reports_method_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "\ntrait AddN {\n  fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N < M;\n}\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:3:3:"));
  t.assert(contains(r.err, "unknown const param in comptime where rhs"));
}

fn test_compile_trait_const_generic_method_comptime_where_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N > 0 { return v + N; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return AddN.addn[3](x, 4); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_trait_const_generic_method_comptime_where_impl_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N >= 0 { return v + N; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}

fn test_compile_trait_const_generic_method_comptime_where_rhs_param_impl_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddNM { fn addnm[const N: i32, const M: i32](x: Self, v: i32) -> i32 where comptime N < M; }
      struct I { v: i32 }
      impl AddNM for I { fn addnm[const N: i32, const M: i32](x: I, v: i32) -> i32 where comptime N <= M { return v + N; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}

fn test_compile_trait_const_generic_method_comptime_where_type_layout_impl_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Fit { fn fit[T](x: Self, v: T) -> i32 where comptime @size_of(T) <= 8; }
      struct I { v: i32 }
      impl Fit for I { fn fit[T](x: I, v: T) -> i32 where comptime @size_of(T) <= 16 { return 1; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}

fn test_compile_trait_const_generic_method_default_violates_comptime_where_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32 = 0](x: Self, v: i32) -> i32 where comptime N > 0; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N > 0 { return v + N; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "default violates comptime where"));
}

fn test_compile_trait_const_generic_method_comptime_where_rhs_reflect_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait FitRU {
        fn fit[T, U](x: Self, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U);
      }
      struct I { v: i32 }
      impl FitRU for I {
        fn fit[T, U](x: I, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U) { return 1; }
      }
      fn main() -> i32 { let x: I = I { v: 1 }; let y: i64 = 0; return FitRU.fit(x, 3, y); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_trait_const_generic_method_comptime_where_rhs_reflect_impl_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait FitRU {
        fn fit[T, U](x: Self, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U);
      }
      struct I { v: i32 }
      impl FitRU for I {
        fn fit[T, U](x: I, a: T, b: U) -> i32 where comptime @size_of(T) < @align_of(U) { return 1; }
      }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "@size_of(T) <= @align_of(U)"), r.err);
}

fn test_compile_trait_const_generic_method_impl_name_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const M: i32](x: I, v: i32) -> i32 { return v + M; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl method const param name mismatch"));
}

fn test_compile_trait_const_generic_method_default_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32 = 3](x: Self, v: i32) -> i32; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32 = 4](x: I, v: i32) -> i32 { return v + N; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "default mismatch"));
}
