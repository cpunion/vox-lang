// Stability: Experimental module API (vox/compile).
// Migration: API may change between minor releases; prefer stable layers for long-term tooling.

import "vox/parse" as p
import "vox/typecheck" as tc
import "vox/macroexpand" as mx
import "vox/irgen" as irgen
import "vox/codegen" as cg
import "vox/loader" as ld
import "vox/ir" as ir
import "vox/ast" as ast
import "std/time" as tm

pub struct CompileResult {
  pub ok: bool,
  pub err_kind: i32,
  pub err_code: String,
  pub err_message: String,
  pub err: String,
  pub c: String,
}

pub struct CompilePhaseProfile {
  pub load_ns: i64,
  pub macroexpand_ns: i64,
  pub rewrite_async_ns: i64,
  pub typecheck_ns: i64,
  pub irgen_ns: i64,
  pub ir_verify_ns: i64,
  pub codegen_ns: i64,
}

pub struct CompileProfileResult {
  pub r: CompileResult,
  pub p: CompilePhaseProfile,
}

pub fn compile_profile_load_ns(p: CompilePhaseProfile) -> i64 { return p.load_ns; }
pub fn compile_profile_macroexpand_ns(p: CompilePhaseProfile) -> i64 { return p.macroexpand_ns; }
pub fn compile_profile_rewrite_async_ns(p: CompilePhaseProfile) -> i64 { return p.rewrite_async_ns; }
pub fn compile_profile_typecheck_ns(p: CompilePhaseProfile) -> i64 { return p.typecheck_ns; }
pub fn compile_profile_irgen_ns(p: CompilePhaseProfile) -> i64 { return p.irgen_ns; }
pub fn compile_profile_ir_verify_ns(p: CompilePhaseProfile) -> i64 { return p.ir_verify_ns; }
pub fn compile_profile_codegen_ns(p: CompilePhaseProfile) -> i64 { return p.codegen_ns; }
pub fn compile_profile_total_ns(p: CompilePhaseProfile) -> i64 {
  return p.load_ns + p.macroexpand_ns + p.rewrite_async_ns + p.typecheck_ns + p.irgen_ns + p.ir_verify_ns + p.codegen_ns;
}

pub fn compile_diag_kind_none() -> i32 { return 0; }
pub fn compile_diag_kind_parse() -> i32 { return 1; }
pub fn compile_diag_kind_lex() -> i32 { return 2; }
pub fn compile_diag_kind_type() -> i32 { return 3; }
pub fn compile_diag_kind_import() -> i32 { return 4; }
pub fn compile_diag_kind_irgen() -> i32 { return 5; }
pub fn compile_diag_kind_ir_verify() -> i32 { return 6; }
pub fn compile_diag_kind_loader() -> i32 { return 7; }
pub fn compile_diag_kind_macroexpand() -> i32 { return 8; }

fn compile_code_ir_verify() -> String { return "E_IR_VERIFY_0001"; }
fn compile_code_macroexpand() -> String { return "E_MACROEXPAND_0001"; }

fn compile_ok(csrc: String) -> CompileResult {
  return CompileResult { ok: true, err_kind: compile_diag_kind_none(), err_code: "", err_message: "", err: "", c: csrc };
}

fn compile_err(kind: i32, code: String, msg: String, rendered: String) -> CompileResult {
  return CompileResult { ok: false, err_kind: kind, err_code: code, err_message: msg, err: rendered, c: "" };
}

fn compile_profile_zero() -> CompilePhaseProfile {
  return CompilePhaseProfile {
    load_ns: 0,
    macroexpand_ns: 0,
    rewrite_async_ns: 0,
    typecheck_ns: 0,
    irgen_ns: 0,
    ir_verify_ns: 0,
    codegen_ns: 0,
  };
}

fn dur_nonneg_ns(start_ns: i64, end_ns: i64) -> i64 {
  if end_ns <= start_ns { return 0; }
  return end_ns - start_ns;
}

fn prof_ok(r: CompileResult, p: CompilePhaseProfile) -> CompileProfileResult {
  return CompileProfileResult { r: r, p: p };
}

fn compile_kind_from_tc(k: i32) -> i32 {
  if k == tc.diag_kind_type() { return compile_diag_kind_type(); }
  if k == tc.diag_kind_import() { return compile_diag_kind_import(); }
  return compile_diag_kind_none();
}

fn compile_kind_from_parse(k: i32) -> i32 {
  if k == p.parse_diag_kind_parse() { return compile_diag_kind_parse(); }
  if k == p.parse_diag_kind_lex() { return compile_diag_kind_lex(); }
  return compile_diag_kind_none();
}

fn compile_kind_from_loader(k: i32) -> i32 {
  if k == ld.load_diag_kind_parse() { return compile_diag_kind_parse(); }
  if k == ld.load_diag_kind_lex() { return compile_diag_kind_lex(); }
  if k == ld.load_diag_kind_loader() { return compile_diag_kind_loader(); }
  return compile_diag_kind_none();
}

fn macroexpand_notes_render(notes: Vec[String]) -> String {
  if notes.len() == 0 { return ""; }
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < notes.len() {
    if i != 0 { out = out.concat("\n"); }
    out = out.concat("[macroexpand] ").concat(notes.get(i));
    i = i + 1;
  }
  return out;
}

fn with_macroexpand_notes(rendered: String, notes: Vec[String]) -> String {
  let ns: String = macroexpand_notes_render(notes);
  if ns == "" { return rendered; }
  return rendered.concat("\n").concat(ns);
}

fn has_prefix(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

fn func_name_exists(fs: Vec[ast.FuncDecl], name: String) -> bool {
  let mut i: i32 = 0;
  while i < fs.len() {
    if fs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn fresh_inner_name(prog: ast.Program, base: String) -> String {
  if !func_name_exists(prog.funcs, base) { return base; }
  let mut n: i32 = 0;
  while true {
    let cand: String = base.concat("$").concat(n.to_string());
    if !func_name_exists(prog.funcs, cand) { return cand; }
    n = n + 1;
  }
  return base.concat("$0");
}

fn import_alias_conflict(imps: Vec[ast.ImportDecl], file: String, alias: String) -> bool {
  let mut i: i32 = 0;
  while i < imps.len() {
    let d: ast.ImportDecl = imps.get(i);
    if d.file == file && d.alias == alias { return true; }
    i = i + 1;
  }
  return false;
}

fn find_std_async_alias(imps: Vec[ast.ImportDecl], file: String) -> String {
  let mut i: i32 = 0;
  while i < imps.len() {
    let d: ast.ImportDecl = imps.get(i);
    if d.file == file && d.path == "std/async" && d.names.len() == 0 && d.alias != "" {
      return d.alias;
    }
    i = i + 1;
  }
  return "";
}

fn prog_has_func(prog: ast.Program, name: String) -> bool {
  let mut i: i32 = 0;
  while i < prog.funcs.len() {
    if prog.funcs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn world_mod_has_func(w: tc.World, mod_path: String, name: String) -> bool {
  let mut i: i32 = 0;
  while i < w.mods.len() {
    let m: tc.WorldModule = w.mods.get(i);
    if m.path == mod_path {
      if prog_has_func(m.prog, name) { return true; }
    }
    i = i + 1;
  }
  return false;
}

struct EnsureAsyncImportResult { prog: ast.Program, alias: String }

fn ensure_std_async_import(prog0: ast.Program, file: String, sp: ast.Span) -> EnsureAsyncImportResult {
  let existing: String = find_std_async_alias(prog0.imports, file);
  if existing != "" {
    return EnsureAsyncImportResult { prog: prog0, alias: existing };
  }
  let mut alias: String = "__async_entry";
  if import_alias_conflict(prog0.imports, file, alias) {
    let mut n: i32 = 0;
    while true {
      let cand: String = "__async_entry".concat(n.to_string());
      if !import_alias_conflict(prog0.imports, file, cand) { alias = cand; break; }
      n = n + 1;
    }
  }
  let mut prog: ast.Program = prog0;
  prog.imports.push(ast.ImportDecl { file: file, sp: sp, path: "std/async", alias: alias, names: Vec() });
  return EnsureAsyncImportResult { prog: prog, alias: alias };
}

struct AddExprToProgResult { prog: ast.Program, id: i32 }

fn add_expr_to_prog(prog0: ast.Program, sp: ast.Span, n: ast.ExprNode) -> AddExprToProgResult {
  let r: ast.AddExprResult = ast.expr_pool_add(prog0.exprs, n, sp);
  let mut prog: ast.Program = prog0;
  prog.exprs = r.pool;
  return AddExprToProgResult { prog: prog, id: r.id };
}

fn dummy_type_name() -> ast.TypeName {
  return ast.TypeName { parts: Vec(), args: Vec() };
}

fn typename_is0(tn: ast.TypeName, s: String) -> bool {
  return tn.parts.len() == 1 && tn.parts.get(0) == s && tn.args.len() == 0;
}

fn fallback_zero_expr_for_type(ret: ast.TypeName) -> ast.ExprNode {
  if typename_is0(ret, "bool") { return ast.ExprNode.Bool(false); }
  if typename_is0(ret, "f32") || typename_is0(ret, "f64") { return ast.ExprNode.Float("0.0"); }
  if typename_is0(ret, "String") || typename_is0(ret, "str") { return ast.ExprNode.Str(""); }
  return ast.ExprNode.Int("0");
}

struct MkAsyncPollLoopBodyResult { prog: ast.Program, body: ast.Block }

fn mk_async_poll_loop_body(
  prog0: ast.Program,
  sp: ast.Span,
  async_alias: String,
  inner_name: String,
  ret: ast.TypeName,
  has_default_runtime: bool,
  has_park_until_wake_with: bool,
  has_park_with: bool,
  has_cancel_drop_state_with: bool,
  has_cancel_drop_with: bool,
  has_cancel_cleanup_state_with: bool,
  has_cancel_cleanup_with: bool,
  has_cancel_return_with: bool,
  has_cancel_requested_with: bool,
  has_pending_wait_with: bool,
  has_park_until_wake: bool,
  has_park: bool,
  has_cancel_drop_state: bool,
  has_cancel_drop: bool,
  has_cancel_cleanup_state: bool,
  has_cancel_cleanup: bool,
  has_cancel_return: bool,
  has_cancel_requested: bool,
  has_pending_wait: bool,
  has_spin_wait: bool,
) -> MkAsyncPollLoopBodyResult {
  let mut prog: ast.Program = prog0;
  let ret_is_unit: bool = typename_is0(ret, "()");

  // A dummy expr id to satisfy AST fields where a tail is unused.
  let r_dummy: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Int("0"));
  prog = r_dummy.prog;

  // cx = async.context(async.waker(0))
  let r_alias: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
  prog = r_alias.prog;
  let r_waker: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_alias.id, "waker"));
  prog = r_waker.prog;
  let r_zero: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Int("0"));
  prog = r_zero.prog;
  let mut wargs: Vec[i32] = Vec();
  wargs.push(r_zero.id);
  let r_wcall: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_waker.id, Vec(), wargs));
  prog = r_wcall.prog;
  let r_ctx_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_alias.id, "context"));
  prog = r_ctx_fn.prog;
  let mut cargs: Vec[i32] = Vec();
  cargs.push(r_wcall.id);
  let r_cx_init: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_ctx_fn.id, Vec(), cargs));
  prog = r_cx_init.prog;
  let s_cx: ast.Stmt = ast.Stmt.Let(sp, false, "cx", false, dummy_type_name(), r_cx_init.id);

  // mut f = inner()
  let r_inner: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(inner_name));
  prog = r_inner.prog;
  let r_f_init: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_inner.id, Vec(), Vec()));
  prog = r_f_init.prog;
  let s_f: ast.Stmt = ast.Stmt.Let(sp, true, "f", false, dummy_type_name(), r_f_init.id);
  let has_runtime_hooks_with: bool =
    has_park_until_wake_with ||
    has_park_with ||
    has_pending_wait_with ||
    has_cancel_requested_with ||
    has_cancel_return_with ||
    has_cancel_cleanup_with ||
    has_cancel_cleanup_state_with ||
    has_cancel_drop_with ||
    has_cancel_drop_state_with;
  let use_runtime_with: bool = has_default_runtime && has_runtime_hooks_with;
  let mut s_rt: ast.Stmt = ast.Stmt.ExprStmt(sp, r_dummy.id);
  if use_runtime_with {
    let r_alias_rt: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_alias_rt.prog;
    let r_default_rt: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_alias_rt.id, "default_runtime"));
    prog = r_default_rt.prog;
    let r_rt_init: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_default_rt.id, Vec(), Vec()));
    prog = r_rt_init.prog;
    s_rt = ast.Stmt.Let(sp, false, "rt", false, dummy_type_name(), r_rt_init.id);
  }
  let mut s_spins: ast.Stmt = ast.Stmt.ExprStmt(sp, r_dummy.id);
  if has_park_until_wake_with || has_park_with || has_pending_wait_with || has_park_until_wake || has_park || has_pending_wait || has_spin_wait {
    let r_spins0: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Int("0"));
    prog = r_spins0.prog;
    s_spins = ast.Stmt.Let(sp, true, "spins", false, dummy_type_name(), r_spins0.id);
  }

  // while true { let p = f.poll(cx); match p { .Pending => { continue; }, .Ready(v) => { return v; } } }
  let r_true: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Bool(true));
  prog = r_true.prog;

  let r_f: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
  prog = r_f.prog;
  let r_poll: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f.id, "poll"));
  prog = r_poll.prog;
  let r_cx: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
  prog = r_cx.prog;
  let mut pargs: Vec[i32] = Vec();
  pargs.push(r_cx.id);
  let r_p_init: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_poll.id, Vec(), pargs));
  prog = r_p_init.prog;
  let s_p: ast.Stmt = ast.Stmt.Let(sp, false, "p", false, dummy_type_name(), r_p_init.id);

  let r_p: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("p"));
  prog = r_p.prog;

  let mut pend_stmts: Vec[ast.Stmt] = Vec();
  if use_runtime_with && has_park_until_wake_with {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_parkw: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "park_until_wake_with"));
    prog = r_parkw.prog;
    let r_rt: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
    prog = r_rt.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let r_cx2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx2.prog;
    let mut parkw_args: Vec[i32] = Vec();
    parkw_args.push(r_rt.id);
    parkw_args.push(r_spinsv.id);
    parkw_args.push(r_cx2.id);
    let r_parkw_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_parkw.id, Vec(), parkw_args));
    prog = r_parkw_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_parkw_call.id));
  } else if use_runtime_with && has_park_with {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_park: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "park_with"));
    prog = r_park.prog;
    let r_rt: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
    prog = r_rt.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let r_cx2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx2.prog;
    let mut park_args: Vec[i32] = Vec();
    park_args.push(r_rt.id);
    park_args.push(r_spinsv.id);
    park_args.push(r_cx2.id);
    let r_park_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_park.id, Vec(), park_args));
    prog = r_park_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_park_call.id));
  } else if use_runtime_with && has_pending_wait_with {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_pwait: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "pending_wait_with"));
    prog = r_pwait.prog;
    let r_rt: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
    prog = r_rt.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let r_cx2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx2.prog;
    let mut pwait_args: Vec[i32] = Vec();
    pwait_args.push(r_rt.id);
    pwait_args.push(r_spinsv.id);
    pwait_args.push(r_cx2.id);
    let r_pwait_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_pwait.id, Vec(), pwait_args));
    prog = r_pwait_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_pwait_call.id));
  } else if has_park_until_wake {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_parkw: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "park_until_wake"));
    prog = r_parkw.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let r_cx2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx2.prog;
    let mut parkw_args: Vec[i32] = Vec();
    parkw_args.push(r_spinsv.id);
    parkw_args.push(r_cx2.id);
    let r_parkw_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_parkw.id, Vec(), parkw_args));
    prog = r_parkw_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_parkw_call.id));
  } else if has_park {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_park: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "park"));
    prog = r_park.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let r_cx2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx2.prog;
    let mut park_args: Vec[i32] = Vec();
    park_args.push(r_spinsv.id);
    park_args.push(r_cx2.id);
    let r_park_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_park.id, Vec(), park_args));
    prog = r_park_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_park_call.id));
  } else if has_pending_wait {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_pwait: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "pending_wait"));
    prog = r_pwait.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let r_cx2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx2.prog;
    let mut pwait_args: Vec[i32] = Vec();
    pwait_args.push(r_spinsv.id);
    pwait_args.push(r_cx2.id);
    let r_pwait_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_pwait.id, Vec(), pwait_args));
    prog = r_pwait_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_pwait_call.id));
  } else if has_spin_wait {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_spin: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "spin_wait"));
    prog = r_spin.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let mut spin_args: Vec[i32] = Vec();
    spin_args.push(r_spinsv.id);
    let r_spin_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_spin.id, Vec(), spin_args));
    prog = r_spin_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_spin_call.id));

    let r_spinsl: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsl.prog;
    let r_one: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Int("1"));
    prog = r_one.prog;
    let r_next: AddExprToProgResult =
      add_expr_to_prog(prog, sp, ast.ExprNode.Binary(ast.BinaryOp.Add, r_spinsl.id, r_one.id));
    prog = r_next.prog;
    pend_stmts.push(ast.Stmt.Assign(sp, "spins", r_next.id));
  }
  if use_runtime_with && has_cancel_requested_with {
    let r_a3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a3.prog;
    let r_cancel_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a3.id, "cancel_requested_with"));
    prog = r_cancel_fn.prog;
    let r_rt2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
    prog = r_rt2.prog;
    let r_cx3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx3.prog;
    let mut cancel_args: Vec[i32] = Vec();
    cancel_args.push(r_rt2.id);
    cancel_args.push(r_cx3.id);
    let r_cancel_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_fn.id, Vec(), cancel_args));
    prog = r_cancel_call.prog;

    let mut then_stmts: Vec[ast.Stmt] = Vec();
    if use_runtime_with && has_cancel_drop_state_with {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_state_with"));
      prog = r_drop_fn.prog;
      let r_rt_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_drop.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let r_f_state: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_drop.id, "state"));
      prog = r_f_state.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_rt_drop.id);
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_state.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if use_runtime_with && has_cancel_drop_with {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_with"));
      prog = r_drop_fn.prog;
      let r_rt_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_drop.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_rt_drop.id);
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if has_cancel_drop_state {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_state"));
      prog = r_drop_fn.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let r_f_state: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_drop.id, "state"));
      prog = r_f_state.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_state.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if has_cancel_drop {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop"));
      prog = r_drop_fn.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    }
    if use_runtime_with && has_cancel_cleanup_state_with {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_state_with"));
      prog = r_cleanup_fn.prog;
      let r_rt_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_cleanup.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let r_f_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_cleanup.prog;
      let r_state_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_cleanup.id, "state"));
      prog = r_state_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_rt_cleanup.id);
      cleanup_args.push(r_cx_cleanup.id);
      cleanup_args.push(r_state_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if use_runtime_with && has_cancel_cleanup_with {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_with"));
      prog = r_cleanup_fn.prog;
      let r_rt_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_cleanup.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_rt_cleanup.id);
      cleanup_args.push(r_cx_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if has_cancel_cleanup_state {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_state"));
      prog = r_cleanup_fn.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let r_f_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_cleanup.prog;
      let r_state_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_cleanup.id, "state"));
      prog = r_state_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_cx_cleanup.id);
      cleanup_args.push(r_state_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if has_cancel_cleanup {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup"));
      prog = r_cleanup_fn.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_cx_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    }
    if use_runtime_with && has_cancel_return_with {
      let r_a4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a4.prog;
      let r_cancel_ret_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a4.id, "cancel_return_with"));
      prog = r_cancel_ret_fn.prog;
      let r_rt3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt3.prog;
      let r_cx4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx4.prog;
      let mut ret_args: Vec[i32] = Vec();
      ret_args.push(r_rt3.id);
      ret_args.push(r_cx4.id);
      let r_cancel_ret_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_ret_fn.id, Vec(), ret_args));
      prog = r_cancel_ret_call.prog;
      if ret_is_unit {
        then_stmts.push(ast.Stmt.ExprStmt(sp, r_cancel_ret_call.id));
        then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
      } else {
        then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret_call.id));
      }
    } else if has_cancel_return {
      let r_a4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a4.prog;
      let r_cancel_ret_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a4.id, "cancel_return"));
      prog = r_cancel_ret_fn.prog;
      let r_cx4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx4.prog;
      let mut ret_args: Vec[i32] = Vec();
      ret_args.push(r_cx4.id);
      let r_cancel_ret_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_ret_fn.id, Vec(), ret_args));
      prog = r_cancel_ret_call.prog;
      if ret_is_unit {
        then_stmts.push(ast.Stmt.ExprStmt(sp, r_cancel_ret_call.id));
        then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
      } else {
        then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret_call.id));
      }
    } else if ret_is_unit {
      then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
    } else {
      let r_cancel_ret: AddExprToProgResult = add_expr_to_prog(prog, sp, fallback_zero_expr_for_type(ret));
      prog = r_cancel_ret.prog;
      then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret.id));
    }
    pend_stmts.push(ast.Stmt.IfStmt(sp, r_cancel_call.id, ast.Block { stmts: then_stmts }, false, ast.Block { stmts: Vec() }));
  } else if has_cancel_requested {
    let r_a3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a3.prog;
    let r_cancel_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a3.id, "cancel_requested"));
    prog = r_cancel_fn.prog;
    let r_cx3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx3.prog;
    let mut cancel_args: Vec[i32] = Vec();
    cancel_args.push(r_cx3.id);
    let r_cancel_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_fn.id, Vec(), cancel_args));
    prog = r_cancel_call.prog;

    let mut then_stmts: Vec[ast.Stmt] = Vec();
    if use_runtime_with && has_cancel_drop_state_with {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_state_with"));
      prog = r_drop_fn.prog;
      let r_rt_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_drop.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let r_f_state: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_drop.id, "state"));
      prog = r_f_state.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_rt_drop.id);
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_state.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if use_runtime_with && has_cancel_drop_with {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_with"));
      prog = r_drop_fn.prog;
      let r_rt_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_drop.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_rt_drop.id);
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if has_cancel_drop_state {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_state"));
      prog = r_drop_fn.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let r_f_state: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_drop.id, "state"));
      prog = r_f_state.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_state.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if has_cancel_drop {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop"));
      prog = r_drop_fn.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    }
    if use_runtime_with && has_cancel_cleanup_state_with {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_state_with"));
      prog = r_cleanup_fn.prog;
      let r_rt_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_cleanup.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let r_f_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_cleanup.prog;
      let r_state_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_cleanup.id, "state"));
      prog = r_state_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_rt_cleanup.id);
      cleanup_args.push(r_cx_cleanup.id);
      cleanup_args.push(r_state_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if use_runtime_with && has_cancel_cleanup_with {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_with"));
      prog = r_cleanup_fn.prog;
      let r_rt_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_cleanup.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_rt_cleanup.id);
      cleanup_args.push(r_cx_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if has_cancel_cleanup_state {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_state"));
      prog = r_cleanup_fn.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let r_f_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_cleanup.prog;
      let r_state_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_cleanup.id, "state"));
      prog = r_state_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_cx_cleanup.id);
      cleanup_args.push(r_state_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if has_cancel_cleanup {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup"));
      prog = r_cleanup_fn.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_cx_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    }
    if use_runtime_with && has_cancel_return_with {
      let r_a4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a4.prog;
      let r_cancel_ret_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a4.id, "cancel_return_with"));
      prog = r_cancel_ret_fn.prog;
      let r_rt3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt3.prog;
      let r_cx4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx4.prog;
      let mut ret_args: Vec[i32] = Vec();
      ret_args.push(r_rt3.id);
      ret_args.push(r_cx4.id);
      let r_cancel_ret_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_ret_fn.id, Vec(), ret_args));
      prog = r_cancel_ret_call.prog;
      if ret_is_unit {
        then_stmts.push(ast.Stmt.ExprStmt(sp, r_cancel_ret_call.id));
        then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
      } else {
        then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret_call.id));
      }
    } else if has_cancel_return {
      let r_a4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a4.prog;
      let r_cancel_ret_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a4.id, "cancel_return"));
      prog = r_cancel_ret_fn.prog;
      let r_cx4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx4.prog;
      let mut ret_args: Vec[i32] = Vec();
      ret_args.push(r_cx4.id);
      let r_cancel_ret_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_ret_fn.id, Vec(), ret_args));
      prog = r_cancel_ret_call.prog;
      if ret_is_unit {
        then_stmts.push(ast.Stmt.ExprStmt(sp, r_cancel_ret_call.id));
        then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
      } else {
        then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret_call.id));
      }
    } else if ret_is_unit {
      then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
    } else {
      let r_cancel_ret: AddExprToProgResult = add_expr_to_prog(prog, sp, fallback_zero_expr_for_type(ret));
      prog = r_cancel_ret.prog;
      then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret.id));
    }
    pend_stmts.push(ast.Stmt.IfStmt(sp, r_cancel_call.id, ast.Block { stmts: then_stmts }, false, ast.Block { stmts: Vec() }));
  }
  pend_stmts.push(ast.Stmt.Continue(sp));
  let r_pend_blk: AddExprToProgResult =
    add_expr_to_prog(prog, sp, ast.ExprNode.Block(ast.ExprBlock { stmts: pend_stmts, has_tail: false, tail: r_dummy.id }));
  prog = r_pend_blk.prog;

  let r_v: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("v"));
  prog = r_v.prog;
  let mut ready_stmts: Vec[ast.Stmt] = Vec();
  if ret_is_unit {
    ready_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
  } else {
    ready_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_v.id));
  }
  let r_ready_blk: AddExprToProgResult =
    add_expr_to_prog(prog, sp, ast.ExprNode.Block(ast.ExprBlock { stmts: ready_stmts, has_tail: false, tail: r_dummy.id }));
  prog = r_ready_blk.prog;

  let mut arms: Vec[ast.MatchArm] = Vec();
  arms.push(ast.MatchArm { pat: ast.Pat.EnumVariant(sp, Vec(), "Pending", Vec()), expr: r_pend_blk.id });
  let mut ready_args: Vec[ast.Pat] = Vec();
  ready_args.push(ast.Pat.Bind(sp, "v"));
  arms.push(ast.MatchArm { pat: ast.Pat.EnumVariant(sp, Vec(), "Ready", ready_args), expr: r_ready_blk.id });
  let r_match: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Match(r_p.id, arms));
  prog = r_match.prog;
  let s_match: ast.Stmt = ast.Stmt.ExprStmt(sp, r_match.id);

  let mut while_stmts: Vec[ast.Stmt] = Vec();
  while_stmts.push(s_p);
  while_stmts.push(s_match);
  let while_body: ast.Block = ast.Block { stmts: while_stmts };
  let s_while: ast.Stmt = ast.Stmt.WhileStmt(sp, r_true.id, while_body);

  let mut ss: Vec[ast.Stmt] = Vec();
  ss.push(s_cx);
  ss.push(s_f);
  if use_runtime_with { ss.push(s_rt); }
  if has_park_until_wake_with || has_park_with || has_pending_wait_with || has_park_until_wake || has_park || has_pending_wait || has_spin_wait {
    ss.push(s_spins);
  }
  ss.push(s_while);
  if !ret_is_unit {
    let r_fallback: AddExprToProgResult = add_expr_to_prog(prog, sp, fallback_zero_expr_for_type(ret));
    prog = r_fallback.prog;
    ss.push(ast.Stmt.ReturnStmt(sp, true, r_fallback.id));
  }
  return MkAsyncPollLoopBodyResult { prog: prog, body: ast.Block { stmts: ss } };
}

fn rewrite_async_main_and_tests_in_program(
  prog0: ast.Program,
  emit_driver_main: bool,
  emit_test_main: bool,
  has_default_runtime: bool,
  has_park_until_wake_with: bool,
  has_park_with: bool,
  has_cancel_drop_state_with: bool,
  has_cancel_drop_with: bool,
  has_cancel_cleanup_state_with: bool,
  has_cancel_cleanup_with: bool,
  has_cancel_return_with: bool,
  has_cancel_requested_with: bool,
  has_pending_wait_with: bool,
  has_park_until_wake: bool,
  has_park: bool,
  has_cancel_drop_state: bool,
  has_cancel_drop: bool,
  has_cancel_cleanup_state: bool,
  has_cancel_cleanup: bool,
  has_cancel_return: bool,
  has_cancel_requested: bool,
  has_pending_wait: bool,
  has_spin_wait: bool,
) -> ast.Program {
  if !emit_driver_main && !emit_test_main { return prog0; }
  let mut prog: ast.Program = prog0;
  let mut out_funcs: Vec[ast.FuncDecl] = Vec();
  let mut appended: Vec[ast.FuncDecl] = Vec(); // renamed async bodies appended at end
  let mut i: i32 = 0;
  while i < prog.funcs.len() {
    let fd0: ast.FuncDecl = prog.funcs.get(i);

    let is_async_main: bool = emit_driver_main && fd0.is_async && fd0.name == "main";
    let is_async_test: bool = emit_test_main && fd0.is_async && has_prefix(fd0.name, "test_");
    if is_async_main || is_async_test {
      // Names starting with `__` are reserved for compiler intrinsics; use a
      // single-underscore prefix for generated wrappers.
      let inner_name: String = fresh_inner_name(prog, "_async$".concat(fd0.name));
      let ir: EnsureAsyncImportResult = ensure_std_async_import(prog, fd0.file, fd0.sp);
      prog = ir.prog;
      let br: MkAsyncPollLoopBodyResult =
        mk_async_poll_loop_body(
          prog,
          fd0.sp,
          ir.alias,
          inner_name,
          fd0.ret,
          has_default_runtime,
          has_park_until_wake_with,
          has_park_with,
          has_cancel_drop_state_with,
          has_cancel_drop_with,
          has_cancel_cleanup_state_with,
          has_cancel_cleanup_with,
          has_cancel_return_with,
          has_cancel_requested_with,
          has_pending_wait_with,
          has_park_until_wake,
          has_park,
          has_cancel_drop_state,
          has_cancel_drop,
          has_cancel_cleanup_state,
          has_cancel_cleanup,
          has_cancel_return,
          has_cancel_requested,
          has_pending_wait,
          has_spin_wait,
        );
      prog = br.prog;

      let mut inner: ast.FuncDecl = fd0;
      inner.name = inner_name;

      let mut wrap: ast.FuncDecl = fd0;
      wrap.is_async = false;
      wrap.type_params = Vec();
      wrap.type_param_packs = Vec();
      wrap.const_params = Vec();
      wrap.type_param_bounds = Vec();
      wrap.const_where_bounds = Vec();
      wrap.params = Vec(); // entrypoints/tests are parameterless in v0
      wrap.body = br.body;

      out_funcs.push(wrap);
      appended.push(inner);
    } else {
      out_funcs.push(fd0);
    }

    i = i + 1;
  }

  let mut j: i32 = 0;
  while j < appended.len() {
    out_funcs.push(appended.get(j));
    j = j + 1;
  }
  prog.funcs = out_funcs;
  return prog;
}

fn rewrite_async_entrypoints(w0: tc.World, opts: cg.EmitOptions) -> tc.World {
  if !opts.emit_driver_main && !opts.emit_test_main { return w0; }
  let has_default_runtime: bool = world_mod_has_func(w0, "std/async", "default_runtime");
  let has_park_until_wake_with: bool = world_mod_has_func(w0, "std/async", "park_until_wake_with");
  let has_park_with: bool = world_mod_has_func(w0, "std/async", "park_with");
  let has_cancel_drop_state_with: bool = world_mod_has_func(w0, "std/async", "cancel_drop_state_with");
  let has_cancel_drop_with: bool = world_mod_has_func(w0, "std/async", "cancel_drop_with");
  let has_cancel_cleanup_state_with: bool = world_mod_has_func(w0, "std/async", "cancel_cleanup_state_with");
  let has_cancel_cleanup_with: bool = world_mod_has_func(w0, "std/async", "cancel_cleanup_with");
  let has_cancel_return_with: bool = world_mod_has_func(w0, "std/async", "cancel_return_with");
  let has_cancel_requested_with: bool = world_mod_has_func(w0, "std/async", "cancel_requested_with");
  let has_pending_wait_with: bool = world_mod_has_func(w0, "std/async", "pending_wait_with");
  let has_park_until_wake: bool = world_mod_has_func(w0, "std/async", "park_until_wake");
  let has_park: bool = world_mod_has_func(w0, "std/async", "park");
  let has_cancel_drop_state: bool = world_mod_has_func(w0, "std/async", "cancel_drop_state");
  let has_cancel_drop: bool = world_mod_has_func(w0, "std/async", "cancel_drop");
  let has_cancel_cleanup_state: bool = world_mod_has_func(w0, "std/async", "cancel_cleanup_state");
  let has_cancel_cleanup: bool = world_mod_has_func(w0, "std/async", "cancel_cleanup");
  let has_cancel_return: bool = world_mod_has_func(w0, "std/async", "cancel_return");
  let has_cancel_requested: bool = world_mod_has_func(w0, "std/async", "cancel_requested");
  let has_pending_wait: bool = world_mod_has_func(w0, "std/async", "pending_wait");
  let has_spin_wait: bool = world_mod_has_func(w0, "std/async", "spin_wait");
  let mut w: tc.World = tc.world();
  let mut i: i32 = 0;
  while i < w0.mods.len() {
    let m: tc.WorldModule = w0.mods.get(i);
    let prog: ast.Program =
      rewrite_async_main_and_tests_in_program(
        m.prog,
        opts.emit_driver_main,
        opts.emit_test_main,
        has_default_runtime,
        has_park_until_wake_with,
        has_park_with,
        has_cancel_drop_state_with,
        has_cancel_drop_with,
        has_cancel_cleanup_state_with,
        has_cancel_cleanup_with,
        has_cancel_return_with,
        has_cancel_requested_with,
        has_pending_wait_with,
        has_park_until_wake,
        has_park,
        has_cancel_drop_state,
        has_cancel_drop,
        has_cancel_cleanup_state,
        has_cancel_cleanup,
        has_cancel_return,
        has_cancel_requested,
        has_pending_wait,
        has_spin_wait,
      );
    w = tc.world_add(w, m.path, prog);
    i = i + 1;
  }
  return w;
}

pub fn compile_main_text_to_c(src: String, opts: cg.EmitOptions) -> CompileResult {
  let pr: p.ParseResult = p.parse_text_with_path("src/main.vox", src);
  if pr.err != p.ParseError.None {
    let pd: p.ParseDiag = p.parse_error_diag("src/main.vox", src, pr.err);
    return compile_err(compile_kind_from_parse(pd.kind), pd.code, pd.message, pd.rendered);
  }

  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "main", pr.prog);

  let xr: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  if !xr.ok {
    let code: String = compile_code_macroexpand();
    let msg0: String = tc.tc_error_message(xr.err);
    let msg: String = if msg0 != "" { msg0 } else { tc.tc_error_to_string(xr.err) };
    let rendered: String = tc.tc_error_to_string(xr.err).concat(" [").concat(code).concat("]");
    return compile_err(compile_diag_kind_macroexpand(), code, msg, rendered);
  }

  let w2: tc.World = rewrite_async_entrypoints(xr.world, opts);
  let br: tc.BuildCtxResult = tc.build_ctx(w2);
  if !br.ok {
    let rendered: String = with_macroexpand_notes(tc.tc_error_to_string(br.err), xr.notes);
    return compile_err(compile_kind_from_tc(tc.tc_error_kind(br.err)), tc.tc_error_code(br.err), tc.tc_error_message(br.err), rendered);
  }
  let tr: tc.TcResult = tc.typecheck_world_with_ctx(w2, br.ctx);
  if !tr.ok {
    let rendered: String = with_macroexpand_notes(tc.tc_error_to_string(tr.err), xr.notes);
    return compile_err(compile_kind_from_tc(tc.tc_error_kind(tr.err)), tc.tc_error_code(tr.err), tc.tc_error_message(tr.err), rendered);
  }

  let gr: irgen.GenResult = irgen.generate_world_with_ctx(w2, br.ctx);
  if !gr.ok {
    return compile_err(compile_diag_kind_irgen(), tc.diag_code_irgen(), gr.err, gr.err);
  }
  let vr: ir.VerifyResult = ir.verify_program(gr.prog);
  if !vr.ok {
    let code: String = compile_code_ir_verify();
    let msg: String = "ir verify failed: ".concat(vr.err);
    let rendered: String = msg.concat(" [").concat(code).concat("]");
    return compile_err(compile_diag_kind_ir_verify(), code, msg, rendered);
  }

  let c: String = cg.emit_c(gr.prog, opts);
  return compile_ok(c);
}

pub fn compile_files_to_c(files: Vec[ld.SourceFile], opts: cg.EmitOptions) -> CompileResult {
  let pr: CompileProfileResult = compile_files_to_c_profile(files, opts);
  return pr.r;
}

pub fn compile_files_to_c_profile(files: Vec[ld.SourceFile], opts: cg.EmitOptions) -> CompileProfileResult {
  let mut prof: CompilePhaseProfile = compile_profile_zero();

  let t0_load: i64 = tm.now_ns();
  let lr: ld.LoadWorldResult = ld.world_from_files(files);
  prof.load_ns = dur_nonneg_ns(t0_load, tm.now_ns());
  if !lr.ok {
    return prof_ok(compile_err(compile_kind_from_loader(lr.err_kind), lr.err_code, lr.err_message, lr.err), prof);
  }
  let t0_expand: i64 = tm.now_ns();
  let xr: mx.ExpandResult = mx.expand_world(lr.world, mx.default_config());
  prof.macroexpand_ns = dur_nonneg_ns(t0_expand, tm.now_ns());
  if !xr.ok {
    let code: String = compile_code_macroexpand();
    let msg0: String = tc.tc_error_message(xr.err);
    let msg: String = if msg0 != "" { msg0 } else { tc.tc_error_to_string(xr.err) };
    let rendered: String = tc.tc_error_to_string(xr.err).concat(" [").concat(code).concat("]");
    return prof_ok(compile_err(compile_diag_kind_macroexpand(), code, msg, rendered), prof);
  }

  let t0_rewrite: i64 = tm.now_ns();
  let w2: tc.World = rewrite_async_entrypoints(xr.world, opts);
  prof.rewrite_async_ns = dur_nonneg_ns(t0_rewrite, tm.now_ns());

  let t0_tc: i64 = tm.now_ns();
  let br: tc.BuildCtxResult = tc.build_ctx(w2);
  if !br.ok {
    prof.typecheck_ns = dur_nonneg_ns(t0_tc, tm.now_ns());
    let rendered: String = with_macroexpand_notes(tc.tc_error_to_string(br.err), xr.notes);
    return prof_ok(compile_err(compile_kind_from_tc(tc.tc_error_kind(br.err)), tc.tc_error_code(br.err), tc.tc_error_message(br.err), rendered), prof);
  }
  let tr: tc.TcResult = tc.typecheck_world_with_ctx(w2, br.ctx);
  prof.typecheck_ns = dur_nonneg_ns(t0_tc, tm.now_ns());
  if !tr.ok {
    let rendered: String = with_macroexpand_notes(tc.tc_error_to_string(tr.err), xr.notes);
    return prof_ok(compile_err(compile_kind_from_tc(tc.tc_error_kind(tr.err)), tc.tc_error_code(tr.err), tc.tc_error_message(tr.err), rendered), prof);
  }

  let t0_irgen: i64 = tm.now_ns();
  let gr: irgen.GenResult = irgen.generate_world_with_ctx(w2, br.ctx);
  prof.irgen_ns = dur_nonneg_ns(t0_irgen, tm.now_ns());
  if !gr.ok {
    return prof_ok(compile_err(compile_diag_kind_irgen(), tc.diag_code_irgen(), gr.err, gr.err), prof);
  }

  let t0_verify: i64 = tm.now_ns();
  let vr: ir.VerifyResult = ir.verify_program(gr.prog);
  prof.ir_verify_ns = dur_nonneg_ns(t0_verify, tm.now_ns());
  if !vr.ok {
    let code: String = compile_code_ir_verify();
    let msg: String = "ir verify failed: ".concat(vr.err);
    let rendered: String = msg.concat(" [").concat(code).concat("]");
    return prof_ok(compile_err(compile_diag_kind_ir_verify(), code, msg, rendered), prof);
  }

  let t0_codegen: i64 = tm.now_ns();
  let c: String = cg.emit_c(gr.prog, opts);
  prof.codegen_ns = dur_nonneg_ns(t0_codegen, tm.now_ns());
  return prof_ok(compile_ok(c), prof);
}
