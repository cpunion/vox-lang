// Stability: Experimental module API (vox/compile).
// Migration: API may change between minor releases; prefer stable layers for long-term tooling.

import "vox/parse" as p
import "vox/typecheck" as tc
import "vox/macroexpand" as mx
import "vox/irgen" as irgen
import "vox/codegen" as cg
import "vox/loader" as ld
import "vox/ir" as ir
import "vox/ast" as ast
import "vox/internal/text" as txt
import "std/time" as tm

pub struct CompileResult {
  pub ok: bool,
  pub err_kind: i32,
  pub err_code: String,
  pub err_message: String,
  pub err: String,
  pub warnings: Vec[String],
  pub c: String,
}

pub struct CompilePhaseProfile {
  pub load_ns: i64,
  pub macroexpand_ns: i64,
  pub rewrite_async_ns: i64,
  pub typecheck_ns: i64,
  pub irgen_ns: i64,
  pub ir_verify_ns: i64,
  pub codegen_ns: i64,
}

pub struct CompileProfileResult {
  pub r: CompileResult,
  pub p: CompilePhaseProfile,
}

pub fn compile_profile_load_ns(p: CompilePhaseProfile) -> i64 { return p.load_ns; }

pub fn compile_profile_macroexpand_ns(p: CompilePhaseProfile) -> i64 { return p.macroexpand_ns; }

pub fn compile_profile_rewrite_async_ns(p: CompilePhaseProfile) -> i64 { return p.rewrite_async_ns; }

pub fn compile_profile_typecheck_ns(p: CompilePhaseProfile) -> i64 { return p.typecheck_ns; }

pub fn compile_profile_irgen_ns(p: CompilePhaseProfile) -> i64 { return p.irgen_ns; }

pub fn compile_profile_ir_verify_ns(p: CompilePhaseProfile) -> i64 { return p.ir_verify_ns; }

pub fn compile_profile_codegen_ns(p: CompilePhaseProfile) -> i64 { return p.codegen_ns; }

pub fn compile_profile_total_ns(p: CompilePhaseProfile) -> i64 {
  return p.load_ns + p.macroexpand_ns + p.rewrite_async_ns + p.typecheck_ns + p.irgen_ns + p.ir_verify_ns + p.codegen_ns;
}

pub fn compile_diag_kind_none() -> i32 { return 0; }

pub fn compile_diag_kind_parse() -> i32 { return 1; }

pub fn compile_diag_kind_lex() -> i32 { return 2; }

pub fn compile_diag_kind_type() -> i32 { return 3; }

pub fn compile_diag_kind_import() -> i32 { return 4; }

pub fn compile_diag_kind_irgen() -> i32 { return 5; }

pub fn compile_diag_kind_ir_verify() -> i32 { return 6; }

pub fn compile_diag_kind_loader() -> i32 { return 7; }

pub fn compile_diag_kind_macroexpand() -> i32 { return 8; }

fn compile_code_ir_verify() -> String { return "E_IR_VERIFY_0001"; }

fn compile_code_macroexpand() -> String { return "E_MACROEXPAND_0001"; }

fn compile_ok(csrc: String, warnings: Vec[String]) -> CompileResult {
  return CompileResult { ok: true, err_kind: compile_diag_kind_none(), err_code: "", err_message: "", err: "", warnings: warnings, c: csrc };
}

fn compile_err(kind: i32, code: String, msg: String, rendered: String, warnings: Vec[String]) -> CompileResult {
  return CompileResult { ok: false, err_kind: kind, err_code: code, err_message: msg, err: rendered, warnings: warnings, c: "" };
}

fn compile_profile_zero() -> CompilePhaseProfile {
  return CompilePhaseProfile {
    load_ns: 0,
    macroexpand_ns: 0,
    rewrite_async_ns: 0,
    typecheck_ns: 0,
    irgen_ns: 0,
    ir_verify_ns: 0,
    codegen_ns: 0,
  };
}

fn dur_nonneg_ns(start_ns: i64, end_ns: i64) -> i64 {
  if end_ns <= start_ns { return 0; }
  return end_ns - start_ns;
}

fn prof_ok(r: CompileResult, p: CompilePhaseProfile) -> CompileProfileResult {
  return CompileProfileResult { r: r, p: p };
}

fn compile_kind_from_tc(k: i32) -> i32 {
  if k == tc.diag_kind_type() { return compile_diag_kind_type(); }
  if k == tc.diag_kind_import() { return compile_diag_kind_import(); }
  return compile_diag_kind_none();
}

fn compile_kind_from_parse(k: i32) -> i32 {
  if k == p.parse_diag_kind_parse() { return compile_diag_kind_parse(); }
  if k == p.parse_diag_kind_lex() { return compile_diag_kind_lex(); }
  return compile_diag_kind_none();
}

fn compile_kind_from_loader(k: i32) -> i32 {
  if k == ld.load_diag_kind_parse() { return compile_diag_kind_parse(); }
  if k == ld.load_diag_kind_lex() { return compile_diag_kind_lex(); }
  if k == ld.load_diag_kind_loader() { return compile_diag_kind_loader(); }
  return compile_diag_kind_none();
}

fn macroexpand_notes_render(notes: Vec[String]) -> String {
  if notes.len() == 0 { return ""; }
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < notes.len() {
    if i != 0 { out = out.concat("\n"); }
    out = out.concat("[macroexpand] ").concat(notes.get(i));
    i = i + 1;
  }
  return out;
}

fn with_macroexpand_notes(rendered: String, notes: Vec[String]) -> String {
  let ns: String = macroexpand_notes_render(notes);
  if ns == "" { return rendered; }
  return rendered.concat("\n").concat(ns);
}

fn compile_code_deprecated() -> String { return "W_DEPRECATED_0001"; }

fn compile_warn_render(sp: ast.Span, msg: String) -> String {
  let code: String = compile_code_deprecated();
  let file: String = if sp.file == "" { "<unknown>" } else { sp.file };
  return file
    .concat(":")
    .concat(sp.line.to_string())
    .concat(":")
    .concat(sp.col.to_string())
    .concat(": warning: ")
    .concat(msg)
    .concat(" [")
    .concat(code)
    .concat("]");
}

fn warning_skip_mod(mod_path: String) -> bool {
  return txt.has_prefix(mod_path, "std/") || txt.has_prefix(mod_path, "vox/");
}

fn warnings_contains(ws: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < ws.len() {
    if ws.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn warnings_add_unique(ws0: Vec[String], s: String) -> Vec[String] {
  if warnings_contains(ws0, s) { return ws0; }
  let mut ws: Vec[String] = ws0;
  ws.push(s);
  return ws;
}

fn deprecated_builtin_message(name: String) -> String {
  if name == "@same_layout" {
    return "use @bitcastable for layout-compatible checks";
  }
  return "";
}

struct DeprecatedFnDecl {
  mod_path: String,
  name: String,
  message: String,
}

fn collect_deprecated_fn_decls(w: tc.World) -> Vec[DeprecatedFnDecl] {
  let mut out: Vec[DeprecatedFnDecl] = Vec();
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: tc.WorldModule = w.mods.get(mi);
    let mut fi: i32 = 0;
    while fi < m.prog.funcs.len() {
      let fd: ast.FuncDecl = m.prog.funcs.get(fi);
      if fd.deprecated_message != "" {
        out.push(DeprecatedFnDecl {
          mod_path: m.path,
          name: fd.name,
          message: fd.deprecated_message,
        });
      }
      fi = fi + 1;
    }
    mi = mi + 1;
  }
  return out;
}

fn find_deprecated_fn_message(ds: Vec[DeprecatedFnDecl], mod_path: String, name: String) -> String {
  let mut i: i32 = 0;
  while i < ds.len() {
    let d: DeprecatedFnDecl = ds.get(i);
    if d.mod_path == mod_path && d.name == name { return d.message; }
    i = i + 1;
  }
  return "";
}

struct QNameSplitResult {
  mod_path: String,
  name: String,
}

fn qname_split(qn: String) -> QNameSplitResult {
  let mut cut: i32 = -1;
  let mut i: i32 = 0;
  while (i + 1) < qn.len() {
    if qn.byte_at(i) == 58 && qn.byte_at(i + 1) == 58 {
      cut = i;
    }
    i = i + 1;
  }
  if cut == -1 {
    return QNameSplitResult { mod_path: "", name: qn };
  }
  return QNameSplitResult { mod_path: qn.slice(0, cut), name: qn.slice(cut + 2, qn.len()) };
}

fn collect_deprecated_warnings_ir(ctx: tc.Ctx, prog: ir.Program, ws0: Vec[String]) -> Vec[String] {
  let mut ws: Vec[String] = ws0;
  let mut fi: i32 = 0;
  while fi < prog.funcs.len() {
    let f: ir.Func = prog.funcs.get(fi);
    let fn_q: QNameSplitResult = qname_split(f.name);
    if warning_skip_mod(fn_q.mod_path) {
      fi = fi + 1;
      continue;
    }
    let mut bi: i32 = 0;
    while bi < f.blocks.len() {
      let b: ir.Block = f.blocks.get(bi);
      let mut ii: i32 = 0;
      while ii < b.instrs.len() {
        let ins: ir.Instr = b.instrs.get(ii);
        if match ins { ir.Instr.Call(_, _, _, _, _) => true, _ => false } {
          let qn: String = match ins { ir.Instr.Call(_, _, _, n, _) => n, _ => "" };
          let cq: QNameSplitResult = qname_split(qn);
          let fr: tc.FindFuncResult = tc.find_func(ctx, cq.mod_path, cq.name);
          if fr.found && fr.deprecated_message != "" {
            let line: String = compile_warn_render(
              ast.span0(),
              "deprecated function `".concat(qn).concat("` (called from `").concat(f.name).concat("`): ").concat(fr.deprecated_message),
            );
            ws = warnings_add_unique(ws, line);
          }
        }
        ii = ii + 1;
      }
      bi = bi + 1;
    }
    fi = fi + 1;
  }
  return ws;
}

struct ResolveMacroTargetResult {
  found: bool,
  mod_path: String,
  name: String,
}

fn resolve_macro_target_none() -> ResolveMacroTargetResult {
  return ResolveMacroTargetResult { found: false, mod_path: "", name: "" };
}

fn import_named_target(imps: Vec[ast.ImportDecl], file: String, local: String) -> ResolveMacroTargetResult {
  let mut i: i32 = 0;
  while i < imps.len() {
    let d: ast.ImportDecl = imps.get(i);
    if d.file != file { i = i + 1; continue; }
    let mut ni: i32 = 0;
    while ni < d.names.len() {
      let nm: ast.ImportName = d.names.get(ni);
      let lname: String = if nm.alias == "" { nm.name } else { nm.alias };
      if lname == local {
        return ResolveMacroTargetResult { found: true, mod_path: d.path, name: nm.name };
      }
      ni = ni + 1;
    }
    i = i + 1;
  }
  return resolve_macro_target_none();
}

fn import_alias_target_mod(imps: Vec[ast.ImportDecl], file: String, alias: String) -> String {
  let mut i: i32 = 0;
  while i < imps.len() {
    let d: ast.ImportDecl = imps.get(i);
    if d.file == file && d.names.len() == 0 && d.alias == alias {
      return d.path;
    }
    i = i + 1;
  }
  return "";
}

fn resolve_macro_target(mod_path: String, imports: Vec[ast.ImportDecl], exprs: ast.ExprPool, file: String, callee: i32) -> ResolveMacroTargetResult {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, callee);
  if match n { ast.ExprNode.Ident(_) => true, _ => false } {
    let name: String = match n { ast.ExprNode.Ident(s) => s, _ => "" };
    let ir: ResolveMacroTargetResult = import_named_target(imports, file, name);
    if ir.found { return ir; }
    return ResolveMacroTargetResult { found: true, mod_path: mod_path, name: name };
  }
  if match n { ast.ExprNode.Member(_, _) => true, _ => false } {
    let recv: i32 = match n { ast.ExprNode.Member(r, _nm) => r, _ => -1 };
    let name: String = match n { ast.ExprNode.Member(_r, nm) => nm, _ => "" };
    let rn: ast.ExprNode = ast.expr_pool_get(exprs, recv);
    if match rn { ast.ExprNode.Ident(_) => true, _ => false } {
      let alias: String = match rn { ast.ExprNode.Ident(s) => s, _ => "" };
      let target_mod: String = import_alias_target_mod(imports, file, alias);
      if target_mod != "" {
        return ResolveMacroTargetResult { found: true, mod_path: target_mod, name: name };
      }
    }
  }
  return resolve_macro_target_none();
}

fn collect_deprecated_warnings_block(
  mod_path: String,
  prog: ast.Program,
  ds: Vec[DeprecatedFnDecl],
  b: ast.Block,
  ws0: Vec[String],
) -> Vec[String] {
  let mut ws: Vec[String] = ws0;
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    ws = collect_deprecated_warnings_stmt(mod_path, prog, ds, b.stmts.get(i), ws);
    i = i + 1;
  }
  return ws;
}

fn collect_deprecated_warnings_expr_block(
  mod_path: String,
  prog: ast.Program,
  ds: Vec[DeprecatedFnDecl],
  b: ast.ExprBlock,
  ws0: Vec[String],
) -> Vec[String] {
  let mut ws: Vec[String] = ws0;
  let mut i: i32 = 0;
  while i < b.stmts.len() {
    ws = collect_deprecated_warnings_stmt(mod_path, prog, ds, b.stmts.get(i), ws);
    i = i + 1;
  }
  if b.has_tail {
    ws = collect_deprecated_warnings_expr(mod_path, prog, ds, b.tail, ws);
  }
  return ws;
}

fn collect_deprecated_warnings_stmt(
  mod_path: String,
  prog: ast.Program,
  ds: Vec[DeprecatedFnDecl],
  st: ast.Stmt,
  ws0: Vec[String],
) -> Vec[String] {
  let mut ws: Vec[String] = ws0;
  return match st {
    ast.Stmt.Let(_sp, _mut, _name, _has_ann, _ann, init) => collect_deprecated_warnings_expr(mod_path, prog, ds, init, ws),
    ast.Stmt.Assign(_sp, _name, ex) => collect_deprecated_warnings_expr(mod_path, prog, ds, ex, ws),
    ast.Stmt.AssignField(_sp, _recv, _field, ex) => collect_deprecated_warnings_expr(mod_path, prog, ds, ex, ws),
    ast.Stmt.ExprStmt(_sp, ex) => collect_deprecated_warnings_expr(mod_path, prog, ds, ex, ws),
    ast.Stmt.IfStmt(_sp, cond, then_b, has_else, else_b) => {
      ws = collect_deprecated_warnings_expr(mod_path, prog, ds, cond, ws);
      ws = collect_deprecated_warnings_block(mod_path, prog, ds, then_b, ws);
      if has_else {
        ws = collect_deprecated_warnings_block(mod_path, prog, ds, else_b, ws);
      }
      ws
    },
    ast.Stmt.WhileStmt(_sp, cond, body) => {
      ws = collect_deprecated_warnings_expr(mod_path, prog, ds, cond, ws);
      collect_deprecated_warnings_block(mod_path, prog, ds, body, ws)
    },
    ast.Stmt.TryBegin(_sp, _name) => ws,
    ast.Stmt.TryEnd(_sp) => ws,
    ast.Stmt.Break(_sp) => ws,
    ast.Stmt.Continue(_sp) => ws,
    ast.Stmt.ReturnStmt(_sp, has_ex, ex) => {
      if has_ex { return collect_deprecated_warnings_expr(mod_path, prog, ds, ex, ws); }
      ws
    },
  };
}

fn collect_deprecated_warnings_expr(
  mod_path: String,
  prog: ast.Program,
  ds: Vec[DeprecatedFnDecl],
  id: i32,
  ws0: Vec[String],
) -> Vec[String] {
  let mut ws: Vec[String] = ws0;
  let n: ast.ExprNode = ast.expr_pool_get(prog.exprs, id);
  let sp: ast.Span = ast.expr_pool_span(prog.exprs, id);

  if match n { ast.ExprNode.Call(_, _, _) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(callee0, _ta, _args) => callee0, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_callee0, _ta, args0) => args0, _ => Vec() };
    let cn: ast.ExprNode = ast.expr_pool_get(prog.exprs, callee);
    if match cn { ast.ExprNode.Ident(_) => true, _ => false } {
      let name: String = match cn { ast.ExprNode.Ident(s) => s, _ => "" };
      let msg: String = deprecated_builtin_message(name);
      if msg != "" && !warning_skip_mod(mod_path) {
        let line: String = compile_warn_render(
          sp,
          "deprecated builtin `".concat(name).concat("`: ").concat(msg),
        );
        ws = warnings_add_unique(ws, line);
      }
    }
    ws = collect_deprecated_warnings_expr(mod_path, prog, ds, callee, ws);
    let mut ai: i32 = 0;
    while ai < args.len() {
      ws = collect_deprecated_warnings_expr(mod_path, prog, ds, args.get(ai), ws);
      ai = ai + 1;
    }
    return ws;
  }

  if match n { ast.ExprNode.MacroCall(_, _, _) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.MacroCall(callee0, _ta, _args) => callee0, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.MacroCall(_callee0, _ta, args0) => args0, _ => Vec() };
    let mr: ResolveMacroTargetResult = resolve_macro_target(mod_path, prog.imports, prog.exprs, sp.file, callee);
    if mr.found && !warning_skip_mod(mod_path) {
      let msg: String = find_deprecated_fn_message(ds, mr.mod_path, mr.name);
      if msg != "" {
        let line: String = compile_warn_render(
          sp,
          "deprecated macro `".concat(mr.name).concat("!`: ").concat(msg),
        );
        ws = warnings_add_unique(ws, line);
      }
    }
    ws = collect_deprecated_warnings_expr(mod_path, prog, ds, callee, ws);
    let mut ai: i32 = 0;
    while ai < args.len() {
      ws = collect_deprecated_warnings_expr(mod_path, prog, ds, args.get(ai), ws);
      ai = ai + 1;
    }
    return ws;
  }

  return match n {
    ast.ExprNode.Int(_) => ws,
    ast.ExprNode.Float(_) => ws,
    ast.ExprNode.Bool(_) => ws,
    ast.ExprNode.Ident(_) => ws,
    ast.ExprNode.Str(_) => ws,
    ast.ExprNode.DotIdent(_) => ws,
    ast.ExprNode.Block(b) => collect_deprecated_warnings_expr_block(mod_path, prog, ds, b, ws),
    ast.ExprNode.If(c0, t0, e0) => {
      ws = collect_deprecated_warnings_expr(mod_path, prog, ds, c0, ws);
      ws = collect_deprecated_warnings_expr(mod_path, prog, ds, t0, ws);
      collect_deprecated_warnings_expr(mod_path, prog, ds, e0, ws)
    },
    ast.ExprNode.Unary(_op, a) => collect_deprecated_warnings_expr(mod_path, prog, ds, a, ws),
    ast.ExprNode.As(a, _tn) => collect_deprecated_warnings_expr(mod_path, prog, ds, a, ws),
    ast.ExprNode.Binary(_op, l, r) => {
      ws = collect_deprecated_warnings_expr(mod_path, prog, ds, l, ws);
      collect_deprecated_warnings_expr(mod_path, prog, ds, r, ws)
    },
    ast.ExprNode.Member(recv, _name) => collect_deprecated_warnings_expr(mod_path, prog, ds, recv, ws),
    ast.ExprNode.Call(_callee, _ta, _args) => ws,
    ast.ExprNode.MacroCall(_callee, _ta, _args) => ws,
    ast.ExprNode.TryBlock(bid) => collect_deprecated_warnings_expr(mod_path, prog, ds, bid, ws),
    ast.ExprNode.Try(a) => collect_deprecated_warnings_expr(mod_path, prog, ds, a, ws),
    ast.ExprNode.Await(a) => collect_deprecated_warnings_expr(mod_path, prog, ds, a, ws),
    ast.ExprNode.StructLit(tyex, fields) => {
      ws = collect_deprecated_warnings_expr(mod_path, prog, ds, tyex, ws);
      let mut fi: i32 = 0;
      while fi < fields.len() {
        ws = collect_deprecated_warnings_expr(mod_path, prog, ds, fields.get(fi).expr, ws);
        fi = fi + 1;
      }
      ws
    },
    ast.ExprNode.Match(scrut, arms) => {
      ws = collect_deprecated_warnings_expr(mod_path, prog, ds, scrut, ws);
      let mut ai: i32 = 0;
      while ai < arms.len() {
        ws = collect_deprecated_warnings_expr(mod_path, prog, ds, arms.get(ai).expr, ws);
        ai = ai + 1;
      }
      ws
    },
  };
}

fn collect_deprecated_warnings_world(w: tc.World) -> Vec[String] {
  let ds: Vec[DeprecatedFnDecl] = collect_deprecated_fn_decls(w);
  let mut ws: Vec[String] = Vec();
  let mut mi: i32 = 0;
  while mi < w.mods.len() {
    let m: tc.WorldModule = w.mods.get(mi);
    let mod_path: String = m.path;
    let prog: ast.Program = m.prog;
    let mut ci: i32 = 0;
    while ci < prog.consts.len() {
      ws = collect_deprecated_warnings_expr(mod_path, prog, ds, prog.consts.get(ci).init, ws);
      ci = ci + 1;
    }
    let mut fi: i32 = 0;
    while fi < prog.funcs.len() {
      ws = collect_deprecated_warnings_block(mod_path, prog, ds, prog.funcs.get(fi).body, ws);
      fi = fi + 1;
    }
    let mut ti: i32 = 0;
    while ti < prog.traits.len() {
      let td: ast.TraitDecl = prog.traits.get(ti);
      let mut tmi: i32 = 0;
      while tmi < td.methods.len() {
        let md: ast.TraitMethodDecl = td.methods.get(tmi);
        if md.has_body {
          ws = collect_deprecated_warnings_block(mod_path, prog, ds, md.body, ws);
        }
        tmi = tmi + 1;
      }
      ti = ti + 1;
    }
    let mut ii: i32 = 0;
    while ii < prog.impls.len() {
      let id: ast.ImplDecl = prog.impls.get(ii);
      let mut im: i32 = 0;
      while im < id.methods.len() {
        ws = collect_deprecated_warnings_block(mod_path, prog, ds, id.methods.get(im).body, ws);
        im = im + 1;
      }
      ii = ii + 1;
    }
    mi = mi + 1;
  }
  return ws;
}

fn func_name_exists(fs: Vec[ast.FuncDecl], name: String) -> bool {
  let mut i: i32 = 0;
  while i < fs.len() {
    if fs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn fresh_inner_name(prog: ast.Program, base: String) -> String {
  if !func_name_exists(prog.funcs, base) { return base; }
  let mut n: i32 = 0;
  while true {
    let cand: String = base.concat("$").concat(n.to_string());
    if !func_name_exists(prog.funcs, cand) { return cand; }
    n = n + 1;
  }
  return base.concat("$0");
}

fn import_alias_conflict(imps: Vec[ast.ImportDecl], file: String, alias: String) -> bool {
  let mut i: i32 = 0;
  while i < imps.len() {
    let d: ast.ImportDecl = imps.get(i);
    if d.file == file && d.alias == alias { return true; }
    i = i + 1;
  }
  return false;
}

fn find_std_async_alias(imps: Vec[ast.ImportDecl], file: String) -> String {
  let mut i: i32 = 0;
  while i < imps.len() {
    let d: ast.ImportDecl = imps.get(i);
    if d.file == file && d.path == "std/async" && d.names.len() == 0 && d.alias != "" {
      return d.alias;
    }
    i = i + 1;
  }
  return "";
}

fn prog_has_func(prog: ast.Program, name: String) -> bool {
  let mut i: i32 = 0;
  while i < prog.funcs.len() {
    if prog.funcs.get(i).name == name { return true; }
    i = i + 1;
  }
  return false;
}

fn world_mod_has_func(w: tc.World, mod_path: String, name: String) -> bool {
  let mut i: i32 = 0;
  while i < w.mods.len() {
    let m: tc.WorldModule = w.mods.get(i);
    if m.path == mod_path {
      if prog_has_func(m.prog, name) { return true; }
    }
    i = i + 1;
  }
  return false;
}

struct EnsureAsyncImportResult { prog: ast.Program, alias: String }

fn ensure_std_async_import(prog0: ast.Program, file: String, sp: ast.Span) -> EnsureAsyncImportResult {
  let existing: String = find_std_async_alias(prog0.imports, file);
  if existing != "" {
    return EnsureAsyncImportResult { prog: prog0, alias: existing };
  }
  let mut alias: String = "__async_entry";
  if import_alias_conflict(prog0.imports, file, alias) {
    let mut n: i32 = 0;
    while true {
      let cand: String = "__async_entry".concat(n.to_string());
      if !import_alias_conflict(prog0.imports, file, cand) { alias = cand; break; }
      n = n + 1;
    }
  }
  let mut prog: ast.Program = prog0;
  prog.imports.push(ast.ImportDecl { file: file, sp: sp, path: "std/async", alias: alias, names: Vec() });
  return EnsureAsyncImportResult { prog: prog, alias: alias };
}

struct AddExprToProgResult { prog: ast.Program, id: i32 }

fn add_expr_to_prog(prog0: ast.Program, sp: ast.Span, n: ast.ExprNode) -> AddExprToProgResult {
  let r: ast.AddExprResult = ast.expr_pool_add(prog0.exprs, n, sp);
  let mut prog: ast.Program = prog0;
  prog.exprs = r.pool;
  return AddExprToProgResult { prog: prog, id: r.id };
}

struct AddCancelHintExprResult { prog: ast.Program, id: i32 }

fn add_cancel_hint_expr(
  prog0: ast.Program,
  sp: ast.Span,
  async_alias: String,
  has_spins_counter: bool,
) -> AddCancelHintExprResult {
  let mut prog: ast.Program = prog0;
  let r_a: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
  prog = r_a.prog;
  let r_hint_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a.id, "cancel_hint"));
  prog = r_hint_fn.prog;
  let r_cx: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
  prog = r_cx.prog;
  let r_f: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
  prog = r_f.prog;
  let r_state: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f.id, "state"));
  prog = r_state.prog;
  let r_spins: AddExprToProgResult =
    if has_spins_counter {
      add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"))
    } else {
      add_expr_to_prog(prog, sp, ast.ExprNode.Int("0"))
    };
  prog = r_spins.prog;
  let mut args: Vec[i32] = Vec();
  args.push(r_cx.id);
  args.push(r_state.id);
  args.push(r_spins.id);
  let r_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_hint_fn.id, Vec(), args));
  prog = r_call.prog;
  return AddCancelHintExprResult { prog: prog, id: r_call.id };
}

fn dummy_type_name() -> ast.TypeName {
  return ast.TypeName { parts: Vec(), args: Vec() };
}

fn typename_is0(tn: ast.TypeName, s: String) -> bool {
  return tn.parts.len() == 1 && tn.parts.get(0) == s && tn.args.len() == 0;
}

fn fallback_zero_expr_for_type(ret: ast.TypeName) -> ast.ExprNode {
  if typename_is0(ret, "bool") { return ast.ExprNode.Bool(false); }
  if typename_is0(ret, "f32") || typename_is0(ret, "f64") { return ast.ExprNode.Float("0.0"); }
  if typename_is0(ret, "String") || typename_is0(ret, "str") { return ast.ExprNode.Str(""); }
  return ast.ExprNode.Int("0");
}

struct MkAsyncPollLoopBodyResult { prog: ast.Program, body: ast.Block }

fn mk_async_poll_loop_body(
  prog0: ast.Program,
  sp: ast.Span,
  async_alias: String,
  inner_name: String,
  ret: ast.TypeName,
  has_default_runtime: bool,
  has_park_until_wake_with: bool,
  has_park_with: bool,
  has_cancel_hint: bool,
  has_cancel_drop_hint_with: bool,
  has_cancel_drop_state_with: bool,
  has_cancel_drop_with: bool,
  has_cancel_cleanup_hint_with: bool,
  has_cancel_cleanup_state_with: bool,
  has_cancel_cleanup_with: bool,
  has_cancel_return_hint_with: bool,
  has_cancel_return_with: bool,
  has_cancel_requested_with: bool,
  has_pending_wait_with: bool,
  has_park_until_wake: bool,
  has_park: bool,
  has_cancel_drop_hint: bool,
  has_cancel_drop_state: bool,
  has_cancel_drop: bool,
  has_cancel_cleanup_hint: bool,
  has_cancel_cleanup_state: bool,
  has_cancel_cleanup: bool,
  has_cancel_return_hint: bool,
  has_cancel_return: bool,
  has_cancel_requested: bool,
  has_pending_wait: bool,
  has_spin_wait: bool,
) -> MkAsyncPollLoopBodyResult {
  let mut prog: ast.Program = prog0;
  let ret_is_unit: bool = typename_is0(ret, "()");

  // A dummy expr id to satisfy AST fields where a tail is unused.
  let r_dummy: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Int("0"));
  prog = r_dummy.prog;

  // cx = async.context(async.waker(0))
  let r_alias: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
  prog = r_alias.prog;
  let r_waker: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_alias.id, "waker"));
  prog = r_waker.prog;
  let r_zero: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Int("0"));
  prog = r_zero.prog;
  let mut wargs: Vec[i32] = Vec();
  wargs.push(r_zero.id);
  let r_wcall: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_waker.id, Vec(), wargs));
  prog = r_wcall.prog;
  let r_ctx_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_alias.id, "context"));
  prog = r_ctx_fn.prog;
  let mut cargs: Vec[i32] = Vec();
  cargs.push(r_wcall.id);
  let r_cx_init: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_ctx_fn.id, Vec(), cargs));
  prog = r_cx_init.prog;
  let s_cx: ast.Stmt = ast.Stmt.Let(sp, false, "cx", false, dummy_type_name(), r_cx_init.id);

  // mut f = inner()
  let r_inner: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(inner_name));
  prog = r_inner.prog;
  let r_f_init: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_inner.id, Vec(), Vec()));
  prog = r_f_init.prog;
  let s_f: ast.Stmt = ast.Stmt.Let(sp, true, "f", false, dummy_type_name(), r_f_init.id);
  let has_runtime_hooks_with: bool =
    has_park_until_wake_with ||
    has_park_with ||
    has_pending_wait_with ||
    has_cancel_requested_with ||
    (has_cancel_hint && has_cancel_return_hint_with) ||
    has_cancel_return_with ||
    (has_cancel_hint && has_cancel_cleanup_hint_with) ||
    has_cancel_cleanup_with ||
    has_cancel_cleanup_state_with ||
    (has_cancel_hint && has_cancel_drop_hint_with) ||
    has_cancel_drop_with ||
    has_cancel_drop_state_with;
  let use_runtime_with: bool = has_default_runtime && has_runtime_hooks_with;
  let mut s_rt: ast.Stmt = ast.Stmt.ExprStmt(sp, r_dummy.id);
  if use_runtime_with {
    let r_alias_rt: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_alias_rt.prog;
    let r_default_rt: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_alias_rt.id, "default_runtime"));
    prog = r_default_rt.prog;
    let r_rt_init: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_default_rt.id, Vec(), Vec()));
    prog = r_rt_init.prog;
    s_rt = ast.Stmt.Let(sp, false, "rt", false, dummy_type_name(), r_rt_init.id);
  }
  let has_spins_counter: bool =
    has_park_until_wake_with ||
    has_park_with ||
    has_pending_wait_with ||
    has_park_until_wake ||
    has_park ||
    has_pending_wait ||
    has_spin_wait;
  let mut s_spins: ast.Stmt = ast.Stmt.ExprStmt(sp, r_dummy.id);
  if has_spins_counter {
    let r_spins0: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Int("0"));
    prog = r_spins0.prog;
    s_spins = ast.Stmt.Let(sp, true, "spins", false, dummy_type_name(), r_spins0.id);
  }

  // while true { let p = f.poll(cx); match p { .Pending => { continue; }, .Ready(v) => { return v; } } }
  let r_true: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Bool(true));
  prog = r_true.prog;

  let r_f: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
  prog = r_f.prog;
  let r_poll: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f.id, "poll"));
  prog = r_poll.prog;
  let r_cx: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
  prog = r_cx.prog;
  let mut pargs: Vec[i32] = Vec();
  pargs.push(r_cx.id);
  let r_p_init: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_poll.id, Vec(), pargs));
  prog = r_p_init.prog;
  let s_p: ast.Stmt = ast.Stmt.Let(sp, false, "p", false, dummy_type_name(), r_p_init.id);

  let r_p: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("p"));
  prog = r_p.prog;

  let mut pend_stmts: Vec[ast.Stmt] = Vec();
  if use_runtime_with && has_park_until_wake_with {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_parkw: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "park_until_wake_with"));
    prog = r_parkw.prog;
    let r_rt: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
    prog = r_rt.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let r_cx2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx2.prog;
    let mut parkw_args: Vec[i32] = Vec();
    parkw_args.push(r_rt.id);
    parkw_args.push(r_spinsv.id);
    parkw_args.push(r_cx2.id);
    let r_parkw_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_parkw.id, Vec(), parkw_args));
    prog = r_parkw_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_parkw_call.id));
  } else if use_runtime_with && has_park_with {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_park: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "park_with"));
    prog = r_park.prog;
    let r_rt: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
    prog = r_rt.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let r_cx2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx2.prog;
    let mut park_args: Vec[i32] = Vec();
    park_args.push(r_rt.id);
    park_args.push(r_spinsv.id);
    park_args.push(r_cx2.id);
    let r_park_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_park.id, Vec(), park_args));
    prog = r_park_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_park_call.id));
  } else if use_runtime_with && has_pending_wait_with {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_pwait: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "pending_wait_with"));
    prog = r_pwait.prog;
    let r_rt: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
    prog = r_rt.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let r_cx2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx2.prog;
    let mut pwait_args: Vec[i32] = Vec();
    pwait_args.push(r_rt.id);
    pwait_args.push(r_spinsv.id);
    pwait_args.push(r_cx2.id);
    let r_pwait_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_pwait.id, Vec(), pwait_args));
    prog = r_pwait_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_pwait_call.id));
  } else if has_park_until_wake {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_parkw: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "park_until_wake"));
    prog = r_parkw.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let r_cx2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx2.prog;
    let mut parkw_args: Vec[i32] = Vec();
    parkw_args.push(r_spinsv.id);
    parkw_args.push(r_cx2.id);
    let r_parkw_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_parkw.id, Vec(), parkw_args));
    prog = r_parkw_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_parkw_call.id));
  } else if has_park {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_park: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "park"));
    prog = r_park.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let r_cx2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx2.prog;
    let mut park_args: Vec[i32] = Vec();
    park_args.push(r_spinsv.id);
    park_args.push(r_cx2.id);
    let r_park_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_park.id, Vec(), park_args));
    prog = r_park_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_park_call.id));
  } else if has_pending_wait {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_pwait: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "pending_wait"));
    prog = r_pwait.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let r_cx2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx2.prog;
    let mut pwait_args: Vec[i32] = Vec();
    pwait_args.push(r_spinsv.id);
    pwait_args.push(r_cx2.id);
    let r_pwait_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_pwait.id, Vec(), pwait_args));
    prog = r_pwait_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_pwait_call.id));
  } else if has_spin_wait {
    let r_a2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a2.prog;
    let r_spin: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a2.id, "spin_wait"));
    prog = r_spin.prog;
    let r_spinsv: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsv.prog;
    let mut spin_args: Vec[i32] = Vec();
    spin_args.push(r_spinsv.id);
    let r_spin_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_spin.id, Vec(), spin_args));
    prog = r_spin_call.prog;
    pend_stmts.push(ast.Stmt.ExprStmt(sp, r_spin_call.id));

    let r_spinsl: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("spins"));
    prog = r_spinsl.prog;
    let r_one: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Int("1"));
    prog = r_one.prog;
    let r_next: AddExprToProgResult =
      add_expr_to_prog(prog, sp, ast.ExprNode.Binary(ast.BinaryOp.Add, r_spinsl.id, r_one.id));
    prog = r_next.prog;
    pend_stmts.push(ast.Stmt.Assign(sp, "spins", r_next.id));
  }
  if use_runtime_with && has_cancel_requested_with {
    let r_a3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a3.prog;
    let r_cancel_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a3.id, "cancel_requested_with"));
    prog = r_cancel_fn.prog;
    let r_rt2: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
    prog = r_rt2.prog;
    let r_cx3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx3.prog;
    let mut cancel_args: Vec[i32] = Vec();
    cancel_args.push(r_rt2.id);
    cancel_args.push(r_cx3.id);
    let r_cancel_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_fn.id, Vec(), cancel_args));
    prog = r_cancel_call.prog;

    let mut then_stmts: Vec[ast.Stmt] = Vec();
    let use_hint_hooks: bool =
      has_cancel_hint
        && (has_cancel_drop_hint_with
          || has_cancel_drop_hint
          || has_cancel_cleanup_hint_with
          || has_cancel_cleanup_hint
          || has_cancel_return_hint_with
          || has_cancel_return_hint);
    let mut hint_id: i32 = -1;
    if use_hint_hooks {
      let hr: AddCancelHintExprResult = add_cancel_hint_expr(prog, sp, async_alias, has_spins_counter);
      prog = hr.prog;
      hint_id = hr.id;
    }
    if use_runtime_with && has_cancel_drop_hint_with && hint_id != -1 {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_hint_with"));
      prog = r_drop_fn.prog;
      let r_rt_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_drop.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_rt_drop.id);
      drop_args.push(r_cx_drop.id);
      drop_args.push(hint_id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if has_cancel_drop_hint && hint_id != -1 {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_hint"));
      prog = r_drop_fn.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_cx_drop.id);
      drop_args.push(hint_id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if use_runtime_with && has_cancel_drop_state_with {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_state_with"));
      prog = r_drop_fn.prog;
      let r_rt_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_drop.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let r_f_state: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_drop.id, "state"));
      prog = r_f_state.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_rt_drop.id);
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_state.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if use_runtime_with && has_cancel_drop_with {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_with"));
      prog = r_drop_fn.prog;
      let r_rt_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_drop.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_rt_drop.id);
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if has_cancel_drop_state {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_state"));
      prog = r_drop_fn.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let r_f_state: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_drop.id, "state"));
      prog = r_f_state.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_state.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if has_cancel_drop {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop"));
      prog = r_drop_fn.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    }
    if use_runtime_with && has_cancel_cleanup_hint_with && hint_id != -1 {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_hint_with"));
      prog = r_cleanup_fn.prog;
      let r_rt_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_cleanup.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_rt_cleanup.id);
      cleanup_args.push(r_cx_cleanup.id);
      cleanup_args.push(hint_id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if has_cancel_cleanup_hint && hint_id != -1 {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_hint"));
      prog = r_cleanup_fn.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_cx_cleanup.id);
      cleanup_args.push(hint_id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if use_runtime_with && has_cancel_cleanup_state_with {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_state_with"));
      prog = r_cleanup_fn.prog;
      let r_rt_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_cleanup.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let r_f_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_cleanup.prog;
      let r_state_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_cleanup.id, "state"));
      prog = r_state_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_rt_cleanup.id);
      cleanup_args.push(r_cx_cleanup.id);
      cleanup_args.push(r_state_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if use_runtime_with && has_cancel_cleanup_with {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_with"));
      prog = r_cleanup_fn.prog;
      let r_rt_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_cleanup.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_rt_cleanup.id);
      cleanup_args.push(r_cx_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if has_cancel_cleanup_state {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_state"));
      prog = r_cleanup_fn.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let r_f_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_cleanup.prog;
      let r_state_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_cleanup.id, "state"));
      prog = r_state_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_cx_cleanup.id);
      cleanup_args.push(r_state_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if has_cancel_cleanup {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup"));
      prog = r_cleanup_fn.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_cx_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    }
    if use_runtime_with && has_cancel_return_hint_with && hint_id != -1 {
      let r_a4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a4.prog;
      let r_cancel_ret_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a4.id, "cancel_return_hint_with"));
      prog = r_cancel_ret_fn.prog;
      let r_rt3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt3.prog;
      let r_cx4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx4.prog;
      let mut ret_args: Vec[i32] = Vec();
      ret_args.push(r_rt3.id);
      ret_args.push(r_cx4.id);
      ret_args.push(hint_id);
      let r_cancel_ret_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_ret_fn.id, Vec(), ret_args));
      prog = r_cancel_ret_call.prog;
      if ret_is_unit {
        then_stmts.push(ast.Stmt.ExprStmt(sp, r_cancel_ret_call.id));
        then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
      } else {
        then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret_call.id));
      }
    } else if has_cancel_return_hint && hint_id != -1 {
      let r_a4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a4.prog;
      let r_cancel_ret_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a4.id, "cancel_return_hint"));
      prog = r_cancel_ret_fn.prog;
      let r_cx4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx4.prog;
      let mut ret_args: Vec[i32] = Vec();
      ret_args.push(r_cx4.id);
      ret_args.push(hint_id);
      let r_cancel_ret_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_ret_fn.id, Vec(), ret_args));
      prog = r_cancel_ret_call.prog;
      if ret_is_unit {
        then_stmts.push(ast.Stmt.ExprStmt(sp, r_cancel_ret_call.id));
        then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
      } else {
        then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret_call.id));
      }
    } else if use_runtime_with && has_cancel_return_with {
      let r_a4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a4.prog;
      let r_cancel_ret_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a4.id, "cancel_return_with"));
      prog = r_cancel_ret_fn.prog;
      let r_rt3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt3.prog;
      let r_cx4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx4.prog;
      let mut ret_args: Vec[i32] = Vec();
      ret_args.push(r_rt3.id);
      ret_args.push(r_cx4.id);
      let r_cancel_ret_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_ret_fn.id, Vec(), ret_args));
      prog = r_cancel_ret_call.prog;
      if ret_is_unit {
        then_stmts.push(ast.Stmt.ExprStmt(sp, r_cancel_ret_call.id));
        then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
      } else {
        then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret_call.id));
      }
    } else if has_cancel_return {
      let r_a4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a4.prog;
      let r_cancel_ret_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a4.id, "cancel_return"));
      prog = r_cancel_ret_fn.prog;
      let r_cx4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx4.prog;
      let mut ret_args: Vec[i32] = Vec();
      ret_args.push(r_cx4.id);
      let r_cancel_ret_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_ret_fn.id, Vec(), ret_args));
      prog = r_cancel_ret_call.prog;
      if ret_is_unit {
        then_stmts.push(ast.Stmt.ExprStmt(sp, r_cancel_ret_call.id));
        then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
      } else {
        then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret_call.id));
      }
    } else if ret_is_unit {
      then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
    } else {
      let r_cancel_ret: AddExprToProgResult = add_expr_to_prog(prog, sp, fallback_zero_expr_for_type(ret));
      prog = r_cancel_ret.prog;
      then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret.id));
    }
    pend_stmts.push(ast.Stmt.IfStmt(sp, r_cancel_call.id, ast.Block { stmts: then_stmts }, false, ast.Block { stmts: Vec() }));
  } else if has_cancel_requested {
    let r_a3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
    prog = r_a3.prog;
    let r_cancel_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a3.id, "cancel_requested"));
    prog = r_cancel_fn.prog;
    let r_cx3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
    prog = r_cx3.prog;
    let mut cancel_args: Vec[i32] = Vec();
    cancel_args.push(r_cx3.id);
    let r_cancel_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_fn.id, Vec(), cancel_args));
    prog = r_cancel_call.prog;

    let mut then_stmts: Vec[ast.Stmt] = Vec();
    let use_hint_hooks: bool =
      has_cancel_hint
        && (has_cancel_drop_hint_with
          || has_cancel_drop_hint
          || has_cancel_cleanup_hint_with
          || has_cancel_cleanup_hint
          || has_cancel_return_hint_with
          || has_cancel_return_hint);
    let mut hint_id: i32 = -1;
    if use_hint_hooks {
      let hr: AddCancelHintExprResult = add_cancel_hint_expr(prog, sp, async_alias, has_spins_counter);
      prog = hr.prog;
      hint_id = hr.id;
    }
    if use_runtime_with && has_cancel_drop_hint_with && hint_id != -1 {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_hint_with"));
      prog = r_drop_fn.prog;
      let r_rt_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_drop.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_rt_drop.id);
      drop_args.push(r_cx_drop.id);
      drop_args.push(hint_id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if has_cancel_drop_hint && hint_id != -1 {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_hint"));
      prog = r_drop_fn.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_cx_drop.id);
      drop_args.push(hint_id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if use_runtime_with && has_cancel_drop_state_with {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_state_with"));
      prog = r_drop_fn.prog;
      let r_rt_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_drop.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let r_f_state: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_drop.id, "state"));
      prog = r_f_state.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_rt_drop.id);
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_state.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if use_runtime_with && has_cancel_drop_with {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_with"));
      prog = r_drop_fn.prog;
      let r_rt_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_drop.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_rt_drop.id);
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if has_cancel_drop_state {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop_state"));
      prog = r_drop_fn.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let r_f_state: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_drop.id, "state"));
      prog = r_f_state.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_state.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    } else if has_cancel_drop {
      let r_a_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_drop.prog;
      let r_drop_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_drop.id, "cancel_drop"));
      prog = r_drop_fn.prog;
      let r_cx_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_drop.prog;
      let r_f_drop: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_drop.prog;
      let mut drop_args: Vec[i32] = Vec();
      drop_args.push(r_cx_drop.id);
      drop_args.push(r_f_drop.id);
      let r_drop_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_drop_fn.id, Vec(), drop_args));
      prog = r_drop_call.prog;
      then_stmts.push(ast.Stmt.Assign(sp, "f", r_drop_call.id));
    }
    if use_runtime_with && has_cancel_cleanup_hint_with && hint_id != -1 {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_hint_with"));
      prog = r_cleanup_fn.prog;
      let r_rt_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_cleanup.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_rt_cleanup.id);
      cleanup_args.push(r_cx_cleanup.id);
      cleanup_args.push(hint_id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if has_cancel_cleanup_hint && hint_id != -1 {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_hint"));
      prog = r_cleanup_fn.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_cx_cleanup.id);
      cleanup_args.push(hint_id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if use_runtime_with && has_cancel_cleanup_state_with {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_state_with"));
      prog = r_cleanup_fn.prog;
      let r_rt_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_cleanup.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let r_f_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_cleanup.prog;
      let r_state_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_cleanup.id, "state"));
      prog = r_state_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_rt_cleanup.id);
      cleanup_args.push(r_cx_cleanup.id);
      cleanup_args.push(r_state_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if use_runtime_with && has_cancel_cleanup_with {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_with"));
      prog = r_cleanup_fn.prog;
      let r_rt_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt_cleanup.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_rt_cleanup.id);
      cleanup_args.push(r_cx_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if has_cancel_cleanup_state {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup_state"));
      prog = r_cleanup_fn.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let r_f_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("f"));
      prog = r_f_cleanup.prog;
      let r_state_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_f_cleanup.id, "state"));
      prog = r_state_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_cx_cleanup.id);
      cleanup_args.push(r_state_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    } else if has_cancel_cleanup {
      let r_a_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a_cleanup.prog;
      let r_cleanup_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a_cleanup.id, "cancel_cleanup"));
      prog = r_cleanup_fn.prog;
      let r_cx_cleanup: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx_cleanup.prog;
      let mut cleanup_args: Vec[i32] = Vec();
      cleanup_args.push(r_cx_cleanup.id);
      let r_cleanup_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cleanup_fn.id, Vec(), cleanup_args));
      prog = r_cleanup_call.prog;
      then_stmts.push(ast.Stmt.ExprStmt(sp, r_cleanup_call.id));
    }
    if use_runtime_with && has_cancel_return_hint_with && hint_id != -1 {
      let r_a4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a4.prog;
      let r_cancel_ret_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a4.id, "cancel_return_hint_with"));
      prog = r_cancel_ret_fn.prog;
      let r_rt3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt3.prog;
      let r_cx4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx4.prog;
      let mut ret_args: Vec[i32] = Vec();
      ret_args.push(r_rt3.id);
      ret_args.push(r_cx4.id);
      ret_args.push(hint_id);
      let r_cancel_ret_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_ret_fn.id, Vec(), ret_args));
      prog = r_cancel_ret_call.prog;
      if ret_is_unit {
        then_stmts.push(ast.Stmt.ExprStmt(sp, r_cancel_ret_call.id));
        then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
      } else {
        then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret_call.id));
      }
    } else if has_cancel_return_hint && hint_id != -1 {
      let r_a4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a4.prog;
      let r_cancel_ret_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a4.id, "cancel_return_hint"));
      prog = r_cancel_ret_fn.prog;
      let r_cx4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx4.prog;
      let mut ret_args: Vec[i32] = Vec();
      ret_args.push(r_cx4.id);
      ret_args.push(hint_id);
      let r_cancel_ret_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_ret_fn.id, Vec(), ret_args));
      prog = r_cancel_ret_call.prog;
      if ret_is_unit {
        then_stmts.push(ast.Stmt.ExprStmt(sp, r_cancel_ret_call.id));
        then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
      } else {
        then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret_call.id));
      }
    } else if use_runtime_with && has_cancel_return_with {
      let r_a4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a4.prog;
      let r_cancel_ret_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a4.id, "cancel_return_with"));
      prog = r_cancel_ret_fn.prog;
      let r_rt3: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("rt"));
      prog = r_rt3.prog;
      let r_cx4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx4.prog;
      let mut ret_args: Vec[i32] = Vec();
      ret_args.push(r_rt3.id);
      ret_args.push(r_cx4.id);
      let r_cancel_ret_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_ret_fn.id, Vec(), ret_args));
      prog = r_cancel_ret_call.prog;
      if ret_is_unit {
        then_stmts.push(ast.Stmt.ExprStmt(sp, r_cancel_ret_call.id));
        then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
      } else {
        then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret_call.id));
      }
    } else if has_cancel_return {
      let r_a4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident(async_alias));
      prog = r_a4.prog;
      let r_cancel_ret_fn: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Member(r_a4.id, "cancel_return"));
      prog = r_cancel_ret_fn.prog;
      let r_cx4: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("cx"));
      prog = r_cx4.prog;
      let mut ret_args: Vec[i32] = Vec();
      ret_args.push(r_cx4.id);
      let r_cancel_ret_call: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Call(r_cancel_ret_fn.id, Vec(), ret_args));
      prog = r_cancel_ret_call.prog;
      if ret_is_unit {
        then_stmts.push(ast.Stmt.ExprStmt(sp, r_cancel_ret_call.id));
        then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
      } else {
        then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret_call.id));
      }
    } else if ret_is_unit {
      then_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
    } else {
      let r_cancel_ret: AddExprToProgResult = add_expr_to_prog(prog, sp, fallback_zero_expr_for_type(ret));
      prog = r_cancel_ret.prog;
      then_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_cancel_ret.id));
    }
    pend_stmts.push(ast.Stmt.IfStmt(sp, r_cancel_call.id, ast.Block { stmts: then_stmts }, false, ast.Block { stmts: Vec() }));
  }
  pend_stmts.push(ast.Stmt.Continue(sp));
  let r_pend_blk: AddExprToProgResult =
    add_expr_to_prog(prog, sp, ast.ExprNode.Block(ast.ExprBlock { stmts: pend_stmts, has_tail: false, tail: r_dummy.id }));
  prog = r_pend_blk.prog;

  let r_v: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Ident("v"));
  prog = r_v.prog;
  let mut ready_stmts: Vec[ast.Stmt] = Vec();
  if ret_is_unit {
    ready_stmts.push(ast.Stmt.ReturnStmt(sp, false, -1));
  } else {
    ready_stmts.push(ast.Stmt.ReturnStmt(sp, true, r_v.id));
  }
  let r_ready_blk: AddExprToProgResult =
    add_expr_to_prog(prog, sp, ast.ExprNode.Block(ast.ExprBlock { stmts: ready_stmts, has_tail: false, tail: r_dummy.id }));
  prog = r_ready_blk.prog;

  let mut arms: Vec[ast.MatchArm] = Vec();
  arms.push(ast.MatchArm { pat: ast.Pat.EnumVariant(sp, Vec(), "Pending", Vec()), expr: r_pend_blk.id });
  let mut ready_args: Vec[ast.Pat] = Vec();
  ready_args.push(ast.Pat.Bind(sp, "v"));
  arms.push(ast.MatchArm { pat: ast.Pat.EnumVariant(sp, Vec(), "Ready", ready_args), expr: r_ready_blk.id });
  let r_match: AddExprToProgResult = add_expr_to_prog(prog, sp, ast.ExprNode.Match(r_p.id, arms));
  prog = r_match.prog;
  let s_match: ast.Stmt = ast.Stmt.ExprStmt(sp, r_match.id);

  let mut while_stmts: Vec[ast.Stmt] = Vec();
  while_stmts.push(s_p);
  while_stmts.push(s_match);
  let while_body: ast.Block = ast.Block { stmts: while_stmts };
  let s_while: ast.Stmt = ast.Stmt.WhileStmt(sp, r_true.id, while_body);

  let mut ss: Vec[ast.Stmt] = Vec();
  ss.push(s_cx);
  ss.push(s_f);
  if use_runtime_with { ss.push(s_rt); }
  if has_park_until_wake_with || has_park_with || has_pending_wait_with || has_park_until_wake || has_park || has_pending_wait || has_spin_wait {
    ss.push(s_spins);
  }
  ss.push(s_while);
  if !ret_is_unit {
    let r_fallback: AddExprToProgResult = add_expr_to_prog(prog, sp, fallback_zero_expr_for_type(ret));
    prog = r_fallback.prog;
    ss.push(ast.Stmt.ReturnStmt(sp, true, r_fallback.id));
  }
  return MkAsyncPollLoopBodyResult { prog: prog, body: ast.Block { stmts: ss } };
}

fn rewrite_async_main_and_tests_in_program(
  prog0: ast.Program,
  emit_driver_main: bool,
  emit_test_main: bool,
  has_default_runtime: bool,
  has_park_until_wake_with: bool,
  has_park_with: bool,
  has_cancel_hint: bool,
  has_cancel_drop_hint_with: bool,
  has_cancel_drop_state_with: bool,
  has_cancel_drop_with: bool,
  has_cancel_cleanup_hint_with: bool,
  has_cancel_cleanup_state_with: bool,
  has_cancel_cleanup_with: bool,
  has_cancel_return_hint_with: bool,
  has_cancel_return_with: bool,
  has_cancel_requested_with: bool,
  has_pending_wait_with: bool,
  has_park_until_wake: bool,
  has_park: bool,
  has_cancel_drop_hint: bool,
  has_cancel_drop_state: bool,
  has_cancel_drop: bool,
  has_cancel_cleanup_hint: bool,
  has_cancel_cleanup_state: bool,
  has_cancel_cleanup: bool,
  has_cancel_return_hint: bool,
  has_cancel_return: bool,
  has_cancel_requested: bool,
  has_pending_wait: bool,
  has_spin_wait: bool,
) -> ast.Program {
  if !emit_driver_main && !emit_test_main { return prog0; }
  let mut prog: ast.Program = prog0;
  let mut out_funcs: Vec[ast.FuncDecl] = Vec();
  let mut appended: Vec[ast.FuncDecl] = Vec(); // renamed async bodies appended at end
  let mut i: i32 = 0;
  while i < prog.funcs.len() {
    let fd0: ast.FuncDecl = prog.funcs.get(i);

    let is_async_main: bool = emit_driver_main && fd0.is_async && fd0.name == "main";
    let is_async_test: bool = emit_test_main && fd0.is_async && txt.has_prefix(fd0.name, "test_");
    if is_async_main || is_async_test {
      // Names starting with `__` are reserved for compiler intrinsics; use a
      // single-underscore prefix for generated wrappers.
      let inner_name: String = fresh_inner_name(prog, "_async$".concat(fd0.name));
      let ir: EnsureAsyncImportResult = ensure_std_async_import(prog, fd0.file, fd0.sp);
      prog = ir.prog;
      let br: MkAsyncPollLoopBodyResult =
        mk_async_poll_loop_body(
          prog,
          fd0.sp,
          ir.alias,
          inner_name,
          fd0.ret,
          has_default_runtime,
          has_park_until_wake_with,
          has_park_with,
          has_cancel_hint,
          has_cancel_drop_hint_with,
          has_cancel_drop_state_with,
          has_cancel_drop_with,
          has_cancel_cleanup_hint_with,
          has_cancel_cleanup_state_with,
          has_cancel_cleanup_with,
          has_cancel_return_hint_with,
          has_cancel_return_with,
          has_cancel_requested_with,
          has_pending_wait_with,
          has_park_until_wake,
          has_park,
          has_cancel_drop_hint,
          has_cancel_drop_state,
          has_cancel_drop,
          has_cancel_cleanup_hint,
          has_cancel_cleanup_state,
          has_cancel_cleanup,
          has_cancel_return_hint,
          has_cancel_return,
          has_cancel_requested,
          has_pending_wait,
          has_spin_wait,
        );
      prog = br.prog;

      let mut inner: ast.FuncDecl = fd0;
      inner.name = inner_name;

      let mut wrap: ast.FuncDecl = fd0;
      wrap.is_async = false;
      wrap.type_params = Vec();
      wrap.type_param_packs = Vec();
      wrap.const_params = Vec();
      wrap.type_param_bounds = Vec();
      wrap.const_where_bounds = Vec();
      wrap.params = Vec(); // entrypoints/tests are parameterless in v0
      wrap.body = br.body;

      out_funcs.push(wrap);
      appended.push(inner);
    } else {
      out_funcs.push(fd0);
    }

    i = i + 1;
  }

  let mut j: i32 = 0;
  while j < appended.len() {
    out_funcs.push(appended.get(j));
    j = j + 1;
  }
  prog.funcs = out_funcs;
  return prog;
}

fn rewrite_async_entrypoints(w0: tc.World, opts: cg.EmitOptions) -> tc.World {
  if !opts.emit_driver_main && !opts.emit_test_main { return w0; }
  let has_default_runtime: bool = world_mod_has_func(w0, "std/async", "default_runtime");
  let has_park_until_wake_with: bool = world_mod_has_func(w0, "std/async", "park_until_wake_with");
  let has_park_with: bool = world_mod_has_func(w0, "std/async", "park_with");
  let has_cancel_hint: bool = world_mod_has_func(w0, "std/async", "cancel_hint");
  let has_cancel_drop_hint_with: bool = world_mod_has_func(w0, "std/async", "cancel_drop_hint_with");
  let has_cancel_drop_state_with: bool = world_mod_has_func(w0, "std/async", "cancel_drop_state_with");
  let has_cancel_drop_with: bool = world_mod_has_func(w0, "std/async", "cancel_drop_with");
  let has_cancel_cleanup_hint_with: bool = world_mod_has_func(w0, "std/async", "cancel_cleanup_hint_with");
  let has_cancel_cleanup_state_with: bool = world_mod_has_func(w0, "std/async", "cancel_cleanup_state_with");
  let has_cancel_cleanup_with: bool = world_mod_has_func(w0, "std/async", "cancel_cleanup_with");
  let has_cancel_return_hint_with: bool = world_mod_has_func(w0, "std/async", "cancel_return_hint_with");
  let has_cancel_return_with: bool = world_mod_has_func(w0, "std/async", "cancel_return_with");
  let has_cancel_requested_with: bool = world_mod_has_func(w0, "std/async", "cancel_requested_with");
  let has_pending_wait_with: bool = world_mod_has_func(w0, "std/async", "pending_wait_with");
  let has_park_until_wake: bool = world_mod_has_func(w0, "std/async", "park_until_wake");
  let has_park: bool = world_mod_has_func(w0, "std/async", "park");
  let has_cancel_drop_hint: bool = world_mod_has_func(w0, "std/async", "cancel_drop_hint");
  let has_cancel_drop_state: bool = world_mod_has_func(w0, "std/async", "cancel_drop_state");
  let has_cancel_drop: bool = world_mod_has_func(w0, "std/async", "cancel_drop");
  let has_cancel_cleanup_hint: bool = world_mod_has_func(w0, "std/async", "cancel_cleanup_hint");
  let has_cancel_cleanup_state: bool = world_mod_has_func(w0, "std/async", "cancel_cleanup_state");
  let has_cancel_cleanup: bool = world_mod_has_func(w0, "std/async", "cancel_cleanup");
  let has_cancel_return_hint: bool = world_mod_has_func(w0, "std/async", "cancel_return_hint");
  let has_cancel_return: bool = world_mod_has_func(w0, "std/async", "cancel_return");
  let has_cancel_requested: bool = world_mod_has_func(w0, "std/async", "cancel_requested");
  let has_pending_wait: bool = world_mod_has_func(w0, "std/async", "pending_wait");
  let has_spin_wait: bool = world_mod_has_func(w0, "std/async", "spin_wait");
  let mut w: tc.World = tc.world();
  let mut i: i32 = 0;
  while i < w0.mods.len() {
    let m: tc.WorldModule = w0.mods.get(i);
    let prog: ast.Program =
      rewrite_async_main_and_tests_in_program(
        m.prog,
        opts.emit_driver_main,
        opts.emit_test_main,
        has_default_runtime,
        has_park_until_wake_with,
        has_park_with,
        has_cancel_hint,
        has_cancel_drop_hint_with,
        has_cancel_drop_state_with,
        has_cancel_drop_with,
        has_cancel_cleanup_hint_with,
        has_cancel_cleanup_state_with,
        has_cancel_cleanup_with,
        has_cancel_return_hint_with,
        has_cancel_return_with,
        has_cancel_requested_with,
        has_pending_wait_with,
        has_park_until_wake,
        has_park,
        has_cancel_drop_hint,
        has_cancel_drop_state,
        has_cancel_drop,
        has_cancel_cleanup_hint,
        has_cancel_cleanup_state,
        has_cancel_cleanup,
        has_cancel_return_hint,
        has_cancel_return,
        has_cancel_requested,
        has_pending_wait,
        has_spin_wait,
      );
    w = tc.world_add(w, m.path, prog);
    i = i + 1;
  }
  return w;
}

pub fn compile_main_text_to_c(src: String, opts: cg.EmitOptions) -> CompileResult {
  return compile_main_text_to_c_for_target(src, opts, 64, "unknown", "unknown");
}

pub fn compile_main_text_to_c_for_ptr_bits(src: String, opts: cg.EmitOptions, ptr_bits: i32) -> CompileResult {
  return compile_main_text_to_c_for_target(src, opts, ptr_bits, "unknown", "unknown");
}

pub fn compile_main_text_to_c_for_target(src: String, opts: cg.EmitOptions, ptr_bits: i32, target_os: String, target_arch: String) -> CompileResult {
  let pr: p.ParseResult = p.parse_text_with_path("src/main.vox", src);
  if pr.err != p.ParseError.None {
    let pd: p.ParseDiag = p.parse_error_diag("src/main.vox", src, pr.err);
    return compile_err(compile_kind_from_parse(pd.kind), pd.code, pd.message, pd.rendered, Vec());
  }

  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "main", pr.prog);
  let warnings0: Vec[String] = collect_deprecated_warnings_world(w);

  let xr: mx.ExpandResult = mx.expand_world(w, mx.default_config());
  if !xr.ok {
    let code: String = compile_code_macroexpand();
    let msg0: String = tc.tc_error_message(xr.err);
    let msg: String = if msg0 != "" { msg0 } else { tc.tc_error_to_string(xr.err) };
    let rendered: String = tc.tc_error_to_string(xr.err).concat(" [").concat(code).concat("]");
    return compile_err(compile_diag_kind_macroexpand(), code, msg, rendered, warnings0);
  }

  let w2: tc.World = rewrite_async_entrypoints(xr.world, opts);
  let br: tc.BuildCtxResult = tc.build_ctx_with_target(w2, ptr_bits, target_os, target_arch);
  if !br.ok {
    let rendered: String = with_macroexpand_notes(tc.tc_error_to_string(br.err), xr.notes);
    return compile_err(compile_kind_from_tc(tc.tc_error_kind(br.err)), tc.tc_error_code(br.err), tc.tc_error_message(br.err), rendered, warnings0);
  }
  let tr: tc.TcResult = tc.typecheck_world_with_ctx(w2, br.ctx);
  if !tr.ok {
    let rendered: String = with_macroexpand_notes(tc.tc_error_to_string(tr.err), xr.notes);
    return compile_err(compile_kind_from_tc(tc.tc_error_kind(tr.err)), tc.tc_error_code(tr.err), tc.tc_error_message(tr.err), rendered, warnings0);
  }

  let gr: irgen.GenResult = irgen.generate_world_with_ctx(w2, br.ctx);
  if !gr.ok {
    return compile_err(compile_diag_kind_irgen(), tc.diag_code_irgen(), gr.err, gr.err, warnings0);
  }
  let warnings: Vec[String] = collect_deprecated_warnings_ir(br.ctx, gr.prog, warnings0);
  let vr: ir.VerifyResult = ir.verify_program(gr.prog);
  if !vr.ok {
    let code: String = compile_code_ir_verify();
    let msg: String = "ir verify failed: ".concat(vr.err);
    let rendered: String = msg.concat(" [").concat(code).concat("]");
    return compile_err(compile_diag_kind_ir_verify(), code, msg, rendered, warnings);
  }

  let c: String = cg.emit_c(gr.prog, opts);
  return compile_ok(c, warnings);
}

pub fn compile_files_to_c(files: Vec[ld.SourceFile], opts: cg.EmitOptions) -> CompileResult {
  let pr: CompileProfileResult = compile_files_to_c_profile(files, opts);
  return pr.r;
}

pub fn compile_files_to_c_profile(files: Vec[ld.SourceFile], opts: cg.EmitOptions) -> CompileProfileResult {
  return compile_files_to_c_profile_for_target(files, opts, 64, "unknown", "unknown");
}

pub fn compile_files_to_c_for_ptr_bits(files: Vec[ld.SourceFile], opts: cg.EmitOptions, ptr_bits: i32) -> CompileResult {
  let pr: CompileProfileResult = compile_files_to_c_profile_for_target(files, opts, ptr_bits, "unknown", "unknown");
  return pr.r;
}

pub fn compile_files_to_c_profile_for_ptr_bits(files: Vec[ld.SourceFile], opts: cg.EmitOptions, ptr_bits: i32) -> CompileProfileResult {
  return compile_files_to_c_profile_for_target(files, opts, ptr_bits, "unknown", "unknown");
}

pub fn compile_files_to_c_for_target(files: Vec[ld.SourceFile], opts: cg.EmitOptions, ptr_bits: i32, target_os: String, target_arch: String) -> CompileResult {
  let pr: CompileProfileResult = compile_files_to_c_profile_for_target(files, opts, ptr_bits, target_os, target_arch);
  return pr.r;
}

pub fn compile_files_to_c_profile_for_target(files: Vec[ld.SourceFile], opts: cg.EmitOptions, ptr_bits: i32, target_os: String, target_arch: String) -> CompileProfileResult {
  let mut prof: CompilePhaseProfile = compile_profile_zero();

  let t0_load: i64 = tm.now_ns();
  let lr: ld.LoadWorldResult = ld.world_from_files(files);
  prof.load_ns = dur_nonneg_ns(t0_load, tm.now_ns());
  if !lr.ok {
    return prof_ok(compile_err(compile_kind_from_loader(lr.err_kind), lr.err_code, lr.err_message, lr.err, Vec()), prof);
  }
  let warnings0: Vec[String] = collect_deprecated_warnings_world(lr.world);
  let t0_expand: i64 = tm.now_ns();
  let xr: mx.ExpandResult = mx.expand_world(lr.world, mx.default_config());
  prof.macroexpand_ns = dur_nonneg_ns(t0_expand, tm.now_ns());
  if !xr.ok {
    let code: String = compile_code_macroexpand();
    let msg0: String = tc.tc_error_message(xr.err);
    let msg: String = if msg0 != "" { msg0 } else { tc.tc_error_to_string(xr.err) };
    let rendered: String = tc.tc_error_to_string(xr.err).concat(" [").concat(code).concat("]");
    return prof_ok(compile_err(compile_diag_kind_macroexpand(), code, msg, rendered, warnings0), prof);
  }

  let t0_rewrite: i64 = tm.now_ns();
  let w2: tc.World = rewrite_async_entrypoints(xr.world, opts);
  prof.rewrite_async_ns = dur_nonneg_ns(t0_rewrite, tm.now_ns());

  let t0_tc: i64 = tm.now_ns();
  let br: tc.BuildCtxResult = tc.build_ctx_with_target(w2, ptr_bits, target_os, target_arch);
  if !br.ok {
    prof.typecheck_ns = dur_nonneg_ns(t0_tc, tm.now_ns());
    let rendered: String = with_macroexpand_notes(tc.tc_error_to_string(br.err), xr.notes);
    return prof_ok(compile_err(compile_kind_from_tc(tc.tc_error_kind(br.err)), tc.tc_error_code(br.err), tc.tc_error_message(br.err), rendered, warnings0), prof);
  }
  let tr: tc.TcResult = tc.typecheck_world_with_ctx(w2, br.ctx);
  prof.typecheck_ns = dur_nonneg_ns(t0_tc, tm.now_ns());
  if !tr.ok {
    let rendered: String = with_macroexpand_notes(tc.tc_error_to_string(tr.err), xr.notes);
    return prof_ok(compile_err(compile_kind_from_tc(tc.tc_error_kind(tr.err)), tc.tc_error_code(tr.err), tc.tc_error_message(tr.err), rendered, warnings0), prof);
  }

  let t0_irgen: i64 = tm.now_ns();
  let gr: irgen.GenResult = irgen.generate_world_with_ctx(w2, br.ctx);
  prof.irgen_ns = dur_nonneg_ns(t0_irgen, tm.now_ns());
  if !gr.ok {
    return prof_ok(compile_err(compile_diag_kind_irgen(), tc.diag_code_irgen(), gr.err, gr.err, warnings0), prof);
  }
  let warnings: Vec[String] = collect_deprecated_warnings_ir(br.ctx, gr.prog, warnings0);

  let t0_verify: i64 = tm.now_ns();
  let vr: ir.VerifyResult = ir.verify_program(gr.prog);
  prof.ir_verify_ns = dur_nonneg_ns(t0_verify, tm.now_ns());
  if !vr.ok {
    let code: String = compile_code_ir_verify();
    let msg: String = "ir verify failed: ".concat(vr.err);
    let rendered: String = msg.concat(" [").concat(code).concat("]");
    return prof_ok(compile_err(compile_diag_kind_ir_verify(), code, msg, rendered, warnings), prof);
  }

  let t0_codegen: i64 = tm.now_ns();
  let c: String = cg.emit_c(gr.prog, opts);
  prof.codegen_ns = dur_nonneg_ns(t0_codegen, tm.now_ns());
  return prof_ok(compile_ok(c, warnings), prof);
}
