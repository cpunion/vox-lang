import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_resource_read_missing_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      @resource(read, Fs)
      fn read() -> i32 { return 1; }
      fn caller() -> i32 { return read(); }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "resource check failed"));
}

fn test_compile_trait_method_resource_read_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Read { @resource(read, Fs) fn read(x: Self) -> i32; }
      struct I { v: i32 }
      impl Read for I { fn read(x: I) -> i32 { return x.v; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl method read resource set mismatch"));
}
