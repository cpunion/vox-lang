import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_std_testing_assert_eq_wrapper_preserves_eq_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_eq[T: Eq](a: T, b: T) -> () { if a != b { panic("assertion failed"); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: "import \"std/prelude\" as prelude\npub fn assert_eq[T: prelude.Eq](a: T, b: T) -> () { prelude.assert_eq(a, b); }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_eq(1, 1); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_std_testing_assert_ne_wrapper_preserves_eq_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_eq[T: Eq](a: T, b: T) -> () { if a != b { panic("assertion failed"); } }
      pub fn assert_ne[T: Eq](a: T, b: T) -> () { if a == b { panic("assertion failed"); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: "import \"std/prelude\" as prelude\npub fn assert_ne[T: prelude.Eq](a: T, b: T) -> () { prelude.assert_ne(a, b); }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_ne(1, 2); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_std_testing_assert_lt_wrapper_preserves_ord_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Ord { fn lt(a: Self, b: Self) -> bool; }
      impl Ord for i32 { fn lt(a: i32, b: i32) -> bool { return a < b; } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_lt[T: Ord](a: T, b: T) -> () { if a < b { return; } panic("assertion failed"); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: """
      import "std/prelude" as prelude
      pub fn assert_lt[T: prelude.Ord](a: T, b: T) -> () { prelude.assert_lt(a, b); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_lt(1, 2); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_std_io_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      pub fn out(msg: String) -> () { print(msg); }
      pub fn out_ln(msg: String) -> () { print(msg); print("\\n"); }
      pub fn fail(msg: String) -> () { panic(msg); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/io\" as io\nfn main() -> i32 { io.out(\"x\"); io.out_ln(\"y\"); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_time_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/time/time.vox",
    text: """
      @ffi_import("c", "vox_rt_now_ns")
      fn rt_now_ns_raw() -> i64;
      pub fn now_ns() -> i64 { return rt_now_ns_raw(); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/time" as tm
      fn main() -> i32 {
        let t0: i64 = tm.now_ns();
        if t0 >= 0 { return 0; }
        return 1;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_sync_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/sync/sync.vox",
    text: """
      @ffi_import("c", "vox_rt_mutex_i32_new")
      fn rt_mutex_i32_new(v: i32) -> isize;
      @ffi_import("c", "vox_rt_mutex_i32_load")
      fn rt_mutex_i32_load(handle: isize) -> i32;
      @ffi_import("c", "vox_rt_mutex_i32_store")
      fn rt_mutex_i32_store(handle: isize, v: i32) -> ();
      @ffi_import("c", "vox_rt_atomic_i32_new")
      fn rt_atomic_i32_new(v: i32) -> isize;
      @ffi_import("c", "vox_rt_atomic_i32_load")
      fn rt_atomic_i32_load(handle: isize) -> i32;
      @ffi_import("c", "vox_rt_atomic_i32_store")
      fn rt_atomic_i32_store(handle: isize, v: i32) -> ();
      @ffi_import("c", "vox_rt_atomic_i32_fetch_add")
      fn rt_atomic_i32_fetch_add(handle: isize, delta: i32) -> i32;
      pub trait SyncScalar {
        fn mutex_new(v: Self) -> isize;
        fn mutex_load(sample: Self, handle: isize) -> Self;
        fn mutex_store(v: Self, handle: isize) -> ();
        fn atomic_new(v: Self) -> isize;
        fn atomic_load(sample: Self, handle: isize) -> Self;
        fn atomic_store(v: Self, handle: isize) -> ();
        fn atomic_fetch_add(delta: Self, handle: isize) -> Self;
      }
      impl SyncScalar for i32 {
        fn mutex_new(v: i32) -> isize { return rt_mutex_i32_new(v) as isize; }
        fn mutex_load(sample: i32, handle: isize) -> i32 { return rt_mutex_i32_load(handle); }
        fn mutex_store(v: i32, handle: isize) -> () { rt_mutex_i32_store(handle, v); }
        fn atomic_new(v: i32) -> isize { return rt_atomic_i32_new(v); }
        fn atomic_load(sample: i32, handle: isize) -> i32 { return rt_atomic_i32_load(handle); }
        fn atomic_store(v: i32, handle: isize) -> () { rt_atomic_i32_store(handle, v); }
        fn atomic_fetch_add(delta: i32, handle: isize) -> i32 { return rt_atomic_i32_fetch_add(handle, delta); }
      }
      pub struct Mutex[T: SyncScalar] { handle: isize, sample: T }
      pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] { return Mutex { handle: SyncScalar.mutex_new(v), sample: v }; }
      pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
        SyncScalar.mutex_store(v, m.handle);
        return Mutex { handle: m.handle, sample: v };
      }
      pub fn mutex_into_inner[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub struct Atomic[T: SyncScalar] { handle: isize, sample: T }
      pub fn atomic[T: SyncScalar](v: T) -> Atomic[T] { return Atomic { handle: SyncScalar.atomic_new(v), sample: v }; }
      pub fn atomic_load[T: SyncScalar](a: Atomic[T]) -> T { return SyncScalar.atomic_load(a.sample, a.handle); }
      pub fn atomic_store[T: SyncScalar](a: Atomic[T], v: T) -> Atomic[T] {
        SyncScalar.atomic_store(v, a.handle);
        return Atomic { handle: a.handle, sample: v };
      }
      pub fn atomic_fetch_add[T: SyncScalar](a: Atomic[T], delta: T) -> Atomic[T] {
        let next: T = SyncScalar.atomic_fetch_add(delta, a.handle);
        return Atomic { handle: a.handle, sample: next };
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/sync" as s
      fn main() -> i32 {
        let m: s.Mutex[i32] = s.mutex[i32](7);
        let x: i32 = s.mutex_into_inner[i32](m);
        let mut a: s.Atomic[i32] = s.atomic[i32](1);
        a = s.atomic_fetch_add[i32](a, 2);
        a = s.atomic_store[i32](a, 4);
        return x + s.atomic_load[i32](a);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_sync_i64_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/sync/sync.vox",
    text: """
      @ffi_import("c", "vox_rt_mutex_i64_new")
      fn rt_mutex_i64_new(v: i64) -> isize;
      @ffi_import("c", "vox_rt_mutex_i64_load")
      fn rt_mutex_i64_load(handle: isize) -> i64;
      @ffi_import("c", "vox_rt_mutex_i64_store")
      fn rt_mutex_i64_store(handle: isize, v: i64) -> ();
      @ffi_import("c", "vox_rt_atomic_i64_new")
      fn rt_atomic_i64_new(v: i64) -> isize;
      @ffi_import("c", "vox_rt_atomic_i64_load")
      fn rt_atomic_i64_load(handle: isize) -> i64;
      @ffi_import("c", "vox_rt_atomic_i64_fetch_add")
      fn rt_atomic_i64_fetch_add(handle: isize, delta: i64) -> i64;
      pub trait SyncScalar {
        fn mutex_new(v: Self) -> isize;
        fn mutex_load(sample: Self, handle: isize) -> Self;
        fn mutex_store(v: Self, handle: isize) -> ();
        fn atomic_new(v: Self) -> isize;
        fn atomic_load(sample: Self, handle: isize) -> Self;
        fn atomic_fetch_add(delta: Self, handle: isize) -> Self;
      }
      impl SyncScalar for i64 {
        fn mutex_new(v: i64) -> isize { return rt_mutex_i64_new(v) as isize; }
        fn mutex_load(sample: i64, handle: isize) -> i64 { return rt_mutex_i64_load(handle); }
        fn mutex_store(v: i64, handle: isize) -> () { rt_mutex_i64_store(handle, v); }
        fn atomic_new(v: i64) -> isize { return rt_atomic_i64_new(v); }
        fn atomic_load(sample: i64, handle: isize) -> i64 { return rt_atomic_i64_load(handle); }
        fn atomic_fetch_add(delta: i64, handle: isize) -> i64 { return rt_atomic_i64_fetch_add(handle, delta); }
      }
      pub struct Mutex[T: SyncScalar] { handle: isize, sample: T }
      pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] { return Mutex { handle: SyncScalar.mutex_new(v), sample: v }; }
      pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
        SyncScalar.mutex_store(v, m.handle);
        return Mutex { handle: m.handle, sample: v };
      }
      pub struct Atomic[T: SyncScalar] { handle: isize, sample: T }
      pub fn atomic[T: SyncScalar](v: T) -> Atomic[T] { return Atomic { handle: SyncScalar.atomic_new(v), sample: v }; }
      pub fn atomic_load[T: SyncScalar](a: Atomic[T]) -> T { return SyncScalar.atomic_load(a.sample, a.handle); }
      pub fn atomic_fetch_add[T: SyncScalar](a: Atomic[T], d: T) -> Atomic[T] {
        let next: T = SyncScalar.atomic_fetch_add(d, a.handle);
        return Atomic { handle: a.handle, sample: next };
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/sync" as s
      fn main() -> i32 {
        let mut m: s.Mutex[i64] = s.mutex[i64](7 as i64);
        let m2: s.Mutex[i64] = m;
        m = s.mutex_store[i64](m, 9 as i64);
        let mut a: s.Atomic[i64] = s.atomic[i64](3 as i64);
        a = s.atomic_fetch_add[i64](a, 4 as i64);
        return (s.mutex_load[i64](m2) + s.atomic_load[i64](a)) as i32;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_io_net_intrinsics_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      @ffi_import("c", "vox_rt_tcp_connect")
      fn rt_tcp_connect_raw(host: String, port: i32) -> isize;
      @ffi_import("c", "vox_rt_tcp_send")
      fn rt_tcp_send_raw(handle: isize, text: String) -> i32;
      @ffi_import("c", "vox_rt_tcp_recv")
      fn rt_tcp_recv_raw(handle: isize, max_n: i32) -> String;
      @ffi_import("c", "vox_rt_tcp_close")
      fn rt_tcp_close_raw(handle: isize) -> ();
      @ffi_import("c", "vox_rt_tcp_wait_read")
      fn rt_tcp_wait_read_raw(handle: isize, timeout_ms: i32) -> bool;
      @ffi_import("c", "vox_rt_tcp_wait_write")
      fn rt_tcp_wait_write_raw(handle: isize, timeout_ms: i32) -> bool;
      pub struct NetAddr { host: String, port: i32 }
      pub struct NetConn { handle: isize, closed: bool }
      pub struct NetI32Result { pub ok: bool, pub err: String, pub n: i32 }
      pub struct NetStringResult { pub ok: bool, pub err: String, pub text: String }
      pub struct NetBoolResult { pub ok: bool, pub err: String, pub ready: bool }
      pub struct NetCloseResult { pub ok: bool, pub err: String, pub conn: NetConn, pub closed_now: bool }
      pub fn closed_conn() -> NetConn { return NetConn { handle: -1 as isize, closed: true }; }
      pub fn net_addr(host: String, port: i32) -> NetAddr { return NetAddr { host: host, port: port }; }
      pub fn net_connect(a: NetAddr) -> NetConn { return NetConn { handle: rt_tcp_connect_raw(a.host, a.port), closed: false }; }
      pub fn net_is_closed(c: &NetConn) -> bool { return c.closed || c.handle < 0; }
      pub fn net_try_send(c: &NetConn, text: String) -> NetI32Result {
        if net_is_closed(c) { return NetI32Result { ok: false, err: "closed", n: 0 }; }
        return NetI32Result { ok: true, err: "", n: rt_tcp_send_raw(c.handle, text) };
      }
      pub fn net_send(c: &NetConn, text: String) -> i32 { return net_try_send(c, text).n; }
      pub fn net_try_recv(c: &NetConn, max_n: i32) -> NetStringResult {
        if net_is_closed(c) { return NetStringResult { ok: false, err: "closed", text: "" }; }
        return NetStringResult { ok: true, err: "", text: rt_tcp_recv_raw(c.handle, max_n) };
      }
      pub fn net_recv(c: &NetConn, max_n: i32) -> String { return net_try_recv(c, max_n).text; }
      pub fn net_try_wait_read(c: &NetConn, timeout_ms: i32) -> NetBoolResult {
        if net_is_closed(c) { return NetBoolResult { ok: false, err: "closed", ready: false }; }
        return NetBoolResult { ok: true, err: "", ready: rt_tcp_wait_read_raw(c.handle, timeout_ms) };
      }
      pub fn net_wait_read(c: &NetConn, timeout_ms: i32) -> bool { return net_try_wait_read(c, timeout_ms).ready; }
      pub fn net_try_wait_write(c: &NetConn, timeout_ms: i32) -> NetBoolResult {
        if net_is_closed(c) { return NetBoolResult { ok: false, err: "closed", ready: false }; }
        return NetBoolResult { ok: true, err: "", ready: rt_tcp_wait_write_raw(c.handle, timeout_ms) };
      }
      pub fn net_wait_write(c: &NetConn, timeout_ms: i32) -> bool { return net_try_wait_write(c, timeout_ms).ready; }
      pub fn net_try_close(c0: NetConn) -> NetCloseResult {
        let mut c: NetConn = c0;
        if net_is_closed(c) { c.handle = -1 as isize; c.closed = true; return NetCloseResult { ok: true, err: "", conn: c, closed_now: false }; }
        rt_tcp_close_raw(c.handle);
        c.handle = -1 as isize;
        c.closed = true;
        return NetCloseResult { ok: true, err: "", conn: c, closed_now: true };
      }
      pub fn net_close(c: NetConn) -> NetConn { return net_try_close(c).conn; }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/io" as io
      fn main() -> i32 {
        let a: io.NetAddr = io.net_addr("127.0.0.1", 7);
        let mut c: io.NetConn = io.net_connect(a);
        let _n: i32 = io.net_send(c, "x");
        let _s: String = io.net_recv(c, 8);
        let _r: bool = io.net_wait_read(c, 1);
        let _w: bool = io.net_wait_write(c, 1);
        let _t0: io.NetI32Result = io.net_try_send(c, "x");
        let _t1: io.NetStringResult = io.net_try_recv(c, 8);
        let _t2: io.NetBoolResult = io.net_try_wait_read(c, 1);
        let _t3: io.NetBoolResult = io.net_try_wait_write(c, 1);
        let cr: io.NetCloseResult = io.net_try_close(c);
        c = cr.conn;
        c = io.net_close(c);
        let _closed: bool = io.net_is_closed(c);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_io_method_style_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      @ffi_import("c", "vox_rt_path_exists")
      fn rt_path_exists_raw(path: String) -> bool;
      @ffi_import("c", "vox_rt_read_file")
      fn rt_read_file_raw(path: String) -> String;
      @ffi_import("c", "vox_rt_write_file")
      fn rt_write_file_raw(path: String, text: String) -> ();
      @ffi_import("c", "vox_rt_mkdir_p")
      fn rt_mkdir_p_raw(path: String) -> ();
      @ffi_import("c", "vox_rt_walk_vox_files")
      fn rt_walk_files_raw(path: String) -> Vec[String];
      @ffi_import("c", "vox_rt_tcp_connect")
      fn rt_tcp_connect_raw(host: String, port: i32) -> isize;
      @ffi_import("c", "vox_rt_tcp_send")
      fn rt_tcp_send_raw(handle: isize, text: String) -> i32;
      @ffi_import("c", "vox_rt_tcp_recv")
      fn rt_tcp_recv_raw(handle: isize, max_n: i32) -> String;
      @ffi_import("c", "vox_rt_tcp_close")
      fn rt_tcp_close_raw(handle: isize) -> ();
      @ffi_import("c", "vox_rt_tcp_wait_read")
      fn rt_tcp_wait_read_raw(handle: isize, timeout_ms: i32) -> bool;
      @ffi_import("c", "vox_rt_tcp_wait_write")
      fn rt_tcp_wait_write_raw(handle: isize, timeout_ms: i32) -> bool;
      pub struct File { path: String }
      pub fn file(path: String) -> File { return File { path: path }; }
      impl File {
        fn exists(f: &File) -> bool { return rt_path_exists_raw(f.path); }
        fn read_all(f: &File) -> String { return rt_read_file_raw(f.path); }
        fn write_all(f: &File, text: String) -> () { rt_write_file_raw(f.path, text); }
        fn mkdir_p(f: &File) -> () { rt_mkdir_p_raw(f.path); }
      }
      pub struct NetAddr { host: String, port: i32 }
      pub struct NetConn { handle: isize, closed: bool }
      pub struct NetI32Result { pub ok: bool, pub err: String, pub n: i32 }
      pub struct NetStringResult { pub ok: bool, pub err: String, pub text: String }
      pub struct NetBoolResult { pub ok: bool, pub err: String, pub ready: bool }
      pub struct NetCloseResult { pub ok: bool, pub err: String, pub conn: NetConn, pub closed_now: bool }
      pub fn closed_conn() -> NetConn { return NetConn { handle: -1 as isize, closed: true }; }
      pub fn net_addr(host: String, port: i32) -> NetAddr { return NetAddr { host: host, port: port }; }
      impl NetAddr {
        fn connect(a: NetAddr) -> NetConn { return NetConn { handle: rt_tcp_connect_raw(a.host, a.port), closed: false }; }
      }
      impl NetConn {
        fn is_closed(c: &NetConn) -> bool { return c.closed || c.handle < 0; }
        fn try_send(c: &NetConn, text: String) -> NetI32Result {
          if c.is_closed() { return NetI32Result { ok: false, err: "closed", n: 0 }; }
          return NetI32Result { ok: true, err: "", n: rt_tcp_send_raw(c.handle, text) };
        }
        fn try_recv(c: &NetConn, max_n: i32) -> NetStringResult {
          if c.is_closed() { return NetStringResult { ok: false, err: "closed", text: "" }; }
          return NetStringResult { ok: true, err: "", text: rt_tcp_recv_raw(c.handle, max_n) };
        }
        fn try_wait_read(c: &NetConn, timeout_ms: i32) -> NetBoolResult {
          if c.is_closed() { return NetBoolResult { ok: false, err: "closed", ready: false }; }
          return NetBoolResult { ok: true, err: "", ready: rt_tcp_wait_read_raw(c.handle, timeout_ms) };
        }
        fn try_wait_write(c: &NetConn, timeout_ms: i32) -> NetBoolResult {
          if c.is_closed() { return NetBoolResult { ok: false, err: "closed", ready: false }; }
          return NetBoolResult { ok: true, err: "", ready: rt_tcp_wait_write_raw(c.handle, timeout_ms) };
        }
        fn send(c: &NetConn, text: String) -> i32 { return rt_tcp_send_raw(c.handle, text); }
        fn recv(c: &NetConn, max_n: i32) -> String { return rt_tcp_recv_raw(c.handle, max_n); }
        fn wait_read(c: &NetConn, timeout_ms: i32) -> bool { return rt_tcp_wait_read_raw(c.handle, timeout_ms); }
        fn wait_write(c: &NetConn, timeout_ms: i32) -> bool { return rt_tcp_wait_write_raw(c.handle, timeout_ms); }
        fn try_close(c0: NetConn) -> NetCloseResult {
          let mut c: NetConn = c0;
          if c.is_closed() { c.handle = -1 as isize; c.closed = true; return NetCloseResult { ok: true, err: "", conn: c, closed_now: false }; }
          rt_tcp_close_raw(c.handle);
          c.handle = -1 as isize;
          c.closed = true;
          return NetCloseResult { ok: true, err: "", conn: c, closed_now: true };
        }
        fn close(c: NetConn) -> NetConn { return c.try_close().conn; }
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/io" as io
      fn main() -> i32 {
        let f: io.File = io.file("a.txt");
        f.write_all("x");
        let _s: String = f.read_all();
        let _b: bool = f.exists();
        let d: io.File = io.file("tmp");
        d.mkdir_p();
        let a: io.NetAddr = io.net_addr("127.0.0.1", 7);
        let mut c: io.NetConn = a.connect();
        let _n: i32 = c.send("x");
        let _r: String = c.recv(8);
        let _wr: bool = c.wait_read(1);
        let _ww: bool = c.wait_write(1);
        let _s0: io.NetI32Result = c.try_send("x");
        let _s1: io.NetStringResult = c.try_recv(8);
        let _s2: io.NetBoolResult = c.try_wait_read(1);
        let _s3: io.NetBoolResult = c.try_wait_write(1);
        let cr: io.NetCloseResult = c.try_close();
        c = cr.conn;
        c = c.close();
        let _closed: bool = c.is_closed();
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_fs_method_style_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/fs/fs.vox",
    text: """
      @ffi_import("c", "vox_rt_path_exists")
      fn rt_path_exists_raw(path: String) -> bool;
      @ffi_import("c", "vox_rt_read_file")
      fn rt_read_file_raw(path: String) -> String;
      @ffi_import("c", "vox_rt_write_file")
      fn rt_write_file_raw(path: String, text: String) -> ();
      @ffi_import("c", "vox_rt_mkdir_p")
      fn rt_mkdir_p_raw(path: String) -> ();
      @ffi_import("c", "vox_rt_walk_vox_files")
      fn rt_walk_files_raw(path: String) -> Vec[String];
      pub struct Path { raw: String }
      pub fn path(raw: String) -> Path { return Path { raw: raw }; }
      pub fn clean(raw: String) -> String { return raw; }
      pub fn join(a: String, b: String) -> String { return a.concat("/").concat(b); }
      pub fn base_name(raw: String) -> String { return raw; }
      pub fn dir_name(_raw: String) -> String { return "."; }
      pub fn ext(_raw: String) -> String { return ""; }
      pub fn stem(raw: String) -> String { return raw; }
      pub fn is_abs(raw: String) -> bool { return raw.len() > 0 && raw.byte_at(0) == 47; }
      impl Path {
        fn clean(p: &Path) -> Path { return path(clean(p.raw)); }
        fn join(p: &Path, elem: String) -> Path { return path(join(p.raw, elem)); }
        fn base_name(p: &Path) -> String { return base_name(p.raw); }
        fn dir_name(p: &Path) -> String { return dir_name(p.raw); }
        fn ext(p: &Path) -> String { return ext(p.raw); }
        fn stem(p: &Path) -> String { return stem(p.raw); }
        fn is_abs(p: &Path) -> bool { return is_abs(p.raw); }
        fn read_to_string(p: &Path) -> String { return rt_read_file_raw(p.raw); }
        fn write_string(p: &Path, text: String) -> () { rt_write_file_raw(p.raw, text); }
        fn exists(p: &Path) -> bool { return rt_path_exists_raw(p.raw); }
        fn mkdir_p(p: &Path) -> () { rt_mkdir_p_raw(p.raw); }
        fn walk_files(p: &Path) -> Vec[String] { return rt_walk_files_raw(p.raw); }
      }
      pub fn read_to_string(raw: String) -> String { let p: Path = path(raw); return p.read_to_string(); }
      pub fn write_string(raw: String, text: String) -> () { let p: Path = path(raw); p.write_string(text); return; }
      pub fn exists(raw: String) -> bool { let p: Path = path(raw); return p.exists(); }
      pub fn mkdir_p(raw: String) -> () { let p: Path = path(raw); p.mkdir_p(); return; }
      pub fn walk_files(raw: String) -> Vec[String] { let p: Path = path(raw); return p.walk_files(); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/fs" as fs
      fn main() -> i32 {
        let p: fs.Path = fs.path("a.txt");
        p.write_string("x");
        let _s: String = p.read_to_string();
        let _b: bool = p.exists();
        let d: fs.Path = fs.path("tmp");
        d.mkdir_p();
        let _xs: Vec[String] = d.walk_files();
        let dc: fs.Path = d.clean();
        let j: fs.Path = dc.join("x.txt");
        let _bn: String = j.base_name();
        let _dn: String = j.dir_name();
        let _ex: String = j.ext();
        let _st: String = j.stem();
        let _ba: bool = j.is_abs();
        let _cj: String = fs.clean("a/./b");
        let _jj: String = fs.join("a", "b");
        fs.write_string("b.txt", "y");
        let _s2: String = fs.read_to_string("b.txt");
        let _b2: bool = fs.exists("b.txt");
        fs.mkdir_p("tmp2");
        let _xs2: Vec[String] = fs.walk_files("tmp2");
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_process_command_style_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/process/process.vox",
    text: """
      @ffi_import("c", "vox_rt_exec")
      fn rt_exec_raw(cmd: String) -> i32;
      @ffi_import("c", "vox_rt_args")
      fn rt_args_raw() -> Vec[String];
      @ffi_import("c", "vox_rt_exe_path")
      fn rt_exe_path_raw() -> String;
      @ffi_import("c", "vox_rt_getenv")
      fn rt_getenv_raw(key: String) -> String;
      pub struct EnvVar { key: String, value: String }
      pub struct Command { prog: String, argv: Vec[String], envs: Vec[EnvVar], cwd: String }
      pub fn command(prog: String) -> Command { return Command { prog: prog, argv: Vec(), envs: Vec(), cwd: "" }; }
      fn sh_quote(s: String) -> String { return s; }
      impl Command {
        fn arg(c: Command, a: String) -> Command { let mut out: Command = c; out.argv.push(a); return out; }
        fn args(c: Command, xs: Vec[String]) -> Command {
          let mut out: Command = c;
          let mut i: i32 = 0;
          while i < xs.len() { out.argv.push(xs.get(i)); i = i + 1; }
          return out;
        }
        fn env(c: Command, key: String, value: String) -> Command {
          let mut out: Command = c;
          out.envs.push(EnvVar { key: key, value: value });
          return out;
        }
        fn env_remove(c: Command, key: String) -> Command {
          let mut out: Command = c;
          let mut next: Vec[EnvVar] = Vec();
          let mut i: i32 = 0;
          while i < out.envs.len() {
            let e: EnvVar = out.envs.get(i);
            if e.key != key { next.push(e); }
            i = i + 1;
          }
          out.envs = next;
          return out;
        }
        fn clear_env(c: Command) -> Command {
          let mut out: Command = c;
          out.envs = Vec();
          return out;
        }
        fn cwd(c: Command, dir: String) -> Command {
          let mut out: Command = c;
          out.cwd = dir;
          return out;
        }
        fn render(c: &Command) -> String {
          let mut out: String = "";
          if c.cwd != "" {
            out = out.concat("cd ").concat(sh_quote(c.cwd)).concat(" && ");
          }
          let mut i: i32 = 0;
          while i < c.envs.len() {
            let e: EnvVar = c.envs.get(i);
            out = out.concat(e.key).concat("=").concat(sh_quote(e.value)).concat(" ");
            i = i + 1;
          }
          out = out.concat(sh_quote(c.prog));
          i = 0;
          while i < c.argv.len() {
            out = out.concat(" ").concat(sh_quote(c.argv.get(i)));
            i = i + 1;
          }
          return out;
        }
        fn run(c: &Command) -> i32 { return exec(c.render()); }
      }
      pub fn args() -> Vec[String] { return rt_args_raw(); }
      pub fn exec(cmd: String) -> i32 { return rt_exec_raw(cmd); }
      pub fn exe_path() -> String { return rt_exe_path_raw(); }
      pub fn getenv(key: String) -> String { return rt_getenv_raw(key); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/process" as p
      fn main() -> i32 {
        let exe: String = p.exe_path();
        let cmd: p.Command = p.command(exe).env("VOX_X", "1").env("VOX_Y", "2").env_remove("VOX_Y").cwd("tmp").arg("version").args(Vec());
        let line: String = cmd.render();
        let _rc0: i32 = p.exec(line);
        let _rc1: i32 = cmd.run();
        let clean: p.Command = cmd.clear_env();
        let _line2: String = clean.render();
        let _as: Vec[String] = p.args();
        let _g: String = p.getenv("HOME");
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_string_collections_method_style_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/string/string.vox",
    text: """
      pub struct StrView { owner: String, lo: i32, hi: i32 }
      pub fn view_all(owner: String) -> StrView {
        let n: i32 = owner.len();
        return StrView { owner: owner, lo: 0, hi: n };
      }
      impl StrView {
        fn len(v: StrView) -> i32 { return v.hi - v.lo; }
        fn is_empty(v: StrView) -> bool { return v.hi == v.lo; }
        fn to_string(v: StrView) -> String { return v.owner.slice(v.lo, v.hi); }
        fn contains(v: StrView, needle: String) -> bool { return v.to_string().contains(needle); }
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/collections/collections.vox",
    text: """
      pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      pub struct Slice[T] { owner: Vec[T], lo: i32, hi: i32 }
      pub fn view_all[T](owner: Vec[T]) -> Slice[T] {
        let n: i32 = owner.len();
        return Slice { owner: owner, lo: 0, hi: n };
      }
      impl[T] Slice[T] {
        fn len(s: Slice[T]) -> i32 { return s.hi - s.lo; }
        fn is_empty(s: Slice[T]) -> bool { return s.hi == s.lo; }
        fn get(s: Slice[T], idx: i32) -> T { return s.owner.get(s.lo + idx); }
        fn to_vec(s: Slice[T]) -> Vec[T] {
          let mut out: Vec[T] = Vec();
          let mut i: i32 = 0;
          let n: i32 = s.hi - s.lo;
          while i < n {
            out.push(s.owner.get(s.lo + i));
            i = i + 1;
          }
          return out;
        }
      }
      impl[T: Eq] Slice[T] {
        fn contains(s: Slice[T], needle: T) -> bool {
          let mut i: i32 = 0;
          let n: i32 = s.hi - s.lo;
          while i < n {
            if s.owner.get(s.lo + i) == needle { return true; }
            i = i + 1;
          }
          return false;
        }
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/string" as s
      import "std/collections" as c
      fn main() -> i32 {
        let _stok: bool = s.view_all("vox-lang").contains("vox");

        let mut xs0: Vec[i32] = Vec();
        xs0.push(1);
        xs0.push(2);
        xs0.push(3);
        let sl: c.Slice[i32] = c.view_all(xs0);
        return sl.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_fs_virtual_fs_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/fs/fs.vox",
    text: """
      pub trait FS {
        fn read_to_string(x: &Self, path: String) -> String;
        fn exists(x: &Self, path: String) -> bool;
        fn walk_files(x: &Self, root: String) -> Vec[String];
      }
      pub trait WritableFS {
        fn write_string(x: Self, path: String, text: String) -> Self;
        fn mkdir_p(x: Self, path: String) -> Self;
      }
      pub struct MemFS { files: Vec[String] }
      pub fn mem_fs() -> MemFS { return MemFS { files: Vec() }; }
      impl MemFS {
        fn read_to_string(_x: &MemFS, _p: String) -> String { return "ok"; }
        fn exists(x: &MemFS, p: String) -> bool {
          let mut i: i32 = 0;
          while i < x.files.len() {
            if x.files.get(i) == p { return true; }
            i = i + 1;
          }
          return false;
        }
        fn walk_files(x: &MemFS, _root: String) -> Vec[String] { return x.files; }
        fn write_string(x: MemFS, p: String, _text: String) -> MemFS {
          let mut ys: Vec[String] = x.files;
          ys.push(p);
          return MemFS { files: ys };
        }
        fn mkdir_p(x: MemFS, _p: String) -> MemFS { return x; }
      }
      impl FS for MemFS {
        fn read_to_string(x: &MemFS, p: String) -> String { return x.read_to_string(p); }
        fn exists(x: &MemFS, p: String) -> bool { return x.exists(p); }
        fn walk_files(x: &MemFS, root: String) -> Vec[String] { return x.walk_files(root); }
      }
      impl WritableFS for MemFS {
        fn write_string(x: MemFS, p: String, text: String) -> MemFS { return x.write_string(p, text); }
        fn mkdir_p(x: MemFS, p: String) -> MemFS { return x.mkdir_p(p); }
      }
      pub fn fs_read_to_string[T: FS](x: T, p: String) -> String { return FS.read_to_string(x, p); }
      pub fn fs_exists[T: FS](x: T, p: String) -> bool { return FS.exists(x, p); }
      pub fn fs_walk_files[T: FS](x: T, root: String) -> Vec[String] { return FS.walk_files(x, root); }
      pub fn fs_write_string[T: WritableFS](x: T, p: String, text: String) -> T { return WritableFS.write_string(x, p, text); }
      pub fn fs_mkdir_p[T: WritableFS](x: T, p: String) -> T { return WritableFS.mkdir_p(x, p); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/fs" as fs
      fn main() -> i32 {
        let mut m: fs.MemFS = fs.mem_fs();
        m = m.mkdir_p("/src");
        m = m.write_string("/src/main.vox", "fn main() -> i32 { return 0; }");
        let _b0: bool = m.exists("/src/main.vox");
        let _s0: String = m.read_to_string("/src/main.vox");
        let _xs: Vec[String] = m.walk_files("/src");
        m = fs.fs_mkdir_p(m, "/pkg");
        m = fs.fs_write_string(m, "/pkg/lib.vox", "fn lib() -> i32 { return 1; }");
        let _b1: bool = fs.fs_exists(m, "/pkg/lib.vox");
        let _s1: String = fs.fs_read_to_string(m, "/pkg/lib.vox");
        let _ys: Vec[String] = fs.fs_walk_files(m, "/pkg");
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_net_socket_addr_style_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      @ffi_import("c", "vox_rt_tcp_connect")
      fn rt_tcp_connect_raw(host: String, port: i32) -> isize;
      pub struct NetAddr { pub host: String, pub port: i32 }
      pub struct NetConn { handle: isize }
      pub fn net_addr(host: String, port: i32) -> NetAddr { return NetAddr { host: host, port: port }; }
      impl NetAddr {
        fn connect(a: &NetAddr) -> NetConn { return NetConn { handle: rt_tcp_connect_raw(a.host, a.port) }; }
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/net/net.vox",
    text: """
      import "std/io" as io
      pub enum NetProto { Tcp, Udp }
      pub struct SocketAddr { pub proto: NetProto, pub host: String, pub port: i32 }
      pub struct SocketAddrParseResult { pub ok: bool, pub err: String, pub addr: SocketAddr }
      pub struct UdpSocket { local: SocketAddr }
      pub struct HttpRequest { pub method: String, pub host: String, pub path: String, pub headers: Vec[String], pub body: String }
      pub struct Request { pub url: String, pub inner: HttpRequest }
      pub struct RequestResult { pub ok: bool, pub err: String, pub req: Request }
      pub struct HttpResponseHead { pub code: i32, pub reason: String }
      pub struct Response { pub raw: String, pub status: HttpResponseHead, pub body: String }
      pub struct ResponseResult { pub ok: bool, pub err: String, pub resp: Response }
      pub struct RoundtripResult { pub ok: bool, pub err: String, pub raw: String }
      pub struct Client { recv_limit: i32 }
      pub fn socket_addr(proto: NetProto, host: String, port: i32) -> SocketAddr {
        return SocketAddr { proto: proto, host: host, port: port };
      }
      pub fn tcp_addr(host: String, port: i32) -> SocketAddr { return socket_addr(NetProto.Tcp, host, port); }
      pub fn udp_addr(host: String, port: i32) -> SocketAddr { return socket_addr(NetProto.Udp, host, port); }
      impl SocketAddr {
        fn is_tcp(a: &SocketAddr) -> bool { return match a.proto { NetProto.Tcp => true, _ => false }; }
        fn is_udp(a: &SocketAddr) -> bool { return match a.proto { NetProto.Udp => true, _ => false }; }
        fn uri(a: &SocketAddr) -> String {
          let scheme: String = match a.proto { NetProto.Tcp => "tcp", _ => "udp" };
          return scheme.concat("://").concat(a.host).concat(":").concat(a.port.to_string());
        }
        fn to_net_addr(a: &SocketAddr) -> io.NetAddr { return io.net_addr(a.host, a.port); }
        fn tcp_connect(a: &SocketAddr) -> io.NetConn {
          let na: io.NetAddr = a.to_net_addr();
          return na.connect();
        }
      }
      pub fn socket_uri(a: SocketAddr) -> String { return a.uri(); }
      pub fn parse_socket_uri(_raw: String) -> SocketAddrParseResult {
        return SocketAddrParseResult { ok: true, err: "", addr: tcp_addr("127.0.0.1", 9000) };
      }
      pub fn tcp_connect_addr(a: SocketAddr) -> io.NetConn { return a.tcp_connect(); }
      pub fn udp_bind(local: SocketAddr) -> UdpSocket { return UdpSocket { local: local }; }
      impl UdpSocket {
        fn local_addr(x: &UdpSocket) -> SocketAddr { return x.local; }
        fn send_to(_x: &UdpSocket, _to: SocketAddr, _data: String) -> i32 { return 0; }
        fn recv_from(_x: &UdpSocket, _max_n: i32) -> String { return ""; }
      }
      pub fn new_request(method: String, url: String) -> RequestResult {
        let req: Request = Request { url: url, inner: HttpRequest { method: method, host: "x", path: "/", headers: Vec(), body: "" } };
        return RequestResult { ok: true, err: "", req: req };
      }
      pub fn request(method: String, url: String) -> Request {
        return Request { url: url, inner: HttpRequest { method: method, host: "x", path: "/", headers: Vec(), body: "" } };
      }
      impl Request {
        fn with_header(r: Request, _name: String, _value: String) -> Request { return r; }
        fn with_body(r: Request, _body: String) -> Request { return r; }
        fn render(_r: &Request) -> String { return "GET / HTTP/1.1\\r\\n\\r\\n"; }
      }
      pub fn response_from_raw(raw: String) -> Response {
        return Response { raw: raw, status: HttpResponseHead { code: 200, reason: "OK" }, body: "" };
      }
      impl Response {
        fn status_code(r: &Response) -> i32 { return r.status.code; }
        fn reason(r: &Response) -> String { return r.status.reason; }
        fn header(_r: &Response, _name: String) -> String { return ""; }
      }
      pub fn http_roundtrip_checked(_url: String, _req: HttpRequest, _recv_limit: i32) -> RoundtripResult {
        return RoundtripResult { ok: true, err: "", raw: "HTTP/1.1 200 OK\\r\\n\\r\\n" };
      }
      pub fn http_roundtrip(_url: String, _req: HttpRequest, _recv_limit: i32) -> String {
        return "HTTP/1.1 200 OK\\r\\n\\r\\n";
      }
      pub fn client() -> Client { return Client { recv_limit: 8192 }; }
      impl Client {
        fn with_recv_limit(c: Client, recv_limit: i32) -> Client {
          let mut out: Client = c;
          out.recv_limit = recv_limit;
          return out;
        }
        fn recv_limit(c: &Client) -> i32 { return c.recv_limit; }
        fn try_send(_c: &Client, req: Request) -> ResponseResult {
          return ResponseResult { ok: true, err: "", resp: response_from_raw(req.render()) };
        }
        fn send(c: &Client, req: Request) -> Response {
          return c.try_send(req).resp;
        }
        fn try_get(c: &Client, _url: String) -> ResponseResult {
          return c.try_send(request("GET", "https://x"));
        }
        fn get(c: &Client, _url: String) -> Response {
          return c.try_get("https://x").resp;
        }
      }
      pub fn http_get(_url: String, _recv_limit: i32) -> String { return "HTTP/1.1 200 OK\\r\\n\\r\\n"; }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/net" as net
      fn main() -> i32 {
        let a: net.SocketAddr = net.tcp_addr("127.0.0.1", 9000);
        let _u: String = a.uri();
        let _b0: bool = a.is_tcp();
        let _b1: bool = a.is_udp();
        let _c = net.tcp_connect_addr(a);
        let p: net.SocketAddrParseResult = net.parse_socket_uri("tcp://127.0.0.1:9000");
        if p.ok {
          let _u2: String = net.socket_uri(p.addr);
        }
        let u: net.SocketAddr = net.udp_addr("0.0.0.0", 53);
        let s: net.UdpSocket = net.udp_bind(u);
        let _lu: net.SocketAddr = s.local_addr();
        let _sn: i32 = s.send_to(net.udp_addr("127.0.0.1", 53), "x");
        let _rx: String = s.recv_from(16);
        let rq: net.RequestResult = net.new_request("GET", "https://x");
        let req: net.Request = rq.req.with_header("K", "V").with_body("b");
        let _req_text: String = req.render();
        let c0: net.Client = net.client();
        let c: net.Client = c0.with_recv_limit(1024);
        let _lim: i32 = c.recv_limit();
        let rr0: net.ResponseResult = c.try_send(req);
        let _resp0: net.Response = rr0.resp;
        let _resp1: net.Response = c.send(net.request("GET", "https://x"));
        let rr1: net.ResponseResult = c.try_get("https://x");
        let _resp2: net.Response = rr1.resp;
        let resp: net.Response = c.get("https://x");
        let _sc: i32 = resp.status_code();
        let _rs: String = resp.reason();
        let _hv: String = resp.header("X");
        let _raw: String = net.http_get("https://x", 1024);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
