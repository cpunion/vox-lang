import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_std_testing_assert_eq_wrapper_preserves_eq_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_eq[T: Eq](a: T, b: T) -> () { if a != b { panic("assertion failed"); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: "import \"std/prelude\" as prelude\npub fn assert_eq[T: prelude.Eq](a: T, b: T) -> () { prelude.assert_eq(a, b); }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_eq(1, 1); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_std_testing_assert_ne_wrapper_preserves_eq_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_eq[T: Eq](a: T, b: T) -> () { if a != b { panic("assertion failed"); } }
      pub fn assert_ne[T: Eq](a: T, b: T) -> () { if a == b { panic("assertion failed"); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: "import \"std/prelude\" as prelude\npub fn assert_ne[T: prelude.Eq](a: T, b: T) -> () { prelude.assert_ne(a, b); }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_ne(1, 2); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_std_testing_assert_lt_wrapper_preserves_ord_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Ord { fn lt(a: Self, b: Self) -> bool; }
      impl Ord for i32 { fn lt(a: i32, b: i32) -> bool { return a < b; } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_lt[T: Ord](a: T, b: T) -> () { if a < b { return; } panic("assertion failed"); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: """
      import "std/prelude" as prelude
      pub fn assert_lt[T: prelude.Ord](a: T, b: T) -> () { prelude.assert_lt(a, b); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_lt(1, 2); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_std_io_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      pub fn out(msg: String) -> () { print(msg); }
      pub fn out_ln(msg: String) -> () { print(msg); print("\\n"); }
      pub fn fail(msg: String) -> () { panic(msg); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/io\" as io\nfn main() -> i32 { io.out(\"x\"); io.out_ln(\"y\"); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_std_time_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/time/time.vox",
    text: """
      pub fn now_ns() -> i64 { return __now_ns(); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/time" as tm
      fn main() -> i32 {
        let t0: i64 = tm.now_ns();
        if t0 >= 0 { return 0; }
        return 1;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_std_sync_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/sync/sync.vox",
    text: """
      pub trait SyncScalar {
        fn mutex_new(v: Self) -> i64;
        fn mutex_load(sample: Self, handle: i64) -> Self;
        fn mutex_store(v: Self, handle: i64) -> ();
        fn atomic_new(v: Self) -> i64;
        fn atomic_load(sample: Self, handle: i64) -> Self;
        fn atomic_store(v: Self, handle: i64) -> ();
        fn atomic_fetch_add(delta: Self, handle: i64) -> Self;
      }
      impl SyncScalar for i32 {
        fn mutex_new(v: i32) -> i64 { return __mutex_i32_new(v); }
        fn mutex_load(sample: i32, handle: i64) -> i32 { return __mutex_i32_load(handle); }
        fn mutex_store(v: i32, handle: i64) -> () { __mutex_i32_store(handle, v); }
        fn atomic_new(v: i32) -> i64 { return __atomic_i32_new(v); }
        fn atomic_load(sample: i32, handle: i64) -> i32 { return __atomic_i32_load(handle); }
        fn atomic_store(v: i32, handle: i64) -> () { __atomic_i32_store(handle, v); }
        fn atomic_fetch_add(delta: i32, handle: i64) -> i32 { return __atomic_i32_fetch_add(handle, delta); }
      }
      pub struct Mutex[T: SyncScalar] { handle: i64, sample: T }
      pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] { return Mutex { handle: SyncScalar.mutex_new(v), sample: v }; }
      pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
        SyncScalar.mutex_store(v, m.handle);
        return Mutex { handle: m.handle, sample: v };
      }
      pub fn mutex_into_inner[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub struct Atomic[T: SyncScalar] { handle: i64, sample: T }
      pub fn atomic[T: SyncScalar](v: T) -> Atomic[T] { return Atomic { handle: SyncScalar.atomic_new(v), sample: v }; }
      pub fn atomic_load[T: SyncScalar](a: Atomic[T]) -> T { return SyncScalar.atomic_load(a.sample, a.handle); }
      pub fn atomic_store[T: SyncScalar](a: Atomic[T], v: T) -> Atomic[T] {
        SyncScalar.atomic_store(v, a.handle);
        return Atomic { handle: a.handle, sample: v };
      }
      pub fn atomic_fetch_add[T: SyncScalar](a: Atomic[T], delta: T) -> Atomic[T] {
        let next: T = SyncScalar.atomic_fetch_add(delta, a.handle);
        return Atomic { handle: a.handle, sample: next };
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/sync" as s
      fn main() -> i32 {
        let m: s.Mutex[i32] = s.mutex[i32](7);
        let x: i32 = s.mutex_into_inner[i32](m);
        let mut a: s.Atomic[i32] = s.atomic[i32](1);
        a = s.atomic_fetch_add[i32](a, 2);
        a = s.atomic_store[i32](a, 4);
        return x + s.atomic_load[i32](a);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_std_sync_i64_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/sync/sync.vox",
    text: """
      pub trait SyncScalar {
        fn mutex_new(v: Self) -> i64;
        fn mutex_load(sample: Self, handle: i64) -> Self;
        fn mutex_store(v: Self, handle: i64) -> ();
        fn atomic_new(v: Self) -> i64;
        fn atomic_load(sample: Self, handle: i64) -> Self;
        fn atomic_fetch_add(delta: Self, handle: i64) -> Self;
      }
      impl SyncScalar for i64 {
        fn mutex_new(v: i64) -> i64 { return __mutex_i64_new(v); }
        fn mutex_load(sample: i64, handle: i64) -> i64 { return __mutex_i64_load(handle); }
        fn mutex_store(v: i64, handle: i64) -> () { __mutex_i64_store(handle, v); }
        fn atomic_new(v: i64) -> i64 { return __atomic_i64_new(v); }
        fn atomic_load(sample: i64, handle: i64) -> i64 { return __atomic_i64_load(handle); }
        fn atomic_fetch_add(delta: i64, handle: i64) -> i64 { return __atomic_i64_fetch_add(handle, delta); }
      }
      pub struct Mutex[T: SyncScalar] { handle: i64, sample: T }
      pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] { return Mutex { handle: SyncScalar.mutex_new(v), sample: v }; }
      pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
        SyncScalar.mutex_store(v, m.handle);
        return Mutex { handle: m.handle, sample: v };
      }
      pub struct Atomic[T: SyncScalar] { handle: i64, sample: T }
      pub fn atomic[T: SyncScalar](v: T) -> Atomic[T] { return Atomic { handle: SyncScalar.atomic_new(v), sample: v }; }
      pub fn atomic_load[T: SyncScalar](a: Atomic[T]) -> T { return SyncScalar.atomic_load(a.sample, a.handle); }
      pub fn atomic_fetch_add[T: SyncScalar](a: Atomic[T], d: T) -> Atomic[T] {
        let next: T = SyncScalar.atomic_fetch_add(d, a.handle);
        return Atomic { handle: a.handle, sample: next };
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/sync" as s
      fn main() -> i32 {
        let mut m: s.Mutex[i64] = s.mutex[i64](7 as i64);
        let m2: s.Mutex[i64] = m;
        m = s.mutex_store[i64](m, 9 as i64);
        let mut a: s.Atomic[i64] = s.atomic[i64](3 as i64);
        a = s.atomic_fetch_add[i64](a, 4 as i64);
        return (s.mutex_load[i64](m2) + s.atomic_load[i64](a)) as i32;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_std_io_net_intrinsics_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      pub struct NetAddr { host: String, port: i32 }
      pub struct NetConn { handle: i64 }
      pub fn net_addr(host: String, port: i32) -> NetAddr { return NetAddr { host: host, port: port }; }
      pub fn net_connect(a: NetAddr) -> NetConn { return NetConn { handle: __tcp_connect(a.host, a.port) }; }
      pub fn net_send(c: NetConn, text: String) -> i32 { return __tcp_send(c.handle, text); }
      pub fn net_recv(c: NetConn, max_n: i32) -> String { return __tcp_recv(c.handle, max_n); }
      pub fn net_close(c: NetConn) -> () { __tcp_close(c.handle); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/io" as io
      fn main() -> i32 {
        let a: io.NetAddr = io.net_addr("127.0.0.1", 7);
        let c: io.NetConn = io.net_connect(a);
        let _n: i32 = io.net_send(c, "x");
        let _s: String = io.net_recv(c, 8);
        io.net_close(c);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
