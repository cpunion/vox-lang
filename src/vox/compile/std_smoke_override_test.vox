import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_std_testing_assert_eq_wrapper_preserves_eq_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_eq[T: Eq](a: T, b: T) -> () { if a != b { panic("assertion failed"); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: "import \"std/prelude\" as prelude\npub fn assert_eq[T: prelude.Eq](a: T, b: T) -> () { prelude.assert_eq(a, b); }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_eq(1, 1); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_std_testing_assert_ne_wrapper_preserves_eq_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_eq[T: Eq](a: T, b: T) -> () { if a != b { panic("assertion failed"); } }
      pub fn assert_ne[T: Eq](a: T, b: T) -> () { if a == b { panic("assertion failed"); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: "import \"std/prelude\" as prelude\npub fn assert_ne[T: prelude.Eq](a: T, b: T) -> () { prelude.assert_ne(a, b); }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_ne(1, 2); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_std_testing_assert_lt_wrapper_preserves_ord_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Ord { fn lt(a: Self, b: Self) -> bool; }
      impl Ord for i32 { fn lt(a: i32, b: i32) -> bool { return a < b; } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_lt[T: Ord](a: T, b: T) -> () { if a < b { return; } panic("assertion failed"); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: """
      import "std/prelude" as prelude
      pub fn assert_lt[T: prelude.Ord](a: T, b: T) -> () { prelude.assert_lt(a, b); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_lt(1, 2); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_std_io_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      pub fn out(msg: String) -> () { print(msg); }
      pub fn out_ln(msg: String) -> () { print(msg); print("\\n"); }
      pub fn fail(msg: String) -> () { panic(msg); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/io\" as io\nfn main() -> i32 { io.out(\"x\"); io.out_ln(\"y\"); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_std_time_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/time/time.vox",
    text: """
      pub fn now_ns() -> i64 { return __now_ns(); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/time" as tm
      fn main() -> i32 {
        let t0: i64 = tm.now_ns();
        if t0 >= 0 { return 0; }
        return 1;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_std_sync_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/sync/sync.vox",
    text: """
      pub trait SyncScalar {
        fn mutex_new(v: Self) -> isize;
        fn mutex_load(sample: Self, handle: isize) -> Self;
        fn mutex_store(v: Self, handle: isize) -> ();
        fn atomic_new(v: Self) -> isize;
        fn atomic_load(sample: Self, handle: isize) -> Self;
        fn atomic_store(v: Self, handle: isize) -> ();
        fn atomic_fetch_add(delta: Self, handle: isize) -> Self;
      }
      impl SyncScalar for i32 {
        fn mutex_new(v: i32) -> isize { return __mutex_i32_new(v) as isize; }
        fn mutex_load(sample: i32, handle: isize) -> i32 { return __mutex_i32_load(handle as i64); }
        fn mutex_store(v: i32, handle: isize) -> () { __mutex_i32_store(handle as i64, v); }
        fn atomic_new(v: i32) -> isize { return __atomic_i32_new(v) as isize; }
        fn atomic_load(sample: i32, handle: isize) -> i32 { return __atomic_i32_load(handle as i64); }
        fn atomic_store(v: i32, handle: isize) -> () { __atomic_i32_store(handle as i64, v); }
        fn atomic_fetch_add(delta: i32, handle: isize) -> i32 { return __atomic_i32_fetch_add(handle as i64, delta); }
      }
      pub struct Mutex[T: SyncScalar] { handle: isize, sample: T }
      pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] { return Mutex { handle: SyncScalar.mutex_new(v), sample: v }; }
      pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
        SyncScalar.mutex_store(v, m.handle);
        return Mutex { handle: m.handle, sample: v };
      }
      pub fn mutex_into_inner[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub struct Atomic[T: SyncScalar] { handle: isize, sample: T }
      pub fn atomic[T: SyncScalar](v: T) -> Atomic[T] { return Atomic { handle: SyncScalar.atomic_new(v), sample: v }; }
      pub fn atomic_load[T: SyncScalar](a: Atomic[T]) -> T { return SyncScalar.atomic_load(a.sample, a.handle); }
      pub fn atomic_store[T: SyncScalar](a: Atomic[T], v: T) -> Atomic[T] {
        SyncScalar.atomic_store(v, a.handle);
        return Atomic { handle: a.handle, sample: v };
      }
      pub fn atomic_fetch_add[T: SyncScalar](a: Atomic[T], delta: T) -> Atomic[T] {
        let next: T = SyncScalar.atomic_fetch_add(delta, a.handle);
        return Atomic { handle: a.handle, sample: next };
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/sync" as s
      fn main() -> i32 {
        let m: s.Mutex[i32] = s.mutex[i32](7);
        let x: i32 = s.mutex_into_inner[i32](m);
        let mut a: s.Atomic[i32] = s.atomic[i32](1);
        a = s.atomic_fetch_add[i32](a, 2);
        a = s.atomic_store[i32](a, 4);
        return x + s.atomic_load[i32](a);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_std_sync_i64_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/sync/sync.vox",
    text: """
      pub trait SyncScalar {
        fn mutex_new(v: Self) -> isize;
        fn mutex_load(sample: Self, handle: isize) -> Self;
        fn mutex_store(v: Self, handle: isize) -> ();
        fn atomic_new(v: Self) -> isize;
        fn atomic_load(sample: Self, handle: isize) -> Self;
        fn atomic_fetch_add(delta: Self, handle: isize) -> Self;
      }
      impl SyncScalar for i64 {
        fn mutex_new(v: i64) -> isize { return __mutex_i64_new(v) as isize; }
        fn mutex_load(sample: i64, handle: isize) -> i64 { return __mutex_i64_load(handle as i64); }
        fn mutex_store(v: i64, handle: isize) -> () { __mutex_i64_store(handle as i64, v); }
        fn atomic_new(v: i64) -> isize { return __atomic_i64_new(v) as isize; }
        fn atomic_load(sample: i64, handle: isize) -> i64 { return __atomic_i64_load(handle as i64); }
        fn atomic_fetch_add(delta: i64, handle: isize) -> i64 { return __atomic_i64_fetch_add(handle as i64, delta); }
      }
      pub struct Mutex[T: SyncScalar] { handle: isize, sample: T }
      pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] { return Mutex { handle: SyncScalar.mutex_new(v), sample: v }; }
      pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
        SyncScalar.mutex_store(v, m.handle);
        return Mutex { handle: m.handle, sample: v };
      }
      pub struct Atomic[T: SyncScalar] { handle: isize, sample: T }
      pub fn atomic[T: SyncScalar](v: T) -> Atomic[T] { return Atomic { handle: SyncScalar.atomic_new(v), sample: v }; }
      pub fn atomic_load[T: SyncScalar](a: Atomic[T]) -> T { return SyncScalar.atomic_load(a.sample, a.handle); }
      pub fn atomic_fetch_add[T: SyncScalar](a: Atomic[T], d: T) -> Atomic[T] {
        let next: T = SyncScalar.atomic_fetch_add(d, a.handle);
        return Atomic { handle: a.handle, sample: next };
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/sync" as s
      fn main() -> i32 {
        let mut m: s.Mutex[i64] = s.mutex[i64](7 as i64);
        let m2: s.Mutex[i64] = m;
        m = s.mutex_store[i64](m, 9 as i64);
        let mut a: s.Atomic[i64] = s.atomic[i64](3 as i64);
        a = s.atomic_fetch_add[i64](a, 4 as i64);
        return (s.mutex_load[i64](m2) + s.atomic_load[i64](a)) as i32;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_std_io_net_intrinsics_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      pub struct NetAddr { host: String, port: i32 }
      pub struct NetConn { handle: isize }
      pub fn net_addr(host: String, port: i32) -> NetAddr { return NetAddr { host: host, port: port }; }
      pub fn net_connect(a: NetAddr) -> NetConn { return NetConn { handle: __tcp_connect(a.host, a.port) as isize }; }
      pub fn net_send(c: NetConn, text: String) -> i32 { return __tcp_send(c.handle as i64, text); }
      pub fn net_recv(c: NetConn, max_n: i32) -> String { return __tcp_recv(c.handle as i64, max_n); }
      pub fn net_wait_read(c: NetConn, timeout_ms: i32) -> bool { return __tcp_wait_read(c.handle as i64, timeout_ms); }
      pub fn net_wait_write(c: NetConn, timeout_ms: i32) -> bool { return __tcp_wait_write(c.handle as i64, timeout_ms); }
      pub fn net_close(c: NetConn) -> () { __tcp_close(c.handle as i64); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/io" as io
      fn main() -> i32 {
        let a: io.NetAddr = io.net_addr("127.0.0.1", 7);
        let c: io.NetConn = io.net_connect(a);
        let _n: i32 = io.net_send(c, "x");
        let _s: String = io.net_recv(c, 8);
        let _r: bool = io.net_wait_read(c, 1);
        let _w: bool = io.net_wait_write(c, 1);
        io.net_close(c);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_io_method_style_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      pub struct File { path: String }
      pub fn file(path: String) -> File { return File { path: path }; }
      impl File {
        fn exists(f: &File) -> bool { return __path_exists(f.path); }
        fn read_all(f: &File) -> String { return __read_file(f.path); }
        fn write_all(f: &File, text: String) -> () { __write_file(f.path, text); }
        fn mkdir_p(f: &File) -> () { __mkdir_p(f.path); }
      }
      pub struct NetAddr { host: String, port: i32 }
      pub struct NetConn { handle: isize }
      pub fn net_addr(host: String, port: i32) -> NetAddr { return NetAddr { host: host, port: port }; }
      impl NetAddr {
        fn connect(a: NetAddr) -> NetConn { return NetConn { handle: __tcp_connect(a.host, a.port) as isize }; }
      }
      impl NetConn {
        fn send(c: &NetConn, text: String) -> i32 { return __tcp_send(c.handle as i64, text); }
        fn recv(c: &NetConn, max_n: i32) -> String { return __tcp_recv(c.handle as i64, max_n); }
        fn wait_read(c: &NetConn, timeout_ms: i32) -> bool { return __tcp_wait_read(c.handle as i64, timeout_ms); }
        fn wait_write(c: &NetConn, timeout_ms: i32) -> bool { return __tcp_wait_write(c.handle as i64, timeout_ms); }
        fn close(c: NetConn) -> () { __tcp_close(c.handle as i64); }
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/io" as io
      fn main() -> i32 {
        let f: io.File = io.file("a.txt");
        f.write_all("x");
        let _s: String = f.read_all();
        let _b: bool = f.exists();
        let d: io.File = io.file("tmp");
        d.mkdir_p();
        let a: io.NetAddr = io.net_addr("127.0.0.1", 7);
        let c: io.NetConn = a.connect();
        let _n: i32 = c.send("x");
        let _r: String = c.recv(8);
        let _wr: bool = c.wait_read(1);
        let _ww: bool = c.wait_write(1);
        c.close();
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_fs_method_style_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/fs/fs.vox",
    text: """
      pub struct Path { raw: String }
      pub fn path(raw: String) -> Path { return Path { raw: raw }; }
      impl Path {
        fn read_to_string(p: &Path) -> String { return __read_file(p.raw); }
        fn write_string(p: &Path, text: String) -> () { __write_file(p.raw, text); }
        fn exists(p: &Path) -> bool { return __path_exists(p.raw); }
        fn mkdir_p(p: &Path) -> () { __mkdir_p(p.raw); }
        fn walk_files(p: &Path) -> Vec[String] { return __walk_vox_files(p.raw); }
      }
      pub fn read_to_string(raw: String) -> String { let p: Path = path(raw); return p.read_to_string(); }
      pub fn write_string(raw: String, text: String) -> () { let p: Path = path(raw); p.write_string(text); return; }
      pub fn exists(raw: String) -> bool { let p: Path = path(raw); return p.exists(); }
      pub fn mkdir_p(raw: String) -> () { let p: Path = path(raw); p.mkdir_p(); return; }
      pub fn walk_files(raw: String) -> Vec[String] { let p: Path = path(raw); return p.walk_files(); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/fs" as fs
      fn main() -> i32 {
        let p: fs.Path = fs.path("a.txt");
        p.write_string("x");
        let _s: String = p.read_to_string();
        let _b: bool = p.exists();
        let d: fs.Path = fs.path("tmp");
        d.mkdir_p();
        let _xs: Vec[String] = d.walk_files();
        fs.write_string("b.txt", "y");
        let _s2: String = fs.read_to_string("b.txt");
        let _b2: bool = fs.exists("b.txt");
        fs.mkdir_p("tmp2");
        let _xs2: Vec[String] = fs.walk_files("tmp2");
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_process_command_style_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/process/process.vox",
    text: """
      pub struct EnvVar { key: String, value: String }
      pub struct Command { prog: String, argv: Vec[String], envs: Vec[EnvVar] }
      pub fn command(prog: String) -> Command { return Command { prog: prog, argv: Vec(), envs: Vec() }; }
      fn sh_quote(s: String) -> String { return s; }
      impl Command {
        fn arg(c: Command, a: String) -> Command { let mut out: Command = c; out.argv.push(a); return out; }
        fn args(c: Command, xs: Vec[String]) -> Command {
          let mut out: Command = c;
          let mut i: i32 = 0;
          while i < xs.len() { out.argv.push(xs.get(i)); i = i + 1; }
          return out;
        }
        fn env(c: Command, key: String, value: String) -> Command {
          let mut out: Command = c;
          out.envs.push(EnvVar { key: key, value: value });
          return out;
        }
        fn render(c: &Command) -> String {
          let mut out: String = "";
          let mut i: i32 = 0;
          while i < c.envs.len() {
            let e: EnvVar = c.envs.get(i);
            out = out.concat(e.key).concat("=").concat(sh_quote(e.value)).concat(" ");
            i = i + 1;
          }
          out = out.concat(sh_quote(c.prog));
          i = 0;
          while i < c.argv.len() {
            out = out.concat(" ").concat(sh_quote(c.argv.get(i)));
            i = i + 1;
          }
          return out;
        }
        fn run(c: &Command) -> i32 { return exec(c.render()); }
      }
      pub fn args() -> Vec[String] { return __args(); }
      pub fn exec(cmd: String) -> i32 { return __exec(cmd); }
      pub fn exe_path() -> String { return __exe_path(); }
      pub fn getenv(key: String) -> String { return __getenv(key); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/process" as p
      fn main() -> i32 {
        let exe: String = p.exe_path();
        let cmd: p.Command = p.command(exe).env("VOX_X", "1").arg("version").args(Vec());
        let line: String = cmd.render();
        let _rc0: i32 = p.exec(line);
        let _rc1: i32 = cmd.run();
        let _as: Vec[String] = p.args();
        let _g: String = p.getenv("HOME");
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_fs_virtual_fs_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/fs/fs.vox",
    text: """
      pub trait FS {
        fn read_to_string(x: &Self, path: String) -> String;
        fn exists(x: &Self, path: String) -> bool;
        fn walk_files(x: &Self, root: String) -> Vec[String];
      }
      pub trait WritableFS {
        fn write_string(x: Self, path: String, text: String) -> Self;
        fn mkdir_p(x: Self, path: String) -> Self;
      }
      pub struct MemFS { files: Vec[String] }
      pub fn mem_fs() -> MemFS { return MemFS { files: Vec() }; }
      impl MemFS {
        fn read_to_string(_x: &MemFS, _p: String) -> String { return "ok"; }
        fn exists(x: &MemFS, p: String) -> bool {
          let mut i: i32 = 0;
          while i < x.files.len() {
            if x.files.get(i) == p { return true; }
            i = i + 1;
          }
          return false;
        }
        fn walk_files(x: &MemFS, _root: String) -> Vec[String] { return x.files; }
        fn write_string(x: MemFS, p: String, _text: String) -> MemFS {
          let mut ys: Vec[String] = x.files;
          ys.push(p);
          return MemFS { files: ys };
        }
        fn mkdir_p(x: MemFS, _p: String) -> MemFS { return x; }
      }
      impl FS for MemFS {
        fn read_to_string(x: &MemFS, p: String) -> String { return x.read_to_string(p); }
        fn exists(x: &MemFS, p: String) -> bool { return x.exists(p); }
        fn walk_files(x: &MemFS, root: String) -> Vec[String] { return x.walk_files(root); }
      }
      impl WritableFS for MemFS {
        fn write_string(x: MemFS, p: String, text: String) -> MemFS { return x.write_string(p, text); }
        fn mkdir_p(x: MemFS, p: String) -> MemFS { return x.mkdir_p(p); }
      }
      pub fn fs_read_to_string[T: FS](x: T, p: String) -> String { return FS.read_to_string(x, p); }
      pub fn fs_exists[T: FS](x: T, p: String) -> bool { return FS.exists(x, p); }
      pub fn fs_walk_files[T: FS](x: T, root: String) -> Vec[String] { return FS.walk_files(x, root); }
      pub fn fs_write_string[T: WritableFS](x: T, p: String, text: String) -> T { return WritableFS.write_string(x, p, text); }
      pub fn fs_mkdir_p[T: WritableFS](x: T, p: String) -> T { return WritableFS.mkdir_p(x, p); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/fs" as fs
      fn main() -> i32 {
        let mut m: fs.MemFS = fs.mem_fs();
        m = m.mkdir_p("/src");
        m = m.write_string("/src/main.vox", "fn main() -> i32 { return 0; }");
        let _b0: bool = m.exists("/src/main.vox");
        let _s0: String = m.read_to_string("/src/main.vox");
        let _xs: Vec[String] = m.walk_files("/src");
        m = fs.fs_mkdir_p(m, "/pkg");
        m = fs.fs_write_string(m, "/pkg/lib.vox", "fn lib() -> i32 { return 1; }");
        let _b1: bool = fs.fs_exists(m, "/pkg/lib.vox");
        let _s1: String = fs.fs_read_to_string(m, "/pkg/lib.vox");
        let _ys: Vec[String] = fs.fs_walk_files(m, "/pkg");
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_std_net_socket_addr_style_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      pub struct NetAddr { pub host: String, pub port: i32 }
      pub struct NetConn { handle: isize }
      pub fn net_addr(host: String, port: i32) -> NetAddr { return NetAddr { host: host, port: port }; }
      impl NetAddr {
        fn connect(a: &NetAddr) -> NetConn { return NetConn { handle: __tcp_connect(a.host, a.port) as isize }; }
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/net/net.vox",
    text: """
      import "std/io" as io
      pub enum NetProto { Tcp, Udp }
      pub struct SocketAddr { pub proto: NetProto, pub host: String, pub port: i32 }
      pub struct SocketAddrParseResult { pub ok: bool, pub err: String, pub addr: SocketAddr }
      pub struct UdpSocket { local: SocketAddr }
      pub fn socket_addr(proto: NetProto, host: String, port: i32) -> SocketAddr {
        return SocketAddr { proto: proto, host: host, port: port };
      }
      pub fn tcp_addr(host: String, port: i32) -> SocketAddr { return socket_addr(NetProto.Tcp, host, port); }
      pub fn udp_addr(host: String, port: i32) -> SocketAddr { return socket_addr(NetProto.Udp, host, port); }
      impl SocketAddr {
        fn is_tcp(a: &SocketAddr) -> bool { return match a.proto { NetProto.Tcp => true, _ => false }; }
        fn is_udp(a: &SocketAddr) -> bool { return match a.proto { NetProto.Udp => true, _ => false }; }
        fn uri(a: &SocketAddr) -> String {
          let scheme: String = match a.proto { NetProto.Tcp => "tcp", _ => "udp" };
          return scheme.concat("://").concat(a.host).concat(":").concat(a.port.to_string());
        }
        fn to_net_addr(a: &SocketAddr) -> io.NetAddr { return io.net_addr(a.host, a.port); }
        fn tcp_connect(a: &SocketAddr) -> io.NetConn {
          let na: io.NetAddr = a.to_net_addr();
          return na.connect();
        }
      }
      pub fn socket_uri(a: SocketAddr) -> String { return a.uri(); }
      pub fn parse_socket_uri(_raw: String) -> SocketAddrParseResult {
        return SocketAddrParseResult { ok: true, err: "", addr: tcp_addr("127.0.0.1", 9000) };
      }
      pub fn tcp_connect_addr(a: SocketAddr) -> io.NetConn { return a.tcp_connect(); }
      pub fn udp_bind(local: SocketAddr) -> UdpSocket { return UdpSocket { local: local }; }
      impl UdpSocket {
        fn local_addr(x: &UdpSocket) -> SocketAddr { return x.local; }
        fn send_to(_x: &UdpSocket, _to: SocketAddr, _data: String) -> i32 { return 0; }
        fn recv_from(_x: &UdpSocket, _max_n: i32) -> String { return ""; }
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/net" as net
      fn main() -> i32 {
        let a: net.SocketAddr = net.tcp_addr("127.0.0.1", 9000);
        let _u: String = a.uri();
        let _b0: bool = a.is_tcp();
        let _b1: bool = a.is_udp();
        let _c = net.tcp_connect_addr(a);
        let p: net.SocketAddrParseResult = net.parse_socket_uri("tcp://127.0.0.1:9000");
        if p.ok {
          let _u2: String = net.socket_uri(p.addr);
        }
        let u: net.SocketAddr = net.udp_addr("0.0.0.0", 53);
        let s: net.UdpSocket = net.udp_bind(u);
        let _lu: net.SocketAddr = s.local_addr();
        let _sn: i32 = s.send_to(net.udp_addr("127.0.0.1", 53), "x");
        let _rx: String = s.recv_from(16);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
