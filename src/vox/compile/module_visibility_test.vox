import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg


fn test_compile_merges_multi_files_in_root_module() -> () {
  // Both files are under src/, so they belong to the same root module ("main").
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/helper.vox", text: "fn helper() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return helper(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_merges_multi_files_in_same_submodule() -> () {
  // Both files are under src/a/, so they belong to the same module "a" and can share private symbols.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/x.vox", text: "fn hidden() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/a/y.vox", text: "pub fn one() -> i32 { return hidden(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a\" as a\nfn main() -> i32 { return a.one(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_pub_crate_visible_inside_src_but_hidden_from_tests() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/a.vox", text: "pub(crate) fn hidden() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/b/b.vox", text: "import \"a\" as a\npub fn call_hidden() -> i32 { return a.hidden(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"b\" as b\nfn main() -> i32 { return b.call_hidden(); }" });
  fs.push(ld.SourceFile { path: "tests/basic.vox", text: "import \"a\" as a\nfn test_pub_crate_not_visible_from_tests() -> () { a.hidden(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_pub_super_visible_in_parent_scope_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/b/c/c.vox", text: "pub(super) fn only_parent_scope() -> i32 { return 7; }" });
  fs.push(ld.SourceFile { path: "src/a/b/use.vox", text: "import \"a/b/c\" as c\npub fn ok() -> i32 { return c.only_parent_scope(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a/b\" as ab\nfn main() -> i32 { return ab.ok(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_pub_super_hidden_outside_parent_scope() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/b/c/c.vox", text: "pub(super) fn only_parent_scope() -> i32 { return 7; }" });
  fs.push(ld.SourceFile { path: "src/a/d/use.vox", text: "import \"a/b/c\" as c\npub fn bad() -> i32 { return c.only_parent_scope(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a/d\" as ad\nfn main() -> i32 { return ad.bad(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_rejects_user_call_to_reserved_intrinsic() -> () {
  // `__*` intrinsics are reserved for std/** modules only.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { __read_file(\"x\"); return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_rejects_user_defines_reserved_name() -> () {
  // Users must not define `__*` names.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn __x() -> i32 { return 0; }\nfn main() -> i32 { return __x(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_rejects_duplicate_import_alias_in_file() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/a.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/b/b.vox", text: "pub fn one() -> i32 { return 2; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a\" as x\nimport \"b\" as x\nfn main() -> i32 { return x.one(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "duplicate import alias"));
  t.assert(contains(r.err, "[E_IMPORT_0004]"));
}
fn test_compile_duplicate_named_import_reports_line() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn one() -> i32 { return 1; }\npub fn two() -> i32 { return 2; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { one as x, two as x } from \"dep\"\nfn main() -> i32 { return x(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:1:"));
  t.assert(contains(r.err, "duplicate imported name"));
  t.assert(contains(r.err, "[E_IMPORT_0005]"));
}
