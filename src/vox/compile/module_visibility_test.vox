import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_merges_multi_files_in_root_module() -> () {
  // Both files are under src/, so they belong to the same root module ("main").
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/helper.vox", text: "fn helper() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return helper(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_merges_multi_files_in_same_submodule() -> () {
  // Both files are under src/a/, so they belong to the same module "a" and can share private symbols.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/x.vox", text: "fn hidden() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/a/y.vox", text: "pub fn one() -> i32 { return hidden(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a\" as a\nfn main() -> i32 { return a.one(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_pub_crate_visible_inside_src_but_hidden_from_tests() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/a.vox", text: "pub(crate) fn hidden() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/b/b.vox", text: "import \"a\" as a\npub fn call_hidden() -> i32 { return a.hidden(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"b\" as b\nfn main() -> i32 { return b.call_hidden(); }" });
  fs.push(ld.SourceFile { path: "tests/basic.vox", text: "import \"a\" as a\nfn test_pub_crate_not_visible_from_tests() -> () { a.hidden(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_pub_super_visible_in_parent_scope_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/b/c/c.vox", text: "pub(super) fn only_parent_scope() -> i32 { return 7; }" });
  fs.push(ld.SourceFile { path: "src/a/b/use.vox", text: "import \"a/b/c\" as c\npub fn ok() -> i32 { return c.only_parent_scope(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a/b\" as ab\nfn main() -> i32 { return ab.ok(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_pub_super_hidden_outside_parent_scope() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/b/c/c.vox", text: "pub(super) fn only_parent_scope() -> i32 { return 7; }" });
  fs.push(ld.SourceFile { path: "src/a/d/use.vox", text: "import \"a/b/c\" as c\npub fn bad() -> i32 { return c.only_parent_scope(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a/d\" as ad\nfn main() -> i32 { return ad.bad(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_rejects_user_call_to_reserved_intrinsic() -> () {
  // `__*` intrinsics are reserved for std/** modules only.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { __read_file(\"x\"); return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
}

fn test_compile_rejects_user_call_to_reserved_intrinsic_yield_now() -> () {
  // New intrinsic should follow the same reserved rule.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { __yield_now(); return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(!r.ok, r.err);
}

fn test_compile_allows_std_module_call_to_runtime_ffi_yield_now() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/time/time.vox",
    text: """
      @ffi_import("c", "vox_impl_yield_now")
      fn rt_yield_now_raw() -> ();
      pub fn yield_now() -> () { rt_yield_now_raw(); return; }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/time\" as tm\nfn main() -> i32 { tm.yield_now(); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_allows_std_module_call_to_runtime_wake_ffi() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/async/async.vox",
    text: """
      @ffi_import("c", "vox_host_wake_notify")
      fn rt_wake_notify_raw(token: i64) -> ();
      @ffi_import("c", "vox_host_wake_wait")
      fn rt_wake_wait_raw(token: i64, timeout_ms: i32) -> bool;
      pub struct Waker { pub token: i64 }
      pub struct Context { pub waker: Waker }
      pub fn wake(c: Context) -> () { rt_wake_notify_raw(c.waker.token); return; }
      pub fn park_until_wake(i: i32, c: Context) -> bool { i; return rt_wake_wait_raw(c.waker.token, 1); }
      pub fn park_any(i: i32, cs: Vec[Context]) -> i32 {
        i;
        if cs.len() == 0 { return -1; }
        if rt_wake_wait_raw(cs.get(0).waker.token, 1) { return 0; }
        let mut j: i32 = 1;
        while j < cs.len() {
          if rt_wake_wait_raw(cs.get(j).waker.token, 0) { return j; }
          j = j + 1;
        }
        return -1;
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/async" as a
      fn main() -> i32 {
        let cx: a.Context = a.Context { waker: a.Waker { token: 1 } };
        let mut cs: Vec[a.Context] = Vec();
        cs.push(cx);
        a.wake(cx);
        let _idx: i32 = a.park_any(0, cs);
        if a.park_until_wake(0, cx) { return 1; }
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_rejects_user_defines_reserved_name() -> () {
  // Users must not define `__*` names.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn __x() -> i32 { return 0; }\nfn main() -> i32 { return __x(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}

fn test_compile_rejects_duplicate_import_alias_in_file() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/a.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/b/b.vox", text: "pub fn one() -> i32 { return 2; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a\" as x\nimport \"b\" as x\nfn main() -> i32 { return x.one(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "duplicate import alias"));
  t.assert(contains(r.err, "[E_IMPORT_0004]"));
}

fn test_compile_duplicate_named_import_reports_line() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn one() -> i32 { return 1; }\npub fn two() -> i32 { return 2; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { one as x, two as x } from \"dep\"\nfn main() -> i32 { return x(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:1:"));
  t.assert(contains(r.err, "duplicate imported name"));
  t.assert(contains(r.err, "[E_IMPORT_0005]"));
}
