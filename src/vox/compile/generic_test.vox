import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_type_alias_field_type_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct S { a: i32, b: String }
      enum E { A(i64), B }
      type B = @field_type(S, 1)
      type TA = @field_type(E, 0)
      type TB = @field_type(E, 1)
      fn touch(x: TB) -> i32 { return 0; }
      fn main() -> i32 {
        let x: B = "ok";
        let a: TA = 7;
        return x.len() + (a as i32);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_type_alias_field_type_generic_nominal_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Pair[T] { a: T, b: T }
      enum Wrap[T] { One(T), None }
      type PA = @field_type(Pair[i32], 0)
      type WA = @field_type(Wrap[i64], 0)
      type WN = @field_type(Wrap[i64], 1)
      fn touch(x: WN) -> i32 { return 0; }
      fn main() -> i32 {
        let a: PA = 3;
        let b: WA = 4;
        return a + (b as i32);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_type_alias_field_type_multi_payload_enum_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum E { A(i32, i64), B }
      type T = @field_type(E, 0)
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_union_type_alias_match_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "type Value = I32: i32 | Str: String\nfn main() -> i32 { let x: Value = Value.I32(7); return match x { .I32(v) => v, .Str(_s) => 0 }; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_generic_eq_operator_with_struct_instantiation_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      struct S { a: i32 }
      impl Eq for S { fn eq(a: S, b: S) -> bool { return a.a == b.a; } }
      fn same[T: Eq](a: T, b: T) -> bool { return a == b; }
      fn main() -> i32 { let x: S = S { a: 1 }; let y: S = S { a: 1 }; return if same(x, y) { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_struct_eq_"));
}
fn test_compile_generic_cmp_operator_with_ord_bound_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Ord { fn lt(a: Self, b: Self) -> bool; }
      impl Ord for i32 { fn lt(a: i32, b: i32) -> bool { return a < b; } }
      fn less[T: Ord](a: T, b: T) -> bool { return a < b; }
      fn main() -> i32 { return if less(1, 2) { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_generic_cmp_operator_without_ord_bound_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn less[T](a: T, b: T) -> bool { return a < b; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_generic_nominal_instantiation_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Pair[T] { a: T, b: T }
      enum Option[T] { Some(T), None }
      fn main() -> i32 {
        let p: Pair[i32] = Pair { a: 1, b: 2 };
        let o: Option[i32] = Option.Some(p.a + p.b);
        return match o { Option.Some(v) => v, Option.None => 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_struct_type_name("Pair$gT_3di32")));
  t.assert(contains(r.c, cg.c_enum_type_name("Option$gT_3di32")));
}
fn test_compile_generic_fn_return_nominal_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Boxed[T] { v: T }
      fn mk[T](x: T) -> Boxed[T] { return Boxed { v: x }; }
      fn main() -> i32 {
        let b: Boxed[i32] = mk[i32](7);
        return b.v;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_struct_type_name("Boxed$gT_3di32")));
}
fn test_compile_generic_nominal_struct_path_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Pair[T] { a: T, b: T }\nstruct Box[T] { a: T, b: T }\nfn main() -> i32 {\n  let _p: Pair[i32] = Box { a: 1, b: 2 };\n  return 0;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert(!r.ok);
}
fn test_compile_generic_nominal_instantiation_with_typed_path_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Pair[T] { a: T, b: T }
      enum Option[T] { Some(T), None }
      fn main() -> i32 {
        let p = Pair[i32] { a: 1, b: 2 };
        let o = Option[i32].Some(p.a + p.b);
        let n = Option[i32].None;
        let y: i32 = match n { Option.Some(v) => v, Option.None => 0 };
        return match o { Option.Some(v) => v + y, Option.None => 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_struct_type_name("Pair$gT_3di32")));
  t.assert(contains(r.c, cg.c_enum_type_name("Option$gT_3di32")));
}
fn test_compile_std_testing_assert_eq_wrapper_preserves_eq_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_eq[T: Eq](a: T, b: T) -> () { if a != b { panic("assertion failed"); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: "import \"std/prelude\" as prelude\npub fn assert_eq[T: prelude.Eq](a: T, b: T) -> () { prelude.assert_eq(a, b); }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_eq(1, 1); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_std_testing_assert_ne_wrapper_preserves_eq_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_eq[T: Eq](a: T, b: T) -> () { if a != b { panic("assertion failed"); } }
      pub fn assert_ne[T: Eq](a: T, b: T) -> () { if a == b { panic("assertion failed"); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: "import \"std/prelude\" as prelude\npub fn assert_ne[T: prelude.Eq](a: T, b: T) -> () { prelude.assert_ne(a, b); }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_ne(1, 2); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_std_testing_assert_lt_wrapper_preserves_ord_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Ord { fn lt(a: Self, b: Self) -> bool; }
      impl Ord for i32 { fn lt(a: i32, b: i32) -> bool { return a < b; } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/assert.vox",
    text: """
      pub fn assert(cond: bool) -> () { if !cond { panic("assertion failed"); } }
      pub fn fail(msg: String) -> () { panic(msg); }
      pub fn assert_lt[T: Ord](a: T, b: T) -> () { if a < b { return; } panic("assertion failed"); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/testing/testing.vox",
    text: """
      import "std/prelude" as prelude
      pub fn assert_lt[T: prelude.Ord](a: T, b: T) -> () { prelude.assert_lt(a, b); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/testing\" as t\nfn main() -> i32 { t.assert_lt(1, 2); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_std_io_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      pub fn out(msg: String) -> () { print(msg); }
      pub fn out_ln(msg: String) -> () { print(msg); print("\\n"); }
      pub fn fail(msg: String) -> () { panic(msg); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"std/io\" as io\nfn main() -> i32 { io.out(\"x\"); io.out_ln(\"y\"); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_std_time_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/time/time.vox",
    text: """
      pub fn now_ns() -> i64 { return __now_ns(); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/time" as tm
      fn main() -> i32 {
        let t0: i64 = tm.now_ns();
        if t0 >= 0 { return 0; }
        return 1;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_std_sync_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/sync/sync.vox",
    text: """
      pub trait SyncScalar {
        fn mutex_new(v: Self) -> i64;
        fn mutex_load(sample: Self, handle: i64) -> Self;
        fn mutex_store(v: Self, handle: i64) -> ();
        fn atomic_new(v: Self) -> i64;
        fn atomic_load(sample: Self, handle: i64) -> Self;
        fn atomic_store(v: Self, handle: i64) -> ();
        fn atomic_fetch_add(delta: Self, handle: i64) -> Self;
      }
      impl SyncScalar for i32 {
        fn mutex_new(v: i32) -> i64 { return __mutex_i32_new(v); }
        fn mutex_load(sample: i32, handle: i64) -> i32 { return __mutex_i32_load(handle); }
        fn mutex_store(v: i32, handle: i64) -> () { __mutex_i32_store(handle, v); }
        fn atomic_new(v: i32) -> i64 { return __atomic_i32_new(v); }
        fn atomic_load(sample: i32, handle: i64) -> i32 { return __atomic_i32_load(handle); }
        fn atomic_store(v: i32, handle: i64) -> () { __atomic_i32_store(handle, v); }
        fn atomic_fetch_add(delta: i32, handle: i64) -> i32 { return __atomic_i32_fetch_add(handle, delta); }
      }
      pub struct Mutex[T: SyncScalar] { handle: i64, sample: T }
      pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] { return Mutex { handle: SyncScalar.mutex_new(v), sample: v }; }
      pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
        SyncScalar.mutex_store(v, m.handle);
        return Mutex { handle: m.handle, sample: v };
      }
      pub fn mutex_into_inner[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub struct Atomic[T: SyncScalar] { handle: i64, sample: T }
      pub fn atomic[T: SyncScalar](v: T) -> Atomic[T] { return Atomic { handle: SyncScalar.atomic_new(v), sample: v }; }
      pub fn atomic_load[T: SyncScalar](a: Atomic[T]) -> T { return SyncScalar.atomic_load(a.sample, a.handle); }
      pub fn atomic_store[T: SyncScalar](a: Atomic[T], v: T) -> Atomic[T] {
        SyncScalar.atomic_store(v, a.handle);
        return Atomic { handle: a.handle, sample: v };
      }
      pub fn atomic_fetch_add[T: SyncScalar](a: Atomic[T], delta: T) -> Atomic[T] {
        let next: T = SyncScalar.atomic_fetch_add(delta, a.handle);
        return Atomic { handle: a.handle, sample: next };
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/sync" as s
      fn main() -> i32 {
        let m: s.Mutex[i32] = s.mutex[i32](7);
        let x: i32 = s.mutex_into_inner[i32](m);
        let mut a: s.Atomic[i32] = s.atomic[i32](1);
        a = s.atomic_fetch_add[i32](a, 2);
        a = s.atomic_store[i32](a, 4);
        return x + s.atomic_load[i32](a);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_std_sync_i64_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/sync/sync.vox",
    text: """
      pub trait SyncScalar {
        fn mutex_new(v: Self) -> i64;
        fn mutex_load(sample: Self, handle: i64) -> Self;
        fn mutex_store(v: Self, handle: i64) -> ();
        fn atomic_new(v: Self) -> i64;
        fn atomic_load(sample: Self, handle: i64) -> Self;
        fn atomic_fetch_add(delta: Self, handle: i64) -> Self;
      }
      impl SyncScalar for i64 {
        fn mutex_new(v: i64) -> i64 { return __mutex_i64_new(v); }
        fn mutex_load(sample: i64, handle: i64) -> i64 { return __mutex_i64_load(handle); }
        fn mutex_store(v: i64, handle: i64) -> () { __mutex_i64_store(handle, v); }
        fn atomic_new(v: i64) -> i64 { return __atomic_i64_new(v); }
        fn atomic_load(sample: i64, handle: i64) -> i64 { return __atomic_i64_load(handle); }
        fn atomic_fetch_add(delta: i64, handle: i64) -> i64 { return __atomic_i64_fetch_add(handle, delta); }
      }
      pub struct Mutex[T: SyncScalar] { handle: i64, sample: T }
      pub fn mutex[T: SyncScalar](v: T) -> Mutex[T] { return Mutex { handle: SyncScalar.mutex_new(v), sample: v }; }
      pub fn mutex_load[T: SyncScalar](m: Mutex[T]) -> T { return SyncScalar.mutex_load(m.sample, m.handle); }
      pub fn mutex_store[T: SyncScalar](m: Mutex[T], v: T) -> Mutex[T] {
        SyncScalar.mutex_store(v, m.handle);
        return Mutex { handle: m.handle, sample: v };
      }
      pub struct Atomic[T: SyncScalar] { handle: i64, sample: T }
      pub fn atomic[T: SyncScalar](v: T) -> Atomic[T] { return Atomic { handle: SyncScalar.atomic_new(v), sample: v }; }
      pub fn atomic_load[T: SyncScalar](a: Atomic[T]) -> T { return SyncScalar.atomic_load(a.sample, a.handle); }
      pub fn atomic_fetch_add[T: SyncScalar](a: Atomic[T], d: T) -> Atomic[T] {
        let next: T = SyncScalar.atomic_fetch_add(d, a.handle);
        return Atomic { handle: a.handle, sample: next };
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/sync" as s
      fn main() -> i32 {
        let mut m: s.Mutex[i64] = s.mutex[i64](7 as i64);
        let m2: s.Mutex[i64] = m;
        m = s.mutex_store[i64](m, 9 as i64);
        let mut a: s.Atomic[i64] = s.atomic[i64](3 as i64);
        a = s.atomic_fetch_add[i64](a, 4 as i64);
        return (s.mutex_load[i64](m2) + s.atomic_load[i64](a)) as i32;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_std_io_net_intrinsics_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/io/io.vox",
    text: """
      pub struct NetAddr { host: String, port: i32 }
      pub struct NetConn { handle: i64 }
      pub fn net_addr(host: String, port: i32) -> NetAddr { return NetAddr { host: host, port: port }; }
      pub fn net_connect(a: NetAddr) -> NetConn { return NetConn { handle: __tcp_connect(a.host, a.port) }; }
      pub fn net_send(c: NetConn, text: String) -> i32 { return __tcp_send(c.handle, text); }
      pub fn net_recv(c: NetConn, max_n: i32) -> String { return __tcp_recv(c.handle, max_n); }
      pub fn net_close(c: NetConn) -> () { __tcp_close(c.handle); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/io" as io
      fn main() -> i32 {
        let a: io.NetAddr = io.net_addr("127.0.0.1", 7);
        let c: io.NetConn = io.net_connect(a);
        let _n: i32 = io.net_send(c, "x");
        let _s: String = io.net_recv(c, 8);
        io.net_close(c);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_generic_impl_trait_static_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      impl[T] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(7); let s: String = Show.show(v); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Show$show$0$gT_3di32")));
}
fn test_compile_generic_impl_trait_method_sugar_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      impl[T] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(7); let s: String = v.show(); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Show$show$0$gT_3di32")));
}
fn test_compile_generic_impl_bound_rejected_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Mark { fn mark(x: Self) -> bool; }
      trait Show { fn show(x: Self) -> String; }
      impl[T: Mark] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(7); let s: String = Show.show(v); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  let bound_msg: bool = contains(r.err, "does not satisfy trait bound");
  let no_impl_msg: bool = contains(r.err, "no impl for trait call");
  t.assert(bound_msg || no_impl_msg);
  if bound_msg {
    t.assert(contains(r.err, "Mark"));
  } else {
    t.assert(contains(r.err, "Show"));
  }
}
fn test_compile_generic_trait_bound_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      fn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }
      fn main() -> i32 { return if same("a", "b") { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_generic_where_trait_bound_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      fn same[T](a: T, b: T) -> bool where T: Eq { return Eq.eq(a, b); }
      fn main() -> i32 { return if same("a", "b") { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_generic_struct_comptime_where_type_layout_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Small[T] where comptime @size_of(T) <= 8, comptime @align_of(T) <= 8 { v: T }\nfn main() -> i32 { let s: Small[i32] = Small[i32] { v: 7 }; return s.v; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_generic_struct_comptime_where_type_layout_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Big { a: i64, b: i64 }\nstruct Small[T] where comptime @size_of(T) <= 8 { v: T }\nfn main() -> i32 { let b: Big = Big { a: 1, b: 2 }; let s: Small[Big] = Small[Big] { v: b }; return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "type resolve failed in let annotation"), r.err);
}
fn test_compile_generic_enum_comptime_where_type_layout_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "enum Tiny[T] where comptime @size_of(T) <= 8 { V(T) }\nfn main() -> i32 { let x: Tiny[i32] = Tiny[i32].V(7); return match x { Tiny.V(v) => v }; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_generic_enum_comptime_where_type_layout_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Big { a: i64, b: i64 }\nenum Tiny[T] where comptime @size_of(T) <= 8 { V(T) }\nfn main() -> i32 { let b: Big = Big { a: 1, b: 2 }; let x: Tiny[Big] = Tiny[Big].V(b); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "type resolve failed in let annotation"), r.err);
}
fn test_compile_generic_fn_body_checked_without_instantiation() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn bad[T](x: T) -> T { let y: i32 = x; return x; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_generic_impl_method_body_checked_without_instantiation() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Boxed { fn id[T](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Boxed for I { fn id[T](x: I, v: T) -> T { let y: i32 = v; return v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_generic_default_method_body_checked_without_instantiation() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Boxed { fn id[T](x: Self, v: T) -> T { let y: i32 = v; return v; } }\nstruct I { v: i32 }\nimpl Boxed for I {}\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_generic_bound_trait_static_call_in_body_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_generic_bound_trait_method_sugar_in_body_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
      fn f[T: Show](x: T) -> String { return x.show(); }
      fn main() -> i32 { let s: String = f(7); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_generic_bound_trait_method_sugar_generic_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      trait Wrap { fn wrap[U: Eq](x: Self, v: U) -> U; }
      struct I { v: i32 }
      impl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }
      fn f[T: Wrap](x: T) -> i32 { return x.wrap[i32](7); }
      fn main() -> i32 { let x: I = I { v: 1 }; return f(x); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_generic_bound_trait_method_sugar_supertrait_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      trait Wrap: Show { fn id(x: Self) -> Self; }
      struct I { v: i32 }
      impl Show for I { fn show(x: I) -> String { return "ok"; } }
      impl Wrap for I { fn id(x: I) -> I { return x; } }
      fn f[T: Wrap](x: T) -> String { return x.show(); }
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = f(x); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_generic_bound_trait_method_sugar_missing_bound_method_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn f[T: Eq](x: T) -> String { return x.show(); }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "trait method not in bounds"));
  t.assert(contains(r.err, "Eq"));
}
fn test_compile_generic_bound_trait_method_sugar_ambiguous_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { fn show(x: Self) -> String; }
      trait B { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl A for I { fn show(x: I) -> String { return "a"; } }
      impl B for I { fn show(x: I) -> String { return "b"; } }
      fn f[T: A + B](x: T) -> String { return x.show(); }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "ambiguous trait method call"));
  t.assert(contains(r.err, "A.show"));
  t.assert(contains(r.err, "B.show"));
}
fn test_compile_merges_multi_files_in_root_module() -> () {
  // Both files are under src/, so they belong to the same root module ("main").
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/helper.vox", text: "fn helper() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return helper(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_merges_multi_files_in_same_submodule() -> () {
  // Both files are under src/a/, so they belong to the same module "a" and can share private symbols.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/x.vox", text: "fn hidden() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/a/y.vox", text: "pub fn one() -> i32 { return hidden(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a\" as a\nfn main() -> i32 { return a.one(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_pub_crate_visible_inside_src_but_hidden_from_tests() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/a.vox", text: "pub(crate) fn hidden() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/b/b.vox", text: "import \"a\" as a\npub fn call_hidden() -> i32 { return a.hidden(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"b\" as b\nfn main() -> i32 { return b.call_hidden(); }" });
  fs.push(ld.SourceFile { path: "tests/basic.vox", text: "import \"a\" as a\nfn test_pub_crate_not_visible_from_tests() -> () { a.hidden(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_pub_super_visible_in_parent_scope_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/b/c/c.vox", text: "pub(super) fn only_parent_scope() -> i32 { return 7; }" });
  fs.push(ld.SourceFile { path: "src/a/b/use.vox", text: "import \"a/b/c\" as c\npub fn ok() -> i32 { return c.only_parent_scope(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a/b\" as ab\nfn main() -> i32 { return ab.ok(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_pub_super_hidden_outside_parent_scope() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/b/c/c.vox", text: "pub(super) fn only_parent_scope() -> i32 { return 7; }" });
  fs.push(ld.SourceFile { path: "src/a/d/use.vox", text: "import \"a/b/c\" as c\npub fn bad() -> i32 { return c.only_parent_scope(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a/d\" as ad\nfn main() -> i32 { return ad.bad(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_rejects_user_call_to_reserved_intrinsic() -> () {
  // `__*` intrinsics are reserved for std/** modules only.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { __read_file(\"x\"); return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_rejects_user_defines_reserved_name() -> () {
  // Users must not define `__*` names.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn __x() -> i32 { return 0; }\nfn main() -> i32 { return __x(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_rejects_duplicate_import_alias_in_file() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/a.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/b/b.vox", text: "pub fn one() -> i32 { return 2; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a\" as x\nimport \"b\" as x\nfn main() -> i32 { return x.one(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "duplicate import alias"));
  t.assert(contains(r.err, "[E_IMPORT_0004]"));
}
fn test_compile_duplicate_named_import_reports_line() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn one() -> i32 { return 1; }\npub fn two() -> i32 { return 2; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import { one as x, two as x } from \"dep\"\nfn main() -> i32 { return x(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:1:"));
  t.assert(contains(r.err, "duplicate imported name"));
  t.assert(contains(r.err, "[E_IMPORT_0005]"));
}
fn test_compile_type_error_has_file_line_col_prefix() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  // Put the error at a stable location: line 2, col 1.
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 {\nnope();\nreturn 0;\n}" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "[E_TYPE_0001]"));
  t.assert(r.err_kind == c.compile_diag_kind_type());
  t.assert(r.err_code == "E_TYPE_0001");
  t.assert(contains(r.err_message, "unknown fn"));
}
fn test_compile_type_error_column_uses_rune_index() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 {\n\"ä½ \"; nope();\nreturn 0;\n}" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:6:"));
  t.assert(contains(r.err, "[E_TYPE_0001]"));
}
fn test_compile_duplicate_trait_reports_decl_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "trait A {}\ntrait A {}\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "duplicate trait"));
}
fn test_compile_type_error_message_includes_reason() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 {\nnope();\nreturn 0;\n}" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "unknown fn"));
  t.assert(contains(r.err, "nope"));
}
fn test_compile_generic_type_param_pack_infer_without_explicit_type_args_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn id[T...](x: T) -> T { return x; }\nfn main() -> i32 { return id(7); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
}
fn test_compile_generic_type_param_pack_type_args_must_precede_const_args_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn f[T..., const N: i32](x: T) -> T { return x; }\nfn main() -> i32 { return f[3, i32](7); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "generic arg order error: type args must come before const args"), r.err);
}
fn test_compile_generic_type_param_pack_extra_type_args_with_const_suffix_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn f[T..., const N: i32](x: T) -> T { return x; }\nfn main() -> i32 { return f[i32, i64, 3](7); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  let ok_msg: bool = contains(r.err, "return type mismatch") || contains(r.err, "typecheck failed");
  t.assert_with(ok_msg, r.err);
}
fn test_compile_generic_type_param_pack_same_type_args_with_const_suffix_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn f[T..., const N: i32](x: T) -> T { return x; }\nfn main() -> i32 { return f[i32, i32, 3](7); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
}
fn test_compile_generic_type_param_pack_unused_allows_heterogeneous_type_args_with_const_suffix_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn keep[T..., const N: i32]() -> i32 { return N; }\nfn main() -> i32 { return keep[i32, String, 7](); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
}
fn test_compile_generic_type_param_pack_heterogeneous_with_trait_bound_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Mark { fn mark(v: Self) -> i32; }
      impl Mark for i32 { fn mark(v: i32) -> i32 { return v; } }
      impl Mark for String { fn mark(v: String) -> i32 { return v.len(); } }
      fn keep[T..., const N: i32]() -> i32 where T: Mark { return N; }
      fn main() -> i32 { return keep[i32, String, 7](); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
}
fn test_compile_generic_type_param_pack_heterogeneous_with_trait_bound_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Mark { fn mark(v: Self) -> i32; }
      impl Mark for i32 { fn mark(v: i32) -> i32 { return v; } }
      fn keep[T..., const N: i32]() -> i32 where T: Mark { return N; }
      fn main() -> i32 { return keep[i32, i64, 7](); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "does not satisfy trait bound"), r.err);
}
fn test_compile_generic_type_param_pack_projection_bounds_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Mark { fn mark(v: Self) -> i32; }
      impl Mark for i32 { fn mark(v: i32) -> i32 { return v; } }
      impl Mark for i64 { fn mark(v: i64) -> i32 { return v as i32; } }
      fn keep[T..., const N: i32](a: T.0, b: T.1) -> i32
        where T.0: Mark, T.1: Mark, comptime @size_of(T.0) < @size_of(T.1) {
        return Mark.mark(a) + Mark.mark(b) + N;
      }
      fn main() -> i32 {
        let b: i64 = 5;
        return keep[i32, i64, 3](4, b);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
}
fn test_compile_generic_type_param_pack_projection_comptime_where_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Mark { fn mark(v: Self) -> i32; }
      impl Mark for i32 { fn mark(v: i32) -> i32 { return v; } }
      impl Mark for i64 { fn mark(v: i64) -> i32 { return v as i32; } }
      fn keep[T..., const N: i32](a: T.0, b: T.1) -> i32
        where T.0: Mark, T.1: Mark, comptime @size_of(T.0) < @size_of(T.1) {
        return Mark.mark(a) + Mark.mark(b) + N;
      }
      fn main() -> i32 {
        let a: i64 = 4;
        return keep[i64, i32, 3](a, 5);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "comptime generic constraint failed"), r.err);
}
