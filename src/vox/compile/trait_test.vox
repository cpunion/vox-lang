import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_trait_static_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl Show for I { fn show(x: I) -> String { return "ok"; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = Show.show(x); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Show$show$0")));
}
fn test_compile_impl_specialization_prefers_more_specific_impl_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T] Tag for Vec[T] { fn tag(x: Vec[T]) -> i32 { return 1; } }
      impl Tag for Vec[i32] { fn tag(x: Vec[i32]) -> i32 { return 2; } }
      fn main() -> i32 { let mut vi: Vec[i32] = Vec(); let mut vs: Vec[String] = Vec(); vi.push(7); vs.push("x"); return Tag.tag(vi) + Tag.tag(vs); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Tag$tag$1")));
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Tag$tag$0$gT_3dString")));
}
fn test_compile_impl_specialization_requires_strict_order_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T] Tag for Vec[T] { fn tag(x: Vec[T]) -> i32 { return 1; } }
      impl[U] Tag for Vec[U] { fn tag(x: Vec[U]) -> i32 { return 2; } }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); return Tag.tag(v); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "overlapping impl without strict specialization"));
}
fn test_compile_impl_specialization_prefers_stronger_bounds_and_filters_non_matching_bounds_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T] Tag for T { fn tag(x: T) -> i32 { return 1; } }
      impl[T: Eq] Tag for T { fn tag(x: T) -> i32 { return 2; } }
      fn main() -> i32 { return Tag.tag(7) + Tag.tag("x"); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_impl_specialization_incomparable_bounds_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { fn a(x: Self) -> i32; }
      trait B { fn b(x: Self) -> i32; }
      impl A for i32 { fn a(x: i32) -> i32 { return x; } }
      impl B for i32 { fn b(x: i32) -> i32 { return x; } }
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T: A] Tag for T { fn tag(x: T) -> i32 { return 1; } }
      impl[T: B] Tag for T { fn tag(x: T) -> i32 { return 2; } }
      fn main() -> i32 { return Tag.tag(1); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "overlapping impl without strict specialization"));
}
fn test_compile_impl_unconstrained_head_type_param_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      trait Tag { fn tag(x: Self) -> i32; }
      impl[T, U: Eq] Tag for T { fn tag(x: T) -> i32 { return 1; } }
      fn main() -> i32 { return Tag.tag(7); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl type param is unconstrained by impl target type: U"));
}
fn test_compile_trait_method_sugar_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl Show for I { fn show(x: I) -> String { return "ok"; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = x.show(); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_trait_method_sugar_mut_receiver_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Bump { fn bump(x: &mut Self) -> i32; }
      struct I { v: i32 }
      impl Bump for I { fn bump(x: &mut I) -> i32 { return x.v + 1; } }
      fn main() -> i32 { let mut x: I = I { v: 1 }; return x.bump(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_trait_method_sugar_mut_receiver_rejects_immutable_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Bump { fn bump(x: &mut Self) -> i32; }
      struct I { v: i32 }
      impl Bump for I { fn bump(x: &mut I) -> i32 { return x.v + 1; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return x.bump(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "is immutable"), r.err);
}
fn test_compile_trait_method_sugar_mut_receiver_rejects_non_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Bump { fn bump(x: &mut Self) -> i32; }
      struct I { v: i32 }
      impl Bump for I { fn bump(x: &mut I) -> i32 { return x.v + 1; } }
      fn main() -> i32 { return I { v: 1 }.bump(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "must be mutable place"), r.err);
}
fn test_compile_trait_method_sugar_ref_receiver_rejects_non_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Peek { fn peek(x: &Self) -> i32; }
      struct I { v: i32 }
      impl Peek for I { fn peek(x: &I) -> i32 { return x.v; } }
      fn main() -> i32 { return I { v: 1 }.peek(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "for & parameter must be place"), r.err);
}
fn test_compile_trait_default_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String { return "ok"; } }
      struct I { v: i32 }
      impl Show for I {}
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = x.show(); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_trait_default_method_external_trait_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/dep/dep.vox",
    text: """
      fn dep_tag() -> String { return "dep"; }
      pub trait Show { fn show(x: Self) -> String { return dep_tag(); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "dep" as d
      struct I { v: i32 }
      impl d.Show for I {}
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = x.show(); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$dep$Show$show")));
}
fn test_compile_trait_generic_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T; }
      struct I { v: i32 }
      impl Wrap for I { fn wrap[T: Eq](x: I, v: T) -> T { return v; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = Wrap.wrap[i32](x, 7); let b: i32 = I { v: 2 }.wrap[i32](9); return a + b; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_trait_const_generic_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = AddN.addn[3](x, 4); let b: i32 = I { v: 2 }.addn[5](6); return a + b; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$AddN$addn$0$gN_3d3_3ai32")));
  t.assert(contains(r.c, cg.c_fn_name("impl$main$AddN$addn$0$gN_3d5_3ai32")));
}
fn test_compile_trait_const_generic_method_default_const_arg_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32 = 3](x: Self, v: i32) -> i32; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 { return v + N; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = AddN.addn(x, 4); let b: i32 = I { v: 2 }.addn(6); return a + b; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$AddN$addn$0$gN_3d3_3ai32")));
}
fn test_compile_trait_const_generic_method_comptime_where_rhs_unknown_reports_method_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "\ntrait AddN {\n  fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N < M;\n}\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:3:3:"));
  t.assert(contains(r.err, "unknown const param in comptime where rhs"));
}
fn test_compile_trait_const_generic_method_comptime_where_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N > 0 { return v + N; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return AddN.addn[3](x, 4); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_trait_const_generic_method_comptime_where_impl_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32 where comptime N > 0; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N >= 0 { return v + N; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}
fn test_compile_trait_const_generic_method_comptime_where_rhs_param_impl_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddNM { fn addnm[const N: i32, const M: i32](x: Self, v: i32) -> i32 where comptime N < M; }
      struct I { v: i32 }
      impl AddNM for I { fn addnm[const N: i32, const M: i32](x: I, v: i32) -> i32 where comptime N <= M { return v + N; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}
fn test_compile_trait_const_generic_method_comptime_where_type_layout_impl_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Fit { fn fit[T](x: Self, v: T) -> i32 where comptime @size_of(T) <= 8; }
      struct I { v: i32 }
      impl Fit for I { fn fit[T](x: I, v: T) -> i32 where comptime @size_of(T) <= 16 { return 1; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "comptime where"));
}
fn test_compile_trait_const_generic_method_default_violates_comptime_where_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32 = 0](x: Self, v: i32) -> i32 where comptime N > 0; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32](x: I, v: i32) -> i32 where comptime N > 0 { return v + N; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "default violates comptime where"));
}
fn test_compile_trait_const_generic_method_comptime_where_rhs_reflect_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait FitRU {
        fn fit[T, U](x: Self, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U);
      }
      struct I { v: i32 }
      impl FitRU for I {
        fn fit[T, U](x: I, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U) { return 1; }
      }
      fn main() -> i32 { let x: I = I { v: 1 }; let y: i64 = 0; return FitRU.fit(x, 3, y); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_trait_const_generic_method_comptime_where_rhs_reflect_impl_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait FitRU {
        fn fit[T, U](x: Self, a: T, b: U) -> i32 where comptime @size_of(T) <= @align_of(U);
      }
      struct I { v: i32 }
      impl FitRU for I {
        fn fit[T, U](x: I, a: T, b: U) -> i32 where comptime @size_of(T) < @align_of(U) { return 1; }
      }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "@size_of(T) <= @align_of(U)"), r.err);
}
fn test_compile_trait_const_generic_method_impl_name_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32](x: Self, v: i32) -> i32; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const M: i32](x: I, v: i32) -> i32 { return v + M; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl method const param name mismatch"));
}
fn test_compile_trait_const_generic_method_default_mismatch_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait AddN { fn addn[const N: i32 = 3](x: Self, v: i32) -> i32; }
      struct I { v: i32 }
      impl AddN for I { fn addn[const N: i32 = 4](x: I, v: i32) -> i32 { return v + N; } }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "default mismatch"));
}
fn test_compile_trait_generic_method_impl_type_param_rename_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T; }
      struct I { v: i32 }
      impl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return Wrap.wrap[i32](x, 7); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_trait_generic_method_impl_type_param_rename_assoc_projection_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Pass { type Item; fn pass[T: Pass](x: Self, v: T.Item) -> T.Item; }
      struct I { v: i32 }
      impl Pass for I { type Item = i32; fn pass[U: Pass](x: I, v: U.Item) -> U.Item { return v; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return Pass.pass[I](x, 7); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_trait_generic_method_impl_type_param_rename_assoc_projection_nested_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Pass { type Item; fn dup[T: Pass](x: Self, v: T.Item) -> Vec[T.Item]; }
      struct I { v: i32 }
      impl Pass for I { type Item = i32; fn dup[U: Pass](x: I, v: U.Item) -> Vec[U.Item] { return Vec(); } }
      fn main() -> i32 { let x: I = I { v: 1 }; let ys: Vec[i32] = Pass.dup[I](x, 7); return ys.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_impl_method_bound_mismatch_reports_missing_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
      pub trait Show { fn show(x: Self) -> String; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Wrap { fn wrap[T: Eq + Show](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl method missing type bound"));
  t.assert(contains(r.err, "Show"));
}
fn test_compile_trait_generic_default_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T { return v; } }
      struct I { v: i32 }
      impl Wrap for I {}
      fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = Wrap.wrap[i32](x, 7); let b: i32 = I { v: 2 }.wrap[i32](9); return a + b; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_supertrait_forward_decl_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait B: A { fn b(x: Self) -> i32; }
      trait A { fn a(x: Self) -> i32; }
      struct I { v: i32 }
      impl A for I { fn a(x: I) -> i32 { return 1; } }
      impl B for I { fn b(x: I) -> i32 { return 2; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return B.b(x) + A.a(x); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_supertrait_impl_requires_parent_impl() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait A { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl B for I { fn b(x: I) -> i32 { return 2; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "requires supertrait A"));
}
fn test_compile_supertrait_cycle_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait A: B { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "supertrait cycle"));
}
fn test_compile_supertrait_cycle_reports_decl_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "\ntrait A: B { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "supertrait cycle"));
}
fn test_compile_supertrait_impl_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { fn a(x: Self) -> i32; }
      trait B: A { fn b(x: Self) -> i32; }
      struct I { v: i32 }
      impl A for I { fn a(x: I) -> i32 { return 1; } }
      impl B for I { fn b(x: I) -> i32 { return 2; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return B.b(x) + A.a(x); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_trait_assoc_type_impl_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Iter { type Item; fn next(x: Self) -> i32; }
      struct I { v: i32 }
      impl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return Iter.next(x); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_trait_assoc_type_projection_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Iter { type Item; fn next(x: Self) -> Self.Item; }
      struct I { v: i32 }
      impl Iter for I { type Item = i32; fn next(x: I) -> Self.Item { return x.v; } }
      fn id[T: Iter](x: T) -> T.Item { return x.next(); }
      fn main() -> i32 { let x: I = I { v: 1 }; let y: i32 = id[I](x); return y; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_trait_assoc_type_projection_infer_local_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Iter { type Item; fn next(x: Self) -> Self.Item; }
      struct I { v: i32 }
      impl Iter for I { type Item = i32; fn next(x: I) -> Self.Item { return x.v; } }
      fn id[T: Iter](x: T) -> T.Item { return x.next(); }
      fn main() -> i32 { let x: I = I { v: 1 }; let y = id[I](x); return y; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_trait_assoc_type_unknown_in_method_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; fn next(x: Self) -> Self.Missing; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "unknown associated type in trait method"));
  t.assert(contains(r.err, "Missing"));
}
fn test_compile_trait_assoc_type_projection_unknown_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait A { fn a(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl A for I { fn a(x: I) -> i32 { return x.v; } }\nfn bad[T: A](x: T) -> T.Item { return 0; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "unknown associated type projection"));
  t.assert(contains(r.err, "T.Item"));
}
fn test_compile_trait_assoc_type_projection_ambiguous_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { type Item; fn a(x: Self) -> i32; }
      trait B { type Item; fn b(x: Self) -> i32; }
      struct I { v: i32 }
      impl A for I { type Item = i32; fn a(x: I) -> i32 { return x.v; } }
      impl B for I { type Item = i32; fn b(x: I) -> i32 { return x.v; } }
      fn bad[T: A + B](x: T) -> T.Item { return x.a(); }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "ambiguous associated type projection"));
  t.assert(contains(r.err, "T.Item"));
}
fn test_compile_trait_assoc_type_impl_missing_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl missing associated type"));
  t.assert(contains(r.err, "Item"));
}
fn test_compile_trait_assoc_type_impl_extra_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl associated type not in trait"));
  t.assert(contains(r.err, "Item"));
}
fn test_compile_trait_assoc_type_duplicate_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "duplicate trait associated type"));
  t.assert(contains(r.err, "Item"));
}
fn test_compile_trait_assoc_type_duplicate_reports_assoc_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter {\n  type Item;\n  type Item;\n  fn next(x: Self) -> i32;\n}\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:3:3:"));
  t.assert(contains(r.err, "duplicate trait associated type"));
}
fn test_compile_impl_assoc_type_duplicate_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; type Item = i64; fn next(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "duplicate impl associated type"));
  t.assert(contains(r.err, "Item"));
}
fn test_compile_impl_assoc_type_duplicate_reports_assoc_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; fn next(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I {\n  type Item = i32;\n  type Item = i64;\n  fn next(x: I) -> i32 { return x.v; }\n}\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:5:3:"));
  t.assert(contains(r.err, "duplicate impl associated type"));
}
fn test_compile_trait_method_name_conflicts_assoc_type_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Iter { type Item; fn Item(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl Iter for I { type Item = i32; fn Item(x: I) -> i32 { return x.v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "trait method conflicts with associated type"));
  t.assert(contains(r.err, "Item"));
}
fn test_compile_trait_method_sugar_ambiguous_rejected_with_candidates() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { fn show(x: Self) -> String; }
      trait B { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl A for I { fn show(x: I) -> String { return "a"; } }
      impl B for I { fn show(x: I) -> String { return "b"; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let _s: String = x.show(); return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "ambiguous trait method call"));
  t.assert(contains(r.err, "A.show"));
  t.assert(contains(r.err, "B.show"));
}
fn test_compile_trait_call_unknown_method_rejected_with_candidates() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; fn debug(x: Self) -> String; }
      struct I { v: i32 }
      impl Show for I { fn show(x: I) -> String { return "ok"; } fn debug(x: I) -> String { return "dbg"; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let _s: String = Show.missing(x); return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "unknown trait method"));
  t.assert(contains(r.err, "available methods"));
  t.assert(contains(r.err, "show"));
  t.assert(contains(r.err, "debug"));
}
fn test_compile_impl_missing_required_method_reports_candidates() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Show { fn show(x: Self) -> String; fn debug(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I { fn show(x: I) -> String { return \"ok\"; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl missing trait method"));
  t.assert(contains(r.err, "required methods"));
  t.assert(contains(r.err, "show"));
  t.assert(contains(r.err, "debug"));
}
fn test_compile_impl_extra_method_reports_candidates() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Show { fn show(x: Self) -> String; }\nstruct I { v: i32 }\nimpl Show for I { fn show(x: I) -> String { return \"ok\"; } fn debug(x: I) -> String { return \"dbg\"; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl method not in trait"));
  t.assert(contains(r.err, "available methods"));
  t.assert(contains(r.err, "show"));
}
fn test_compile_prelude_trait_fallback_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
      pub trait Show { fn show(x: Self) -> String; }
      impl Eq for String { fn eq(a: String, b: String) -> bool { return a == b; } }
      impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 {\n  let s: String = Show.show(7);\n  if Eq.eq(s, \"7\") { return 1; }\n  return 0;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_prelude_trait_default_method_fallback_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "fn tag() -> String { return \"pre\"; }\npub trait Show { fn show(x: Self) -> String { return tag(); } }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct I { v: i32 }\nimpl Show for I {}\nfn main() -> i32 { let s: String = I { v: 1 }.show(); return s.len(); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("std.prelude::tag")));
}
fn test_compile_inherent_impl_method_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct I { v: i32 }
      impl I { fn inc(x: I) -> i32 { return x.v + 1; } }
      fn main() -> i32 { return I { v: 1 }.inc(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_inherent_impl_method_mut_receiver_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct I { v: i32 }
      impl I { fn inc(x: &mut I) -> i32 { return x.v + 1; } }
      fn main() -> i32 { let mut x: I = I { v: 1 }; return x.inc(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_inherent_impl_method_mut_receiver_rejects_immutable_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct I { v: i32 }
      impl I { fn inc(x: &mut I) -> i32 { return x.v + 1; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return x.inc(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "is immutable"), r.err);
}
fn test_compile_inherent_impl_method_mut_receiver_rejects_non_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct I { v: i32 }
      impl I { fn inc(x: &mut I) -> i32 { return x.v + 1; } }
      fn main() -> i32 { return I { v: 1 }.inc(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "must be mutable place"), r.err);
}
