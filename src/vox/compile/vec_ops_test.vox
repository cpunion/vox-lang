import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_vec_is_empty_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        if v.is_empty() { v.push(9); }
        return if !v.is_empty() && v.len() == 1 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, ".len;"));
}

fn test_compile_vec_clear_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        v.push(1);
        v.push(2);
        v.clear();
        return if v.len() == 0 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_v->len = 0;"));
}

fn test_compile_vec_extend_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut a: Vec[i32] = Vec();
        a.push(1);
        let mut b: Vec[i32] = Vec();
        b.push(2);
        b.push(3);
        a.extend(b);
        return if a.len() == 3 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vec extend elem_size mismatch"));
}

fn test_compile_vec_insert_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        v.push(1);
        v.insert(0, 9);
        return v.get(0) + v.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vec insert index out of bounds"));
}

fn test_compile_vec_pop_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        v.push(1);
        v.push(2);
        return v.pop() + v.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vec pop on empty vector"));
}

fn test_compile_vec_remove_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        v.push(1);
        v.push(2);
        return v.remove(0) + v.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vec remove index out of bounds"));
}

fn test_compile_vec_join_uses_prelude_impl() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/string.vox",
    text: """
      impl String {
        fn len(s: String) -> i32 { return 0; }
        fn concat(s: String, other: String) -> String { return ""; }
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/std/prelude/vec.vox",
    text: """
      impl Vec[String] {
        fn join(v: Vec[String], sep: String) -> String {
          let mut out: String = "";
          let mut i: i32 = 0;
          while i < v.len() {
            if i != 0 {
              out = out.concat(sep);
            }
            out = out.concat(v.get(i));
            i = i + 1;
          }
          return out;
        }
      }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> String {
        let mut v: Vec[String] = Vec();
        v.push("a");
        v.push("b");
        return v.join(",");
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(!contains(r.c, "vec_str_join"));
}
