import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_supertrait_forward_decl_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait B: A { fn b(x: Self) -> i32; }
      trait A { fn a(x: Self) -> i32; }
      struct I { v: i32 }
      impl A for I { fn a(x: I) -> i32 { return 1; } }
      impl B for I { fn b(x: I) -> i32 { return 2; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return B.b(x) + A.a(x); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(r.ok);
}

fn test_compile_supertrait_impl_requires_parent_impl() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait A { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nimpl B for I { fn b(x: I) -> i32 { return 2; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "requires supertrait A"));
}

fn test_compile_supertrait_cycle_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait A: B { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nstruct I { v: i32 }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "supertrait cycle"));
}

fn test_compile_supertrait_cycle_reports_decl_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "\ntrait A: B { fn a(x: Self) -> i32; }\ntrait B: A { fn b(x: Self) -> i32; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "supertrait cycle"));
}

fn test_compile_supertrait_impl_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { fn a(x: Self) -> i32; }
      trait B: A { fn b(x: Self) -> i32; }
      struct I { v: i32 }
      impl A for I { fn a(x: I) -> i32 { return 1; } }
      impl B for I { fn b(x: I) -> i32 { return 2; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return B.b(x) + A.a(x); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(r.ok);
}
