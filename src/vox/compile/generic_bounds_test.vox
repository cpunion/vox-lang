import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg


fn test_compile_generic_impl_trait_static_call_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      impl[T] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(7); let s: String = Show.show(v); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Show$show$0$gT_3di32")));
}
fn test_compile_generic_impl_trait_method_sugar_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      impl[T] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(7); let s: String = v.show(); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("impl$main$Show$show$0$gT_3di32")));
}
fn test_compile_generic_impl_bound_rejected_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Mark { fn mark(x: Self) -> bool; }
      trait Show { fn show(x: Self) -> String; }
      impl[T: Mark] Show for Vec[T] { fn show(x: Vec[T]) -> String { return x.len().to_string(); } }
      fn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(7); let s: String = Show.show(v); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  let bound_msg: bool = contains(r.err, "does not satisfy trait bound");
  let no_impl_msg: bool = contains(r.err, "no impl for trait call");
  t.assert(bound_msg || no_impl_msg);
  if bound_msg {
    t.assert(contains(r.err, "Mark"));
  } else {
    t.assert(contains(r.err, "Show"));
  }
}
fn test_compile_generic_trait_bound_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      fn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }
      fn main() -> i32 { return if same("a", "b") { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_generic_where_trait_bound_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      fn same[T](a: T, b: T) -> bool where T: Eq { return Eq.eq(a, b); }
      fn main() -> i32 { return if same("a", "b") { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_generic_struct_comptime_where_type_layout_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Small[T] where comptime @size_of(T) <= 8, comptime @align_of(T) <= 8 { v: T }\nfn main() -> i32 { let s: Small[i32] = Small[i32] { v: 7 }; return s.v; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_generic_struct_comptime_where_type_layout_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Big { a: i64, b: i64 }\nstruct Small[T] where comptime @size_of(T) <= 8 { v: T }\nfn main() -> i32 { let b: Big = Big { a: 1, b: 2 }; let s: Small[Big] = Small[Big] { v: b }; return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "type resolve failed in let annotation"), r.err);
}
fn test_compile_generic_enum_comptime_where_type_layout_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "enum Tiny[T] where comptime @size_of(T) <= 8 { V(T) }\nfn main() -> i32 { let x: Tiny[i32] = Tiny[i32].V(7); return match x { Tiny.V(v) => v }; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_generic_enum_comptime_where_type_layout_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Big { a: i64, b: i64 }\nenum Tiny[T] where comptime @size_of(T) <= 8 { V(T) }\nfn main() -> i32 { let b: Big = Big { a: 1, b: 2 }; let x: Tiny[Big] = Tiny[Big].V(b); return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "type resolve failed in let annotation"), r.err);
}
fn test_compile_generic_fn_body_checked_without_instantiation() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn bad[T](x: T) -> T { let y: i32 = x; return x; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_generic_impl_method_body_checked_without_instantiation() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Boxed { fn id[T](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Boxed for I { fn id[T](x: I, v: T) -> T { let y: i32 = v; return v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_generic_default_method_body_checked_without_instantiation() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Boxed { fn id[T](x: Self, v: T) -> T { let y: i32 = v; return v; } }\nstruct I { v: i32 }\nimpl Boxed for I {}\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_generic_bound_trait_static_call_in_body_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn same[T: Eq](a: T, b: T) -> bool { return Eq.eq(a, b); }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_generic_bound_trait_method_sugar_in_body_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
      fn f[T: Show](x: T) -> String { return x.show(); }
      fn main() -> i32 { let s: String = f(7); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_generic_bound_trait_method_sugar_generic_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      trait Wrap { fn wrap[U: Eq](x: Self, v: U) -> U; }
      struct I { v: i32 }
      impl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }
      fn f[T: Wrap](x: T) -> i32 { return x.wrap[i32](7); }
      fn main() -> i32 { let x: I = I { v: 1 }; return f(x); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_generic_bound_trait_method_sugar_supertrait_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      trait Wrap: Show { fn id(x: Self) -> Self; }
      struct I { v: i32 }
      impl Show for I { fn show(x: I) -> String { return "ok"; } }
      impl Wrap for I { fn id(x: I) -> I { return x; } }
      fn f[T: Wrap](x: T) -> String { return x.show(); }
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = f(x); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_generic_bound_trait_method_sugar_missing_bound_method_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }\nfn f[T: Eq](x: T) -> String { return x.show(); }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "trait method not in bounds"));
  t.assert(contains(r.err, "Eq"));
}
fn test_compile_generic_bound_trait_method_sugar_ambiguous_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait A { fn show(x: Self) -> String; }
      trait B { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl A for I { fn show(x: I) -> String { return "a"; } }
      impl B for I { fn show(x: I) -> String { return "b"; } }
      fn f[T: A + B](x: T) -> String { return x.show(); }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "ambiguous trait method call"));
  t.assert(contains(r.err, "A.show"));
  t.assert(contains(r.err, "B.show"));
}
