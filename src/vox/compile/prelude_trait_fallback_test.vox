import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_prelude_trait_fallback_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
      pub trait Show { fn show(x: Self) -> String; }
      impl Eq for String { fn eq(a: String, b: String) -> bool { return a == b; } }
      impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 {\n  let s: String = Show.show(7);\n  if Eq.eq(s, \"7\") { return 1; }\n  return 0;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}

fn test_compile_prelude_trait_default_method_fallback_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "fn tag() -> String { return \"pre\"; }\npub trait Show { fn show(x: Self) -> String { return tag(); } }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct I { v: i32 }\nimpl Show for I {}\nfn main() -> i32 { let s: String = I { v: 1 }.show(); return s.len(); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("std.prelude::tag")));
}
