import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_string_to_string_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let s: String = \"vox\"; let t2: String = s.to_string(); return t2.len(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_string_predicate_methods_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let s: String = "vox-lang";
        if s.starts_with("vox") && s.ends_with("lang") && s.contains("-") { return 1; }
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_str_starts_with("));
  t.assert(contains(r.c, "vox_str_ends_with("));
  t.assert(contains(r.c, "vox_str_contains("));
}
fn test_compile_string_index_methods_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let s: String = "vox-lang-vox";
        let i0: i32 = s.index_of("vox");
        let i1: i32 = s.last_index_of("vox");
        let i2: i32 = s.index_of("zzz");
        return i0 + i1 + i2;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_str_index_of("));
  t.assert(contains(r.c, "vox_str_last_index_of("));
}
fn test_compile_string_is_empty_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let s0: String = "";
        let s1: String = "vox";
        return if s0.is_empty() && !s1.is_empty() { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_str_len("));
}
fn test_compile_string_ordered_compare_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { if \"ab\" < \"ac\" { return 1; } return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "strcmp("));
}

fn test_compile_string_concat_deep_chain_smoke() -> () {
  let mut expr: String = "\"x\"";
  let mut i: i32 = 0;
  while i < 24 {
    expr = expr.concat(".concat(\"x\")");
    i = i + 1;
  }
  let src: String =
    "fn main() -> i32 {\n"
      .concat("  let s: String = ").concat(expr).concat(";\n")
      .concat("  return s.len();\n")
      .concat("}");

  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: src });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
