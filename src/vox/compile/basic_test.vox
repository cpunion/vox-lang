import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_main_text_to_c_smoke() -> () {
  let r: c.CompileResult = c.compile_main_text_to_c(
    "fn main() -> i32 { print(\"x\"); return 0; }",
    cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" },
  );
  t.assert(r.ok);
}

fn test_compile_files_to_c_smoke_multi_module() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/a.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"a\" as a\nfn main() -> i32 { return a.one(); }" });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(r.ok);
  // Expect both main and imported module symbol to appear.
  t.assert(contains(r.c, "vox_fn_mmain"));
  t.assert(contains(r.c, "vox_fn_ma_3a_3aone"));
}
