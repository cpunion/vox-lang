import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_vec_is_empty_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        if v.is_empty() { v.push(9); }
        return if !v.is_empty() && v.len() == 1 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_len("));
}
fn test_compile_vec_clear_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        v.push(1);
        v.push(2);
        v.clear();
        return if v.len() == 0 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_clear("));
}
fn test_compile_vec_extend_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut a: Vec[i32] = Vec();
        a.push(1);
        let mut b: Vec[i32] = Vec();
        b.push(2);
        b.push(3);
        a.extend(b);
        return if a.len() == 3 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_extend("));
}
fn test_compile_vec_insert_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        v.push(1);
        v.insert(0, 9);
        return v.get(0) + v.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_insert("));
}
fn test_compile_vec_pop_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        v.push(1);
        v.push(2);
        return v.pop() + v.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_pop("));
}
fn test_compile_vec_remove_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let mut v: Vec[i32] = Vec();
        v.push(1);
        v.push(2);
        return v.remove(0) + v.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_remove("));
}
fn test_compile_nested_field_assign_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "struct I { x: i32 }\nstruct O { i: I }\nfn main() -> i32 { let mut o: O = O { i: I { x: 1 } }; o.i.x = 2; o.i.x += 3; return o.i.x; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_vec_nested_field_push_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        o.inner.items.push(40);
        o.inner.items.push(2);
        return o.inner.items.get(0) + o.inner.items.get(1) + o.inner.items.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_vec_nested_field_clear_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        o.inner.items.push(40);
        o.inner.items.clear();
        return if o.inner.items.len() == 0 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_clear("));
}
fn test_compile_vec_nested_field_extend_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        let mut extra: Vec[i32] = Vec();
        extra.push(40);
        extra.push(2);
        o.inner.items.extend(extra);
        return if o.inner.items.len() == 2 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_extend("));
}
fn test_compile_vec_nested_field_insert_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        o.inner.items.push(40);
        o.inner.items.insert(0, 2);
        return o.inner.items.get(0);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_insert("));
}
fn test_compile_vec_nested_field_set_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        o.inner.items.push(40);
        o.inner.items.set(0, 2);
        return o.inner.items.get(0);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_set("));
}
fn test_compile_vec_nested_field_pop_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        o.inner.items.push(40);
        o.inner.items.push(2);
        return o.inner.items.pop();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_pop("));
}
fn test_compile_vec_nested_field_remove_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Inner { items: Vec[i32] }
      struct Outer { inner: Inner }
      fn main() -> i32 {
        let mut o: Outer = Outer { inner: Inner { items: Vec() } };
        o.inner.items.push(40);
        o.inner.items.push(2);
        return o.inner.items.remove(0);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "vox_vec_remove("));
}
fn test_compile_vec_push_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        v.push(1);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.push receiver is immutable"));
}
fn test_compile_vec_insert_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        v.insert(0, 1);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.insert receiver is immutable"));
}
fn test_compile_vec_set_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        v.set(0, 1);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.set receiver is immutable"));
}
fn test_compile_vec_extend_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        let w2: Vec[i32] = Vec();
        v.extend(w2);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.extend receiver is immutable"));
}
fn test_compile_vec_clear_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        v.clear();
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.clear receiver is immutable"));
}
fn test_compile_vec_pop_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        return v.pop();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.pop receiver is immutable"));
}
fn test_compile_vec_remove_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        return v.remove(0);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.remove receiver is immutable"));
}
fn test_compile_nested_field_compound_assign_all_ops_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct I { x: i32 }
      struct O { i: I }
      fn main() -> i32 {
        let mut o: O = O { i: I { x: 255 } };
        o.i.x += 1;
        o.i.x -= 2;
        o.i.x *= 3;
        o.i.x /= 4;
        o.i.x %= 5;
        o.i.x &= 6;
        o.i.x |= 7;
        o.i.x ^= 8;
        o.i.x <<= 1;
        o.i.x >>= 2;
        return o.i.x;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
