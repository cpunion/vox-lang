import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_question_propagation_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Result[T, E] { Ok(T), Err(E) }
      fn get(flag: bool) -> Result[i32, String] { if flag { return .Ok(7); } return .Err("bad"); }
      fn run(flag: bool) -> Result[i32, String] { let v: i32 = get(flag)?; return .Ok(v + 1); }
      fn main() -> i32 { let r: Result[i32, String] = run(true); return match r { .Ok(v) => v, .Err(_e) => 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_try_block_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Result[T, E] { Ok(T), Err(E) }
      fn get() -> Result[i32, String] { return .Ok(2); }
      fn run() -> Result[i32, String] { let r: Result[i32, String] = try { let v: i32 = get()?; v * 3 }; return r; }
      fn main() -> i32 { let r: Result[i32, String] = run(); return match r { .Ok(v) => v, .Err(_e) => 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_option_question_propagation_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Option[T] { Some(T), None }
      fn get(flag: bool) -> Option[i32] { if flag { return .Some(5); } return .None; }
      fn run(flag: bool) -> Option[i32] { let v: i32 = get(flag)?; return .Some(v + 1); }
      fn main() -> i32 { let r: Option[i32] = run(true); return match r { .Some(v) => v, .None => 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_question_result_err_into_conversion_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Into { type Target; fn into(x: Self) -> Self.Target; }\nimpl Into for i32 { type Target = String; fn into(x: i32) -> String { return x.to_string(); } }",
  });
  fs.push(ld.SourceFile { path: "src/std/prelude/string.vox", text: "impl String { fn len(s: String) -> i32 { return 0; } fn is_empty(s: String) -> bool { return true; } fn byte_at(s: String, idx: i32) -> i32 { return 0; } fn slice(s: String, start: i32, end: i32) -> String { return \"\"; } fn concat(s: String, other: String) -> String { return \"\"; } fn starts_with(s: String, pre: String) -> bool { return false; } fn ends_with(s: String, suf: String) -> bool { return false; } fn contains(s: String, needle: String) -> bool { return false; } fn index_of(s: String, needle: String) -> i32 { return 0; } fn last_index_of(s: String, needle: String) -> i32 { return 0; } fn escape_c(s: String) -> String { return \"\"; } fn to_string(s: String) -> String { return s; } }\nimpl bool { fn to_string(v: bool) -> String { return \"\"; } }\nimpl i8 { fn to_string(v: i8) -> String { return \"\"; } }\nimpl u8 { fn to_string(v: u8) -> String { return \"\"; } }\nimpl i16 { fn to_string(v: i16) -> String { return \"\"; } }\nimpl u16 { fn to_string(v: u16) -> String { return \"\"; } }\nimpl i32 { fn to_string(v: i32) -> String { return \"\"; } }\nimpl u32 { fn to_string(v: u32) -> String { return \"\"; } }\nimpl i64 { fn to_string(v: i64) -> String { return \"\"; } }\nimpl u64 { fn to_string(v: u64) -> String { return \"\"; } }\nimpl isize { fn to_string(v: isize) -> String { return \"\"; } }\nimpl usize { fn to_string(v: usize) -> String { return \"\"; } }\nimpl f32 { fn to_string(v: f32) -> String { return \"\"; } }\nimpl f64 { fn to_string(v: f64) -> String { return \"\"; } }" });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Result[T, E] { Ok(T), Err(E) }
      fn get() -> Result[i32, i32] { return .Err(7); }
      fn run() -> Result[i32, String] { let _v: i32 = get()?; return .Ok(1); }
      fn main() -> i32 { let r: Result[i32, String] = run(); return match r { .Ok(v) => v, .Err(_e) => 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_question_result_err_generic_into_conversion_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Into { type Target; fn into[T](x: Self) -> Self.Target; }\nimpl Into for i32 { type Target = String; fn into[T](x: i32) -> String { return x.to_string(); } }",
  });
  fs.push(ld.SourceFile { path: "src/std/prelude/string.vox", text: "impl String { fn len(s: String) -> i32 { return 0; } fn is_empty(s: String) -> bool { return true; } fn byte_at(s: String, idx: i32) -> i32 { return 0; } fn slice(s: String, start: i32, end: i32) -> String { return \"\"; } fn concat(s: String, other: String) -> String { return \"\"; } fn starts_with(s: String, pre: String) -> bool { return false; } fn ends_with(s: String, suf: String) -> bool { return false; } fn contains(s: String, needle: String) -> bool { return false; } fn index_of(s: String, needle: String) -> i32 { return 0; } fn last_index_of(s: String, needle: String) -> i32 { return 0; } fn escape_c(s: String) -> String { return \"\"; } fn to_string(s: String) -> String { return s; } }\nimpl bool { fn to_string(v: bool) -> String { return \"\"; } }\nimpl i8 { fn to_string(v: i8) -> String { return \"\"; } }\nimpl u8 { fn to_string(v: u8) -> String { return \"\"; } }\nimpl i16 { fn to_string(v: i16) -> String { return \"\"; } }\nimpl u16 { fn to_string(v: u16) -> String { return \"\"; } }\nimpl i32 { fn to_string(v: i32) -> String { return \"\"; } }\nimpl u32 { fn to_string(v: u32) -> String { return \"\"; } }\nimpl i64 { fn to_string(v: i64) -> String { return \"\"; } }\nimpl u64 { fn to_string(v: u64) -> String { return \"\"; } }\nimpl isize { fn to_string(v: isize) -> String { return \"\"; } }\nimpl usize { fn to_string(v: usize) -> String { return \"\"; } }\nimpl f32 { fn to_string(v: f32) -> String { return \"\"; } }\nimpl f64 { fn to_string(v: f64) -> String { return \"\"; } }" });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum Result[T, E] { Ok(T), Err(E) }
      fn get() -> Result[i32, i32] { return .Err(7); }
      fn run() -> Result[i32, String] { let _v: i32 = get()?; return .Ok(1); }
      fn main() -> i32 { let r: Result[i32, String] = run(); return match r { .Ok(v) => v, .Err(_e) => 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
