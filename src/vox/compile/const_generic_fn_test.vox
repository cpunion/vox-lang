import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_const_generic_fn_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn[3](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  // C backend mangles IR symbols: '$' -> '_24', '_' -> '_5f'.
  t.assert(contains(r.c, "addn_24gN_5f3d3_5f3ai32"));
}

fn test_compile_const_generic_fn_forwards_const_param_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn wrap[const N: i32](x: i32) -> i32 { return addn[N](x); }\nfn main() -> i32 { return wrap[3](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "wrap_24gN_5f3d3_5f3ai32"));
  t.assert(contains(r.c, "addn_24gN_5f3d3_5f3ai32"));
}

fn test_compile_const_generic_fn_forwards_const_param_with_comptime_where_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0 { return x + N; }\nfn wrap[const N: i32](x: i32) -> i32 { return addn[N](x); }\nfn main() -> i32 { return wrap[3](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_forwards_const_param_with_comptime_where_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0 { return x + N; }\nfn wrap[const N: i32](x: i32) -> i32 { return addn[N](x); }\nfn main() -> i32 { return wrap[0](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "constraint failed"));
}

fn test_compile_const_generic_fn_comptime_where_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0, comptime N <= 8 { return x + N; }\nfn main() -> i32 { return addn[3](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 where comptime N > 0, comptime N <= 8 { return x + N; }\nfn main() -> i32 { return addn[0](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "constraint failed"));
}

fn test_compile_const_generic_fn_comptime_where_rhs_param_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addnm[const N: i32, const M: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return addnm[3, 5](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_rhs_param_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addnm[const N: i32, const M: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return addnm[5, 3](4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "constraint failed"));
}

fn test_compile_const_generic_fn_comptime_where_rhs_unknown_reports_decl_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "\n\nfn addnm[const N: i32](x: i32) -> i32 where comptime N < M { return x + N; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:3:1:"));
  t.assert(contains(r.err, "unknown const param in comptime where rhs"));
}

fn test_compile_const_generic_fn_comptime_where_type_layout_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn fit[T](x: T) -> i32 where comptime @size_of(T) <= 8, comptime @align_of(T) <= 8 { return 7; }\nfn main() -> i32 { return fit(3); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_type_layout_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Big { a: i64, b: i64 }\nfn fit[T](x: T) -> i32 where comptime @size_of(T) <= 8 { return 7; }\nfn main() -> i32 { return fit(Big { a: 1, b: 2 }); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "@size_of(T) <= 8"));
}

fn test_compile_const_generic_fn_comptime_where_type_layout_rhs_param_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn fit[T, const LIM: i32](x: T) -> i32 where comptime @size_of(T) <= LIM { return 7; }\nfn main() -> i32 { return fit[8](3); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_field_count_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Pair { a: i32, b: i32 }\nfn fit[T](x: T) -> i32 where comptime @field_count(T) <= 2 { return 7; }\nfn main() -> i32 { let p: Pair = Pair { a: 1, b: 2 }; return fit(p); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_field_count_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "struct Triple { a: i32, b: i32, c: i32 }\nfn fit[T](x: T) -> i32 where comptime @field_count(T) <= 2 { return 7; }\nfn main() -> i32 { let t0: Triple = Triple { a: 1, b: 2, c: 3 }; return fit(t0); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "@field_count(T) <= 2"));
}

fn test_compile_const_generic_fn_comptime_where_type_id_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn fit[T](x: T) -> i32 where comptime @type(T) > 0 { return 7; }\nfn main() -> i32 { return fit(3); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_type_id_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn fit[T](x: T) -> i32 where comptime @type(T) < 0 { return 7; }\nfn main() -> i32 { return fit(3); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "@type(T) < 0"));
}

fn test_compile_const_generic_fn_comptime_where_rhs_reflect_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn fit[T, U](x: T, y: U) -> i32 where comptime @size_of(T) <= @align_of(U) { return 7; }\nfn main() -> i32 { let y: i64 = 0; return fit(3, y); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_generic_fn_comptime_where_rhs_reflect_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn fit[T, U](x: T, y: U) -> i32 where comptime @size_of(T) <= @align_of(U) { return 7; }\nfn main() -> i32 { let y: u8 = 0; let x: i64 = 1; return fit(x, y); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "@size_of(T) <= @align_of(U)"));
}

fn test_compile_const_generic_fn_default_violates_comptime_where_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32 = 0](x: i32) -> i32 where comptime N > 0 { return x + N; }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert(contains(r.err, "default violates comptime where"));
}

fn test_compile_const_generic_fn_default_const_arg_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn(4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "addn_24gN_5f3d3_5f3ai32"));
}

fn test_compile_const_generic_fn_default_const_arg_override_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32 = 3](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { let a: i32 = addn(4); let b: i32 = addn[9](4); return a + b; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "addn_24gN_5f3d3_5f3ai32"));
  t.assert(contains(r.c, "addn_24gN_5f3d9_5f3ai32"));
}

fn test_compile_const_generic_fn_missing_const_arg_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn addn[const N: i32](x: i32) -> i32 { return x + N; }\nfn main() -> i32 { return addn(4); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
}
