import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_trait_generic_method_impl_type_param_rename_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
    """,
  });
  fs.push(ld.SourceFile { path: "src/std/prelude/string.vox", text: "impl String { fn len(s: String) -> i32 { return 0; } fn is_empty(s: String) -> bool { return true; } fn byte_at(s: String, idx: i32) -> i32 { return 0; } fn slice(s: String, start: i32, end: i32) -> String { return \"\"; } fn concat(s: String, other: String) -> String { return \"\"; } fn starts_with(s: String, pre: String) -> bool { return false; } fn ends_with(s: String, suf: String) -> bool { return false; } fn contains(s: String, needle: String) -> bool { return false; } fn index_of(s: String, needle: String) -> i32 { return 0; } fn last_index_of(s: String, needle: String) -> i32 { return 0; } fn escape_c(s: String) -> String { return \"\"; } fn to_string(s: String) -> String { return s; } }\nimpl bool { fn to_string(v: bool) -> String { return \"\"; } }\nimpl i8 { fn to_string(v: i8) -> String { return \"\"; } }\nimpl u8 { fn to_string(v: u8) -> String { return \"\"; } }\nimpl i16 { fn to_string(v: i16) -> String { return \"\"; } }\nimpl u16 { fn to_string(v: u16) -> String { return \"\"; } }\nimpl i32 { fn to_string(v: i32) -> String { return \"\"; } }\nimpl u32 { fn to_string(v: u32) -> String { return \"\"; } }\nimpl i64 { fn to_string(v: i64) -> String { return \"\"; } }\nimpl u64 { fn to_string(v: u64) -> String { return \"\"; } }\nimpl isize { fn to_string(v: isize) -> String { return \"\"; } }\nimpl usize { fn to_string(v: usize) -> String { return \"\"; } }\nimpl f32 { fn to_string(v: f32) -> String { return \"\"; } }\nimpl f64 { fn to_string(v: f64) -> String { return \"\"; } }" });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T; }
      struct I { v: i32 }
      impl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return Wrap.wrap[i32](x, 7); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_trait_generic_method_impl_type_param_rename_assoc_projection_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Pass { type Item; fn pass[T: Pass](x: Self, v: T.Item) -> T.Item; }
      struct I { v: i32 }
      impl Pass for I { type Item = i32; fn pass[U: Pass](x: I, v: U.Item) -> U.Item { return v; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return Pass.pass[I](x, 7); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_trait_generic_method_impl_type_param_rename_assoc_projection_nested_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Pass { type Item; fn dup[T: Pass](x: Self, v: T.Item) -> Vec[T.Item]; }
      struct I { v: i32 }
      impl Pass for I { type Item = i32; fn dup[U: Pass](x: I, v: U.Item) -> Vec[U.Item] { return Vec(); } }
      fn main() -> i32 { let x: I = I { v: 1 }; let ys: Vec[i32] = Pass.dup[I](x, 7); return ys.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_impl_method_bound_mismatch_reports_missing_bound() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: """
      pub trait Eq { fn eq(a: Self, b: Self) -> bool; }
      pub trait Show { fn show(x: Self) -> String; }
      impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
      impl Show for i32 { fn show(x: i32) -> String { return x.to_string(); } }
    """,
  });
  fs.push(ld.SourceFile { path: "src/std/prelude/string.vox", text: "impl String { fn len(s: String) -> i32 { return 0; } fn is_empty(s: String) -> bool { return true; } fn byte_at(s: String, idx: i32) -> i32 { return 0; } fn slice(s: String, start: i32, end: i32) -> String { return \"\"; } fn concat(s: String, other: String) -> String { return \"\"; } fn starts_with(s: String, pre: String) -> bool { return false; } fn ends_with(s: String, suf: String) -> bool { return false; } fn contains(s: String, needle: String) -> bool { return false; } fn index_of(s: String, needle: String) -> i32 { return 0; } fn last_index_of(s: String, needle: String) -> i32 { return 0; } fn escape_c(s: String) -> String { return \"\"; } fn to_string(s: String) -> String { return s; } }\nimpl bool { fn to_string(v: bool) -> String { return \"\"; } }\nimpl i8 { fn to_string(v: i8) -> String { return \"\"; } }\nimpl u8 { fn to_string(v: u8) -> String { return \"\"; } }\nimpl i16 { fn to_string(v: i16) -> String { return \"\"; } }\nimpl u16 { fn to_string(v: u16) -> String { return \"\"; } }\nimpl i32 { fn to_string(v: i32) -> String { return \"\"; } }\nimpl u32 { fn to_string(v: u32) -> String { return \"\"; } }\nimpl i64 { fn to_string(v: i64) -> String { return \"\"; } }\nimpl u64 { fn to_string(v: u64) -> String { return \"\"; } }\nimpl isize { fn to_string(v: isize) -> String { return \"\"; } }\nimpl usize { fn to_string(v: usize) -> String { return \"\"; } }\nimpl f32 { fn to_string(v: f32) -> String { return \"\"; } }\nimpl f64 { fn to_string(v: f64) -> String { return \"\"; } }" });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "trait Wrap { fn wrap[T: Eq + Show](x: Self, v: T) -> T; }\nstruct I { v: i32 }\nimpl Wrap for I { fn wrap[U: Eq](x: I, v: U) -> U { return v; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "impl method missing type bound"));
  t.assert(contains(r.err, "Show"));
}

fn test_compile_trait_generic_default_method_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Eq { fn eq(a: Self, b: Self) -> bool; }\nimpl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }",
  });
  fs.push(ld.SourceFile { path: "src/std/prelude/string.vox", text: "impl String { fn len(s: String) -> i32 { return 0; } fn is_empty(s: String) -> bool { return true; } fn byte_at(s: String, idx: i32) -> i32 { return 0; } fn slice(s: String, start: i32, end: i32) -> String { return \"\"; } fn concat(s: String, other: String) -> String { return \"\"; } fn starts_with(s: String, pre: String) -> bool { return false; } fn ends_with(s: String, suf: String) -> bool { return false; } fn contains(s: String, needle: String) -> bool { return false; } fn index_of(s: String, needle: String) -> i32 { return 0; } fn last_index_of(s: String, needle: String) -> i32 { return 0; } fn escape_c(s: String) -> String { return \"\"; } fn to_string(s: String) -> String { return s; } }\nimpl bool { fn to_string(v: bool) -> String { return \"\"; } }\nimpl i8 { fn to_string(v: i8) -> String { return \"\"; } }\nimpl u8 { fn to_string(v: u8) -> String { return \"\"; } }\nimpl i16 { fn to_string(v: i16) -> String { return \"\"; } }\nimpl u16 { fn to_string(v: u16) -> String { return \"\"; } }\nimpl i32 { fn to_string(v: i32) -> String { return \"\"; } }\nimpl u32 { fn to_string(v: u32) -> String { return \"\"; } }\nimpl i64 { fn to_string(v: i64) -> String { return \"\"; } }\nimpl u64 { fn to_string(v: u64) -> String { return \"\"; } }\nimpl isize { fn to_string(v: isize) -> String { return \"\"; } }\nimpl usize { fn to_string(v: usize) -> String { return \"\"; } }\nimpl f32 { fn to_string(v: f32) -> String { return \"\"; } }\nimpl f64 { fn to_string(v: f64) -> String { return \"\"; } }" });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Wrap { fn wrap[T: Eq](x: Self, v: T) -> T { return v; } }
      struct I { v: i32 }
      impl Wrap for I {}
      fn main() -> i32 { let x: I = I { v: 1 }; let a: i32 = Wrap.wrap[i32](x, 7); let b: i32 = I { v: 2 }.wrap[i32](9); return a + b; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}
