import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_vec_push_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        v.push(1);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.push receiver is immutable"));
}

fn test_compile_vec_insert_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        v.insert(0, 1);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.insert receiver is immutable"));
}

fn test_compile_vec_set_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        v.set(0, 1);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.set receiver is immutable"));
}

fn test_compile_vec_extend_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        let w2: Vec[i32] = Vec();
        v.extend(w2);
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.extend receiver is immutable"));
}

fn test_compile_vec_clear_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        v.clear();
        return 0;
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.clear receiver is immutable"));
}

fn test_compile_vec_pop_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        return v.pop();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.pop receiver is immutable"));
}

fn test_compile_vec_remove_rejects_immutable_receiver() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let v: Vec[i32] = Vec();
        return v.remove(0);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "Vec.remove receiver is immutable"));
}
