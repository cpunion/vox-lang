import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_char_literal_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> u32 {\n  let a: char = 'A';\n  let b: char = '\\n';\n  return a + b;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_char_literal_unicode_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> u32 { let c: char = 'ä½ '; return c; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert_with(r.ok, r.err);
}
