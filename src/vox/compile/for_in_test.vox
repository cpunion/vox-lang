import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_for_in_vec_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn sum(xs: Vec[i32]) -> i32 {
        let mut s: i32 = 0;
        for x in xs {
          s = s + x;
        }
        return s;
      }
      fn main() -> i32 {
        let mut xs: Vec[i32] = Vec();
        xs.push(1);
        xs.push(2);
        return sum(xs);
      }
    """,
  });
  let r: c.CompileResult =
    c.compile_files_to_c(
      fs,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() },
    );
  t.assert_with(r.ok, r.err);
}

fn test_compile_for_in_non_iterable_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let x: i32 = 9;
        for v in x {
          print(v.to_string());
        }
        return 0;
      }
    """,
  });
  let r: c.CompileResult =
    c.compile_files_to_c(
      fs,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() },
    );
  t.assert_with(!r.ok, "compile should fail for non-iterable for-in source");
}
