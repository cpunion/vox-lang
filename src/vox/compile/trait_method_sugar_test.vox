import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_trait_method_sugar_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl Show for I { fn show(x: I) -> String { return "ok"; } }
      fn main() -> i32 { let x: I = I { v: 1 }; let s: String = x.show(); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(r.ok);
}

fn test_compile_trait_method_sugar_mut_receiver_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Bump { fn bump(x: &mut Self) -> i32; }
      struct I { v: i32 }
      impl Bump for I { fn bump(x: &mut I) -> i32 { return x.v + 1; } }
      fn main() -> i32 { let mut x: I = I { v: 1 }; return x.bump(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_trait_method_sugar_mut_receiver_rejects_immutable_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Bump { fn bump(x: &mut Self) -> i32; }
      struct I { v: i32 }
      impl Bump for I { fn bump(x: &mut I) -> i32 { return x.v + 1; } }
      fn main() -> i32 { let x: I = I { v: 1 }; return x.bump(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "is immutable"), r.err);
}

fn test_compile_trait_method_sugar_mut_receiver_rejects_non_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Bump { fn bump(x: &mut Self) -> i32; }
      struct I { v: i32 }
      impl Bump for I { fn bump(x: &mut I) -> i32 { return x.v + 1; } }
      fn main() -> i32 { return I { v: 1 }.bump(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "must be mutable place"), r.err);
}

fn test_compile_trait_method_sugar_ref_receiver_rejects_non_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Peek { fn peek(x: &Self) -> i32; }
      struct I { v: i32 }
      impl Peek for I { fn peek(x: &I) -> i32 { return x.v; } }
      fn main() -> i32 { return I { v: 1 }.peek(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "for & parameter must be place"), r.err);
}

fn test_compile_trait_method_sugar_prefers_inherent_when_name_conflicts() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl I { fn show(self: Self) -> i32 { return self.v + 1; } }
      impl Show for I { fn show(x: I) -> String { return "trait"; } }
      fn main() -> i32 { let i: I = I { v: 1 }; return i.show(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_trait_ufcs_call_uses_trait_when_inherent_name_conflicts() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Show { fn show(x: Self) -> String; }
      struct I { v: i32 }
      impl I { fn show(self: Self) -> i32 { return self.v + 1; } }
      impl Show for I { fn show(x: I) -> String { return "trait"; } }
      fn main() -> i32 {
        let i: I = I { v: 1 };
        let s: String = Show.show(i);
        return s.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert_with(r.ok, r.err);
}
