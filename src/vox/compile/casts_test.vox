import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_i64_literal_over_i32_range_smoke() -> () {
  // Stage1 v0: integer literals are stored as text and typed later, so values beyond
  // i32 range must still work when an i64 type is expected.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const X: i64 = 3000000000\nfn main() -> i32 { if X > 2000000000 { return 1; } return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "3000000000"));
}

fn test_compile_float_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let x: f64 = 1.5; let y: f32 = x as f32; let z: f64 = y as f64; if z > 0.0 { return 1; } return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "(float)"));
  t.assert(contains(r.c, "(double)"));
}

fn test_compile_int_float_cast_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let x: i32 = 7; let y: f64 = x as f64; let z: i32 = y as i32; return z; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "isfinite"));
}

fn test_compile_unary_not_int_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let x: i32 = !1; return x; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_int_cast_safe_widen_skips_runtime_check() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main(x: i32) -> i64 { let y: i64 = x as i64; return y; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(!contains(r.c, "i32 to i64 overflow"));
}

fn test_compile_int_cast_narrow_keeps_runtime_check() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main(x: i64) -> i32 { let y: i32 = x as i32; return y; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "i64 to i32 overflow"));
}

fn test_compile_float_scientific_and_suffix_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let a: f64 = 1e3; let b: f32 = 2.5e-2f32; let c: f64 = b as f64; if a > c { return 1; } return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, "1e3"));
}

fn test_compile_float_mod_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> f64 { return 5.5 % 2.0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
  t.assert(contains(r.c, "fmod("));
}

fn test_compile_const_verified_cast_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn in_small(x: i32) -> bool { return x >= 0 && x <= 3; }\ntype Small = @verified(in_small) i32\nconst N: Small = 2 as Small\nfn main() -> i32 { return N as i32; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_verified_cast_rejected_on_predicate_false() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn in_small(x: i32) -> bool { return x >= 0 && x <= 3; }\ntype Small = @verified(in_small) i32\nconst N: Small = 5 as Small\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "verified check failed"));
}

fn test_compile_const_verified_char_cast_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn is_ascii(x: char) -> bool { return (x as u32) <= (127 as u32); }\ntype Ascii = @verified(is_ascii) char\nconst C: Ascii = 65 as Ascii\nfn main() -> u32 { let v: char = C; return v; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_const_verified_char_cast_rejected_on_predicate_false() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn is_ascii(x: char) -> bool { return (x as u32) <= (127 as u32); }\ntype Ascii = @verified(is_ascii) char\nconst C: Ascii = 255 as Ascii\nfn main() -> u32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "verified check failed"));
}

fn test_compile_ptr_int_cast_isize_roundtrip() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn foo(p: rawptr) -> rawptr { let i: isize = p as isize; return i as rawptr; }\nfn main() -> () { return; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(contains(r.c, "(intptr_t)"));
  t.assert(contains(r.c, "(void*)"));
}

fn test_compile_ptr_int_cast_usize_roundtrip() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn foo(p: rawptr) -> rawptr { let u: usize = p as usize; return u as rawptr; }\nfn main() -> () { return; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(contains(r.c, "(uintptr_t)"));
  t.assert(contains(r.c, "(void*)"));
}

fn test_compile_ptr_int_cast_const_rawptr_to_isize() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn foo(p: const rawptr) -> isize { return p as isize; }\nfn main() -> () { return; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(contains(r.c, "(intptr_t)"));
}

fn test_compile_rawptr_to_string_cast_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn foo(p: rawptr) -> String { return p as String; }\nfn main() -> () { return; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
}

fn test_compile_ptr_i32_cast_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn foo(x: i32) -> rawptr { return x as rawptr; }\nfn main() -> () { return; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
