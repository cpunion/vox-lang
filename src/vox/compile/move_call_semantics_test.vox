import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_move_call_by_value_use_after_call_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/std/prelude/string.vox", text: "impl String { fn len(s: String) -> i32 { return 0; } fn is_empty(s: String) -> bool { return true; } fn byte_at(s: String, idx: i32) -> i32 { return 0; } fn slice(s: String, start: i32, end: i32) -> String { return \"\"; } fn concat(s: String, other: String) -> String { return \"\"; } fn starts_with(s: String, pre: String) -> bool { return false; } fn ends_with(s: String, suf: String) -> bool { return false; } fn contains(s: String, needle: String) -> bool { return false; } fn index_of(s: String, needle: String) -> i32 { return 0; } fn last_index_of(s: String, needle: String) -> i32 { return 0; } fn escape_c(s: String) -> String { return \"\"; } fn to_string(s: String) -> String { return s; } }\nimpl bool { fn to_string(v: bool) -> String { return \"\"; } }\nimpl i8 { fn to_string(v: i8) -> String { return \"\"; } }\nimpl u8 { fn to_string(v: u8) -> String { return \"\"; } }\nimpl i16 { fn to_string(v: i16) -> String { return \"\"; } }\nimpl u16 { fn to_string(v: u16) -> String { return \"\"; } }\nimpl i32 { fn to_string(v: i32) -> String { return \"\"; } }\nimpl u32 { fn to_string(v: u32) -> String { return \"\"; } }\nimpl i64 { fn to_string(v: i64) -> String { return \"\"; } }\nimpl u64 { fn to_string(v: u64) -> String { return \"\"; } }\nimpl isize { fn to_string(v: isize) -> String { return \"\"; } }\nimpl usize { fn to_string(v: usize) -> String { return \"\"; } }\nimpl f32 { fn to_string(v: f32) -> String { return \"\"; } }\nimpl f64 { fn to_string(v: f64) -> String { return \"\"; } }" });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct S { text: String }
      fn take(x: S) -> i32 { return x.text.len(); }
      fn main() -> i32 {
        let a: S = S { text: "x" };
        let _n: i32 = take(a);
        return a.text.len();
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "use of moved value: a"), r.err);
}

fn test_compile_move_call_by_borrow_keeps_value_available() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/std/prelude/string.vox", text: "impl String { fn len(s: String) -> i32 { return 0; } fn is_empty(s: String) -> bool { return true; } fn byte_at(s: String, idx: i32) -> i32 { return 0; } fn slice(s: String, start: i32, end: i32) -> String { return \"\"; } fn concat(s: String, other: String) -> String { return \"\"; } fn starts_with(s: String, pre: String) -> bool { return false; } fn ends_with(s: String, suf: String) -> bool { return false; } fn contains(s: String, needle: String) -> bool { return false; } fn index_of(s: String, needle: String) -> i32 { return 0; } fn last_index_of(s: String, needle: String) -> i32 { return 0; } fn escape_c(s: String) -> String { return \"\"; } fn to_string(s: String) -> String { return s; } }\nimpl bool { fn to_string(v: bool) -> String { return \"\"; } }\nimpl i8 { fn to_string(v: i8) -> String { return \"\"; } }\nimpl u8 { fn to_string(v: u8) -> String { return \"\"; } }\nimpl i16 { fn to_string(v: i16) -> String { return \"\"; } }\nimpl u16 { fn to_string(v: u16) -> String { return \"\"; } }\nimpl i32 { fn to_string(v: i32) -> String { return \"\"; } }\nimpl u32 { fn to_string(v: u32) -> String { return \"\"; } }\nimpl i64 { fn to_string(v: i64) -> String { return \"\"; } }\nimpl u64 { fn to_string(v: u64) -> String { return \"\"; } }\nimpl isize { fn to_string(v: isize) -> String { return \"\"; } }\nimpl usize { fn to_string(v: usize) -> String { return \"\"; } }\nimpl f32 { fn to_string(v: f32) -> String { return \"\"; } }\nimpl f64 { fn to_string(v: f64) -> String { return \"\"; } }" });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct S { text: String }
      fn peek(x: &S) -> i32 { return x.text.len(); }
      fn main() -> i32 {
        let a: S = S { text: "x" };
        let _n: i32 = peek(a);
        return a.text.len();
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_move_call_i32_copy_not_moved() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn id(x: i32) -> i32 { return x; }
      fn main() -> i32 {
        let a: i32 = 7;
        let _n: i32 = id(a);
        return a;
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_move_trait_method_by_value_receiver_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Take { fn take(x: Self) -> i32; }
      struct S { text: String }
      impl Take for S { fn take(x: S) -> i32 { return x.text.len(); } }
      fn main() -> i32 {
        let a: S = S { text: "x" };
        let _n: i32 = a.take();
        return a.text.len();
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "use of moved value: a"), r.err);
}

fn test_compile_move_trait_method_by_borrow_receiver_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Peek { fn peek(x: &Self) -> i32; }
      struct S { n: i32 }
      impl Peek for S { fn peek(x: &S) -> i32 { return x.n; } }
      fn main() -> i32 {
        let a: S = S { n: 7 };
        let _n: i32 = a.peek();
        return a.n;
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert_with(r.ok, r.err);
}

fn test_compile_move_call_member_arg_keeps_root_available() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn take(x: String) -> i32 { return x.len(); }
      struct H { text: String }
      fn main() -> i32 {
        let a: H = H { text: "x" };
        let _n: i32 = take(a.text);
        return a.text.len();
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert_with(r.ok, r.err);
}
