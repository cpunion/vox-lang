import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_reflect_intrinsics_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      type R = @range(0..=7) i32
      struct S { a: i32, b: i64 }
      enum E { A(i32), B }
      const SZ: usize = @size_of(S)
      const AL: usize = @align_of(S)
      const FC_S: usize = @field_count(S)
      const FC_E: usize = @field_count(E)
      const FN0: String = @field_name(S, 0)
      const VN1: String = @field_name(E, 1)
      const FT1: String = @field_type(S, 1)
      const ET0: String = @field_type(E, 0)
      const ET1: String = @field_type(E, 1)
      const FTY1: TypeId = @field_type_id(S, 1)
      const ETY0: TypeId = @field_type_id(E, 0)
      const ETY1: TypeId = @field_type_id(E, 1)
      const TY_S: TypeId = @type(S)
      const TY_I32: TypeId = @type(i32)
      const TY_I64: TypeId = @type(i64)
      const TN: String = @type_name(S)
      const EQTY: bool = @same_type(i32, i32)
      const NETY: bool = @same_type(i32, i64)
      const A0: bool = @assignable_to(R, i32)
      const A1: bool = @assignable_to(i32, R)
      const A2: bool = @assignable_to(i32, i32)
      const C0: bool = @castable_to(i32, f64)
      const C1: bool = @castable_to(String, i32)
      const E2E0: bool = @eq_comparable_with(S, S)
      const E2E1: bool = @eq_comparable_with(Vec[i32], Vec[i32])
      const O2O0: bool = @ordered_with(String, String)
      const O2O1: bool = @ordered_with(S, S)
      const I0: bool = @is_integer(i32)
      const I1: bool = @is_integer(S)
      const SI: bool = @is_signed_int(i64)
      const SU: bool = @is_unsigned_int(u64)
      const F0: bool = @is_float(f64)
      const B0: bool = @is_bool(bool)
      const S0: bool = @is_string(String)
      const ST: bool = @is_struct(S)
      const EN: bool = @is_enum(E)
      const V0: bool = @is_vec(Vec[i32])
      const R0: bool = @is_range(R)
      const EQC0: bool = @is_eq_comparable(S)
      const EQC1: bool = @is_eq_comparable(Vec[i32])
      const ORD0: bool = @is_ordered(String)
      const ORD1: bool = @is_ordered(S)
      const U0: bool = @is_unit(())
      const U1: bool = @is_unit(i32)
      const N0: bool = @is_numeric(i32)
      const N1: bool = @is_numeric(String)
      fn main() -> i32 {
        return if SZ >= AL && FC_S == 2 && FC_E == 2 && FN0 == "a" && VN1 == "B" &&
            FT1 == "i64" && ET0 == "i32" && ET1 == "()" && FTY1 == TY_I64 && ETY0 == TY_I32 &&
            ETY1 == @type(()) && TY_S == @type(S) && TY_I32 != TY_I64 && EQTY && !NETY &&
            A0 && !A1 && A2 && C0 && !C1 && E2E0 && !E2E1 && O2O0 && !O2O1 && TN.len() > 0 &&
            I0 && !I1 && SI && SU && F0 && B0 && S0 && ST && EN && V0 && R0 &&
            EQC0 && !EQC1 && ORD0 && !ORD1 && U0 && !U1 && N0 && !N1 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_reflect_target_intrinsics_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      const OS: String = @target_os()
      const ARCH: String = @target_arch()
      const PTR: usize = @target_ptr_bits()
      fn main() -> i32 {
        return if OS == "linux" && ARCH == "x86" && PTR == 32 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult =
    c.compile_files_to_c_for_target(
      fs,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() },
      32,
      "linux",
      "x86",
    );
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_target_cfg_oop_prelude_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/cfg.vox",
    text: """
      pub const TARGET_OS: String = @target_os()
      pub const TARGET_ARCH: String = @target_arch()
      pub const TARGET_PTR_BITS: usize = @target_ptr_bits()

      pub struct Target { pub os: String, pub arch: String, pub ptr_bits: usize }
      pub fn target() -> Target {
        return Target { os: TARGET_OS, arch: TARGET_ARCH, ptr_bits: TARGET_PTR_BITS };
      }
      impl Target {
        fn is_os(t: Target, name: String) -> bool { return t.os == name; }
        fn is_arch(t: Target, name: String) -> bool { return t.arch == name; }
        fn is_windows(t: Target) -> bool { return t.os == "windows"; }
        fn is_unix(t: Target) -> bool { return t.os == "linux" || t.os == "darwin"; }
        fn is_wasm(t: Target) -> bool { return t.os == "wasm"; }
        fn is_32bit(t: Target) -> bool { return t.ptr_bits == 32; }
        fn is_64bit(t: Target) -> bool { return t.ptr_bits == 64; }
      }
      pub fn cfg_os(name: String) -> bool { return target().is_os(name); }
    """,
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let t = target();
        return if cfg_os("darwin") && t.is_arch("arm64") && t.is_64bit() && !t.is_wasm() { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult =
    c.compile_files_to_c_for_target(
      fs,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() },
      64,
      "darwin",
      "arm64",
    );
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_reflect_intrinsic_field_type_id_multi_payload_enum_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      enum E { A(i32, i64), B(i32, i64), C(i32, i32), D }
      const T0: TypeId = @field_type_id(E, 0)
      const T1: TypeId = @field_type_id(E, 1)
      const T2: TypeId = @field_type_id(E, 2)
      const TD: TypeId = @field_type_id(E, 3)
      const OK0: bool = T0 == T1
      const OK1: bool = T0 != T2
      const OK2: bool = TD == @type(())
      fn main() -> i32 { return if OK0 && OK1 && OK2 { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_reflect_layout_intrinsics_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      const Z0: bool = @is_zero_sized(())
      const Z1: bool = @is_zero_sized(i32)
      const L0: bool = @same_layout(i32, u32)
      const L1: bool = @same_layout(i32, i64)
      const B0: bool = @bitcastable(i32, u32)
      const B1: bool = @bitcastable(i32, i64)
      fn main() -> i32 { return if Z0 && !Z1 && L0 && !L1 && B0 && !B1 { 1 } else { 0 }; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_send_sync_auto_derive_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Send {}\npub trait Sync {}",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct Point { x: i32, y: i32 }
      enum Msg { Quit, Move(Point), Data(Vec[i32]) }

      fn need_send[T: Send](x: T) -> i32 { return 1; }
      fn need_sync[T: Sync](x: T) -> i32 { return 1; }

      fn main() -> i32 {
        let p: Point = Point { x: 1, y: 2 };
        let m: Msg = Msg.Move(Point { x: 3, y: 4 });
        let mut xs: Vec[i32] = Vec();
        xs.push(7);
        return need_send(p) + need_send(m) + need_sync(xs);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
}
fn test_compile_reflect_type_name_and_type_id_for_borrow_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      const N0: String = @type_name(&i32)
      const N1: String = @type_name(&mut i32)
      const N2: String = @type_name(&'static str)
      const N3: String = @type_name(&'static mut i32)
      const N4: String = @type_name(&str)
      const T0: TypeId = @type(&i32)
      const T1: TypeId = @type(i32)

      fn main() -> i32 {
        return if N0 == "&i32" && N1 == "&mut i32" && N2 == "&'static str" &&
            N3 == "&'static mut i32" && N4 == "&str" && T0 != T1 { 1 } else { 0 };
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
}
