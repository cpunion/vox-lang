import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_compile_error_rejected_with_message() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { @compile_error(\"boom\"); return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "compile_error: boom"));
}
fn test_compile_match_bool_patterns_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main(b: bool) -> i32 { return match b { true => 1, false => 0 }; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_ifexpr_branch_return_diverges_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main(flag: bool) -> i32 {\n  let x: i32 = if flag {\n    return 7;\n  } else {\n    3\n  };\n  return x;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_ifexpr_both_branches_diverge_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main(flag: bool) -> i32 {\n  let _x: i32 = if flag {\n    return 7;\n  } else {\n    return 9;\n  };\n  return 0;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_ifexpr_branch_break_in_loop_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn main() -> i32 {\n  let mut i: i32 = 0;\n  while i < 10 {\n    let _x: i32 = if i > 5 {\n      break;\n    } else {\n      i\n    };\n    i = i + 1;\n  }\n  return i;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_ifexpr_range_result_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    // Repro: if-expression result type is a refined integer.
    text: "type Tiny = @range(1..=3) i32\nfn main(flag: bool) -> i32 {\n  let x: Tiny = if flag {\n    2 as Tiny\n  } else {\n    3 as Tiny\n  };\n  return x as i32;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_char_alias_and_range_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "type Ascii = @range(0..=127) char\nfn main() -> u32 {\n  let a: Ascii = 65 as Ascii;\n  let b: char = a;\n  return b;\n}",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_ifexpr_else_if_chain_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "fn sign(x: i32) -> i32 {\n  let y: i32 = if x < 0 {\n    -1\n  } else if x == 0 {\n    0\n  } else {\n    1\n  };\n  return y;\n}\nfn main() -> i32 { return sign(7); }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
fn test_compile_orphan_impl_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/dep/dep.vox",
    text: "pub trait Show { fn show(x: Self) -> String; }",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: "import \"dep\" as d\nimpl d.Show for i32 { fn show(x: i32) -> String { return \"x\"; } }\nfn main() -> i32 { return 0; }",
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(contains(r.err, "orphan impl is not allowed"));
}
fn test_compile_u64_max_literal_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "const X: u64 = 18446744073709551615\nfn main() -> i32 { if X > 1 { return 1; } return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
}
fn test_compile_external_tests_cannot_call_private() -> () {
  // tests/** runs in a separate "tests" module; it must not access private symbols from src/**.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a/a.vox", text: "pub fn one() -> i32 { return hidden(); }\nfn hidden() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return 0; }" });
  fs.push(ld.SourceFile { path: "tests/basic.vox", text: "import \"a\" as a\nfn test_private_is_not_accessible() -> () { a.hidden(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_imports_are_file_local() -> () {
  // Imports must be file-local (Go-like). Importing in a.vox should not enable
  // using that namespace in main.vox.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/a.vox", text: "import \"dep\" as dep\nfn ok() -> i32 { return dep.one(); }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return dep.one(); }" });
  fs.push(ld.SourceFile { path: "dep/src/dep.vox", text: "pub fn one() -> i32 { return 1; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
}
fn test_compile_macroexpand_error_has_kind_and_code() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return compile!(1, 2); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(r.err_kind == c.compile_diag_kind_macroexpand());
  t.assert(r.err_code == "E_MACROEXPAND_0001");
  t.assert(contains(r.err_message, "compile! expects exactly one value arg"));
  t.assert(contains(r.err, "[E_MACROEXPAND_0001]"));
}
fn test_compile_irgen_missing_return_reports_fn_span() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "\nfn helper() -> i32 {\nlet x: i32 = 1;\n}\nfn main() -> i32 { return helper(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "irgen error: missing return"));
  t.assert(contains(r.err, "[E_IRGEN_0001]"));
}
fn test_compile_parse_error_includes_code() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return 0; }\nelse" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:1:"));
  t.assert(contains(r.err, "[E_PARSE_0001]"));
  t.assert(r.err_kind == c.compile_diag_kind_parse());
  t.assert(r.err_code == "E_PARSE_0001");
  t.assert(contains(r.err_message, "unexpected token"));
}
fn test_compile_lex_error_includes_code_and_rune_col() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { return 0; }\n\"ä½ \"#" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:2:4:"));
  t.assert(contains(r.err, "[E_LEX_0001]"));
  t.assert(r.err_kind == c.compile_diag_kind_lex());
  t.assert(r.err_code == "E_LEX_0001");
  t.assert(contains(r.err_message, "lex error"));
}
fn test_compile_loader_error_meta() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "README.vox", text: "fn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(r.err_kind == c.compile_diag_kind_loader());
  t.assert(r.err_code == "E_LOAD_0001");
}
fn test_compile_ambiguous_import_requires_scheme() -> () {
  // If a local module `dep` and a dependency package `dep` both exist,
  // plain `import "dep"` is ambiguous and must be disambiguated with `pkg:` or `mod:`.
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "dep/src/dep.vox", text: "pub fn one() -> i32 { return 2; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"dep\" as dep\nfn main() -> i32 { return dep.one(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(!r.ok);
  t.assert(starts_with(r.err, "src/main.vox:1:1:"));
  t.assert(contains(r.err, "ambiguous import"));
  t.assert(contains(r.err, "[E_IMPORT_0003]"));
  t.assert(r.err_kind == c.compile_diag_kind_import());
  t.assert(r.err_code == "E_IMPORT_0003");
}
fn test_compile_pkg_scheme_disambiguates_import() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/dep/dep.vox", text: "pub fn one() -> i32 { return 1; }" });
  fs.push(ld.SourceFile { path: "dep/src/dep.vox", text: "pub fn one() -> i32 { return 2; }" });
  fs.push(ld.SourceFile { path: "src/main.vox", text: "import \"pkg:dep\" as dep\nfn main() -> i32 { return dep.one(); }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert(r.ok);
  t.assert(contains(r.c, cg.c_fn_name("pkg.dep::one")));
}
fn test_compile_send_bound_not_inferred_for_type_param_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Send {}\npub trait Sync {}",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn need_send[T: Send](x: T) -> i32 { return 0; }
      fn relay[T](x: T) -> i32 { return need_send[T](x); }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "does not satisfy trait bound"), r.err);
}

fn test_compile_negative_send_impl_overrides_auto_derive() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Send {}\npub trait Sync {}",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct UiHandle { id: i32 }
      impl !Send for UiHandle {}
      fn need_send[T: Send](x: T) -> i32 { return 1; }
      fn main() -> i32 {
        let h: UiHandle = UiHandle { id: 7 };
        return need_send(h);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "does not satisfy trait bound"), r.err);
}

fn test_compile_negative_impl_non_send_sync_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Send {}\npub trait Sync {}",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      trait Marker {}
      struct UiHandle { id: i32 }
      impl !Marker for UiHandle {}
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "negative impl is only allowed for std/prelude::Send and std/prelude::Sync"), r.err);
}

fn test_compile_negative_send_impl_non_empty_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Send {}\npub trait Sync {}",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct UiHandle { id: i32 }
      impl !Send for UiHandle {
        fn mark(x: UiHandle) -> i32 { return x.id; }
      }
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "negative impl must not define methods"), r.err);
}

fn test_compile_manual_positive_send_impl_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Send {}\npub trait Sync {}",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct UiHandle { id: i32 }
      impl Send for UiHandle {}
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "manual impl of auto marker trait is not allowed"), r.err);
}

fn test_compile_manual_positive_sync_impl_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/std/prelude/traits.vox",
    text: "pub trait Send {}\npub trait Sync {}",
  });
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      struct UiHandle { id: i32 }
      impl Sync for UiHandle {}
      fn main() -> i32 { return 0; }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: true,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "manual impl of auto marker trait is not allowed"), r.err);
}
