import "std/testing" as t
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg

fn test_compile_bare_str_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn main() -> i32 {
        let s: str = "vox";
        return s.len();
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(!r.ok, r.err);
  t.assert(contains(r.err, "bare str is not allowed"));
}

fn test_compile_ref_str_alias_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn len1(s: &str) -> i32 { return s.len(); }
      fn main() -> i32 { return len1("vox"); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ref_static_str_alias_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn id(s: &'static str) -> &'static str { return s; }
      fn main() -> i32 { let s: &'static str = id("vox"); return s.len(); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ref_i32_alias_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn add1(x: &i32) -> i32 { return x + 1; }
      fn main() -> i32 {
        let v: i32 = 41;
        return add1(v);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ref_mut_i32_alias_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn add1(x: &mut i32) -> i32 { return x + 1; }
      fn main() -> i32 {
        let mut v: i32 = 41;
        return add1(v);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ref_mut_arg_requires_mutable_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn add1(x: &mut i32) -> i32 { return x + 1; }
      fn main() -> i32 { return add1(41); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "must be mutable place"), r.err);
}

fn test_compile_ref_mut_arg_rejects_immutable_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn add1(x: &mut i32) -> i32 { return x + 1; }
      fn main() -> i32 {
        let v: i32 = 41;
        return add1(v);
      }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "is immutable"), r.err);
}

fn test_compile_ref_arg_requires_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      fn add1(x: &i32) -> i32 { return x + 1; }
      fn main() -> i32 { return add1(41); }
    """,
  });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(!r.ok, r.err);
  t.assert_with(contains(r.err, "for & parameter must be place"), r.err);
}

fn test_compile_ref_named_lifetime_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn bad(s: &'a str) -> i32 { return s.len(); }\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "only 'static is allowed"), r.err);
}

fn test_compile_ref_mut_named_lifetime_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn bad(s: &'a mut i32) -> i32 { return s; }\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "only 'static is allowed"), r.err);
}

fn test_compile_ref_named_lifetime_in_let_annotation_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let x: &'a i32 = 1; return x; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "only 'static is allowed"), r.err);
}

fn test_compile_ref_nonstatic_return_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn bad(x: &i32) -> &i32 { return x; }\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "non-static borrowed type is not allowed in return type"), r.err);
}

fn test_compile_ref_nonstatic_struct_field_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "struct S { x: &i32 }\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "non-static borrowed type is not allowed in struct field"), r.err);
}

fn test_compile_ref_nonstatic_container_param_rejected() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn bad(xs: Vec[&i32]) -> i32 { return xs.len(); }\nfn main() -> i32 { return 0; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "non-static borrowed type in parameter must be top-level &T or &mut T"), r.err);
}

fn test_compile_ref_let_init_requires_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let r: &i32 = 41; return r; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "let init for & annotation must be place"), r.err);
}

fn test_compile_ref_let_init_from_place_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let v: i32 = 41; let r: &i32 = v; return r; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}

fn test_compile_ref_mut_let_init_requires_mutable_place() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let v: i32 = 41; let r: &mut i32 = v; return r; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert(!r.ok);
  t.assert_with(contains(r.err, "let init for &mut annotation is immutable"), r.err);
}

fn test_compile_ref_mut_let_init_from_mutable_place_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(ld.SourceFile { path: "src/main.vox", text: "fn main() -> i32 { let mut v: i32 = 41; let r: &mut i32 = v; return r; }" });
  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), std_root: "src/std" });
  t.assert_with(r.ok, r.err);
  t.assert(r.ok);
}
