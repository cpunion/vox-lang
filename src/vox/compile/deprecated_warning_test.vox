import "std/testing" as t
import "vox/compile" as c
import "vox/codegen" as cg

fn has_warning(ws: Vec[String], needle: String) -> bool {
  let mut i: i32 = 0;
  while i < ws.len() {
    if contains(ws.get(i), needle) { return true; }
    i = i + 1;
  }
  return false;
}

fn test_compile_warns_on_deprecated_builtin_smoke() -> () {
  let src: String = """
    const OK: bool = @same_layout(i32, i32)
    fn main() -> i32 { return if OK { 1 } else { 0 }; }
  """;
  let r: c.CompileResult =
    c.compile_main_text_to_c(
      src,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() },
    );
  t.assert_with(r.ok, r.err);
  t.assert_with(r.warnings.len() > 0, "expected deprecated builtin warning");
  t.assert_with(has_warning(r.warnings, "deprecated builtin `@same_layout`"), "expected @same_layout deprecation warning");
}

fn test_compile_warns_on_deprecated_macro_smoke() -> () {
  let src: String = """
    @deprecated("use new_expr! instead")
    fn old_expr() -> AstExpr { return compile!(1); }
    fn main() -> i32 {
      let v: i32 = old_expr!();
      return v;
    }
  """;
  let r: c.CompileResult =
    c.compile_main_text_to_c(
      src,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() },
    );
  t.assert_with(r.ok, r.err);
  t.assert_with(r.warnings.len() > 0, "expected deprecated macro warning");
  t.assert_with(has_warning(r.warnings, "deprecated macro `old_expr!`"), "expected old_expr! deprecation warning");
}

fn test_compile_warns_on_deprecated_inherent_method_smoke() -> () {
  let src: String = """
    struct S { v: i32 }
    impl S {
      @deprecated("use new_m")
      fn old_m(x: S) -> i32 { return 1; }
      fn new_m(_x: S) -> i32 { return 2; }
    }
    fn main() -> i32 {
      let s: S = S { v: 1 };
      return s.old_m();
    }
  """;
  let r: c.CompileResult =
    c.compile_main_text_to_c(
      src,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() },
    );
  t.assert_with(r.ok, r.err);
  t.assert_with(has_warning(r.warnings, "deprecated function"), "expected deprecated method warning");
  t.assert_with(has_warning(r.warnings, "use new_m"), "expected deprecated method message");
}

fn test_compile_warns_on_deprecated_trait_method_smoke() -> () {
  let src: String = """
    trait T {
      @deprecated("use newer")
      fn old(x: Self) -> i32;
    }
    struct S { v: i32 }
    impl T for S {
      fn old(_x: S) -> i32 { return 7; }
    }
    fn main() -> i32 {
      let s: S = S { v: 1 };
      return s.old();
    }
  """;
  let r: c.CompileResult =
    c.compile_main_text_to_c(
      src,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() },
    );
  t.assert_with(r.ok, r.err);
  t.assert_with(has_warning(r.warnings, "deprecated function"), "expected deprecated trait method warning");
  t.assert_with(has_warning(r.warnings, "use newer"), "expected deprecated trait method message");
}

fn test_compile_warns_on_deprecated_top_level_function_smoke() -> () {
  let src: String = """
    @deprecated("use v2")
    fn old_api() -> i32 { return 5; }
    fn main() -> i32 { return old_api(); }
  """;
  let r: c.CompileResult =
    c.compile_main_text_to_c(
      src,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() },
    );
  t.assert_with(r.ok, r.err);
  t.assert_with(has_warning(r.warnings, "deprecated function"), "expected deprecated top-level fn warning");
  t.assert_with(has_warning(r.warnings, "use v2"), "expected deprecated top-level fn message");
  t.assert_with(has_warning(r.warnings, "called from"), "expected caller function name in warning");
}

fn test_compile_warns_on_deprecated_trait_default_method_smoke() -> () {
  let src: String = """
    trait T {
      @deprecated("use newer")
      fn old(x: Self) -> i32 { return 9; }
    }
    struct S { v: i32 }
    impl T for S {}
    fn main() -> i32 {
      let s: S = S { v: 1 };
      return s.old();
    }
  """;
  let r: c.CompileResult =
    c.compile_main_text_to_c(
      src,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() },
    );
  t.assert_with(r.ok, r.err);
  t.assert_with(has_warning(r.warnings, "deprecated function"), "expected deprecated default method warning");
  t.assert_with(has_warning(r.warnings, "use newer"), "expected deprecated default method message");
}
