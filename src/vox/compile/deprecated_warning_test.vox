import "std/testing" as t
import "vox/compile" as c
import "vox/codegen" as cg

fn has_warning(ws: Vec[String], needle: String) -> bool {
  let mut i: i32 = 0;
  while i < ws.len() {
    if contains(ws.get(i), needle) { return true; }
    i = i + 1;
  }
  return false;
}

fn test_compile_warns_on_deprecated_builtin_smoke() -> () {
  let src: String = """
    const OK: bool = @same_layout(i32, i32)
    fn main() -> i32 { return if OK { 1 } else { 0 }; }
  """;
  let r: c.CompileResult =
    c.compile_main_text_to_c(
      src,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() },
    );
  t.assert_with(r.ok, r.err);
  t.assert_with(r.warnings.len() > 0, "expected deprecated builtin warning");
  t.assert_with(has_warning(r.warnings, "deprecated builtin `@same_layout`"), "expected @same_layout deprecation warning");
}

fn test_compile_warns_on_deprecated_macro_smoke() -> () {
  let src: String = """
    @deprecated("use new_expr! instead")
    fn old_expr() -> AstExpr { return compile!(1); }
    fn main() -> i32 {
      let v: i32 = old_expr!();
      return v;
    }
  """;
  let r: c.CompileResult =
    c.compile_main_text_to_c(
      src,
      cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec() },
    );
  t.assert_with(r.ok, r.err);
  t.assert_with(r.warnings.len() > 0, "expected deprecated macro warning");
  t.assert_with(has_warning(r.warnings, "deprecated macro `old_expr!`"), "expected old_expr! deprecation warning");
}
