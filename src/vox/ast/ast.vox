// Stability: Stable module API (vox/ast).
// Migration: Backward-compatible within minor releases; breaking changes require migration notes.

// Stage1 AST (initial minimal subset).
//
// Note: In Stage0 subset we avoid references/pointers, so recursive structures
// are modeled directly with nested structs/enums (small programs) or later via
// arena + indices.

pub struct Program {
  pub imports: Vec[ImportDecl],
  pub types: Vec[TypeAliasDecl],
  pub consts: Vec[ConstDecl],
  pub structs: Vec[StructDecl],
  pub enums: Vec[EnumDecl],
  pub traits: Vec[TraitDecl],
  pub impls: Vec[ImplDecl],
  pub funcs: Vec[FuncDecl],
  pub exprs: ExprPool,
}

// Minimal span for diagnostics (v0): we only need file + 1-based line/col.
pub struct Span {
  pub file: String,
  pub line: i32,
  pub col: i32,
}

pub fn span0() -> Span { return Span { file: "", line: 1, col: 1 }; }

pub fn vis_private() -> i32 { return 0; }
pub fn vis_pub() -> i32 { return 1; }
pub fn vis_crate() -> i32 { return 2; }
pub fn vis_super() -> i32 { return 3; }
pub fn vis_is_pub(v: i32) -> bool { return v != vis_private(); }
pub fn comptime_where_lhs_const_param() -> i32 { return 0; }
pub fn comptime_where_lhs_size_of() -> i32 { return 1; }
pub fn comptime_where_lhs_align_of() -> i32 { return 2; }
pub fn comptime_where_lhs_field_count() -> i32 { return 3; }
pub fn comptime_where_lhs_type() -> i32 { return 4; }
pub fn resource_read() -> i32 { return 0; }
pub fn resource_write() -> i32 { return 1; }

pub struct TypeAliasDecl {
  pub file: String,
  pub sp: Span,
  pub vis: i32,
  pub is_pub: bool,
  pub name: String,
  pub ty: TypeName,
}

pub struct ConstDecl {
  pub file: String,
  pub sp: Span,
  pub vis: i32,
  pub is_pub: bool,
  pub name: String,
  pub ty: TypeName,
  pub init: i32, // expr id
}

pub struct ImportDecl {
  // Source file path (e.g. "src/main.vox"). Used to make imports file-local.
  pub file: String,
  pub sp: Span,
  pub path: String,
  // Empty means "no alias" (use default alias rule later).
  pub alias: String,
  // Named imports (stage0 parity). When non-empty, this import does not introduce
  // a module alias; it only brings selected names into the file scope.
  pub names: Vec[ImportName],
}

pub struct ImportName {
  pub name: String,
  // Empty means "no alias" (defaults to name).
  pub alias: String,
  pub sp: Span,
}

pub struct StructDecl {
  pub file: String,
  pub sp: Span,
  pub vis: i32,
  pub is_pub: bool,
  pub name: String,
  pub type_params: Vec[String],
  pub type_param_bounds: Vec[TypeParamBoundsDecl],
  pub const_where_bounds: Vec[ConstWhereDecl],
  pub fields: Vec[FieldDecl],
}

pub struct FieldDecl {
  pub vis: i32,
  pub is_pub: bool,
  pub name: String,
  pub ty: TypeName,
}

pub struct EnumDecl {
  pub file: String,
  pub sp: Span,
  pub vis: i32,
  pub is_pub: bool,
  pub name: String,
  pub type_params: Vec[String],
  pub type_param_bounds: Vec[TypeParamBoundsDecl],
  pub const_where_bounds: Vec[ConstWhereDecl],
  pub variants: Vec[EnumVariantDecl],
}

pub struct EnumVariantDecl {
  pub name: String,
  // Payload types; empty means unit variant.
  pub fields: Vec[TypeName],
}

pub struct TraitMethodDecl {
  pub sp: Span,
  pub is_async: bool,
  pub name: String,
  pub type_params: Vec[String],
  // Names declared with `...` in `[T..., U]`.
  // Stored separately to preserve the base type param name (`T`) for diagnostics.
  pub type_param_packs: Vec[String],
  pub const_params: Vec[ConstParamDecl],
  pub type_param_bounds: Vec[TypeParamBoundsDecl],
  pub const_where_bounds: Vec[ConstWhereDecl],
  pub params: Vec[Param],
  pub ret: TypeName,
  pub effects: Vec[EffectAttr],
  pub resources: Vec[ResourceAttr],
  pub has_body: bool,
  pub body: Block,
}

pub struct TraitAssocTypeDecl {
  pub sp: Span,
  pub name: String,
}

pub struct TraitDecl {
  pub file: String,
  pub sp: Span,
  pub vis: i32,
  pub is_pub: bool,
  pub name: String,
  pub supers: Vec[TypeName],
  pub assoc_types: Vec[TraitAssocTypeDecl],
  pub methods: Vec[TraitMethodDecl],
}

pub struct ImplAssocTypeBinding {
  pub sp: Span,
  pub name: String,
  pub ty: TypeName,
}

pub struct ImplDecl {
  pub file: String,
  pub sp: Span,
  // true => `impl Type { ... }`
  // false => `impl Trait for Type { ... }`
  pub is_inherent: bool,
  // true => `impl !Trait for Type { ... }`
  pub is_negative: bool,
  pub type_params: Vec[String],
  pub type_param_bounds: Vec[TypeParamBoundsDecl],
  pub const_where_bounds: Vec[ConstWhereDecl],
  pub trait_name: TypeName,
  pub for_ty: TypeName,
  pub assoc_types: Vec[ImplAssocTypeBinding],
  pub methods: Vec[FuncDecl],
}

pub struct FfiImportAttr {
  pub sp: Span,
  pub target: String,
  pub module: String,
  pub symbol: String,
}

pub struct FfiExportAttr {
  pub sp: Span,
  pub target: String,
  pub symbol: String,
}

pub struct EffectAttr {
  pub sp: Span,
  pub name: String,
}

pub struct ResourceAttr {
  pub sp: Span,
  pub kind: i32,
  pub name: String,
}

pub struct FuncDecl {
  pub file: String,
  pub sp: Span,
  pub vis: i32,
  pub is_pub: bool,
  pub is_async: bool,
  pub track_caller: bool,
  // Empty means not deprecated.
  pub deprecated_message: String,
  pub name: String,
  pub type_params: Vec[String],
  // Names declared with `...` in `[T..., U]`.
  pub type_param_packs: Vec[String],
  pub const_params: Vec[ConstParamDecl],
  pub type_param_bounds: Vec[TypeParamBoundsDecl],
  pub const_where_bounds: Vec[ConstWhereDecl],
  pub params: Vec[Param],
  pub ret: TypeName,
  pub ffi_imports: Vec[FfiImportAttr],
  pub ffi_exports: Vec[FfiExportAttr],
  pub effects: Vec[EffectAttr],
  pub resources: Vec[ResourceAttr],
  pub body: Block,
}

pub struct ConstParamDecl {
  pub name: String,
  pub ty: TypeName,
  pub has_default: bool,
  pub default_text: String,
}

pub struct TypeParamBoundsDecl {
  pub name: String,
  pub bounds: Vec[TypeName], // e.g. T: Eq + Show
}

pub struct ConstWhereDecl {
  pub lhs_kind: i32,        // comptime_where_lhs_*
  pub name: String,         // const/type param name depending lhs_kind
  pub op: BinaryOp,         // one of Eq/Ne/Lt/Le/Gt/Ge
  pub rhs_is_param: bool,   // true => rhs_param; false => rhs_text as integer literal
  pub rhs_param: String,    // const param name when rhs_is_param
  pub rhs_text: String,     // source text for diagnostics (literal text or rhs_param)
}

pub struct Param {
  pub name: String,
  pub ty: TypeName,
}

pub struct TypeName {
  // Qualified type path segments, e.g. ["i32"], ["std","io","Reader"].
  pub parts: Vec[String],
  // Generic type args: `Vec[i32]` has args [i32].
  pub args: Vec[TypeName],
}

pub struct Block {
  pub stmts: Vec[Stmt],
}

pub enum Stmt {
  Let(Span, bool, String, bool, TypeName, i32), // span, mutable, name, has_ann, ann, init expr id
  Assign(Span, String, i32),                    // span, name, expr id
  AssignField(Span, String, String, i32),       // span, recv var name, field name, rhs expr id
  ExprStmt(Span, i32),                          // span, expr id
  IfStmt(Span, i32, Block, bool, Block),        // span, cond, then, has_else, else_block (dummy when !has_else)
  WhileStmt(Span, i32, Block),                  // span, cond, body
  // Internal try-scope markers used by async normalization when lifting `await`
  // out of `try { ... }` expressions. These are not user-facing syntax.
  //
  // IRGen treats statements between TryBegin/TryEnd as a `try` propagation
  // region where `expr?` targets the container stored in `out_name`.
  TryBegin(Span, String),                       // span, out_name
  TryEnd(Span),                                 // span
  Break(Span),
  Continue(Span),
  ReturnStmt(Span, bool, i32),                  // span, has_expr, expr id
}
