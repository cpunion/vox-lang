import "std/testing" as t
import "vox/ast" as ast
import "vox/lex" as lex
import "vox/parse" as p
import "vox/token" as tok
import "vox/manifest" as mf
import "vox/ir" as ir
import "vox/typecheck" as tc
import "vox/types" as tys
import "vox/compile" as c
import "vox/loader" as ld
import "vox/codegen" as cg
import "vox/macroexpand" as mx

fn lex_err_none(e: lex.LexError) -> bool {
  return match e { lex.LexError.None => true, _ => false, };
}

fn parse_err_none(e: p.ParseError) -> bool {
  return match e { p.ParseError.None => true, _ => false, };
}

fn test_public_api_ast_smoke() -> () {
  let sp: ast.Span = ast.span0();
  t.assert_eq(sp.line, 1);
  t.assert_eq(sp.col, 1);
  t.assert(ast.vis_is_pub(ast.vis_pub()));
  t.assert(!ast.vis_is_pub(ast.vis_private()));

  let pool0: ast.ExprPool = ast.expr_pool();
  let add: ast.AddExprResult = ast.expr_pool_add(pool0, ast.ExprNode.Int("42"), sp);
  let node: ast.ExprNode = ast.expr_pool_get(add.pool, add.id);
  let out: String = match node { ast.ExprNode.Int(s) => s, _ => "", };
  t.assert_eq(out, "42");
}

fn test_public_api_token_smoke() -> () {
  let ar: tok.AddFileResult = tok.file_set_add_file_from_text(tok.file_set(), "src/main.vox", "a\nb");

  let ps0: tok.Pos = tok.file_set_pos(ar.fset, ar.file_idx, tok.off_from_raw(0));
  t.assert(tok.pos_is_valid(ps0));
  let fo0: tok.FileOffsetResult = tok.file_offset(ar.file, ps0);
  t.assert(fo0.ok);
  t.assert_eq(tok.off_raw(fo0.off), 0);

  let p0: tok.Position = tok.file_set_position(ar.fset, ps0);
  t.assert_eq(p0.filename, "src/main.vox");
  t.assert_eq(p0.line, 1);
  t.assert_eq(p0.col, 1);

  let ps2: tok.Pos = tok.file_set_pos(ar.fset, ar.file_idx, tok.off_from_raw(2));
  let fo2: tok.FileOffsetResult = tok.file_offset(ar.file, ps2);
  t.assert(fo2.ok);
  t.assert_eq(tok.off_raw(fo2.off), 2);
  t.assert_eq(tok.file_offset_raw(ar.file, ps2), 2);

  let p2: tok.Position = tok.file_set_position(ar.fset, ps2);
  t.assert_eq(p2.line, 2);
  t.assert_eq(p2.col, 1);

  let np0: tok.Pos = tok.no_pos();
  t.assert(!tok.pos_is_valid(np0));
  let np: tok.Position = tok.file_set_position(ar.fset, np0);
  t.assert_eq(np.line, 0);
  t.assert_eq(np.col, 0);
}

fn test_public_api_lex_smoke() -> () {
  let r: lex.LexResult = lex.lex_text("fn main() -> i32 { return 0; }");
  t.assert(lex_err_none(r.err));
  t.assert(r.tokens.len() > 0);

  let t0: lex.Token = r.tokens.get(0);
  t.assert(lex.token_kind_eq(t0.kind, lex.TokenKind.KwFn));
  t.assert_eq(lex.token_kind_name(t0.kind), "fn");

  let te: lex.Token = r.tokens.get(r.tokens.len() - 1);
  t.assert(lex.token_kind_eq(te.kind, lex.TokenKind.Eof));
}

fn test_public_api_parse_smoke() -> () {
  let src: String = "fn main() -> i32 { return 0; }";
  let r: p.ParseResult = p.parse_text(src);
  t.assert(parse_err_none(r.err));
  t.assert_eq(r.prog.funcs.len(), 1);
  t.assert_eq(r.prog.funcs.get(0).name, "main");
}

fn test_public_api_manifest_smoke() -> () {
  let text: String =
    "[package]\n"
      .concat("name = \"demo\"\n\n")
      .concat("[dependencies]\n")
      .concat("foo = \"1.2.3\"\n")
      .concat("bar = { path = \"../bar\" }\n");

  let r: mf.ParseResult = mf.parse(text);
  t.assert(r.ok);
  t.assert_eq(r.m.pkg_name, "demo");
  t.assert_eq(r.m.deps.len(), 2);

  let d0: mf.Dependency = r.m.deps.get(0);
  t.assert_eq(d0.name, "foo");
  t.assert(d0.has_version);
  t.assert_eq(d0.version, "1.2.3");

  let d1: mf.Dependency = r.m.deps.get(1);
  t.assert_eq(d1.name, "bar");
  t.assert(d1.has_path);
  t.assert_eq(d1.path, "../bar");
}

fn test_public_api_ir_smoke() -> () {
  let add: ir.AddTyResult = ir.ty_pool_add(ir.ty_pool(), ir.ty_i32());
  let ty: ir.Ty = ir.ty_pool_get(add.pool, add.idx);
  let is_i32: bool = match ty.kind { ir.TyKind.I32 => true, _ => false, };
  t.assert(is_i32);

  let prog: ir.Program = ir.program(add.pool);
  let text: String = ir.format_program(prog);
  t.assert(text.len() >= 5);
  t.assert_eq(text.slice(0, 5), "ir v0");

  let vr: ir.VerifyResult = ir.verify_program(prog);
  t.assert(vr.ok);
}

fn test_public_api_types_smoke() -> () {
  let pr: p.ParseResult = p.parse_text_with_path("src/main.vox", "fn main() -> i32 { return 0; }");
  t.assert(parse_err_none(pr.err));

  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "main", pr.prog);

  let r: tys.CheckResult = tys.check_world(w);
  t.assert_with(r.ok, tys.error_string(r.err));
}

fn std_async_file() -> ld.SourceFile {
  return ld.SourceFile {
    path: "src/std/async/async.vox",
    text: """
      pub enum Poll[T] { Pending, Ready(T) }
      pub struct Waker { pub token: i64 }
      pub struct Context { pub waker: Waker }
      pub trait Future { type Output; fn poll(x: &mut Self, cx: &Context) -> Poll[Self.Output]; }
    """,
  };
}

fn test_public_api_async_compile_smoke() -> () {
  let mut fs: Vec[ld.SourceFile] = Vec();
  fs.push(std_async_file());
  fs.push(ld.SourceFile {
    path: "src/main.vox",
    text: """
      import "std/async" as a

      trait I { async fn f(x: Self) -> i32; }

      struct S { n: i32 }
      impl I for S {
        async fn f(x: S) -> i32 {
          let p: a.Poll[i32] = .Ready(x.n);
          let y: i32 = p.await;
          return y + 1;
        }
      }

      async fn inc(x: i32) -> i32 { return x + 1; }
      async fn main() -> i32 {
        let s: S = S { n: 1 };
        let x: i32 = s.f().await;
        return inc(x).await;
      }
    """,
  });

  let r: c.CompileResult = c.compile_files_to_c(fs, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
  });
  t.assert_with(r.ok, r.err);
}
