import "vox/ast" as ast

// Async CFG builder used by both typecheck (capture + await operand ordering) and
// irgen (poll body synthesis). This lowers structured statements (if/while/break/continue)
// into a state-machine CFG where each state is a "block" keyed by `frame.state`.
//
// This module is intentionally "untyped": it only reasons about names and AST shape.

pub enum Term {
  Unset,
  Goto(i32),        // next block id
  If(i32, i32, i32), // cond expr id, then id, else id
  Return,
  Panic,
}

pub enum Payload {
  Normal,
  // Current block ends by evaluating operand, storing into frame.a<await_idx>,
  // and jumping to `poll_block`.
  AwaitInit(i32, i32, i32), // await_idx, operand expr id, poll block id
  // Poll block: re-await frame.a<await_idx>. On Ready, jump to `next_block` if has_next.
  AwaitPoll(i32, ast.Stmt, bool, i32, bool), // await_idx, original stmt, is_try, next_block, has_next
}

pub struct Block {
  pub id: i32,
  pub stmts: Vec[ast.Stmt],
  pub payload: Payload,
  pub term: Term,
  pub resume: bool,
}

pub struct BuildResult {
  pub ok: bool,
  pub err: String,
  pub blocks: Vec[Block],
  pub entry: i32,
  pub await_count: i32,
  pub resume_blocks: Vec[i32],
}

fn vec_contains(xs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

fn vec_add_unique(xs0: Vec[String], s: String) -> Vec[String] {
  let mut xs: Vec[String] = xs0;
  if s != "" && !vec_contains(xs, s) { xs.push(s); }
  return xs;
}

fn vec_union_into(dst0: Vec[String], src: Vec[String]) -> Vec[String] {
  let mut dst: Vec[String] = dst0;
  let mut i: i32 = 0;
  while i < src.len() {
    dst = vec_add_unique(dst, src.get(i));
    i = i + 1;
  }
  return dst;
}

fn expr_used_names(exprs: ast.ExprPool, eid: i32) -> Vec[String] {
  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);
  if match n { ast.ExprNode.Ident(_s) => true, _ => false } {
    let s: String = match n { ast.ExprNode.Ident(x) => x, _ => "" };
    let mut out: Vec[String] = Vec();
    out.push(s);
    return out;
  }
  if match n { ast.ExprNode.Int(_v) => true, ast.ExprNode.Float(_v) => true, ast.ExprNode.Bool(_b) => true, ast.ExprNode.Str(_s) => true, ast.ExprNode.DotIdent(_s) => true, _ => false } {
    return Vec();
  }
  if match n { ast.ExprNode.Unary(_op, _a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Unary(_op, x) => x, _ => -1 };
    return expr_used_names(exprs, a);
  }
  if match n { ast.ExprNode.As(_a, _tn) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.As(x, _tn) => x, _ => -1 };
    return expr_used_names(exprs, a);
  }
  if match n { ast.ExprNode.Binary(_op, _l, _r) => true, _ => false } {
    let l: i32 = match n { ast.ExprNode.Binary(_op, x, _r) => x, _ => -1 };
    let r: i32 = match n { ast.ExprNode.Binary(_op, _l, x) => x, _ => -1 };
    return vec_union_into(expr_used_names(exprs, l), expr_used_names(exprs, r));
  }
  if match n { ast.ExprNode.Member(_r, _f) => true, _ => false } {
    let r: i32 = match n { ast.ExprNode.Member(x, _f) => x, _ => -1 };
    return expr_used_names(exprs, r);
  }
  if match n { ast.ExprNode.Call(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.Call(x, _t, _a) => x, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.Call(_c, _t, x) => x, _ => Vec() };
    let mut out: Vec[String] = expr_used_names(exprs, callee);
    let mut i: i32 = 0;
    while i < args.len() {
      out = vec_union_into(out, expr_used_names(exprs, args.get(i)));
      i = i + 1;
    }
    return out;
  }
  if match n { ast.ExprNode.TryBlock(_bid) => true, _ => false } {
    let bid: i32 = match n { ast.ExprNode.TryBlock(x) => x, _ => -1 };
    return expr_used_names(exprs, bid);
  }
  if match n { ast.ExprNode.Try(_a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Try(x) => x, _ => -1 };
    return expr_used_names(exprs, a);
  }
  if match n { ast.ExprNode.Await(_a) => true, _ => false } {
    let a: i32 = match n { ast.ExprNode.Await(x) => x, _ => -1 };
    return expr_used_names(exprs, a);
  }
  if match n { ast.ExprNode.StructLit(_t, _fs) => true, _ => false } {
    let ty_expr: i32 = match n { ast.ExprNode.StructLit(x, _fs) => x, _ => -1 };
    let fs: Vec[ast.StructLitField] = match n { ast.ExprNode.StructLit(_t, x) => x, _ => Vec() };
    let mut out: Vec[String] = expr_used_names(exprs, ty_expr);
    let mut i: i32 = 0;
    while i < fs.len() {
      out = vec_union_into(out, expr_used_names(exprs, fs.get(i).expr));
      i = i + 1;
    }
    return out;
  }
  if match n { ast.ExprNode.Block(_b) => true, _ => false } {
    let b0: ast.ExprBlock = match n { ast.ExprNode.Block(x) => x, _ => ast.ExprBlock { stmts: Vec(), has_tail: false, tail: -1 } };
    let mut out: Vec[String] = Vec();
    let mut i: i32 = 0;
    while i < b0.stmts.len() {
      out = vec_union_into(out, stmt_used_names(exprs, b0.stmts.get(i)));
      i = i + 1;
    }
    if b0.has_tail && b0.tail != -1 {
      out = vec_union_into(out, expr_used_names(exprs, b0.tail));
    }
    return out;
  }
  if match n { ast.ExprNode.If(_c, _t, _e) => true, _ => false } {
    let c: i32 = match n { ast.ExprNode.If(x, _t, _e) => x, _ => -1 };
    let t: i32 = match n { ast.ExprNode.If(_c, x, _e) => x, _ => -1 };
    let e: i32 = match n { ast.ExprNode.If(_c, _t, x) => x, _ => -1 };
    return vec_union_into(vec_union_into(expr_used_names(exprs, c), expr_used_names(exprs, t)), expr_used_names(exprs, e));
  }
  if match n { ast.ExprNode.Match(_s, _as) => true, _ => false } {
    let s: i32 = match n { ast.ExprNode.Match(x, _as) => x, _ => -1 };
    let arms: Vec[ast.MatchArm] = match n { ast.ExprNode.Match(_s, x) => x, _ => Vec() };
    let mut out: Vec[String] = expr_used_names(exprs, s);
    let mut i: i32 = 0;
    while i < arms.len() {
      out = vec_union_into(out, expr_used_names(exprs, arms.get(i).expr));
      i = i + 1;
    }
    return out;
  }
  if match n { ast.ExprNode.MacroCall(_c, _t, _a) => true, _ => false } {
    let callee: i32 = match n { ast.ExprNode.MacroCall(x, _t, _a) => x, _ => -1 };
    let args: Vec[i32] = match n { ast.ExprNode.MacroCall(_c, _t, x) => x, _ => Vec() };
    let mut out: Vec[String] = expr_used_names(exprs, callee);
    let mut i: i32 = 0;
    while i < args.len() {
      out = vec_union_into(out, expr_used_names(exprs, args.get(i)));
      i = i + 1;
    }
    return out;
  }

  return Vec();
}

fn stmt_def_name(st: ast.Stmt) -> String {
  if match st { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, _e) => true, _ => false } {
    return match st { ast.Stmt.Let(_sp, _m, n0, _ha, _ann, _e) => n0, _ => "" };
  }
  if match st { ast.Stmt.Assign(_sp, _n, _e) => true, _ => false } {
    return match st { ast.Stmt.Assign(_sp, n0, _e) => n0, _ => "" };
  }
  return "";
}

fn stmt_used_names(exprs: ast.ExprPool, st: ast.Stmt) -> Vec[String] {
  return match st {
    ast.Stmt.Let(_sp, _m, _n, _ha, _ann, init) => expr_used_names(exprs, init),
    ast.Stmt.Assign(_sp, _n, ex) => expr_used_names(exprs, ex),
    ast.Stmt.AssignField(_sp, recv, _field, ex) => vec_add_unique(expr_used_names(exprs, ex), recv),
    ast.Stmt.ExprStmt(_sp, ex) => expr_used_names(exprs, ex),
    ast.Stmt.IfStmt(_sp, cond, then_b, has_else, else_b) => {
      let mut out: Vec[String] = expr_used_names(exprs, cond);
      let mut i: i32 = 0;
      while i < then_b.stmts.len() { out = vec_union_into(out, stmt_used_names(exprs, then_b.stmts.get(i))); i = i + 1; }
      if has_else {
        i = 0;
        while i < else_b.stmts.len() { out = vec_union_into(out, stmt_used_names(exprs, else_b.stmts.get(i))); i = i + 1; }
      }
      out
    },
    ast.Stmt.WhileStmt(_sp, cond, body) => {
      let mut out: Vec[String] = expr_used_names(exprs, cond);
      let mut i: i32 = 0;
      while i < body.stmts.len() { out = vec_union_into(out, stmt_used_names(exprs, body.stmts.get(i))); i = i + 1; }
      out
    },
    ast.Stmt.TryBegin(_sp, _out) => Vec(),
    ast.Stmt.TryEnd(_sp) => Vec(),
    ast.Stmt.Break(_sp) => Vec(),
    ast.Stmt.Continue(_sp) => Vec(),
    ast.Stmt.ReturnStmt(_sp, has_ex, ex) => if has_ex { expr_used_names(exprs, ex) } else { Vec() },
  };
}

struct AwaitInfo { ok: bool, operand: i32, is_try: bool }

fn stmt_await_info(exprs: ast.ExprPool, st: ast.Stmt) -> AwaitInfo {
  let eid: i32 =
    if match st { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, _e) => true, _ => false } {
      match st { ast.Stmt.Let(_sp, _m, _n, _ha, _ann, e) => e, _ => -1 }
    } else if match st { ast.Stmt.ExprStmt(_sp, _e) => true, _ => false } {
      match st { ast.Stmt.ExprStmt(_sp, e) => e, _ => -1 }
    } else if match st { ast.Stmt.ReturnStmt(_sp, h, _e) => true, _ => false } {
      let has0: bool = match st { ast.Stmt.ReturnStmt(_sp, h, _e) => h, _ => false };
      if has0 { match st { ast.Stmt.ReturnStmt(_sp, _h, e) => e, _ => -1 } } else { -1 }
    } else { -1 };
  if eid == -1 { return AwaitInfo { ok: false, operand: -1, is_try: false }; }

  let n: ast.ExprNode = ast.expr_pool_get(exprs, eid);
  if match n { ast.ExprNode.Await(_x) => true, _ => false } {
    let op: i32 = match n { ast.ExprNode.Await(x) => x, _ => -1 };
    return AwaitInfo { ok: true, operand: op, is_try: false };
  }
  if match n { ast.ExprNode.Try(_x) => true, _ => false } {
    let x: i32 = match n { ast.ExprNode.Try(y) => y, _ => -1 };
    let nx: ast.ExprNode = ast.expr_pool_get(exprs, x);
    if match nx { ast.ExprNode.Await(_y) => true, _ => false } {
      let op: i32 = match nx { ast.ExprNode.Await(y) => y, _ => -1 };
      return AwaitInfo { ok: true, operand: op, is_try: true };
    }
  }
  return AwaitInfo { ok: false, operand: -1, is_try: false };
}

struct Build {
  exprs: ast.ExprPool,
  blocks: Vec[Block],
  next_id: i32,
  next_await: i32,
  resume: Vec[i32],
}

struct BuildNewBlockResult { b: Build, id: i32 }

fn build_new_block(b0: Build) -> BuildNewBlockResult {
  let mut b: Build = b0;
  let id: i32 = b.next_id;
  b.next_id = b.next_id + 1;
  b.blocks.push(Block { id: id, stmts: Vec(), payload: Payload.Normal, term: Term.Unset, resume: false });
  return BuildNewBlockResult { b: b, id: id };
}

fn blocks_replace_at(xs: Vec[Block], idx: i32, v: Block) -> Vec[Block] {
  let mut out: Vec[Block] = Vec();
  let mut i: i32 = 0;
  while i < xs.len() {
    if i == idx { out.push(v); } else { out.push(xs.get(i)); }
    i = i + 1;
  }
  return out;
}

fn build_find_block_idx(bs: Vec[Block], id: i32) -> i32 {
  let mut i: i32 = 0;
  while i < bs.len() {
    if bs.get(i).id == id { return i; }
    i = i + 1;
  }
  return -1;
}

fn build_push_stmt(b0: Build, bid: i32, st: ast.Stmt) -> Build {
  let mut b: Build = b0;
  let idx: i32 = build_find_block_idx(b.blocks, bid);
  if idx == -1 { return b; }
  let mut bb: Block = b.blocks.get(idx);
  bb.stmts.push(st);
  b.blocks = blocks_replace_at(b.blocks, idx, bb);
  return b;
}

fn build_set_term(b0: Build, bid: i32, t: Term) -> Build {
  let mut b: Build = b0;
  let idx: i32 = build_find_block_idx(b.blocks, bid);
  if idx == -1 { return b; }
  let mut bb: Block = b.blocks.get(idx);
  bb.term = t;
  b.blocks = blocks_replace_at(b.blocks, idx, bb);
  return b;
}

fn build_set_payload(b0: Build, bid: i32, p: Payload) -> Build {
  let mut b: Build = b0;
  let idx: i32 = build_find_block_idx(b.blocks, bid);
  if idx == -1 { return b; }
  let mut bb: Block = b.blocks.get(idx);
  bb.payload = p;
  b.blocks = blocks_replace_at(b.blocks, idx, bb);
  return b;
}

fn build_mark_resume(b0: Build, bid: i32) -> Build {
  let mut b: Build = b0;
  let idx: i32 = build_find_block_idx(b.blocks, bid);
  if idx == -1 { return b; }
  let mut bb: Block = b.blocks.get(idx);
  bb.resume = true;
  b.blocks = blocks_replace_at(b.blocks, idx, bb);
  b.resume.push(bid);
  return b;
}

struct LowerResult { b: Build, cur: i32 }

fn lower_stmt_list(b0: Build, ss: Vec[ast.Stmt], cur0: i32, break_tgt: i32, continue_tgt: i32) -> LowerResult {
  let mut b: Build = b0;
  let mut cur: i32 = cur0;

  let mut i: i32 = 0;
  while i < ss.len() {
    let st: ast.Stmt = ss.get(i);

    if match st { ast.Stmt.IfStmt(_sp, _c, _t, _h, _e) => true, _ => false } {
      let cond: i32 = match st { ast.Stmt.IfStmt(_sp, c0, _t, _h, _e) => c0, _ => -1 };
      let then_b: ast.Block = match st { ast.Stmt.IfStmt(_sp, _c, t0, _h, _e) => t0, _ => ast.Block { stmts: Vec() } };
      let has_else: bool = match st { ast.Stmt.IfStmt(_sp, _c, _t, h0, _e) => h0, _ => false };
      let else_b: ast.Block = match st { ast.Stmt.IfStmt(_sp, _c, _t, _h, e0) => e0, _ => ast.Block { stmts: Vec() } };

      let rj: BuildNewBlockResult = build_new_block(b); b = rj.b; let join: i32 = rj.id;
      let rt: BuildNewBlockResult = build_new_block(b); b = rt.b; let then_entry: i32 = rt.id;
      let else_entry: i32 =
        if has_else {
          let re: BuildNewBlockResult = build_new_block(b); b = re.b; re.id
        } else { join };

      let r_then: LowerResult = lower_stmt_list(b, then_b.stmts, then_entry, break_tgt, continue_tgt);
      b = r_then.b;
      let then_end: i32 = r_then.cur;
      if then_end != join {
        b = build_set_term(b, then_end, Term.Goto(join));
      }

      if has_else {
        let r_else: LowerResult = lower_stmt_list(b, else_b.stmts, else_entry, break_tgt, continue_tgt);
        b = r_else.b;
        let else_end: i32 = r_else.cur;
        if else_end != join {
          b = build_set_term(b, else_end, Term.Goto(join));
        }
      }

      b = build_set_term(b, cur, Term.If(cond, then_entry, else_entry));
      cur = join;
      i = i + 1;
      continue;
    }

    if match st { ast.Stmt.WhileStmt(_sp, _c, _b) => true, _ => false } {
      let cond: i32 = match st { ast.Stmt.WhileStmt(_sp, c0, _b) => c0, _ => -1 };
      let body0: ast.Block = match st { ast.Stmt.WhileStmt(_sp, _c0, b0) => b0, _ => ast.Block { stmts: Vec() } };

      let rc: BuildNewBlockResult = build_new_block(b); b = rc.b; let cond_blk: i32 = rc.id;
      let ra: BuildNewBlockResult = build_new_block(b); b = ra.b; let after: i32 = ra.id;
      let rb: BuildNewBlockResult = build_new_block(b); b = rb.b; let body_entry: i32 = rb.id;

      b = build_set_term(b, cur, Term.Goto(cond_blk));
      b = build_set_term(b, cond_blk, Term.If(cond, body_entry, after));

      let r_body: LowerResult = lower_stmt_list(b, body0.stmts, body_entry, after, cond_blk);
      b = r_body.b;
      let body_end: i32 = r_body.cur;
      if body_end != cond_blk {
        b = build_set_term(b, body_end, Term.Goto(cond_blk));
      }

      cur = after;
      i = i + 1;
      continue;
    }

    if match st { ast.Stmt.Break(_sp) => true, _ => false } {
      if break_tgt == -1 {
        return LowerResult { b: b, cur: -1 };
      }
      b = build_set_term(b, cur, Term.Goto(break_tgt));
      let r: BuildNewBlockResult = build_new_block(b);
      b = r.b;
      cur = r.id;
      i = i + 1;
      continue;
    }
    if match st { ast.Stmt.Continue(_sp) => true, _ => false } {
      if continue_tgt == -1 {
        return LowerResult { b: b, cur: -1 };
      }
      b = build_set_term(b, cur, Term.Goto(continue_tgt));
      let r: BuildNewBlockResult = build_new_block(b);
      b = r.b;
      cur = r.id;
      i = i + 1;
      continue;
    }

    // Await statement (let/expr/return) becomes init+poll blocks.
    let ai: AwaitInfo = stmt_await_info(b.exprs, st);
    if ai.ok {
      let await_idx: i32 = b.next_await;
      b.next_await = b.next_await + 1;

      let rp: BuildNewBlockResult = build_new_block(b); b = rp.b; let poll_blk: i32 = rp.id;
      let mut has_next: bool = true;
      let mut next_blk: i32 = -1;
      if match st { ast.Stmt.ReturnStmt(_sp, _h, _e) => true, _ => false } {
        has_next = false;
      } else {
        let rn: BuildNewBlockResult = build_new_block(b); b = rn.b; next_blk = rn.id;
      }

      b = build_set_payload(b, cur, Payload.AwaitInit(await_idx, ai.operand, poll_blk));
      b = build_set_term(b, cur, Term.Goto(poll_blk));

      b = build_set_payload(b, poll_blk, Payload.AwaitPoll(await_idx, st, ai.is_try, next_blk, has_next));
      if has_next {
        b = build_set_term(b, poll_blk, Term.Goto(next_blk));
        cur = next_blk;
      } else {
        b = build_set_term(b, poll_blk, Term.Return);
        let r: BuildNewBlockResult = build_new_block(b);
        b = r.b;
        cur = r.id;
      }
      b = build_mark_resume(b, poll_blk);
      i = i + 1;
      continue;
    }

    if match st { ast.Stmt.ReturnStmt(_sp, _h, _e) => true, _ => false } {
      b = build_push_stmt(b, cur, st);
      b = build_set_term(b, cur, Term.Return);
      let r: BuildNewBlockResult = build_new_block(b);
      b = r.b;
      cur = r.id;
      i = i + 1;
      continue;
    }

    // Simple statement: keep in current block.
    b = build_push_stmt(b, cur, st);
    i = i + 1;
  }

  return LowerResult { b: b, cur: cur };
}

pub fn build(exprs0: ast.ExprPool, b0: ast.Block, allow_fallthrough_return: bool) -> BuildResult {
  let mut b: Build = Build { exprs: exprs0, blocks: Vec(), next_id: 0, next_await: 0, resume: Vec() };
  let r0: BuildNewBlockResult = build_new_block(b);
  b = r0.b;
  let entry: i32 = r0.id;

  let r1: LowerResult = lower_stmt_list(b, b0.stmts, entry, -1, -1);
  b = r1.b;
  let end: i32 = r1.cur;
  if end == -1 {
    return BuildResult { ok: false, err: "break/continue outside loop in async cfg build", blocks: b.blocks, entry: entry, await_count: b.next_await, resume_blocks: b.resume };
  }

  // Close any remaining open block.
  // For unit-return async bodies we allow implicit fallthrough return at block end.
  let idx_end: i32 = build_find_block_idx(b.blocks, end);
  if idx_end != -1 {
    let bb: Block = b.blocks.get(idx_end);
    if match bb.term { Term.Unset => true, _ => false } {
      if allow_fallthrough_return {
        b = build_set_term(b, end, Term.Return);
      } else {
        b = build_set_term(b, end, Term.Panic);
      }
    }
  }

  return BuildResult { ok: true, err: "", blocks: b.blocks, entry: entry, await_count: b.next_await, resume_blocks: b.resume };
}

pub struct CapturesResult { pub ok: bool, pub err: String, pub captures: Vec[String] }

fn ids_index_of(ids: Vec[i32], id: i32) -> i32 {
  let mut i: i32 = 0;
  while i < ids.len() {
    if ids.get(i) == id { return i; }
    i = i + 1;
  }
  return -1;
}

fn blocks_replace_vec_vec(xs: Vec[Vec[String]], idx: i32, v: Vec[String]) -> Vec[Vec[String]] {
  let mut out: Vec[Vec[String]] = Vec();
  let mut i: i32 = 0;
  while i < xs.len() {
    if i == idx { out.push(v); } else { out.push(xs.get(i)); }
    i = i + 1;
  }
  return out;
}

// Compute captures as names that are live-in at any resume block (await poll state).
// `exclude` lets callers remove params (they already live in the frame as p_<name>).
pub fn captures(exprs: ast.ExprPool, cfg: BuildResult, exclude: Vec[String]) -> CapturesResult {
  if !cfg.ok {
    return CapturesResult { ok: false, err: cfg.err, captures: Vec() };
  }

  // Map block id -> index.
  let mut ids: Vec[i32] = Vec();
  let mut i: i32 = 0;
  while i < cfg.blocks.len() { ids.push(cfg.blocks.get(i).id); i = i + 1; }

  // Precompute per-block use/def sets at block-entry granularity (uses before defs).
  let mut use0: Vec[Vec[String]] = Vec();
  let mut def0: Vec[Vec[String]] = Vec();

  i = 0;
  while i < cfg.blocks.len() {
    let blk: Block = cfg.blocks.get(i);
    let mut use_s: Vec[String] = Vec();
    let mut def_s: Vec[String] = Vec();

    let mut j: i32 = 0;
    while j < blk.stmts.len() {
      let st: ast.Stmt = blk.stmts.get(j);
      let used: Vec[String] = stmt_used_names(exprs, st);
      let mut ui: i32 = 0;
      while ui < used.len() {
        let nm: String = used.get(ui);
        if !vec_contains(def_s, nm) { use_s = vec_add_unique(use_s, nm); }
        ui = ui + 1;
      }
      let dn: String = stmt_def_name(st);
      if dn != "" { def_s = vec_add_unique(def_s, dn); }
      j = j + 1;
    }

    // Payload uses/defs.
    if match blk.payload { Payload.AwaitInit(_k, _op, _p) => true, _ => false } {
      let op: i32 = match blk.payload { Payload.AwaitInit(_k, op0, _p) => op0, _ => -1 };
      let used2: Vec[String] = expr_used_names(exprs, op);
      let mut ui2: i32 = 0;
      while ui2 < used2.len() {
        let nm2: String = used2.get(ui2);
        if !vec_contains(def_s, nm2) { use_s = vec_add_unique(use_s, nm2); }
        ui2 = ui2 + 1;
      }
    }
    if match blk.payload { Payload.AwaitPoll(_k, _st, _is_try, _n, _h) => true, _ => false } {
      let st0: ast.Stmt = match blk.payload { Payload.AwaitPoll(_k, s0, _t, _n, _h) => s0, _ => ast.Stmt.Break(ast.span0()) };
      let dn0: String = stmt_def_name(st0);
      if dn0 != "" { def_s = vec_add_unique(def_s, dn0); }
    }

    if match blk.term { Term.If(_c, _t, _e) => true, _ => false } {
      let c: i32 = match blk.term { Term.If(c0, _t, _e) => c0, _ => -1 };
      let usedc: Vec[String] = expr_used_names(exprs, c);
      let mut uc: i32 = 0;
      while uc < usedc.len() {
        let nm3: String = usedc.get(uc);
        if !vec_contains(def_s, nm3) { use_s = vec_add_unique(use_s, nm3); }
        uc = uc + 1;
      }
    }

    use0.push(use_s);
    def0.push(def_s);
    i = i + 1;
  }

  // Successors.
  let mut succs: Vec[Vec[i32]] = Vec();
  i = 0;
  while i < cfg.blocks.len() {
    let blk: Block = cfg.blocks.get(i);
    let mut ss: Vec[i32] = Vec();
    if match blk.term { Term.Goto(_t) => true, _ => false } {
      ss.push(match blk.term { Term.Goto(t0) => t0, _ => -1 });
    } else if match blk.term { Term.If(_c, _t, _e) => true, _ => false } {
      let a: i32 = match blk.term { Term.If(_c, t0, _e) => t0, _ => -1 };
      let b: i32 = match blk.term { Term.If(_c, _t, e0) => e0, _ => -1 };
      ss.push(a);
      if b != a { ss.push(b); }
    }
    succs.push(ss);
    i = i + 1;
  }

  // Iterative liveness to fixpoint.
  let mut live_in: Vec[Vec[String]] = Vec();
  let mut live_out: Vec[Vec[String]] = Vec();
  i = 0;
  while i < cfg.blocks.len() { live_in.push(Vec()); live_out.push(Vec()); i = i + 1; }

  let mut changed: bool = true;
  let mut iter: i32 = 0;
  while changed && iter < 1000 {
    changed = false;
    iter = iter + 1;
    let mut bi: i32 = cfg.blocks.len() - 1;
    while bi >= 0 {
      let mut out_set: Vec[String] = Vec();
      let mut si: i32 = 0;
      while si < succs.get(bi).len() {
        let tid: i32 = succs.get(bi).get(si);
        let ti: i32 = ids_index_of(ids, tid);
        if ti != -1 { out_set = vec_union_into(out_set, live_in.get(ti)); }
        si = si + 1;
      }

      let mut in_set: Vec[String] = use0.get(bi);
      // out - def
      let mut oi: i32 = 0;
      while oi < out_set.len() {
        let nm: String = out_set.get(oi);
        if !vec_contains(def0.get(bi), nm) { in_set = vec_add_unique(in_set, nm); }
        oi = oi + 1;
      }

      if out_set.len() != live_out.get(bi).len() || in_set.len() != live_in.get(bi).len() {
        // Conservative equality check: compare by length and membership.
        let mut diff: bool = false;
        let mut k: i32 = 0;
        while k < out_set.len() {
          if !vec_contains(live_out.get(bi), out_set.get(k)) { diff = true; }
          k = k + 1;
        }
        k = 0;
        while k < in_set.len() {
          if !vec_contains(live_in.get(bi), in_set.get(k)) { diff = true; }
          k = k + 1;
        }
        if diff { changed = true; }
      }
      live_out = blocks_replace_vec_vec(live_out, bi, out_set);
      live_in = blocks_replace_vec_vec(live_in, bi, in_set);
      bi = bi - 1;
    }
  }

  let mut caps: Vec[String] = Vec();
  i = 0;
  while i < cfg.resume_blocks.len() {
    let bid: i32 = cfg.resume_blocks.get(i);
    let bi: i32 = ids_index_of(ids, bid);
    if bi != -1 {
      caps = vec_union_into(caps, live_in.get(bi));
    }
    i = i + 1;
  }

  // Exclude params etc.
  let mut out_caps: Vec[String] = Vec();
  i = 0;
  while i < caps.len() {
    let nm: String = caps.get(i);
    if !vec_contains(exclude, nm) { out_caps = vec_add_unique(out_caps, nm); }
    i = i + 1;
  }

  return CapturesResult { ok: true, err: "", captures: out_caps };
}
