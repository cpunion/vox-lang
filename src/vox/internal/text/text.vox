// internal text helpers shared by compiler modules.

fn str_as_ptr(s: String) -> rawptr {
  let cp: const rawptr = s as const rawptr;
  let ip: isize = cp as isize;
  return ip as rawptr;
}

fn ptr_next(p: rawptr) -> rawptr {
  return @ptr_offset(p, 1 as isize);
}

pub fn has_prefix(s: String, pre: String) -> bool {
  if s.len() < pre.len() { return false; }
  return s.slice(0, pre.len()) == pre;
}

pub fn has_suffix(s: String, suf: String) -> bool {
  if s.len() < suf.len() { return false; }
  return s.slice(s.len() - suf.len(), s.len()) == suf;
}

pub fn is_space(ch: i32) -> bool {
  return ch == 32 || ch == 9 || ch == 10 || ch == 13;
}

pub fn index_byte(s: String, b: i32) -> i32 {
  let mut i: i32 = 0;
  while i < s.len() {
    if s.byte_at(i) == b { return i; }
    i = i + 1;
  }
  return -1;
}

pub fn trim_space(s: String) -> String {
  let n: i32 = s.len();
  if n == 0 { return ""; }
  let mut i: i32 = 0;
  while i < n && is_space(s.byte_at(i)) { i = i + 1; }
  let mut j: i32 = n;
  while j > i && is_space(s.byte_at(j - 1)) { j = j - 1; }
  return s.slice(i, j);
}

pub fn unquote_double_trimmed(s0: String) -> String {
  let s: String = trim_space(s0);
  if s.len() >= 2 && s.byte_at(0) == 34 && s.byte_at(s.len() - 1) == 34 {
    return s.slice(1, s.len() - 1);
  }
  return s;
}

pub fn contains_str(vs: Vec[String], s: String) -> bool {
  let mut i: i32 = 0;
  while i < vs.len() {
    if vs.get(i) == s { return true; }
    i = i + 1;
  }
  return false;
}

pub fn split_lines(text: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let n: i32 = text.len();
  let mut i: i32 = 0;
  let mut start: i32 = 0;
  let mut p: rawptr = str_as_ptr(text);
  while i < n {
    if (@ptr_read[u8](p) as i32) == 10 { // '\n'
      out.push(text.slice(start, i));
      start = i + 1;
    }
    p = ptr_next(p);
    i = i + 1;
  }
  if start <= n { out.push(text.slice(start, n)); }
  return out;
}

pub fn split_by_comma(text: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let n: i32 = text.len();
  let mut i: i32 = 0;
  let mut start: i32 = 0;
  let mut p: rawptr = str_as_ptr(text);
  while i < n {
    if (@ptr_read[u8](p) as i32) == 44 { // ','
      out.push(text.slice(start, i));
      start = i + 1;
    }
    p = ptr_next(p);
    i = i + 1;
  }
  if start <= n { out.push(text.slice(start, n)); }
  return out;
}
