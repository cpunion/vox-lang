import "std/testing" as t
import "vox/fmt" as fmt

fn test_fmt_top_level_items_have_blank_line_smoke() -> () {
  let src: String =
    "import \"a\"\n"
      .concat("import \"b\"\n")
      .concat("fn a() -> i32 { return 1; }\n")
      .concat("@track_caller\n")
      .concat("fn p(msg: String) -> i32 { return 0; }\n")
      .concat("fn b() -> i32 { return 2; }\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "import \"a\"\n"
      .concat("import \"b\"\n")
      .concat("\n")
      .concat("fn a() -> i32 { return 1; }\n")
      .concat("\n")
      .concat("@track_caller\n")
      .concat("fn p(msg: String) -> i32 { return 0; }\n")
      .concat("\n")
      .concat("fn b() -> i32 { return 2; }\n");
  t.assert_eq(got, want);
}

fn test_fmt_indent_and_blank_lines_smoke() -> () {
  let src: String =
    "fn main()->i32 {\n"
      .concat("let x:i32=1;    \n")
      .concat("\n")
      .concat("\n")
      .concat("if x>0 {\n")
      .concat("return x;\n")
      .concat("}\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn main()->i32 {\n"
      .concat("  let x:i32=1;\n")
      .concat("\n")
      .concat("  if x>0 {\n")
      .concat("    return x;\n")
      .concat("  }\n")
      .concat("}\n");
  if got != want {
    print(got);
    print("---\n");
    print(want);
  }
  t.assert_eq(got, want);
}

fn test_fmt_preserve_triple_string_smoke() -> () {
  let src: String =
    "fn main() -> () {\n"
      .concat("let s: String = \"\"\"\n")
      .concat("{ keep } // not comment\n")
      .concat("\"\"\";\n")
      .concat("if true {\n")
      .concat("return;\n")
      .concat("}\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn main() -> () {\n"
      .concat("  let s: String = \"\"\"\n")
      .concat("{ keep } // not comment\n")
      .concat("\"\"\";\n")
      .concat("  if true {\n")
      .concat("    return;\n")
      .concat("  }\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_continuation_indent_smoke() -> () {
  let src: String =
    "fn main() -> String {\n"
      .concat("let mode: String =\n")
      .concat("if true {\n")
      .concat("\"a\"\n")
      .concat("} else {\n")
      .concat("\"b\"\n")
      .concat("};\n")
      .concat("let s: String = \"x\"\n")
      .concat(".concat(\"y\")\n")
      .concat(".concat(\"z\");\n")
      .concat("let ok: bool =\n")
      .concat("true ||\n")
      .concat("false;\n")
      .concat("match mode {\n")
      .concat("\"a\" =>\n")
      .concat("\"yes\",\n")
      .concat("_ => \"no\",\n")
      .concat("}\n")
      .concat("}\n");

  let got: String = fmt.format_text(src);
  let want: String =
    "fn main() -> String {\n"
      .concat("  let mode: String =\n")
      .concat("    if true {\n")
      .concat("      \"a\"\n")
      .concat("    } else {\n")
      .concat("      \"b\"\n")
      .concat("    };\n")
      .concat("  let s: String = \"x\"\n")
      .concat("    .concat(\"y\")\n")
      .concat("    .concat(\"z\");\n")
      .concat("  let ok: bool =\n")
      .concat("    true ||\n")
      .concat("    false;\n")
      .concat("  match mode {\n")
      .concat("    \"a\" =>\n")
      .concat("      \"yes\",\n")
      .concat("    _ => \"no\",\n")
      .concat("  }\n")
      .concat("}\n");

  t.assert_eq(got, want);
}

fn test_fmt_continuation_scope_inner_semicolon_smoke() -> () {
  let src: String =
    "fn main() -> String {\n"
      .concat("let os: String =\n")
      .concat("if true {\n")
      .concat("let x: i32 = 1;\n")
      .concat("if x > 0 { \"a\" } else { \"b\" }\n")
      .concat("} else {\n")
      .concat("\"c\"\n")
      .concat("};\n")
      .concat("return os;\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn main() -> String {\n"
      .concat("  let os: String =\n")
      .concat("    if true {\n")
      .concat("      let x: i32 = 1;\n")
      .concat("      if x > 0 { \"a\" } else { \"b\" }\n")
      .concat("    } else {\n")
      .concat("      \"c\"\n")
      .concat("    };\n")
      .concat("  return os;\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_return_multiline_match_smoke() -> () {
  let src: String =
    "fn f(x: i32) -> bool {\n"
      .concat("return\n")
      .concat("match x {\n")
      .concat("1 => true,\n")
      .concat("_ => false,\n")
      .concat("};\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn f(x: i32) -> bool {\n"
      .concat("  return\n")
      .concat("    match x {\n")
      .concat("      1 => true,\n")
      .concat("      _ => false,\n")
      .concat("    };\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_return_bool_chain_indent_smoke() -> () {
  let src: String =
    "fn ok(cmd: String) -> bool {\n"
      .concat("return\n")
      .concat("cmd == \"build\"\n")
      .concat("|| cmd == \"test\"\n")
      .concat("|| cmd == \"run\";\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn ok(cmd: String) -> bool {\n"
      .concat("  return\n")
      .concat("    cmd == \"build\"\n")
      .concat("      || cmd == \"test\"\n")
      .concat("      || cmd == \"run\";\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_nested_call_arg_indent_smoke() -> () {
  let src: String =
    "fn main() -> String {\n"
      .concat("return lock_err(\n")
      .concat("\"a\".concat(\"b\").concat(\n")
      .concat("\"c\")\n")
      .concat(");\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn main() -> String {\n"
      .concat("  return lock_err(\n")
      .concat("    \"a\".concat(\"b\").concat(\n")
      .concat("      \"c\"),\n")
      .concat("  );\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_struct_field_in_call_no_extra_paren_indent_smoke() -> () {
  let src: String =
    "fn main() -> () {\n"
      .concat("let mut ds: Vec[String] = Vec();\n")
      .concat("ds.push(Item {\n")
      .concat("name: \"a\",\n")
      .concat("value: \"b\",\n")
      .concat("});\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn main() -> () {\n"
      .concat("  let mut ds: Vec[String] = Vec();\n")
      .concat("  ds.push(Item {\n")
      .concat("    name: \"a\",\n")
      .concat("    value: \"b\",\n")
      .concat("  });\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_dot_chain_in_call_uses_single_extra_level_smoke() -> () {
  let src: String =
    "fn main() -> String {\n"
      .concat("return vec1(\"  \"\n")
      .concat(".concat(\"a\")\n")
      .concat(".concat(\"b\"));\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn main() -> String {\n"
      .concat("  return vec1(\"  \"\n")
      .concat("      .concat(\"a\")\n")
      .concat("      .concat(\"b\"));\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_fn_params_keep_single_indent_smoke() -> () {
  let src: String =
    "fn add(\n"
      .concat("a: i32,\n")
      .concat("b: i32,\n")
      .concat(") -> i32 {\n")
      .concat("return a + b;\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn add(\n"
      .concat("  a: i32,\n")
      .concat("  b: i32,\n")
      .concat(") -> i32 {\n")
      .concat("  return a + b;\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_call_args_after_comma_indent_smoke() -> () {
  let src: String =
    "fn main() -> i32 {\n"
      .concat("let x: i32 = sum(\n")
      .concat("1,\n")
      .concat("cfg.Value { a: 1 }\n")
      .concat(");\n")
      .concat("return x;\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn main() -> i32 {\n"
      .concat("  let x: i32 = sum(\n")
      .concat("    1,\n")
      .concat("    cfg.Value { a: 1 },\n")
      .concat("  );\n")
      .concat("  return x;\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_call_closer_in_assignment_scope_indent_smoke() -> () {
  let src: String =
    "fn main() -> () {\n"
      .concat("let x: i32 =\n")
      .concat("sum(\n")
      .concat("1,\n")
      .concat("2\n")
      .concat(");\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn main() -> () {\n"
      .concat("  let x: i32 =\n")
      .concat("    sum(\n")
      .concat("      1,\n")
      .concat("      2,\n")
      .concat("    );\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_fn_params_add_trailing_comma_smoke() -> () {
  let src: String =
    "fn report(\n"
      .concat("discovered: i32,\n")
      .concat("total_ns: i64\n")
      .concat(") -> () {\n")
      .concat("return;\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn report(\n"
      .concat("  discovered: i32,\n")
      .concat("  total_ns: i64,\n")
      .concat(") -> () {\n")
      .concat("  return;\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_comment_in_struct_literal_call_align_smoke() -> () {
  let src: String =
    "fn main() -> () {\n"
      .concat("let mut fs: Vec[ld.SourceFile] = Vec();\n")
      .concat("fs.push(ld.SourceFile {\n")
      .concat("path: \"src/main.vox\",\n")
      .concat("// Repro\n")
      .concat("text: \"x\",\n")
      .concat("});\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn main() -> () {\n"
      .concat("  let mut fs: Vec[ld.SourceFile] = Vec();\n")
      .concat("  fs.push(ld.SourceFile {\n")
      .concat("    path: \"src/main.vox\",\n")
      .concat("    // Repro\n")
      .concat("    text: \"x\",\n")
      .concat("  });\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_struct_field_label_value_continuation_indent_smoke() -> () {
  let src: String =
    "fn main() -> () {\n"
      .concat("let mut fs: Vec[ld.SourceFile] = Vec();\n")
      .concat("fs.push(ld.SourceFile {\n")
      .concat("text:\n")
      .concat("\"a\"\n")
      .concat(".concat(\"b\"),\n")
      .concat("});\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn main() -> () {\n"
      .concat("  let mut fs: Vec[ld.SourceFile] = Vec();\n")
      .concat("  fs.push(ld.SourceFile {\n")
      .concat("    text:\n")
      .concat("      \"a\"\n")
      .concat("        .concat(\"b\"),\n")
      .concat("  });\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_triple_string_assignment_scope_closes_on_terminator_smoke() -> () {
  let src: String =
    "fn main() -> () {\n"
      .concat("let a: i32 = add(\"\"\"\n")
      .concat("x\n")
      .concat("\"\"\");\n")
      .concat("let b: i32 = add(\"\"\"\n")
      .concat("y\n")
      .concat("\"\"\");\n")
      .concat("let c: i32 = 1;\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn main() -> () {\n"
      .concat("  let a: i32 = add(\"\"\"\n")
      .concat("x\n")
      .concat("\"\"\");\n")
      .concat("  let b: i32 = add(\"\"\"\n")
      .concat("y\n")
      .concat("\"\"\");\n")
      .concat("  let c: i32 = 1;\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_match_arm_multiline_expr_indent_smoke() -> () {
  let src: String =
    "fn main() -> i32 {\n"
      .concat("return\n")
      .concat("match x {\n")
      .concat("A =>\n")
      .concat("if cond {\n")
      .concat("1\n")
      .concat("} else {\n")
      .concat("2\n")
      .concat("},\n")
      .concat("B => 3,\n")
      .concat("};\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn main() -> i32 {\n"
      .concat("  return\n")
      .concat("    match x {\n")
      .concat("      A =>\n")
      .concat("        if cond {\n")
      .concat("          1\n")
      .concat("        } else {\n")
      .concat("          2\n")
      .concat("        },\n")
      .concat("      B => 3,\n")
      .concat("    };\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_nested_match_in_continuation_block_indent_smoke() -> () {
  let src: String =
    "fn t() -> bool {\n"
      .concat("let ok_shape: bool = match n0 {\n")
      .concat("ast.ExprNode.Await(inner) => match ast.expr_pool_get(r.prog.exprs, inner) {\n")
      .concat("ast.ExprNode.Call(callee, _targs, args) => args.len() == 0 &&\n")
      .concat("match ast.expr_pool_get(r.prog.exprs, callee) {\n")
      .concat("ast.ExprNode.Member(recv, name) => name == \"f\" &&\n")
      .concat("match ast.expr_pool_get(r.prog.exprs, recv) {\n")
      .concat("ast.ExprNode.Ident(v) => v == \"s\",\n")
      .concat("_ => false,\n")
      .concat("},\n")
      .concat("_ => false,\n")
      .concat("},\n")
      .concat("_ => false,\n")
      .concat("},\n")
      .concat("_ => false,\n")
      .concat("};\n")
      .concat("return ok_shape;\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn t() -> bool {\n"
      .concat("  let ok_shape: bool = match n0 {\n")
      .concat("    ast.ExprNode.Await(inner) => match ast.expr_pool_get(r.prog.exprs, inner) {\n")
      .concat("      ast.ExprNode.Call(callee, _targs, args) => args.len() == 0 &&\n")
      .concat("        match ast.expr_pool_get(r.prog.exprs, callee) {\n")
      .concat("          ast.ExprNode.Member(recv, name) => name == \"f\" &&\n")
      .concat("            match ast.expr_pool_get(r.prog.exprs, recv) {\n")
      .concat("              ast.ExprNode.Ident(v) => v == \"s\",\n")
      .concat("              _ => false,\n")
      .concat("            },\n")
      .concat("          _ => false,\n")
      .concat("        },\n")
      .concat("      _ => false,\n")
      .concat("    },\n")
      .concat("    _ => false,\n")
      .concat("  };\n")
      .concat("  return ok_shape;\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_match_arm_dot_chain_in_paren_not_over_indented_smoke() -> () {
  let src: String =
    "fn t() -> i32 {\n"
      .concat("return match x {\n")
      .concat("A =>\n")
      .concat("vec1(\"  \"\n")
      .concat(".concat(\"a\")\n")
      .concat(".concat(\"b\")),\n")
      .concat("_ => 0,\n")
      .concat("};\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn t() -> i32 {\n"
      .concat("  return match x {\n")
      .concat("    A =>\n")
      .concat("      vec1(\"  \"\n")
      .concat("        .concat(\"a\")\n")
      .concat("        .concat(\"b\")),\n")
      .concat("    _ => 0,\n")
      .concat("  };\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_nested_match_arm_stack_indent_smoke() -> () {
  let src: String =
    "fn t() -> bool {\n"
      .concat("let ok0: bool = match st {\n")
      .concat("S =>\n")
      .concat("has && match expr {\n")
      .concat("M =>\n")
      .concat("arms.len() == 2 &&\n")
      .concat("match p { _ => false },\n")
      .concat("_ => false,\n")
      .concat("},\n")
      .concat("_ => false,\n")
      .concat("};\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn t() -> bool {\n"
      .concat("  let ok0: bool = match st {\n")
      .concat("    S =>\n")
      .concat("      has && match expr {\n")
      .concat("        M =>\n")
      .concat("          arms.len() == 2 &&\n")
      .concat("            match p { _ => false },\n")
      .concat("        _ => false,\n")
      .concat("      },\n")
      .concat("    _ => false,\n")
      .concat("  };\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_match_expr_arg_closing_brace_indent_smoke() -> () {
  let src: String =
    "fn t() -> () {\n"
      .concat("t.assert_with(\n")
      .concat("match n {\n")
      .concat("A => true,\n")
      .concat("_ => false,\n")
      .concat("},\n")
      .concat("\"msg\");\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn t() -> () {\n"
      .concat("  t.assert_with(\n")
      .concat("    match n {\n")
      .concat("      A => true,\n")
      .concat("      _ => false,\n")
      .concat("    },\n")
      .concat("    \"msg\");\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_else_if_split_condition_continuation_smoke() -> () {
  let src: String =
    "fn t(a: bool, b: bool) -> bool {\n"
      .concat("if a {\n")
      .concat("return true;\n")
      .concat("} else if\n")
      .concat("a ||\n")
      .concat("b {\n")
      .concat("return false;\n")
      .concat("}\n")
      .concat("return false;\n")
      .concat("}\n");
  let got: String = fmt.format_text(src);
  let want: String =
    "fn t(a: bool, b: bool) -> bool {\n"
      .concat("  if a {\n")
      .concat("    return true;\n")
      .concat("  } else if\n")
      .concat("    a ||\n")
      .concat("    b {\n")
      .concat("    return false;\n")
      .concat("  }\n")
      .concat("  return false;\n")
      .concat("}\n");
  t.assert_eq(got, want);
}

fn test_fmt_discover_files_file_and_dir_smoke() -> () {
  let mut paths: Vec[String] = Vec();
  paths.push("src/main.vox");
  paths.push("src/vox/fmt");
  let files: Vec[String] = fmt.discover_files(paths);
  t.assert(files.len() > 0);
}
