// Stability: Experimental module API (vox/fmt).

import "std/fs" as fs
import "std/sys" as sys
import "vox/internal/source" as srcw
import "vox/internal/text" as txt

struct ScanState {
  brace_delta: i32,
  paren_delta: i32,
  leading_paren_close: i32,
  in_triple: bool,
}

fn is_space_tab(b: i32) -> bool { return b == 32 || b == 9; }

fn str_as_ptr(s: String) -> rawptr {
  return (s as const rawptr) as isize as rawptr;
}

fn byte_at_unchecked(s: String, idx: i32) -> i32 {
  let p: rawptr = @ptr_offset(str_as_ptr(s), idx as isize);
  return @ptr_read[u8](p) as i32;
}

fn slice_unchecked(s: String, start: i32, end: i32) -> String {
  let m: i32 = end - start;
  let out: rawptr = sys.malloc((m as usize) + (1 as usize));
  if (out as isize) == (0 as isize) { panic("out of memory"); }
  let srcp: rawptr = @ptr_offset(str_as_ptr(s), start as isize);
  let _: rawptr = sys.memcpy(out, srcp as const rawptr, m as usize);
  @ptr_write[u8](@ptr_offset(out, m as isize), 0 as u8);
  return out as String;
}

fn range_has_non_ws(s: String, start: i32, end: i32) -> bool {
  let mut i: i32 = start;
  while i < end {
    let b: i32 = byte_at_unchecked(s, i);
    if !is_space_tab(b) && b != 13 { return true; }
    i = i + 1;
  }
  return false;
}

fn trim_range_to_string(s: String, start: i32, end: i32) -> String {
  let mut i: i32 = start;
  while i < end {
    let b: i32 = byte_at_unchecked(s, i);
    if !is_space_tab(b) && b != 13 { break; }
    i = i + 1;
  }
  let mut j: i32 = end;
  while j > i {
    let b: i32 = byte_at_unchecked(s, j - 1);
    if !is_space_tab(b) && b != 13 { break; }
    j = j - 1;
  }
  return slice_unchecked(s, i, j);
}

fn has_suffix(s: String, suf: String) -> bool {
  return txt.has_suffix(s, suf);
}

fn has_prefix(s: String, pre: String) -> bool {
  return txt.has_prefix(s, pre);
}

fn line_has_non_ws(s: String) -> bool {
  let n: i32 = s.len();
  let mut i: i32 = 0;
  while i < n {
    let b: i32 = byte_at_unchecked(s, i);
    if !is_space_tab(b) && b != 13 {
      return true;
    }
    i = i + 1;
  }
  return false;
}

fn is_ident_continue_ascii(b: i32) -> bool {
  if b >= 65 && b <= 90 { return true; } // A-Z
  if b >= 97 && b <= 122 { return true; } // a-z
  if b >= 48 && b <= 57 { return true; } // 0-9
  if b == 95 { return true; } // '_'
  return false;
}

fn trim_left_ws(s: String) -> String {
  let n: i32 = s.len();
  let mut i: i32 = 0;
  while i < n && is_space_tab(byte_at_unchecked(s, i)) {
    i = i + 1;
  }
  return s.slice(i, n);
}

fn trim_right_ws(s: String) -> String {
  let n: i32 = s.len();
  if n == 0 { return s; }
  let mut i: i32 = n - 1;
  while i >= 0 {
    let b: i32 = byte_at_unchecked(s, i);
    if !is_space_tab(b) && b != 13 {
      return s.slice(0, i + 1);
    }
    i = i - 1;
  }
  return "";
}

fn strip_line_comment(s: String) -> String {
  let n: i32 = s.len();
  let mut i: i32 = 0;
  while i < n {
    if i + 1 < n && byte_at_unchecked(s, i) == 47 && byte_at_unchecked(s, i + 1) == 47 {
      return s.slice(0, i);
    }
    if byte_at_unchecked(s, i) == 34 { // string
      i = i + 1;
      while i < n {
        let b: i32 = byte_at_unchecked(s, i);
        if b == 92 { // escape
          i = i + 2;
          continue;
        }
        if b == 34 {
          i = i + 1;
          break;
        }
        i = i + 1;
      }
      continue;
    }
    i = i + 1;
  }
  return s;
}

fn line_starts_with_continuation_clean(s: String) -> bool {
  let n: i32 = s.len();
  if n == 0 { return false; }
  // '.' chain line, or infix boolean continuation.
  if byte_at_unchecked(s, 0) == 46 { return true; } // '.'
  if n >= 2 && byte_at_unchecked(s, 0) == 124 && byte_at_unchecked(s, 1) == 124 { return true; } // "||"
  if n >= 2 && byte_at_unchecked(s, 0) == 38 && byte_at_unchecked(s, 1) == 38 { return true; } // "&&"
  return false;
}

fn line_starts_with_continuation(s0: String) -> bool {
  let s: String = trim_left_ws(strip_line_comment(s0));
  return line_starts_with_continuation_clean(s);
}

fn line_ends_with_scope_start_clean(s: String) -> bool {
  if s.len() == 0 { return false; }
  let t: String = trim_left_ws(s);
  if t == "return" { return true; }
  let n: i32 = s.len();
  let c1: i32 = byte_at_unchecked(s, n - 1);
  let c0: i32 = if n >= 2 { byte_at_unchecked(s, n - 2) } else { -1 };
  // assignment "=" (not comparison), and match arm "=>".
  if c1 == 61 {
    if c0 == 61 || c0 == 33 || c0 == 60 || c0 == 62 { return false; }
    return true;
  }
  return false;
}

fn line_ends_with_scope_start(s0: String) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  return line_ends_with_scope_start_clean(s);
}

fn line_ends_with_char_clean(s: String, ch: i32) -> bool {
  let n: i32 = s.len();
  if n == 0 { return false; }
  return byte_at_unchecked(s, n - 1) == ch;
}

fn line_ends_with_char(s0: String, ch: i32) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  return line_ends_with_char_clean(s, ch);
}

fn line_ends_with_match_arm_arrow_clean(s: String) -> bool {
  if s.len() < 2 { return false; }
  let n: i32 = s.len();
  return byte_at_unchecked(s, n - 2) == 61 && byte_at_unchecked(s, n - 1) == 62; // "=>"
}

fn line_ends_with_match_arm_arrow(s0: String) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  return line_ends_with_match_arm_arrow_clean(s);
}

fn line_ends_with_field_label_colon_clean(s: String) -> bool {
  if s.len() == 0 { return false; }
  let n: i32 = s.len();
  if byte_at_unchecked(s, n - 1) != 58 { return false; } // ':'
  if n >= 2 && byte_at_unchecked(s, n - 2) == 58 { return false; } // '::'
  return true;
}

fn line_ends_with_field_label_colon(s0: String) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  return line_ends_with_field_label_colon_clean(s);
}

fn line_starts_with_match_keyword_clean(s: String) -> bool {
  let n: i32 = s.len();
  if n < 5 { return false; }
  if s.slice(0, 5) != "match" { return false; }
  if n == 5 { return true; }
  return !is_ident_continue_ascii(byte_at_unchecked(s, 5));
}

fn line_starts_with_match_keyword(s0: String) -> bool {
  let s: String = trim_left_ws(strip_line_comment(s0));
  return line_starts_with_match_keyword_clean(s);
}

fn line_is_comment_only(s0: String) -> bool {
  let s: String = trim_left_ws(s0);
  let n: i32 = s.len();
  return n >= 2 && byte_at_unchecked(s, 0) == 47 && byte_at_unchecked(s, 1) == 47; // "//"
}

fn starts_with_keyword(s: String, kw: String) -> bool {
  let s_n: i32 = s.len();
  let kw_n: i32 = kw.len();
  if s_n < kw_n { return false; }
  if s.slice(0, kw_n) != kw { return false; }
  if s_n == kw_n { return true; }
  return !is_ident_continue_ascii(byte_at_unchecked(s, kw_n));
}

fn top_level_decl_kind(s0: String) -> i32 {
  let s: String = trim_left_ws(strip_line_comment(s0));
  let s_n: i32 = s.len();
  if s_n == 0 { return 0; }
  if starts_with_keyword(s, "import") { return 1; }
  if byte_at_unchecked(s, 0) == 64 { return 2; } // '@'
  if starts_with_keyword(s, "pub") {
    let tail: String = trim_left_ws(s.slice(3, s_n));
    if starts_with_keyword(tail, "fn")
      || starts_with_keyword(tail, "const")
      || starts_with_keyword(tail, "struct")
      || starts_with_keyword(tail, "enum")
      || starts_with_keyword(tail, "trait")
      || starts_with_keyword(tail, "impl")
      || starts_with_keyword(tail, "type") {
      return 3;
    }
    return 0;
  }
  if starts_with_keyword(s, "fn")
    || starts_with_keyword(s, "const")
    || starts_with_keyword(s, "struct")
    || starts_with_keyword(s, "enum")
    || starts_with_keyword(s, "trait")
    || starts_with_keyword(s, "impl")
    || starts_with_keyword(s, "type") {
    return 3;
  }
  return 0;
}

fn should_insert_top_level_blank(prev_kind: i32, curr_kind: i32) -> bool {
  // Keep import block contiguous.
  if prev_kind == 1 && curr_kind == 1 { return false; }
  // Keep attribute stacks contiguous.
  if prev_kind == 2 && curr_kind == 2 { return false; }
  // Attribute + declaration belong to one item.
  if prev_kind == 2 && curr_kind != 2 { return false; }
  return true;
}

fn next_nonblank_content(src: String, from0: i32) -> String {
  let src_n: i32 = src.len();
  let mut pos: i32 = from0;
  if pos < 0 { pos = 0; }
  if pos > src_n { return ""; }
  let mut line_start: i32 = pos;
  let mut i: i32 = pos;
  while i <= src_n {
    let at_eof: bool = i == src_n;
    if !at_eof && byte_at_unchecked(src, i) != 10 {
      i = i + 1;
      continue;
    }
    if range_has_non_ws(src, line_start, i) { return trim_range_to_string(src, line_start, i); }
    line_start = i + 1;
    i = i + 1;
  }
  return "";
}

fn should_add_trailing_comma_in_multiline_paren(content0: String, next0: String, paren_for_line: i32) -> bool {
  if paren_for_line <= 0 { return false; }
  let content_clean: String = trim_right_ws(strip_line_comment(content0));
  if content_clean.len() == 0 { return false; }
  let next: String = trim_left_ws(next0);
  if next.len() == 0 { return false; }
  if next.byte_at(0) != 41 { return false; } // ')'
  if line_ends_with_char_clean(content_clean, 44) { return false; } // ','
  if line_ends_with_char_clean(content_clean, 59) { return false; } // ';'
  if line_ends_with_char_clean(content_clean, 40) { return false; } // '('
  if line_ends_with_char_clean(content_clean, 123) { return false; } // '{'
  if line_ends_with_scope_start_clean(content_clean) { return false; }
  if line_ends_with_continuation_clean(content_clean) { return false; }
  return true;
}

fn line_ends_with_continuation_clean(s: String) -> bool {
  if s.len() == 0 { return false; }

  let n: i32 = s.len();
  let c1: i32 = byte_at_unchecked(s, n - 1);
  let c0: i32 = if n >= 2 { byte_at_unchecked(s, n - 2) } else { -1 };

  // obvious continue marker: member-chain dot.
  if c1 == 46 { return true; } // "."
  // assignment "=", but not "==", "!=", "<=", ">=".
  if c1 == 61 {
    if c0 == 61 || c0 == 33 || c0 == 60 || c0 == 62 { return false; }
    return true;
  }
  // boolean chains, and arithmetic infix endings.
  if c1 == 124 && c0 == 124 { return true; } // "||"
  if c1 == 38 && c0 == 38 { return true; } // "&&"
  if c1 == 43 || c1 == 45 || c1 == 42 || c1 == 47 || c1 == 37 { return true; } // "+-*/%"
  // split keyword line: `else if` (condition on next line).
  if n >= 2 && s.slice(n - 2, n) == "if" {
    if n == 2 { return true; }
    let p: i32 = s.byte_at(n - 3);
    if !is_ident_continue_ascii(p) { return true; }
  }
  return false;
}

fn line_ends_with_continuation(s0: String) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  return line_ends_with_continuation_clean(s);
}

fn repeat_spaces(n0: i32) -> String {
  let mut n: i32 = n0;
  if n < 0 { n = 0; }
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < n {
    out = out.concat(" ");
    i = i + 1;
  }
  return out;
}

fn scan_line_state(line: String, in_triple0: bool) -> ScanState {
  let n: i32 = line.len();
  let mut in_triple: bool = in_triple0;
  let mut brace_delta: i32 = 0;
  let mut paren_delta: i32 = 0;
  let mut leading_paren_close: i32 = 0;
  let mut seen_code: bool = false;
  let mut i: i32 = 0;
  while i < n {
    if in_triple {
      if i + 2 < n && byte_at_unchecked(line, i) == 34 && byte_at_unchecked(line, i + 1) == 34 && byte_at_unchecked(line, i + 2) == 34 {
        in_triple = false;
        i = i + 3;
        continue;
      }
      i = i + 1;
      continue;
    }

    // line comment
    if i + 1 < n && byte_at_unchecked(line, i) == 47 && byte_at_unchecked(line, i + 1) == 47 {
      break;
    }

    // triple-quoted string
    if i + 2 < n && byte_at_unchecked(line, i) == 34 && byte_at_unchecked(line, i + 1) == 34 && byte_at_unchecked(line, i + 2) == 34 {
      in_triple = true;
      i = i + 3;
      continue;
    }

    // normal string
    if byte_at_unchecked(line, i) == 34 {
      seen_code = true;
      i = i + 1;
      while i < n {
        let b: i32 = byte_at_unchecked(line, i);
        if b == 92 { // escape
          i = i + 2;
          continue;
        }
        if b == 34 {
          i = i + 1;
          break;
        }
        i = i + 1;
      }
      continue;
    }

    let b: i32 = byte_at_unchecked(line, i);
    if !seen_code {
      if b == 32 || b == 9 || b == 13 {
        i = i + 1;
        continue;
      }
      if b == 41 || b == 93 { // ')' or ']'
        leading_paren_close = leading_paren_close + 1;
      } else {
        seen_code = true;
      }
    }

    if b == 123 {
      brace_delta = brace_delta + 1;
      i = i + 1;
      continue;
    }
    if b == 125 {
      brace_delta = brace_delta - 1;
      i = i + 1;
      continue;
    }
    if b == 40 || b == 91 { // '(' or '['
      paren_delta = paren_delta + 1;
      i = i + 1;
      continue;
    }
    if b == 41 || b == 93 { // ')' or ']'
      paren_delta = paren_delta - 1;
      i = i + 1;
      continue;
    }
    i = i + 1;
  }
  return
    ScanState {
      brace_delta: brace_delta,
      paren_delta: paren_delta,
      leading_paren_close: leading_paren_close,
      in_triple: in_triple
    };
}

fn line_ends_with_open_brace_clean(s: String) -> bool {
  let n: i32 = s.len();
  if n == 0 { return false; }
  return byte_at_unchecked(s, n - 1) == 123; // '{'
}

fn line_ends_with_open_brace(s0: String) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  return line_ends_with_open_brace_clean(s);
}

fn line_ends_with_open_brace_in_paren_ctx_clean(s: String, paren_depth_before: i32) -> bool {
  let n: i32 = s.len();
  if n == 0 { return false; }
  if byte_at_unchecked(s, n - 1) != 123 { return false; } // '{'
  let mut depth: i32 = paren_depth_before;
  let mut i: i32 = 0;
  while i < n - 1 {
    let b: i32 = byte_at_unchecked(s, i);
    if b == 40 || b == 91 { depth = depth + 1; } // '(' or '['
    if (b == 41 || b == 93) && depth > 0 { depth = depth - 1; } // ')' or ']'
    i = i + 1;
  }
  return depth > 0;
}

fn line_ends_with_open_brace_in_paren_ctx(s0: String, paren_depth_before: i32) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  return line_ends_with_open_brace_in_paren_ctx_clean(s, paren_depth_before);
}

pub fn format_text(src: String) -> String {
  let src_n: i32 = src.len();
  if src_n == 0 { return src; }

  let mut out_lines: Vec[String] = Vec();
  let mut indent: i32 = 0;
  let mut in_triple: bool = false;
  let mut blank_run: i32 = 0;
  let mut continue_next: bool = false;
  let mut continuation_bases: Vec[i32] = Vec();
  let mut match_arm_depths: Vec[i32] = Vec();
  let mut field_value_depths: Vec[i32] = Vec();
  let mut continuation_block_depths: Vec[i32] = Vec();
  let mut paren_depth: i32 = 0;
  let mut paren_field_scope: i32 = 0;
  let mut prev_top_decl_kind: i32 = 0;

  let mut line_start: i32 = 0;
  let mut i: i32 = 0;
  while i <= src_n {
    let at_eof: bool = i == src_n;
    if !at_eof && byte_at_unchecked(src, i) != 10 {
      i = i + 1;
      continue;
    }

    let raw_line: String = slice_unchecked(src, line_start, i);
    line_start = i + 1;
    i = i + 1;

    if in_triple {
      out_lines.push(raw_line);
      let st0: ScanState = scan_line_state(raw_line, true);
      let paren_before_t: i32 = paren_depth;
      indent = indent + st0.brace_delta;
      if indent < 0 { indent = 0; }
      paren_depth = paren_depth + st0.paren_delta;
      if paren_depth < 0 { paren_depth = 0; }
      in_triple = st0.in_triple;
      if !in_triple {
        let content_t: String = trim_left_ws(trim_right_ws(raw_line));
        let content_t_clean_r: String = trim_right_ws(strip_line_comment(content_t));
        let content_t_clean_l: String = trim_left_ws(content_t_clean_r);
        if line_ends_with_open_brace_in_paren_ctx_clean(content_t_clean_r, paren_before_t) && !line_starts_with_match_keyword_clean(content_t_clean_l) {
          paren_field_scope = paren_field_scope + 1;
        }
        let is_closing_brace_t: bool = content_t.len() > 0 && byte_at_unchecked(content_t, 0) == 125;
        if is_closing_brace_t && paren_field_scope > 0 {
          paren_field_scope = paren_field_scope - 1;
        }
        continue_next = line_ends_with_continuation_clean(content_t_clean_r);
        if line_ends_with_match_arm_arrow_clean(content_t_clean_r) {
          match_arm_depths.push(indent);
        }
        if line_ends_with_field_label_colon_clean(content_t_clean_r) {
          field_value_depths.push(indent);
        }
        if line_ends_with_scope_start_clean(content_t_clean_r) {
          continuation_bases.push(indent);
        }
        if continuation_bases.len() > 0 {
          let top_t: i32 = continuation_bases.get(continuation_bases.len() - 1);
          let ends_scope_t: bool = line_ends_with_char_clean(content_t_clean_r, 59);
          if ends_scope_t && indent <= top_t {
            continuation_bases.pop();
          }
        }
        if match_arm_depths.len() > 0 {
          let arm_depth_t: i32 = match_arm_depths.get(match_arm_depths.len() - 1);
          let arm_ends_by_comma_t: bool = line_ends_with_char_clean(content_t_clean_r, 44) && indent <= arm_depth_t;
          let arm_ends_by_scope_leave_t: bool = indent < arm_depth_t;
          if arm_ends_by_comma_t || arm_ends_by_scope_leave_t {
            match_arm_depths.pop();
          }
        }
        if field_value_depths.len() > 0 {
          let field_depth_t: i32 = field_value_depths.get(field_value_depths.len() - 1);
          let field_ends_by_comma_t: bool = line_ends_with_char_clean(content_t_clean_r, 44) && indent <= field_depth_t;
          let field_ends_by_semi_t: bool = line_ends_with_char_clean(content_t_clean_r, 59) && indent <= field_depth_t;
          let field_ends_by_scope_leave_t: bool = indent < field_depth_t;
          if field_ends_by_comma_t || field_ends_by_semi_t || field_ends_by_scope_leave_t {
            field_value_depths.pop();
          }
        }
      }
      continue;
    }

    let line_trim_right: String = trim_right_ws(raw_line);
    let content: String = trim_left_ws(line_trim_right);
    if !line_has_non_ws(content) {
      blank_run = blank_run + 1;
      if blank_run <= 1 {
        out_lines.push("");
      }
      if indent == 0 && paren_depth == 0 {
        prev_top_decl_kind = 0;
      }
      continue_next = false;
      continue;
    }
    blank_run = 0;

    let mut line_indent: i32 = indent;
    let is_closing_brace: bool = content.len() > 0 && byte_at_unchecked(content, 0) == 125;
    if is_closing_brace && line_indent > 0 { // '}'
      line_indent = line_indent - 1;
    }
    let st: ScanState = scan_line_state(content, false);
    let paren_before: i32 = paren_depth;
    let mut paren_for_line: i32 = paren_depth - st.leading_paren_close;
    if paren_for_line < 0 { paren_for_line = 0; }
    // For multiline struct literals in call args (e.g. `call(Item { ... })`),
    // `{}` indentation is sufficient; avoid stacking one extra `()` level.
    if paren_for_line > 0 && paren_field_scope > 0 {
      paren_for_line = paren_for_line - 1;
    }
    line_indent = line_indent + paren_for_line;

    let next_content: String = next_nonblank_content(src, line_start);
    let mut content_out: String = content;
    if should_add_trailing_comma_in_multiline_paren(content, next_content, paren_for_line) {
      content_out = content.concat(",");
    }
    let content_out_clean_r: String = trim_right_ws(strip_line_comment(content_out));
    let content_out_clean_l: String = trim_left_ws(content_out_clean_r);

    let at_top_level: bool = indent == 0 && paren_depth == 0;
    let curr_top_decl_kind: i32 = if at_top_level { top_level_decl_kind(content_out) } else { 0 };
    if curr_top_decl_kind != 0
      && prev_top_decl_kind != 0
      && blank_run == 0
      && should_insert_top_level_blank(prev_top_decl_kind, curr_top_decl_kind) {
      out_lines.push("");
    }

    let starts_cont: bool = line_starts_with_continuation_clean(content_out_clean_l);
    let continued_by_prev_line: bool = continue_next;
    if match_arm_depths.len() > 0 {
      line_indent = line_indent + match_arm_depths.len();
    }
    if field_value_depths.len() > 0 {
      line_indent = line_indent + field_value_depths.len();
    }
    let continuation_base: bool = continuation_bases.len() > 0 || continue_next;
    if continuation_block_depths.len() > 0 {
      line_indent = line_indent + continuation_block_depths.len();
    }
    if continuation_base && (!is_closing_brace || continuation_bases.len() > 0) {
      line_indent = line_indent + 1;
    }
    if starts_cont && !continuation_base {
      if !is_closing_brace || continuation_bases.len() > 0 {
        if match_arm_depths.len() == 0 || paren_for_line == 0 {
          line_indent = line_indent + 1;
        }
      }
    }
    if starts_cont && continuation_base {
      if match_arm_depths.len() == 0 || paren_for_line == 0 {
        line_indent = line_indent + 1;
      }
    }
    out_lines.push(repeat_spaces(line_indent * 2).concat(content_out));

    if at_top_level {
      if curr_top_decl_kind != 0 {
        prev_top_decl_kind = curr_top_decl_kind;
      } else if line_is_comment_only(content_out) {
        // Comments can document the next top-level item; do not force a gap after them.
        prev_top_decl_kind = 0;
      } else {
        prev_top_decl_kind = 0;
      }
    }

    indent = indent + st.brace_delta;
    if indent < 0 { indent = 0; }
    paren_depth = paren_depth + st.paren_delta;
    if paren_depth < 0 { paren_depth = 0; }
    in_triple = st.in_triple;
    if line_ends_with_open_brace_in_paren_ctx_clean(content_out_clean_r, paren_before) && !line_starts_with_match_keyword_clean(content_out_clean_l) {
      paren_field_scope = paren_field_scope + 1;
    }
    if is_closing_brace && paren_field_scope > 0 {
      paren_field_scope = paren_field_scope - 1;
    }
    continue_next = line_ends_with_continuation_clean(content_out_clean_r);
    if continued_by_prev_line && continuation_bases.len() == 0 && line_starts_with_match_keyword_clean(content_out_clean_l) && line_ends_with_open_brace_clean(content_out_clean_r) {
      continuation_block_depths.push(indent);
    }
    if line_ends_with_match_arm_arrow_clean(content_out_clean_r) {
      match_arm_depths.push(indent);
    }
    if line_ends_with_field_label_colon_clean(content_out_clean_r) {
      field_value_depths.push(indent);
    }
    if line_ends_with_scope_start_clean(content_out_clean_r) {
      continuation_bases.push(line_indent);
    }
    if continuation_bases.len() > 0 {
      let top: i32 = continuation_bases.get(continuation_bases.len() - 1);
      let ends_scope: bool = line_ends_with_char_clean(content_out_clean_r, 59);
      if ends_scope && indent <= top {
        continuation_bases.pop();
      }
    }
    if match_arm_depths.len() > 0 {
      let arm_depth: i32 = match_arm_depths.get(match_arm_depths.len() - 1);
      let arm_ends_by_comma: bool = line_ends_with_char_clean(content_out_clean_r, 44) && indent <= arm_depth;
      let arm_ends_by_scope_leave: bool = indent < arm_depth;
      if arm_ends_by_comma || arm_ends_by_scope_leave {
        match_arm_depths.pop();
      }
    }
    if field_value_depths.len() > 0 {
      let field_depth: i32 = field_value_depths.get(field_value_depths.len() - 1);
      let field_ends_by_comma: bool = line_ends_with_char_clean(content_out_clean_r, 44) && indent <= field_depth;
      let field_ends_by_semi: bool = line_ends_with_char_clean(content_out_clean_r, 59) && indent <= field_depth;
      let field_ends_by_scope_leave: bool = indent < field_depth;
      if field_ends_by_comma || field_ends_by_semi || field_ends_by_scope_leave {
        field_value_depths.pop();
      }
    }
    while continuation_block_depths.len() > 0 {
      let block_depth: i32 = continuation_block_depths.get(continuation_block_depths.len() - 1);
      if indent < block_depth {
        continuation_block_depths.pop();
      } else {
        break;
      }
    }
  }

  // Keep a single trailing newline and no trailing blank line run.
  while out_lines.len() > 0 {
    let last: String = out_lines.get(out_lines.len() - 1);
    if line_has_non_ws(last) { break; }
    out_lines.pop();
  }
  if out_lines.len() == 0 { return "\n"; }
  return out_lines.join("\n").concat("\n");
}

fn collect_files_from_path(path: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  if fs.exists(path) && has_suffix(path, ".vox") {
    out.push(path);
    return out;
  }
  let xs: Vec[String] = srcw.walk_vox_files(path);
  let mut i: i32 = 0;
  while i < xs.len() {
    out.push(xs.get(i));
    i = i + 1;
  }
  if out.len() == 0 && fs.exists(path) {
    let all: Vec[String] = srcw.walk_vox_files(".");
    let mut pre: String = path;
    if pre != "" && !has_suffix(pre, "/") {
      pre = pre.concat("/");
    }
    let mut j: i32 = 0;
    while j < all.len() {
      let p: String = all.get(j);
      if p == path || has_prefix(p, pre) {
        out.push(p);
      }
      j = j + 1;
    }
  }
  return out;
}

fn contains(xs: Vec[String], x: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == x { return true; }
    i = i + 1;
  }
  return false;
}

fn dedup_paths(xs: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < xs.len() {
    let x: String = xs.get(i);
    if !contains(out, x) {
      out.push(x);
    }
    i = i + 1;
  }
  return out;
}

pub fn discover_files(paths: Vec[String]) -> Vec[String] {
  let mut all: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let xs: Vec[String] = collect_files_from_path(paths.get(i));
    let mut j: i32 = 0;
    while j < xs.len() {
      all.push(xs.get(j));
      j = j + 1;
    }
    i = i + 1;
  }
  return dedup_paths(all);
}
