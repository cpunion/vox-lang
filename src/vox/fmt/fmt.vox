// Stability: Experimental module API (vox/fmt).

import "std/fs" as fs
import "vox/internal/text" as txt

struct ScanState {
  brace_delta: i32,
  paren_delta: i32,
  leading_paren_close: i32,
  in_triple: bool,
}

fn is_space_tab(b: i32) -> bool { return b == 32 || b == 9; }

fn has_suffix(s: String, suf: String) -> bool {
  return txt.has_suffix(s, suf);
}

fn has_prefix(s: String, pre: String) -> bool {
  return txt.has_prefix(s, pre);
}

fn line_has_non_ws(s: String) -> bool {
  let mut i: i32 = 0;
  while i < s.len() {
    if !is_space_tab(s.byte_at(i)) && s.byte_at(i) != 13 {
      return true;
    }
    i = i + 1;
  }
  return false;
}

fn is_ident_continue_ascii(b: i32) -> bool {
  if b >= 65 && b <= 90 { return true; } // A-Z
  if b >= 97 && b <= 122 { return true; } // a-z
  if b >= 48 && b <= 57 { return true; } // 0-9
  if b == 95 { return true; } // '_'
  return false;
}

fn trim_left_ws(s: String) -> String {
  let mut i: i32 = 0;
  while i < s.len() && is_space_tab(s.byte_at(i)) {
    i = i + 1;
  }
  return s.slice(i, s.len());
}

fn trim_right_ws(s: String) -> String {
  if s.len() == 0 { return s; }
  let mut i: i32 = s.len() - 1;
  while i >= 0 {
    let b: i32 = s.byte_at(i);
    if !is_space_tab(b) && b != 13 {
      return s.slice(0, i + 1);
    }
    i = i - 1;
  }
  return "";
}

fn strip_line_comment(s: String) -> String {
  let mut i: i32 = 0;
  while i < s.len() {
    if i + 1 < s.len() && s.byte_at(i) == 47 && s.byte_at(i + 1) == 47 {
      return s.slice(0, i);
    }
    if s.byte_at(i) == 34 { // string
      i = i + 1;
      while i < s.len() {
        let b: i32 = s.byte_at(i);
        if b == 92 { // escape
          i = i + 2;
          continue;
        }
        if b == 34 {
          i = i + 1;
          break;
        }
        i = i + 1;
      }
      continue;
    }
    i = i + 1;
  }
  return s;
}

fn line_starts_with_continuation(s0: String) -> bool {
  let s: String = trim_left_ws(strip_line_comment(s0));
  if s.len() == 0 { return false; }
  // '.' chain line, or infix boolean continuation.
  if s.byte_at(0) == 46 { return true; } // '.'
  if s.len() >= 2 && s.byte_at(0) == 124 && s.byte_at(1) == 124 { return true; } // "||"
  if s.len() >= 2 && s.byte_at(0) == 38 && s.byte_at(1) == 38 { return true; } // "&&"
  return false;
}

fn line_ends_with_scope_start(s0: String) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  if s.len() == 0 { return false; }
  let t: String = trim_left_ws(s);
  if t == "return" { return true; }
  let n: i32 = s.len();
  let c1: i32 = s.byte_at(n - 1);
  let c0: i32 = if n >= 2 { s.byte_at(n - 2) } else { -1 };
  // assignment "=" (not comparison), and match arm "=>".
  if c1 == 61 {
    if c0 == 61 || c0 == 33 || c0 == 60 || c0 == 62 { return false; }
    return true;
  }
  return false;
}

fn line_ends_with_char(s0: String, ch: i32) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  if s.len() == 0 { return false; }
  return s.byte_at(s.len() - 1) == ch;
}

fn line_ends_with_match_arm_arrow(s0: String) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  if s.len() < 2 { return false; }
  let n: i32 = s.len();
  return s.byte_at(n - 2) == 61 && s.byte_at(n - 1) == 62; // "=>"
}

fn line_ends_with_field_label_colon(s0: String) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  if s.len() == 0 { return false; }
  let n: i32 = s.len();
  if s.byte_at(n - 1) != 58 { return false; } // ':'
  if n >= 2 && s.byte_at(n - 2) == 58 { return false; } // '::'
  return true;
}

fn line_starts_with_match_keyword(s0: String) -> bool {
  let s: String = trim_left_ws(strip_line_comment(s0));
  if s.len() < 5 { return false; }
  if s.slice(0, 5) != "match" { return false; }
  if s.len() == 5 { return true; }
  return !is_ident_continue_ascii(s.byte_at(5));
}

fn line_is_comment_only(s0: String) -> bool {
  let s: String = trim_left_ws(s0);
  return s.len() >= 2 && s.byte_at(0) == 47 && s.byte_at(1) == 47; // "//"
}

fn next_nonblank_content(src: String, from0: i32) -> String {
  let mut pos: i32 = from0;
  if pos < 0 { pos = 0; }
  if pos > src.len() { return ""; }
  let mut line_start: i32 = pos;
  let mut i: i32 = pos;
  while i <= src.len() {
    let at_eof: bool = i == src.len();
    if !at_eof && src.byte_at(i) != 10 {
      i = i + 1;
      continue;
    }
    let raw_line: String = src.slice(line_start, i);
    let content: String = trim_left_ws(trim_right_ws(raw_line));
    if line_has_non_ws(content) { return content; }
    line_start = i + 1;
    i = i + 1;
  }
  return "";
}

fn should_add_trailing_comma_in_multiline_paren(content0: String, next0: String, paren_for_line: i32) -> bool {
  if paren_for_line <= 0 { return false; }
  let content: String = trim_right_ws(content0);
  if content.len() == 0 { return false; }
  if line_is_comment_only(content) { return false; }
  let next: String = trim_left_ws(next0);
  if next.len() == 0 { return false; }
  if next.byte_at(0) != 41 { return false; } // ')'
  if line_ends_with_char(content, 44) { return false; } // ','
  if line_ends_with_char(content, 59) { return false; } // ';'
  if line_ends_with_char(content, 40) { return false; } // '('
  if line_ends_with_char(content, 123) { return false; } // '{'
  if line_ends_with_scope_start(content) { return false; }
  if line_ends_with_continuation(content) { return false; }
  return true;
}

fn line_ends_with_continuation(s0: String) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  if s.len() == 0 { return false; }

  let n: i32 = s.len();
  let c1: i32 = s.byte_at(n - 1);
  let c0: i32 = if n >= 2 { s.byte_at(n - 2) } else { -1 };

  // obvious continue marker: member-chain dot.
  if c1 == 46 { return true; } // "."
  // assignment "=", but not "==", "!=", "<=", ">=".
  if c1 == 61 {
    if c0 == 61 || c0 == 33 || c0 == 60 || c0 == 62 { return false; }
    return true;
  }
  // boolean chains, and arithmetic infix endings.
  if c1 == 124 && c0 == 124 { return true; } // "||"
  if c1 == 38 && c0 == 38 { return true; } // "&&"
  if c1 == 43 || c1 == 45 || c1 == 42 || c1 == 47 || c1 == 37 { return true; } // "+-*/%"
  // split keyword line: `else if` (condition on next line).
  if n >= 2 && s.slice(n - 2, n) == "if" {
    if n == 2 { return true; }
    let p: i32 = s.byte_at(n - 3);
    if !is_ident_continue_ascii(p) { return true; }
  }
  return false;
}

fn repeat_spaces(n0: i32) -> String {
  let mut n: i32 = n0;
  if n < 0 { n = 0; }
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < n {
    out = out.concat(" ");
    i = i + 1;
  }
  return out;
}

fn scan_line_state(line: String, in_triple0: bool) -> ScanState {
  let mut in_triple: bool = in_triple0;
  let mut brace_delta: i32 = 0;
  let mut paren_delta: i32 = 0;
  let mut leading_paren_close: i32 = 0;
  let mut seen_code: bool = false;
  let mut i: i32 = 0;
  while i < line.len() {
    if in_triple {
      if i + 2 < line.len() && line.byte_at(i) == 34 && line.byte_at(i + 1) == 34 && line.byte_at(i + 2) == 34 {
        in_triple = false;
        i = i + 3;
        continue;
      }
      i = i + 1;
      continue;
    }

    // line comment
    if i + 1 < line.len() && line.byte_at(i) == 47 && line.byte_at(i + 1) == 47 {
      break;
    }

    // triple-quoted string
    if i + 2 < line.len() && line.byte_at(i) == 34 && line.byte_at(i + 1) == 34 && line.byte_at(i + 2) == 34 {
      in_triple = true;
      i = i + 3;
      continue;
    }

    // normal string
    if line.byte_at(i) == 34 {
      seen_code = true;
      i = i + 1;
      while i < line.len() {
        let b: i32 = line.byte_at(i);
        if b == 92 { // escape
          i = i + 2;
          continue;
        }
        if b == 34 {
          i = i + 1;
          break;
        }
        i = i + 1;
      }
      continue;
    }

    let b: i32 = line.byte_at(i);
    if !seen_code {
      if b == 32 || b == 9 || b == 13 {
        i = i + 1;
        continue;
      }
      if b == 41 || b == 93 { // ')' or ']'
        leading_paren_close = leading_paren_close + 1;
      } else {
        seen_code = true;
      }
    }

    if line.byte_at(i) == 123 {
      brace_delta = brace_delta + 1;
      i = i + 1;
      continue;
    }
    if line.byte_at(i) == 125 {
      brace_delta = brace_delta - 1;
      i = i + 1;
      continue;
    }
    if line.byte_at(i) == 40 || line.byte_at(i) == 91 { // '(' or '['
      paren_delta = paren_delta + 1;
      i = i + 1;
      continue;
    }
    if line.byte_at(i) == 41 || line.byte_at(i) == 93 { // ')' or ']'
      paren_delta = paren_delta - 1;
      i = i + 1;
      continue;
    }
    i = i + 1;
  }
  return
    ScanState {
      brace_delta: brace_delta,
      paren_delta: paren_delta,
      leading_paren_close: leading_paren_close,
      in_triple: in_triple
    };
}

fn line_ends_with_open_brace(s0: String) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  if s.len() == 0 { return false; }
  return s.byte_at(s.len() - 1) == 123; // '{'
}

fn line_ends_with_open_brace_in_paren_ctx(s0: String, paren_depth_before: i32) -> bool {
  let s: String = trim_right_ws(strip_line_comment(s0));
  if s.len() == 0 { return false; }
  if s.byte_at(s.len() - 1) != 123 { return false; } // '{'
  let mut depth: i32 = paren_depth_before;
  let mut i: i32 = 0;
  while i < s.len() - 1 {
    let b: i32 = s.byte_at(i);
    if b == 40 || b == 91 { depth = depth + 1; } // '(' or '['
    if (b == 41 || b == 93) && depth > 0 { depth = depth - 1; } // ')' or ']'
    i = i + 1;
  }
  return depth > 0;
}

pub fn format_text(src: String) -> String {
  if src.len() == 0 { return src; }

  let mut out: String = "";
  let mut indent: i32 = 0;
  let mut in_triple: bool = false;
  let mut blank_run: i32 = 0;
  let mut continue_next: bool = false;
  let mut continuation_bases: Vec[i32] = Vec();
  let mut match_arm_depths: Vec[i32] = Vec();
  let mut field_value_depths: Vec[i32] = Vec();
  let mut continuation_block_depths: Vec[i32] = Vec();
  let mut paren_depth: i32 = 0;
  let mut paren_field_scope: i32 = 0;

  let mut line_start: i32 = 0;
  let mut i: i32 = 0;
  while i <= src.len() {
    let at_eof: bool = i == src.len();
    if !at_eof && src.byte_at(i) != 10 {
      i = i + 1;
      continue;
    }

    let raw_line: String = src.slice(line_start, i);
    line_start = i + 1;
    i = i + 1;

    if in_triple {
      out = out.concat(raw_line).concat("\n");
      let st0: ScanState = scan_line_state(raw_line, true);
      let paren_before_t: i32 = paren_depth;
      indent = indent + st0.brace_delta;
      if indent < 0 { indent = 0; }
      paren_depth = paren_depth + st0.paren_delta;
      if paren_depth < 0 { paren_depth = 0; }
      in_triple = st0.in_triple;
      if !in_triple {
        let content_t: String = trim_left_ws(trim_right_ws(raw_line));
        if line_ends_with_open_brace_in_paren_ctx(content_t, paren_before_t) && !line_starts_with_match_keyword(content_t) {
          paren_field_scope = paren_field_scope + 1;
        }
        let is_closing_brace_t: bool = content_t.len() > 0 && content_t.byte_at(0) == 125;
        if is_closing_brace_t && paren_field_scope > 0 {
          paren_field_scope = paren_field_scope - 1;
        }
        continue_next = line_ends_with_continuation(content_t);
        if line_ends_with_match_arm_arrow(content_t) {
          match_arm_depths.push(indent);
        }
        if line_ends_with_field_label_colon(content_t) {
          field_value_depths.push(indent);
        }
        if line_ends_with_scope_start(content_t) {
          continuation_bases.push(indent);
        }
        if continuation_bases.len() > 0 {
          let top_t: i32 = continuation_bases.get(continuation_bases.len() - 1);
          let ends_scope_t: bool = line_ends_with_char(content_t, 59);
          if ends_scope_t && indent <= top_t {
            continuation_bases.pop();
          }
        }
        if match_arm_depths.len() > 0 {
          let arm_depth_t: i32 = match_arm_depths.get(match_arm_depths.len() - 1);
          let arm_ends_by_comma_t: bool = line_ends_with_char(content_t, 44) && indent <= arm_depth_t;
          let arm_ends_by_scope_leave_t: bool = indent < arm_depth_t;
          if arm_ends_by_comma_t || arm_ends_by_scope_leave_t {
            match_arm_depths.pop();
          }
        }
        if field_value_depths.len() > 0 {
          let field_depth_t: i32 = field_value_depths.get(field_value_depths.len() - 1);
          let field_ends_by_comma_t: bool = line_ends_with_char(content_t, 44) && indent <= field_depth_t;
          let field_ends_by_semi_t: bool = line_ends_with_char(content_t, 59) && indent <= field_depth_t;
          let field_ends_by_scope_leave_t: bool = indent < field_depth_t;
          if field_ends_by_comma_t || field_ends_by_semi_t || field_ends_by_scope_leave_t {
            field_value_depths.pop();
          }
        }
      }
      continue;
    }

    let line_trim_right: String = trim_right_ws(raw_line);
    let content: String = trim_left_ws(line_trim_right);
    if !line_has_non_ws(content) {
      blank_run = blank_run + 1;
      if blank_run <= 1 {
        out = out.concat("\n");
      }
      continue_next = false;
      continue;
    }
    blank_run = 0;

    let mut line_indent: i32 = indent;
    let is_closing_brace: bool = content.len() > 0 && content.byte_at(0) == 125;
    if is_closing_brace && line_indent > 0 { // '}'
      line_indent = line_indent - 1;
    }
    let st: ScanState = scan_line_state(content, false);
    let paren_before: i32 = paren_depth;
    let mut paren_for_line: i32 = paren_depth - st.leading_paren_close;
    if paren_for_line < 0 { paren_for_line = 0; }
    // For multiline struct literals in call args (e.g. `call(Item { ... })`),
    // `{}` indentation is sufficient; avoid stacking one extra `()` level.
    if paren_for_line > 0 && paren_field_scope > 0 {
      paren_for_line = paren_for_line - 1;
    }
    line_indent = line_indent + paren_for_line;

    let next_content: String = next_nonblank_content(src, line_start);
    let mut content_out: String = content;
    if should_add_trailing_comma_in_multiline_paren(content, next_content, paren_for_line) {
      content_out = content.concat(",");
    }

    let starts_cont: bool = line_starts_with_continuation(content_out);
    let continued_by_prev_line: bool = continue_next;
    if match_arm_depths.len() > 0 {
      line_indent = line_indent + match_arm_depths.len();
    }
    if field_value_depths.len() > 0 {
      line_indent = line_indent + field_value_depths.len();
    }
    let continuation_base: bool = continuation_bases.len() > 0 || continue_next;
    if continuation_block_depths.len() > 0 {
      line_indent = line_indent + continuation_block_depths.len();
    }
    if continuation_base && (!is_closing_brace || continuation_bases.len() > 0) {
      line_indent = line_indent + 1;
    }
    if starts_cont && !continuation_base {
      if !is_closing_brace || continuation_bases.len() > 0 {
        if match_arm_depths.len() == 0 || paren_for_line == 0 {
          line_indent = line_indent + 1;
        }
      }
    }
    if starts_cont && continuation_base {
      if match_arm_depths.len() == 0 || paren_for_line == 0 {
        line_indent = line_indent + 1;
      }
    }
    out = out.concat(repeat_spaces(line_indent * 2)).concat(content_out).concat("\n");

    indent = indent + st.brace_delta;
    if indent < 0 { indent = 0; }
    paren_depth = paren_depth + st.paren_delta;
    if paren_depth < 0 { paren_depth = 0; }
    in_triple = st.in_triple;
    if line_ends_with_open_brace_in_paren_ctx(content_out, paren_before) && !line_starts_with_match_keyword(content_out) {
      paren_field_scope = paren_field_scope + 1;
    }
    if is_closing_brace && paren_field_scope > 0 {
      paren_field_scope = paren_field_scope - 1;
    }
    continue_next = line_ends_with_continuation(content_out);
    if continued_by_prev_line && continuation_bases.len() == 0 && line_starts_with_match_keyword(content_out) && line_ends_with_open_brace(content_out) {
      continuation_block_depths.push(indent);
    }
    if line_ends_with_match_arm_arrow(content_out) {
      match_arm_depths.push(indent);
    }
    if line_ends_with_field_label_colon(content_out) {
      field_value_depths.push(indent);
    }
    if line_ends_with_scope_start(content_out) {
      continuation_bases.push(line_indent);
    }
    if continuation_bases.len() > 0 {
      let top: i32 = continuation_bases.get(continuation_bases.len() - 1);
      let ends_scope: bool = line_ends_with_char(content_out, 59);
      if ends_scope && indent <= top {
        continuation_bases.pop();
      }
    }
    if match_arm_depths.len() > 0 {
      let arm_depth: i32 = match_arm_depths.get(match_arm_depths.len() - 1);
      let arm_ends_by_comma: bool = line_ends_with_char(content_out, 44) && indent <= arm_depth;
      let arm_ends_by_scope_leave: bool = indent < arm_depth;
      if arm_ends_by_comma || arm_ends_by_scope_leave {
        match_arm_depths.pop();
      }
    }
    if field_value_depths.len() > 0 {
      let field_depth: i32 = field_value_depths.get(field_value_depths.len() - 1);
      let field_ends_by_comma: bool = line_ends_with_char(content_out, 44) && indent <= field_depth;
      let field_ends_by_semi: bool = line_ends_with_char(content_out, 59) && indent <= field_depth;
      let field_ends_by_scope_leave: bool = indent < field_depth;
      if field_ends_by_comma || field_ends_by_semi || field_ends_by_scope_leave {
        field_value_depths.pop();
      }
    }
    while continuation_block_depths.len() > 0 {
      let block_depth: i32 = continuation_block_depths.get(continuation_block_depths.len() - 1);
      if indent < block_depth {
        continuation_block_depths.pop();
      } else {
        break;
      }
    }
  }

  // Keep a single trailing newline and no trailing blank line run.
  while out.len() >= 2 && out.slice(out.len() - 2, out.len()) == "\n\n" {
    out = out.slice(0, out.len() - 1);
  }
  if out.len() > 0 && out.byte_at(out.len() - 1) != 10 {
    out = out.concat("\n");
  }
  return out;
}

fn collect_files_from_path(path: String) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  if fs.exists(path) && has_suffix(path, ".vox") {
    out.push(path);
    return out;
  }
  let xs: Vec[String] = fs.walk_vox_files(path);
  let mut i: i32 = 0;
  while i < xs.len() {
    out.push(xs.get(i));
    i = i + 1;
  }
  if out.len() == 0 && fs.exists(path) {
    let all: Vec[String] = fs.walk_vox_files(".");
    let mut pre: String = path;
    if pre != "" && !has_suffix(pre, "/") {
      pre = pre.concat("/");
    }
    let mut j: i32 = 0;
    while j < all.len() {
      let p: String = all.get(j);
      if p == path || has_prefix(p, pre) {
        out.push(p);
      }
      j = j + 1;
    }
  }
  return out;
}

fn contains(xs: Vec[String], x: String) -> bool {
  let mut i: i32 = 0;
  while i < xs.len() {
    if xs.get(i) == x { return true; }
    i = i + 1;
  }
  return false;
}

fn dedup_paths(xs: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < xs.len() {
    let x: String = xs.get(i);
    if !contains(out, x) {
      out.push(x);
    }
    i = i + 1;
  }
  return out;
}

pub fn discover_files(paths: Vec[String]) -> Vec[String] {
  let mut all: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < paths.len() {
    let xs: Vec[String] = collect_files_from_path(paths.get(i));
    let mut j: i32 = 0;
    while j < xs.len() {
      all.push(xs.get(j));
      j = j + 1;
    }
    i = i + 1;
  }
  return dedup_paths(all);
}
