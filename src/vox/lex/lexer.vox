// Stability: Stable module API (vox/lex).
// Migration: Backward-compatible within minor releases; breaking changes require migration notes.

// LexError is a minimal error channel for stage1 lexer.
pub enum LexError {
  None,
  UnexpectedChar(i32),     // byte offset
  UnterminatedString(i32), // byte offset of opening quote
}

pub fn lex_error_to_string(e: LexError) -> String {
  return match e {
    LexError.None => "none",
    LexError.UnexpectedChar(at) => "unexpected char at ".concat(at.to_string()),
    LexError.UnterminatedString(at) => "unterminated string at ".concat(at.to_string()),
  };
}

pub struct LexResult {
  pub tokens: Vec[Token],
  pub err: LexError,
}

fn is_space(b: i32) -> bool {
  return b == 32 || b == 9 || b == 10 || b == 13; // ' ' '\t' '\n' '\r'
}

fn is_alpha(b: i32) -> bool {
  return (b >= 65 && b <= 90) || (b >= 97 && b <= 122) || b == 95; // A-Z a-z _
}

fn is_digit(b: i32) -> bool {
  return b >= 48 && b <= 57; // 0-9
}

fn is_alnum(b: i32) -> bool {
  return is_alpha(b) || is_digit(b);
}

fn is_utf8_cont_byte(b: i32) -> bool {
  return b >= 128 && b <= 191;
}

fn utf8_char_width(head: i32) -> i32 {
  if head >= 0 && head <= 127 { return 1; }
  if head >= 194 && head <= 223 { return 2; }
  if head >= 224 && head <= 239 { return 3; }
  if head >= 240 && head <= 244 { return 4; }
  return 1;
}

fn utf8_has_valid_cont_bytes(text: String, start: i32, width: i32, n: i32) -> bool {
  if width <= 1 { return true; }
  if start + width > n { return false; }
  let mut i: i32 = start + 1;
  while i < (start + width) {
    if !is_utf8_cont_byte(text.byte_at(i)) { return false; }
    i = i + 1;
  }
  return true;
}

fn utf8_next_scalar_end(text: String, start: i32, n: i32) -> i32 {
  if start >= n { return n; }
  let width: i32 = utf8_char_width(text.byte_at(start));
  if utf8_has_valid_cont_bytes(text, start, width, n) { return start + width; }
  return start + 1;
}

fn kw_kind(text: String, start: i32, end: i32) -> TokenKind {
  // Keyword detection without substring support: compare by length + bytes.
  let n: i32 = end - start;

  // 2
  if n == 2 {
    let b0: i32 = text.byte_at(start + 0);
    let b1: i32 = text.byte_at(start + 1);
    if b0 == 102 && b1 == 110 { return TokenKind.KwFn; } // fn
    if b0 == 105 && b1 == 102 { return TokenKind.KwIf; } // if
    if b0 == 97 && b1 == 115 { return TokenKind.KwAs; }  // as
    return TokenKind.Ident;
  }

  // 3
  if n == 3 {
    let b0: i32 = text.byte_at(start + 0);
    let b1: i32 = text.byte_at(start + 1);
    let b2: i32 = text.byte_at(start + 2);
    if b0 == 108 && b1 == 101 && b2 == 116 { return TokenKind.KwLet; } // let
    if b0 == 109 && b1 == 117 && b2 == 116 { return TokenKind.KwMut; } // mut
    if b0 == 112 && b1 == 117 && b2 == 98 { return TokenKind.KwPub; }  // pub
    if b0 == 102 && b1 == 111 && b2 == 114 { return TokenKind.KwFor; }  // for
    if b0 == 116 && b1 == 114 && b2 == 121 { return TokenKind.KwTry; }  // try
    return TokenKind.Ident;
  }

  // 4
  if n == 4 {
    let b0: i32 = text.byte_at(start + 0);
    let b1: i32 = text.byte_at(start + 1);
    let b2: i32 = text.byte_at(start + 2);
    let b3: i32 = text.byte_at(start + 3);
    if b0 == 101 && b1 == 108 && b2 == 115 && b3 == 101 { return TokenKind.KwElse; } // else
    if b0 == 101 && b1 == 110 && b2 == 117 && b3 == 109 { return TokenKind.KwEnum; } // enum
    if b0 == 102 && b1 == 114 && b2 == 111 && b3 == 109 { return TokenKind.KwFrom; } // from
    if b0 == 105 && b1 == 109 && b2 == 112 && b3 == 108 { return TokenKind.KwImpl; } // impl
    if b0 == 116 && b1 == 114 && b2 == 117 && b3 == 101 { return TokenKind.KwTrue; } // true
    if b0 == 116 && b1 == 121 && b2 == 112 && b3 == 101 { return TokenKind.KwType; } // type
    return TokenKind.Ident;
  }

  // 5
  if n == 5 {
    let b0: i32 = text.byte_at(start + 0);
    let b1: i32 = text.byte_at(start + 1);
    let b2: i32 = text.byte_at(start + 2);
    let b3: i32 = text.byte_at(start + 3);
    let b4: i32 = text.byte_at(start + 4);
    if b0 == 119 && b1 == 104 && b2 == 105 && b3 == 108 && b4 == 101 { return TokenKind.KwWhile; } // while
    if b0 == 109 && b1 == 97 && b2 == 116 && b3 == 99 && b4 == 104 { return TokenKind.KwMatch; }  // match
    if b0 == 98 && b1 == 114 && b2 == 101 && b3 == 97 && b4 == 107 { return TokenKind.KwBreak; }  // break
    if b0 == 119 && b1 == 104 && b2 == 101 && b3 == 114 && b4 == 101 { return TokenKind.KwWhere; } // where
    if b0 == 102 && b1 == 97 && b2 == 108 && b3 == 115 && b4 == 101 { return TokenKind.KwFalse; } // false
    if b0 == 99 && b1 == 111 && b2 == 110 && b3 == 115 && b4 == 116 { return TokenKind.KwConst; } // const
    if b0 == 116 && b1 == 114 && b2 == 97 && b3 == 105 && b4 == 116 { return TokenKind.KwTrait; } // trait
    if b0 == 97 && b1 == 115 && b2 == 121 && b3 == 110 && b4 == 99 { return TokenKind.KwAsync; } // async
    if b0 == 97 && b1 == 119 && b2 == 97 && b3 == 105 && b4 == 116 { return TokenKind.KwAwait; } // await
    return TokenKind.Ident;
  }

  // 6
  if n == 6 {
    let b0: i32 = text.byte_at(start + 0);
    let b1: i32 = text.byte_at(start + 1);
    let b2: i32 = text.byte_at(start + 2);
    let b3: i32 = text.byte_at(start + 3);
    let b4: i32 = text.byte_at(start + 4);
    let b5: i32 = text.byte_at(start + 5);
    if b0 == 114 && b1 == 101 && b2 == 116 && b3 == 117 && b4 == 114 && b5 == 110 { return TokenKind.KwReturn; } // return
    if b0 == 115 && b1 == 116 && b2 == 114 && b3 == 117 && b4 == 99 && b5 == 116 { return TokenKind.KwStruct; } // struct
    if b0 == 105 && b1 == 109 && b2 == 112 && b3 == 111 && b4 == 114 && b5 == 116 { return TokenKind.KwImport; } // import
    return TokenKind.Ident;
  }

  // 8
  if n == 8 {
    let b0: i32 = text.byte_at(start + 0);
    let b1: i32 = text.byte_at(start + 1);
    let b2: i32 = text.byte_at(start + 2);
    let b3: i32 = text.byte_at(start + 3);
    let b4: i32 = text.byte_at(start + 4);
    let b5: i32 = text.byte_at(start + 5);
    let b6: i32 = text.byte_at(start + 6);
    let b7: i32 = text.byte_at(start + 7);
    if b0 == 99 && b1 == 111 && b2 == 110 && b3 == 116 && b4 == 105 && b5 == 110 && b6 == 117 && b7 == 101 {
      return TokenKind.KwContinue; // continue
    }
    if b0 == 99 && b1 == 111 && b2 == 109 && b3 == 112 && b4 == 116 && b5 == 105 && b6 == 109 && b7 == 101 {
      return TokenKind.KwComptime; // comptime
    }
    return TokenKind.Ident;
  }

  return TokenKind.Ident;
}

pub fn lex_text(text: String) -> LexResult {
  let mut i: i32 = 0;
  let n: i32 = text.len();
  let mut line: i32 = 1;
  let mut col: i32 = 1;
  let mut toks: Vec[Token] = Vec();

  while i < n {
    let b: i32 = text.byte_at(i);

    // whitespace
    if is_space(b) {
      i = i + 1;
      if b == 10 {
        line = line + 1;
        col = 1;
      } else if !is_utf8_cont_byte(b) {
        col = col + 1;
      }
      continue;
    }

    // line comment: //
    if b == 47 {
      if (i + 1) < n {
        if text.byte_at(i + 1) == 47 {
          i = i + 2;
          col = col + 2;
          while i < n {
            let cb: i32 = text.byte_at(i);
            if cb == 10 {
              break;
            }
            i = i + 1;
            if !is_utf8_cont_byte(cb) { col = col + 1; }
          }
          continue;
        }
      }
    }

    let start: i32 = i;
    let start_line: i32 = line;
    let start_col: i32 = col;

    // identifier / keyword
    if is_alpha(b) {
      i = i + 1;
      col = col + 1;
      while i < n {
        if !is_alnum(text.byte_at(i)) {
          break;
        }
        i = i + 1;
        col = col + 1;
      }
      let k: TokenKind = kw_kind(text, start, i);
      toks.push(Token { kind: k, start: start, end: i, line: start_line, col: start_col });
      continue;
    }

    // number literal: int or float.
    // float forms:
    // - digits '.' digits
    // - digits [ '.' digits ] [e|E [+-]? digits]
    // - any of the above with suffix f32/f64
    if is_digit(b) {
      let mut is_float: bool = false;
      i = i + 1;
      col = col + 1;
      while i < n {
        if !is_digit(text.byte_at(i)) {
          break;
        }
        i = i + 1;
        col = col + 1;
      }

      // Fractional part requires at least one digit after dot.
      if i < n && text.byte_at(i) == 46 && (i + 1) < n && is_digit(text.byte_at(i + 1)) {
        is_float = true;
        i = i + 1; // '.'
        col = col + 1;
        while i < n {
          if !is_digit(text.byte_at(i)) { break; }
          i = i + 1;
          col = col + 1;
        }
      }

      // Optional scientific exponent.
      if i < n && (text.byte_at(i) == 101 || text.byte_at(i) == 69) { // e/E
        let mut j: i32 = i + 1;
        if j < n && (text.byte_at(j) == 43 || text.byte_at(j) == 45) { j = j + 1; } // +/-
        if j < n && is_digit(text.byte_at(j)) {
          is_float = true;
          col = col + (j - i);
          i = j + 1;
          col = col + 1;
          while i < n {
            if !is_digit(text.byte_at(i)) { break; }
            i = i + 1;
            col = col + 1;
          }
        }
      }

      // Optional explicit float suffix.
      if (i + 2) < n && text.byte_at(i) == 102 { // 'f'
        let b1: i32 = text.byte_at(i + 1);
        let b2: i32 = text.byte_at(i + 2);
        if (b1 == 51 && b2 == 50) || (b1 == 54 && b2 == 52) { // 32 / 64
          is_float = true;
          i = i + 3;
          col = col + 3;
        }
      }

      let kind: TokenKind = if is_float { TokenKind.Float } else { TokenKind.Int };
      toks.push(Token { kind: kind, start: start, end: i, line: start_line, col: start_col });
      continue;
    }

    // string literal: "..." or multiline """..."""
    if b == 34 { // '"'
      // Multiline triple-quoted string.
      if (i + 2) < n && text.byte_at(i + 1) == 34 && text.byte_at(i + 2) == 34 {
        i = i + 3;
        col = col + 3;
        let mut closed3: bool = false;
        while (i + 2) < n {
          if text.byte_at(i) == 34 && text.byte_at(i + 1) == 34 && text.byte_at(i + 2) == 34 {
            i = i + 3;
            col = col + 3;
            toks.push(Token { kind: TokenKind.Str, start: start, end: i, line: start_line, col: start_col });
            closed3 = true;
            break;
          }
          let cb: i32 = text.byte_at(i);
          i = i + 1;
          if cb == 10 {
            line = line + 1;
            col = 1;
          } else if !is_utf8_cont_byte(cb) {
            col = col + 1;
          }
        }
        if !closed3 {
          return LexResult { tokens: toks, err: LexError.UnterminatedString(start) };
        }
        continue;
      }

      i = i + 1;
      col = col + 1;
      let mut closed: bool = false;
      while i < n {
        let c: i32 = text.byte_at(i);
        if c == 34 { // closing '"'
          i = i + 1;
          col = col + 1;
          toks.push(Token { kind: TokenKind.Str, start: start, end: i, line: start_line, col: start_col });
          closed = true;
          break;
        }
        if c == 92 { // '\\' escape, skip next char if present
          i = i + 1;
          col = col + 1;
          if i < n {
            let c2: i32 = text.byte_at(i);
            i = i + 1;
            if c2 == 10 {
              line = line + 1;
              col = 1;
            } else if !is_utf8_cont_byte(c2) {
              col = col + 1;
            }
          }
          continue;
        }
        i = i + 1;
        if c == 10 {
          line = line + 1;
          col = 1;
        } else if !is_utf8_cont_byte(c) {
          col = col + 1;
        }
      }
      if !closed {
        return LexResult { tokens: toks, err: LexError.UnterminatedString(start) };
      }
      continue;
    }

    // char literal: `'a'`, `'\n'`, `'\''`, `'ä½ '`
    //
    // We only treat it as a char token when the quote pair encloses exactly one
    // scalar or one escape sequence. Otherwise fallback to Tick token, so
    // lifetime-like syntax (`'static`) keeps existing behavior.
    if b == 39 { // '\''
      let mut end_char: i32 = -1;
      if (i + 1) < n {
        let b1: i32 = text.byte_at(i + 1);
        if b1 == 92 { // escape form: '\'' '\n' ...
          if (i + 3) < n && text.byte_at(i + 3) == 39 {
            end_char = i + 4;
          }
        } else if b1 != 39 && b1 != 10 && b1 != 13 {
          let scalar_end: i32 = utf8_next_scalar_end(text, i + 1, n);
          if scalar_end < n && text.byte_at(scalar_end) == 39 {
            end_char = scalar_end + 1;
          }
        }
      }
      if end_char != -1 {
        let mut j: i32 = i;
        while j < end_char {
          let cb: i32 = text.byte_at(j);
          if cb == 10 {
            line = line + 1;
            col = 1;
          } else if !is_utf8_cont_byte(cb) {
            col = col + 1;
          }
          j = j + 1;
        }
        toks.push(Token { kind: TokenKind.Char, start: start, end: end_char, line: start_line, col: start_col });
        i = end_char;
        continue;
      }
      i = i + 1;
      col = col + 1;
      toks.push(Token { kind: TokenKind.Tick, start: start, end: i, line: start_line, col: start_col });
      continue;
    }

    // punctuators / operators (maximal munch)
    // 3-char ops
    if (i + 2) < n {
      let b1: i32 = text.byte_at(i + 1);
      let b2: i32 = text.byte_at(i + 2);
      // ...
      if b == 46 && b1 == 46 && b2 == 46 {
        i = i + 3;
        col = col + 3;
        toks.push(Token { kind: TokenKind.DotDotDot, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // ..=
      if b == 46 && b1 == 46 && b2 == 61 {
        i = i + 3;
        col = col + 3;
        toks.push(Token { kind: TokenKind.DotDotEq, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // <<=
      if b == 60 && b1 == 60 && b2 == 61 {
        i = i + 3;
        col = col + 3;
        toks.push(Token { kind: TokenKind.LtLtEq, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // >>=
      if b == 62 && b1 == 62 && b2 == 61 {
        i = i + 3;
        col = col + 3;
        toks.push(Token { kind: TokenKind.GtGtEq, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
    }

    // 2-char ops
    if (i + 1) < n {
      let b1: i32 = text.byte_at(i + 1);
      // ->
      if b == 45 && b1 == 62 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.Arrow, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // ..
      if b == 46 && b1 == 46 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.DotDot, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // =>
      if b == 61 && b1 == 62 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.FatArrow, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // +=
      if b == 43 && b1 == 61 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.PlusEq, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // -=
      if b == 45 && b1 == 61 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.MinusEq, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // *=
      if b == 42 && b1 == 61 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.StarEq, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // /=
      if b == 47 && b1 == 61 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.SlashEq, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // %=
      if b == 37 && b1 == 61 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.PercentEq, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // ==
      if b == 61 && b1 == 61 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.EqEq, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // !=
      if b == 33 && b1 == 61 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.Ne, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // <=
      if b == 60 && b1 == 61 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.Le, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // <<
      if b == 60 && b1 == 60 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.LtLt, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // >=
      if b == 62 && b1 == 61 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.Ge, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // >>
      if b == 62 && b1 == 62 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.GtGt, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // &&
      if b == 38 && b1 == 38 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.AndAnd, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // &=
      if b == 38 && b1 == 61 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.AmpEq, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // ||
      if b == 124 && b1 == 124 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.OrOr, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // |=
      if b == 124 && b1 == 61 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.PipeEq, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
      // ^=
      if b == 94 && b1 == 61 {
        i = i + 2;
        col = col + 2;
        toks.push(Token { kind: TokenKind.CaretEq, start: start, end: i, line: start_line, col: start_col });
        continue;
      }
    }

    // 1-char tokens
    if b == 40 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.LParen, start: start, end: i, line: start_line, col: start_col }); continue; }   // (
    if b == 41 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.RParen, start: start, end: i, line: start_line, col: start_col }); continue; }   // )
    if b == 123 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.LBrace, start: start, end: i, line: start_line, col: start_col }); continue; }  // {
    if b == 125 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.RBrace, start: start, end: i, line: start_line, col: start_col }); continue; }  // }
    if b == 91 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.LBracket, start: start, end: i, line: start_line, col: start_col }); continue; } // [
    if b == 93 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.RBracket, start: start, end: i, line: start_line, col: start_col }); continue; } // ]
    if b == 44 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Comma, start: start, end: i, line: start_line, col: start_col }); continue; }    // ,
    if b == 59 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Semicolon, start: start, end: i, line: start_line, col: start_col }); continue; } // ;
    if b == 46 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Dot, start: start, end: i, line: start_line, col: start_col }); continue; }      // .
    if b == 58 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Colon, start: start, end: i, line: start_line, col: start_col }); continue; }    // :
    if b == 64 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.At, start: start, end: i, line: start_line, col: start_col }); continue; }       // @
    if b == 36 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Dollar, start: start, end: i, line: start_line, col: start_col }); continue; }   // $
    if b == 39 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Tick, start: start, end: i, line: start_line, col: start_col }); continue; }     // '
    if b == 63 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Question, start: start, end: i, line: start_line, col: start_col }); continue; } // ?

    if b == 61 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Eq, start: start, end: i, line: start_line, col: start_col }); continue; }      // =
    if b == 60 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Lt, start: start, end: i, line: start_line, col: start_col }); continue; }      // <
    if b == 62 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Gt, start: start, end: i, line: start_line, col: start_col }); continue; }      // >
    if b == 33 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Not, start: start, end: i, line: start_line, col: start_col }); continue; }     // !

    if b == 43 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Plus, start: start, end: i, line: start_line, col: start_col }); continue; }    // +
    if b == 45 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Minus, start: start, end: i, line: start_line, col: start_col }); continue; }   // -
    if b == 42 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Star, start: start, end: i, line: start_line, col: start_col }); continue; }    // *
    if b == 47 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Slash, start: start, end: i, line: start_line, col: start_col }); continue; }   // /
    if b == 37 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Percent, start: start, end: i, line: start_line, col: start_col }); continue; } // %
    if b == 38 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Amp, start: start, end: i, line: start_line, col: start_col }); continue; }     // &
    if b == 124 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Pipe, start: start, end: i, line: start_line, col: start_col }); continue; }   // |
    if b == 94 { i = i + 1; col = col + 1; toks.push(Token { kind: TokenKind.Caret, start: start, end: i, line: start_line, col: start_col }); continue; }   // ^

    return LexResult { tokens: toks, err: LexError.UnexpectedChar(i) };
  }

  toks.push(Token { kind: TokenKind.Eof, start: n, end: n, line: line, col: col });
  return LexResult { tokens: toks, err: LexError.None };
}
