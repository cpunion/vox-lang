fn emit_runtime_to_string_fn(
  name: String,
  cty: String,
  fmt_expr: String,
  arg_expr: String,
  buf_size: i32,
) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("static const char* ".concat(name).concat("(").concat(cty).concat(" v) {"));
  out.push("  char buf[".concat(buf_size.to_string()).concat("];"));
  out.push("  int n = snprintf(buf, sizeof(buf), ".concat(fmt_expr).concat(", ").concat(arg_expr).concat(");"));
  out.push("  if (n < 0 || (size_t)n >= sizeof(buf)) { vox_host_panic(\"format failed or buffer too small\"); }");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)n + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");
  return out;
}

fn emit_rt_core_lines() -> Vec[String] {
  let mut out: Vec[String] = Vec();

  // Platform headers used by c_runtime only (kept out of top-level headers
  // so that user FFI extern declarations do not collide with system symbols).
  out.push("#include <dirent.h>");
  out.push("#include <sys/stat.h>");
  out.push("#if defined(_WIN32)");
  out.push("#define WIN32_LEAN_AND_MEAN");
  out.push("#include <windows.h>");
  out.push("#include <direct.h>");
  out.push("#include <io.h>");
  out.push("#if defined(_MSC_VER)");
  out.push("#pragma comment(lib, \"ws2_32.lib\")");
  out.push("#endif");
  out.push("#else");
  out.push("#include <errno.h>");
  out.push("#include <unistd.h>");
  out.push("#include <sched.h>");
  out.push("#if defined(__linux__)");
  out.push("int epoll_create1(int);");
  out.push("int epoll_ctl(int, int, int, void*);");
  out.push("int epoll_wait(int, void*, int, int);");
  out.push("int eventfd(unsigned int, int);");
  out.push("#define VOX_EPOLLIN       0x001");
  out.push("#define VOX_EPOLLOUT      0x004");
  out.push("#define VOX_EPOLLERR      0x008");
  out.push("#define VOX_EPOLLHUP      0x010");
  out.push("#define VOX_EPOLL_CTL_ADD 1");
  out.push("#define VOX_EPOLL_CLOEXEC 0x80000");
  out.push("#define VOX_EFD_NONBLOCK  0x800");
  out.push("#define VOX_EFD_CLOEXEC   0x80000");
  out.push("#endif");
  out.push("#if defined(__APPLE__)");
  out.push("int kqueue(void);");
  out.push("int kevent(int, void*, int, void*, int, void*);");
  out.push("#define VOX_EVFILT_READ   (-1)");
  out.push("#define VOX_EVFILT_WRITE  (-2)");
  out.push("#define VOX_EVFILT_USER   (-10)");
  out.push("#define VOX_EV_ADD        0x0001");
  out.push("#define VOX_EV_ENABLE     0x0004");
  out.push("#define VOX_EV_ONESHOT    0x0010");
  out.push("#define VOX_EV_CLEAR      0x0020");
  out.push("#define VOX_NOTE_TRIGGER  0x01000000");
  out.push("#define VOX_KEVENT_SZ 32");
  out.push("static void vox_kev_set(void* buf, uintptr_t ident, int16_t filter, uint16_t flags, uint32_t fflags, intptr_t data, void* udata) {");
  out.push("  memset(buf, 0, VOX_KEVENT_SZ);");
  out.push("  *(uintptr_t*)buf = ident;");
  out.push("  *(int16_t*)((char*)buf+8) = filter;");
  out.push("  *(uint16_t*)((char*)buf+10) = flags;");
  out.push("  *(uint32_t*)((char*)buf+12) = fflags;");
  out.push("  *(intptr_t*)((char*)buf+16) = data;");
  out.push("  *(void**)((char*)buf+24) = udata;");
  out.push("}");
  out.push("#elif defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)");
  out.push("#include <sys/event.h>");
  out.push("#endif");
  out.push("#endif");
  out.push("");

  out.push("#if defined(_MSC_VER)");
  out.push("#  define VOX_NORETURN __declspec(noreturn)");
  out.push("#elif defined(__GNUC__) || defined(__clang__)");
  out.push("#  define VOX_NORETURN __attribute__((noreturn))");
  out.push("#else");
  out.push("#  define VOX_NORETURN");
  out.push("#endif");
  out.push("");
  out.push("static VOX_NORETURN void vox_host_panic(const char* msg) {");
  out.push("  if (!msg) msg = \"\";");
  out.push("  size_t n = strlen(msg);");
  out.push("#ifdef _WIN32");
  out.push("  _write(2, msg, (unsigned int)n);");
  out.push("  _write(2, \"\\n\", 1);");
  out.push("#else");
  out.push("  write(2, msg, n);");
  out.push("  write(2, \"\\n\", 1);");
  out.push("#endif");
  out.push("  exit(1);");
  out.push("}");
  out.push("");

  // Unit value representation (cannot use `void` for locals/fields in C).
  out.push("typedef uint8_t vox_unit;");

  // Stage1/Stage2 converged Vec runtime:
  // - per-value logical len
  // - shared backing storage handle (copy-safe under realloc)
  out.push("typedef struct { uint8_t* data; int32_t cap; int32_t elem_size; } vox_vec_data;");
  out.push("typedef struct { vox_vec_data* h; int32_t len; } vox_vec;");
  out.push("typedef struct vox_alloc_node { void* ptr; struct vox_alloc_node* next; } vox_alloc_node;");
  out.push("static vox_alloc_node* vox_alloc_head = NULL;");
  out.push("static bool vox_alloc_cleanup_registered = false;");
  out.push("static void vox_impl_cleanup(void) {");
  out.push("  vox_alloc_node* cur = vox_alloc_head;");
  out.push("  vox_alloc_head = NULL;");
  out.push("  while (cur) {");
  out.push("    vox_alloc_node* next = cur->next;");
  out.push("    if (cur->ptr) free(cur->ptr);");
  out.push("    free(cur);");
  out.push("    cur = next;");
  out.push("  }");
  out.push("}");
  out.push("static void vox_impl_register_cleanup(void) {");
  out.push("  if (vox_alloc_cleanup_registered) return;");
  out.push("  if (atexit(vox_impl_cleanup) != 0) { vox_host_panic(\"register atexit cleanup failed\"); }");
  out.push("  vox_alloc_cleanup_registered = true;");
  out.push("}");
  out.push("static void* vox_impl_malloc(size_t n) {");
  out.push("  if (n == 0) n = 1;");
  out.push("  void* p = malloc(n);");
  out.push("  if (!p) { vox_host_panic(\"out of memory\"); }");
  out.push("  vox_impl_register_cleanup();");
  out.push("  vox_alloc_node* node = (vox_alloc_node*)malloc(sizeof(vox_alloc_node));");
  out.push("  if (!node) { vox_host_panic(\"out of memory\"); }");
  out.push("  node->ptr = p;");
  out.push("  node->next = vox_alloc_head;");
  out.push("  vox_alloc_head = node;");
  out.push("  return p;");
  out.push("}");
  out.push("static void* vox_impl_realloc(void* old_ptr, size_t n) {");
  out.push("  if (!old_ptr) return vox_impl_malloc(n);");
  out.push("  if (n == 0) n = 1;");
  out.push("  void* p = realloc(old_ptr, n);");
  out.push("  if (!p) { vox_host_panic(\"out of memory\"); }");
  out.push("  vox_alloc_node* cur = vox_alloc_head;");
  out.push("  while (cur) {");
  out.push("    if (cur->ptr == old_ptr) {");
  out.push("      cur->ptr = p;");
  out.push("      return p;");
  out.push("    }");
  out.push("    cur = cur->next;");
  out.push("  }");
  out.push("  vox_impl_register_cleanup();");
  out.push("  vox_alloc_node* node = (vox_alloc_node*)malloc(sizeof(vox_alloc_node));");
  out.push("  if (!node) { vox_host_panic(\"out of memory\"); }");
  out.push("  node->ptr = p;");
  out.push("  node->next = vox_alloc_head;");
  out.push("  vox_alloc_head = node;");
  out.push("  return p;");
  out.push("}");
  out.push("static bool vox_impl_forget(void* p) {");
  out.push("  if (!p) return false;");
  out.push("  vox_alloc_node** cur = &vox_alloc_head;");
  out.push("  while (*cur) {");
  out.push("    vox_alloc_node* node = *cur;");
  out.push("    if (node->ptr == p) {");
  out.push("      *cur = node->next;");
  out.push("      free(node);");
  out.push("      return true;");
  out.push("    }");
  out.push("    cur = &node->next;");
  out.push("  }");
  out.push("  return false;");
  out.push("}");
  out.push("static void vox_impl_free(void* p) {");
  out.push("  if (!p) return;");
  out.push("  bool tracked = vox_impl_forget(p);");
  out.push("  if (!tracked) return;");
  out.push("  free(p);");
  out.push("}");
  out.push("static vox_vec_data* vox_vec_data_new(int32_t elem_size) {");
  out.push("  vox_vec_data* h = (vox_vec_data*)vox_impl_malloc(sizeof(vox_vec_data));");
  out.push("  if (!h) { vox_host_panic(\"out of memory\"); }");
  out.push("  h->data = NULL;");
  out.push("  h->cap = 0;");
  out.push("  h->elem_size = elem_size;");
  out.push("  return h;");
  out.push("}");
  out.push("static vox_vec vox_vec_new(int32_t elem_size) {");
  out.push("  vox_vec v; v.h = vox_vec_data_new(elem_size); v.len = 0; return v;");
  out.push("}");
  out.push("static void vox_vec_grow(vox_vec* v, int32_t new_cap) {");
  out.push("  if (!v || !v->h) { vox_host_panic(\"vec grow invalid vec\"); }");
  out.push("  if (new_cap <= v->h->cap) return;");
  out.push("  if (new_cap < 4) new_cap = 4;");
  out.push("  size_t bytes = (size_t)new_cap * (size_t)v->h->elem_size;");
  out.push("  uint8_t* p = (uint8_t*)vox_impl_realloc(v->h->data, bytes);");
  out.push("  if (!p) { vox_host_panic(\"out of memory\"); }");
  out.push("  v->h->data = p;");
  out.push("  v->h->cap = new_cap;");
  out.push("}");
  out.push("static void vox_vec_push(vox_vec* v, const void* elem) {");
  out.push("  if (!v || !v->h || !elem) { vox_host_panic(\"vec push invalid args\"); }");
  out.push("  if (v->len == v->h->cap) { int32_t nc = v->h->cap == 0 ? 4 : v->h->cap * 2; vox_vec_grow(v, nc); }");
  out.push("  memcpy(v->h->data + (size_t)v->len * (size_t)v->h->elem_size, elem, (size_t)v->h->elem_size);");
  out.push("  v->len++;");
  out.push("}");
  out.push("static void vox_vec_insert(vox_vec* v, int32_t idx, const void* elem) {");
  out.push("  if (!v || !v->h || !elem) { vox_host_panic(\"vec insert invalid args\"); }");
  out.push("  if (idx < 0 || idx > v->len) { char buf[96]; snprintf(buf, sizeof(buf), \"vec insert index out of bounds: idx=%\" PRId32 \" len=%\" PRId32, idx, v->len); vox_host_panic(buf); }");
  out.push("  if (v->len == v->h->cap) { int32_t nc = v->h->cap == 0 ? 4 : v->h->cap * 2; vox_vec_grow(v, nc); }");
  out.push("  uint8_t* ptr = v->h->data + (size_t)idx * (size_t)v->h->elem_size;");
  out.push("  int32_t tail = v->len - idx;");
  out.push("  if (tail > 0) {");
  out.push("    memmove(ptr + (size_t)v->h->elem_size, ptr, (size_t)tail * (size_t)v->h->elem_size);");
  out.push("  }");
  out.push("  memcpy(ptr, elem, (size_t)v->h->elem_size);");
  out.push("  v->len++;");
  out.push("}");
  out.push("static void vox_vec_set(vox_vec* v, int32_t idx, const void* elem) {");
  out.push("  if (!v || !v->h || !elem) { vox_host_panic(\"vec set invalid args\"); }");
  out.push("  if (idx < 0 || idx >= v->len) { char buf[96]; snprintf(buf, sizeof(buf), \"vec set index out of bounds: idx=%\" PRId32 \" len=%\" PRId32, idx, v->len); vox_host_panic(buf); }");
  out.push("  memcpy(v->h->data + (size_t)idx * (size_t)v->h->elem_size, elem, (size_t)v->h->elem_size);");
  out.push("}");
  out.push("static void vox_vec_clear(vox_vec* v) {");
  out.push("  if (!v) return;");
  out.push("  v->len = 0;");
  out.push("}");
  out.push("static void vox_vec_extend(vox_vec* v, const vox_vec* other) {");
  out.push("  if (!v || !v->h || !other || !other->h) return;");
  out.push("  if (other->len <= 0) return;");
  out.push("  if (v->h->elem_size != other->h->elem_size) { vox_host_panic(\"vec extend elem_size mismatch\"); }");
  out.push("  int64_t need64 = (int64_t)v->len + (int64_t)other->len;");
  out.push("  if (need64 > INT32_MAX) { vox_host_panic(\"vec too large\"); }");
  out.push("  int32_t need = (int32_t)need64;");
  out.push("  if (need > v->h->cap) {");
  out.push("    int32_t nc = v->h->cap == 0 ? 4 : v->h->cap;");
  out.push("    while (nc < need) {");
  out.push("      if (nc > INT32_MAX / 2) { nc = need; break; }");
  out.push("      nc = nc * 2;");
  out.push("    }");
  out.push("    vox_vec_grow(v, nc);");
  out.push("  }");
  out.push("  memcpy(v->h->data + (size_t)v->len * (size_t)v->h->elem_size, other->h->data, (size_t)other->len * (size_t)other->h->elem_size);");
  out.push("  v->len = need;");
  out.push("}");
  out.push("static void vox_vec_pop(vox_vec* v, void* out) {");
  out.push("  if (!v || !v->h || !out) { vox_host_panic(\"vec pop invalid args\"); }");
  out.push("  if (v->len <= 0) { vox_host_panic(\"vec pop on empty vector\"); }");
  out.push("  int32_t idx = v->len - 1;");
  out.push("  memcpy(out, v->h->data + (size_t)idx * (size_t)v->h->elem_size, (size_t)v->h->elem_size);");
  out.push("  v->len = idx;");
  out.push("}");
  out.push("static void vox_vec_remove(vox_vec* v, int32_t idx, void* out) {");
  out.push("  if (!v || !v->h || !out) { vox_host_panic(\"vec remove invalid args\"); }");
  out.push("  if (idx < 0 || idx >= v->len) { char buf[96]; snprintf(buf, sizeof(buf), \"vec remove index out of bounds: idx=%\" PRId32 \" len=%\" PRId32, idx, v->len); vox_host_panic(buf); }");
  out.push("  uint8_t* ptr = v->h->data + (size_t)idx * (size_t)v->h->elem_size;");
  out.push("  memcpy(out, ptr, (size_t)v->h->elem_size);");
  out.push("  int32_t tail = v->len - idx - 1;");
  out.push("  if (tail > 0) {");
  out.push("    memmove(ptr, ptr + (size_t)v->h->elem_size, (size_t)tail * (size_t)v->h->elem_size);");
  out.push("  }");
  out.push("  v->len = v->len - 1;");
  out.push("}");
  out.push("static int32_t vox_vec_len(const vox_vec* v) { return v ? v->len : 0; }");
  out.push("static bool vox_vec_eq(const vox_vec* a, const vox_vec* b) {");
  out.push("  if (!a || !b) return false;");
  out.push("  if (a->len != b->len) return false;");
  out.push("  if (!a->h || !b->h) return a->len == 0 && b->len == 0;");
  out.push("  if (a->h->elem_size != b->h->elem_size) return false;");
  out.push("  size_t bytes = (size_t)a->len * (size_t)a->h->elem_size;");
  out.push("  if (bytes == 0) return true;");
  out.push("  return memcmp(a->h->data, b->h->data, bytes) == 0;");
  out.push("}");
  out.push("static void vox_vec_get(const vox_vec* v, int32_t idx, void* out) {");
  out.push("  if (!v || !v->h || !out) { vox_host_panic(\"vec get invalid args\"); }");
  out.push("  if (idx < 0 || idx >= v->len) { char buf[96]; snprintf(buf, sizeof(buf), \"vec index out of bounds: idx=%\" PRId32 \" len=%\" PRId32, idx, v->len); vox_host_panic(buf); }");
  out.push("  memcpy(out, v->h->data + (size_t)idx * (size_t)v->h->elem_size, (size_t)v->h->elem_size);");
  out.push("}");
  out.push("");

  // Minimal string runtime helpers (stage0).
  out.push("static int32_t vox_str_len(const char* s) {");
  out.push("  if (!s) return 0;");
  out.push("  size_t n = strlen(s);");
  out.push("  if (n > INT32_MAX) { vox_host_panic(\"string too long\"); }");
  out.push("  return (int32_t)n;");
  out.push("}");
  out.push("static int32_t vox_str_byte_at(const char* s, int32_t idx) {");
  out.push("  int32_t n = vox_str_len(s);");
  out.push("  if (idx < 0 || idx >= n) { vox_host_panic(\"string index out of bounds\"); }");
  out.push("  return (int32_t)(uint8_t)s[idx];");
  out.push("}");
  out.push("");
  out.push("static const char* vox_str_slice(const char* s, int32_t start, int32_t end) {");
  out.push("  int32_t n = vox_str_len(s);");
  out.push("  if (start < 0 || end < start || end > n) { vox_host_panic(\"string slice out of bounds\"); }");
  out.push("  int32_t m = end - start;");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)m + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, s + start, (size_t)m);");
  out.push("  out[m] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_str_concat(const char* a, const char* b) {");
  out.push("  if (!a) a = \"\";");
  out.push("  if (!b) b = \"\";");
  out.push("  size_t na = strlen(a);");
  out.push("  size_t nb = strlen(b);");
  out.push("  if (na + nb + 1 > SIZE_MAX) { vox_host_panic(\"string too long\"); }");
  out.push("  char* out = (char*)vox_impl_malloc(na + nb + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, a, na);");
  out.push("  memcpy(out + na, b, nb);");
  out.push("  out[na + nb] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static bool vox_str_starts_with(const char* s, const char* pre) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!pre) pre = \"\";");
  out.push("  size_t ns = strlen(s);");
  out.push("  size_t np = strlen(pre);");
  out.push("  if (np > ns) return false;");
  out.push("  return memcmp(s, pre, np) == 0;");
  out.push("}");
  out.push("");
  out.push("static bool vox_str_ends_with(const char* s, const char* suf) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!suf) suf = \"\";");
  out.push("  size_t ns = strlen(s);");
  out.push("  size_t nf = strlen(suf);");
  out.push("  if (nf > ns) return false;");
  out.push("  return memcmp(s + (ns - nf), suf, nf) == 0;");
  out.push("}");
  out.push("");
  out.push("static bool vox_str_contains(const char* s, const char* needle) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!needle) needle = \"\";");
  out.push("  return strstr(s, needle) != NULL;");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_str_index_of(const char* s, const char* needle) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!needle) needle = \"\";");
  out.push("  if (needle[0] == '\\0') return 0;");
  out.push("  const char* p = strstr(s, needle);");
  out.push("  if (!p) return -1;");
  out.push("  size_t idx = (size_t)(p - s);");
  out.push("  if (idx > (size_t)INT32_MAX) { vox_host_panic(\"string index overflow\"); }");
  out.push("  return (int32_t)idx;");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_str_last_index_of(const char* s, const char* needle) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!needle) needle = \"\";");
  out.push("  int32_t ns = vox_str_len(s);");
  out.push("  int32_t nn = vox_str_len(needle);");
  out.push("  if (nn == 0) return ns;");
  out.push("  if (ns < nn) return -1;");
  out.push("  int32_t last = -1;");
  out.push("  for (int32_t i = 0; i <= ns - nn; i++) {");
  out.push("    if (memcmp(s + i, needle, (size_t)nn) == 0) last = i;");
  out.push("  }");
  out.push("  return last;");
  out.push("}");
  out.push("");
  out = append_lines(out, emit_runtime_to_string_fn("vox_i32_to_string", "int32_t", "\"%\" PRId32", "v", 32));
  out = append_lines(out, emit_runtime_to_string_fn("vox_i64_to_string", "int64_t", "\"%\" PRId64", "v", 32));
  out = append_lines(out, emit_runtime_to_string_fn("vox_u64_to_string", "uint64_t", "\"%\" PRIu64", "v", 32));
  out = append_lines(out, emit_runtime_to_string_fn("vox_isize_to_string", "intptr_t", "\"%\" PRIdPTR", "v", 32));
  out = append_lines(out, emit_runtime_to_string_fn("vox_usize_to_string", "uintptr_t", "\"%\" PRIuPTR", "v", 32));
  out = append_lines(out, emit_runtime_to_string_fn("vox_f32_to_string", "float", "\"%.9g\"", "(double)v", 64));
  out = append_lines(out, emit_runtime_to_string_fn("vox_f64_to_string", "double", "\"%.17g\"", "v", 64));
  out.push("static const char* vox_bool_to_string(bool v) {");
  out.push("  return v ? \"true\" : \"false\";");
  out.push("}");
  out.push("");
  out.push("static const char* vox_str_escape_c(const char* s) {");
  out.push("  if (!s) s = \"\";");
  out.push("  size_t n = strlen(s);");
  out.push("  // First pass: compute output length.");
  out.push("  size_t out_n = 0;");
  out.push("  for (size_t i = 0; i < n; i++) {");
  out.push("    unsigned char ch = (unsigned char)s[i];");
  out.push("    switch (ch) {");
  out.push("    case '\\\\':");
  out.push("    case '\"':");
  out.push("    case '\\n':");
  out.push("    case '\\r':");
  out.push("    case '\\t':");
  out.push("      out_n += 2;");
  out.push("      break;");
  out.push("    default:");
  out.push("      if (ch >= 0x20 && ch <= 0x7e) out_n += 1; else out_n += 4; // \\\\xHH");
  out.push("      break;");
  out.push("    }");
  out.push("  }");
  out.push("  char* out = (char*)vox_impl_malloc(out_n + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  size_t j = 0;");
  out.push("  for (size_t i = 0; i < n; i++) {");
  out.push("    unsigned char ch = (unsigned char)s[i];");
  out.push("    switch (ch) {");
  out.push("    case '\\\\': out[j++] = '\\\\'; out[j++] = '\\\\'; break;");
  out.push("    case '\"': out[j++] = '\\\\'; out[j++] = '\"'; break;");
  out.push("    case '\\n': out[j++] = '\\\\'; out[j++] = 'n'; break;");
  out.push("    case '\\r': out[j++] = '\\\\'; out[j++] = 'r'; break;");
  out.push("    case '\\t': out[j++] = '\\\\'; out[j++] = 't'; break;");
  out.push("    default:");
  out.push("      if (ch >= 0x20 && ch <= 0x7e) { out[j++] = (char)ch; }");
  out.push("      else {");
  out.push("        static const char* hex = \"0123456789abcdef\";");
  out.push("        out[j++] = '\\\\'; out[j++] = 'x';");
  out.push("        out[j++] = hex[(ch >> 4) & 0xf];");
  out.push("        out[j++] = hex[ch & 0xf];");
  out.push("      }");
  out.push("      break;");
  out.push("    }");
  out.push("  }");
  out.push("  out[j] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_vec_str_join(const vox_vec* v, const char* sep) {");
  out.push("  if (!sep) sep = \"\";");
  out.push("  if (!v || !v->h || v->h->elem_size != (int32_t)sizeof(const char*)) { vox_host_panic(\"vec_str_join expects Vec[String]\"); }");
  out.push("  int32_t n = v->len;");
  out.push("  const char* const* items = (const char* const*)v->h->data;");
  out.push("  size_t sep_n = strlen(sep);");
  out.push("  size_t total = 0;");
  out.push("  for (int32_t i = 0; i < n; i++) {");
  out.push("    const char* s = items[i];");
  out.push("    if (!s) s = \"\";");
  out.push("    total += strlen(s);");
  out.push("    if (i + 1 < n) total += sep_n;");
  out.push("  }");
  out.push("  if (total + 1 > SIZE_MAX) { vox_host_panic(\"string too long\"); }");
  out.push("  char* out = (char*)vox_impl_malloc(total + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  size_t j = 0;");
  out.push("  for (int32_t i = 0; i < n; i++) {");
  out.push("    const char* s = items[i];");
  out.push("    if (!s) s = \"\";");
  out.push("    size_t m = strlen(s);");
  out.push("    memcpy(out + j, s, m);");
  out.push("    j += m;");
  out.push("    if (i + 1 < n && sep_n != 0) {");
  out.push("      memcpy(out + j, sep, sep_n);");
  out.push("      j += sep_n;");
  out.push("    }");
  out.push("  }");
  out.push("  out[j] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");

  return out;
}
