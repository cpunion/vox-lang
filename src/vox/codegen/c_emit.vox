// Stability: Experimental module API (vox/codegen).
// Migration: API may change between minor releases; backend options/runtime ABI may evolve.

import "vox/ir" as ir

pub enum DriverMainKind { User, Tool }

pub struct EmitOptions {
  pub emit_driver_main: bool,
  pub driver_main_kind: DriverMainKind,
  pub emit_test_main: bool,
  pub test_funcs: Vec[String], // qualified IR names
}

fn emit_header_lines() -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("// generated by vox stage1");
  out.push("#include <stdint.h>");
  out.push("#include <stdbool.h>");
  out.push("#include <inttypes.h>");
  out.push("#include <stddef.h>");
  out.push("#include <string.h>");
  out.push("#include <limits.h>");
  out.push("#include <math.h>");
  out.push("#include <stdatomic.h>");
  out.push("#include <time.h>");
  out.push("");
  out.push("extern void* malloc(size_t);");
  out.push("extern void* realloc(void*, size_t);");
  out.push("extern void free(void*);");
  out.push("extern int atexit(void(*)(void));");
  out.push("extern void exit(int);");
  out.push("extern int printf(const char*, ...);");
  out.push("extern int snprintf(char*, size_t, const char*, ...);");
  out.push("");
  return out;
}

fn append_lines(out0: Vec[String], lines: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = out0;
  let mut i: i32 = 0;
  while i < lines.len() {
    out.push(lines.get(i));
    i = i + 1;
  }
  return out;
}

fn emit_forward_decl(pool: ir.TyPool, f: ir.Func) -> String {
  let mut s: String = "static ".concat(c_ret_type(pool, f.ret)).concat(" ").concat(c_fn_name(f.name)).concat("(");
  let mut i: i32 = 0;
  while i < f.params.len() {
    if i != 0 { s = s.concat(", "); }
    let pa: ir.Param = f.params.get(i);
    s = s.concat(c_type(pool, pa.ty)).concat(" ").concat(c_param_name(i));
    i = i + 1;
  }
  return s.concat(");");
}

fn emit_ffi_import_decl(pool: ir.TyPool, f: ir.FfiImportDecl) -> String {
  if f.target != "c" && f.target != "wasm" { panic("c backend does not support ffi_import target: ".concat(f.target)); }
  let mut pre: String = "extern ";
  let mut cname: String = f.symbol;
  if f.target == "wasm" {
    let q: String = "\"";
    pre = pre
      .concat("__attribute__((import_module(")
      .concat(q)
      .concat(f.module)
      .concat(q)
      .concat("), import_name(")
      .concat(q)
      .concat(f.symbol)
      .concat(q)
      .concat("))) ");
    cname = c_ffi_import_name(f.func);
  }

  let mut s: String = pre.concat(c_ret_type(pool, f.ret)).concat(" ").concat(cname).concat("(");
  let mut i: i32 = 0;
  while i < f.params.len() {
    if i != 0 { s = s.concat(", "); }
    let pa: ir.Param = f.params.get(i);
    s = s.concat(c_type(pool, pa.ty)).concat(" ").concat(c_param_name(i));
    i = i + 1;
  }
  if f.has_variadic {
    if f.params.len() != 0 { s = s.concat(", "); }
    s = s.concat("...");
  }
  return s.concat(");");
}

fn static_init_value(pool: ir.TyPool, sv: ir.StaticVarDecl) -> String {
  // init_kind: 1=int, 2=bool, 3=str, 4=float
  if sv.init_kind == 2 {
    return if sv.init_bv { "true" } else { "false" };
  }
  if sv.init_kind == 3 {
    return "\"".concat(sv.init_sv.escape_c()).concat("\"");
  }
  if sv.init_kind == 4 {
    return sv.init_sv;
  }
  // Default: integer init (kind 1 or 0).
  let t: ir.Ty = ir.ty_pool_get(pool, sv.ty);
  let rk: ir.TyKind = t.kind;
  let is_string: bool = match rk { ir.TyKind.String => true, _ => false };
  if is_string { return "\"\""; }
  let is_rawptr: bool = match rk { ir.TyKind.RawPtr => true, _ => false };
  if is_rawptr { return "(void*)0"; }
  return sv.init_iv.to_string();
}

struct FindFuncByNameResult { found: bool, f: ir.Func }

fn find_func_by_name(p: ir.Program, name: String) -> FindFuncByNameResult {
  let mut i: i32 = 0;
  while i < p.funcs.len() {
    let f: ir.Func = p.funcs.get(i);
    if f.name == name { return FindFuncByNameResult { found: true, f: f }; }
    i = i + 1;
  }
  return FindFuncByNameResult { found: false, f: ir.Func { name: "", params: Vec(), ret: -1, blocks: Vec() } };
}

fn emit_ffi_export_wrapper(pool: ir.TyPool, p: ir.Program, ex: ir.FfiExportDecl) -> Vec[String] {
  if ex.target != "c" && ex.target != "wasm" { panic("c backend does not support ffi_export target: ".concat(ex.target)); }
  let fr: FindFuncByNameResult = find_func_by_name(p, ex.func);
  if !fr.found { panic("ffi export function not found"); }

  let f: ir.Func = fr.f;
  let mut out: Vec[String] = Vec();
  let mut sig: String = "";
  let mut cname: String = ex.symbol;
  if ex.target == "wasm" {
    let q: String = "\"";
    sig = "__attribute__((export_name("
      .concat(q)
      .concat(ex.symbol)
      .concat(q)
      .concat("))) ");
    cname = c_ffi_export_wasm_name(ex.func, ex.symbol);
  }
  sig = sig.concat(c_ret_type(pool, f.ret)).concat(" ").concat(cname).concat("(");
  let mut i: i32 = 0;
  while i < f.params.len() {
    if i != 0 { sig = sig.concat(", "); }
    let pa: ir.Param = f.params.get(i);
    sig = sig.concat(c_type(pool, pa.ty)).concat(" ").concat(c_param_name(i));
    i = i + 1;
  }
  sig = sig.concat(") {");
  out.push(sig);

  let mut call: String = c_fn_name(f.name).concat("(");
  i = 0;
  while i < f.params.len() {
    if i != 0 { call = call.concat(", "); }
    call = call.concat(c_param_name(i));
    i = i + 1;
  }
  call = call.concat(")");

  let rk: ir.TyKind = main_ret_kind(pool, f.ret);
  if rk == ir.TyKind.Unit {
    out.push("  ".concat(call).concat(";"));
    out.push("  return;");
  } else {
    out.push("  return ".concat(call).concat(";"));
  }
  out.push("}");
  return out;
}

fn find_main(p: ir.Program) -> MainResult {
  let mut i: i32 = 0;
  while i < p.funcs.len() {
    let f: ir.Func = p.funcs.get(i);
    if f.name == "main" { return MainResult { found: true, f: f }; }
    i = i + 1;
  }
  return MainResult { found: false, f: ir.Func { name: "", params: Vec(), ret: -1, blocks: Vec() } };
}

struct MainResult { found: bool, f: ir.Func }

fn main_ret_kind(pool: ir.TyPool, ty0: i32) -> ir.TyKind {
  let mut cur: i32 = ty0;
  while true {
    let t: ir.Ty = ir.ty_pool_get(pool, cur);
    if t.kind == ir.TyKind.Range || t.kind == ir.TyKind.Verified || t.kind == ir.TyKind.Ref {
      cur = t.elem;
      continue;
    }
    return t.kind;
  }
  return ir.TyKind.Bad;
}

fn emit_driver_main(pool: ir.TyPool, main_fn: ir.Func, kind: DriverMainKind, statics: Vec[ir.StaticVarDecl]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("int main(int argc, char** argv) {");
  out.push("  vox__argc = argc;");
  out.push("  vox__argv = argv;");
  // Propagate argc/argv to Vox statics if std/sys declares them.
  let mut si: i32 = 0;
  while si < statics.len() {
    let sv: ir.StaticVarDecl = statics.get(si);
    if sv.name == "std/sys::g_argc" {
      out.push("  ".concat(c_static_name(sv.name)).concat(" = (int32_t)argc;"));
    }
    if sv.name == "std/sys::g_argv" {
      out.push("  ".concat(c_static_name(sv.name)).concat(" = (intptr_t)argv;"));
    }
    si = si + 1;
  }
  let rk: ir.TyKind = main_ret_kind(pool, main_fn.ret);
  if kind == DriverMainKind.User {
    if rk == ir.TyKind.Unit {
      out.push("  ".concat(c_fn_name("main")).concat("();"));
    } else if rk == ir.TyKind.Bool {
      out.push("  bool v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%s\\n\", v ? \"true\" : \"false\");");
    } else if rk == ir.TyKind.I8 {
      out.push("  int8_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRId8 \"\\n\", v);");
    } else if rk == ir.TyKind.U8 {
      out.push("  uint8_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRIu8 \"\\n\", v);");
    } else if rk == ir.TyKind.I16 {
      out.push("  int16_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRId16 \"\\n\", v);");
    } else if rk == ir.TyKind.U16 {
      out.push("  uint16_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRIu16 \"\\n\", v);");
    } else if rk == ir.TyKind.I32 {
      out.push("  int32_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRId32 \"\\n\", v);");
    } else if rk == ir.TyKind.U32 {
      out.push("  uint32_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRIu32 \"\\n\", v);");
    } else if rk == ir.TyKind.I64 {
      out.push("  int64_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRId64 \"\\n\", v);");
    } else if rk == ir.TyKind.ISize {
      out.push("  intptr_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRIdPTR \"\\n\", v);");
    } else if rk == ir.TyKind.U64 {
      out.push("  uint64_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRIu64 \"\\n\", v);");
    } else if rk == ir.TyKind.USize {
      out.push("  uintptr_t v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%\" PRIuPTR \"\\n\", v);");
    } else if rk == ir.TyKind.F32 {
      out.push("  float v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%.9g\\n\", (double)v);");
    } else if rk == ir.TyKind.F64 {
      out.push("  double v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%.17g\\n\", v);");
    } else if rk == ir.TyKind.String {
      out.push("  const char* v = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%s\\n\", v ? v : \"\");");
    } else {
      panic("unsupported main return type in driver");
    }
    out.push("  return 0;");
  } else {
    if rk == ir.TyKind.Unit {
      out.push("  ".concat(c_fn_name("main")).concat("();"));
      out.push("  return 0;");
    } else if rk == ir.TyKind.Bool {
      out.push("  bool rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return rc ? 0 : 1;");
    } else if rk == ir.TyKind.I8 {
      out.push("  int8_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.U8 {
      out.push("  uint8_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.I16 {
      out.push("  int16_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.U16 {
      out.push("  uint16_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.I32 {
      out.push("  int32_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.U32 {
      out.push("  uint32_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.I64 {
      out.push("  int64_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.ISize {
      out.push("  intptr_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.U64 {
      out.push("  uint64_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.USize {
      out.push("  uintptr_t rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.F32 {
      out.push("  float rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.F64 {
      out.push("  double rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.String {
      out.push("  const char* rc = ".concat(c_fn_name("main")).concat("();"));
      out.push("  printf(\"%s\\n\", rc ? rc : \"\");");
      out.push("  return 0;");
    } else {
      panic("unsupported main return type in tool driver (expected ()/bool/<int>/<float>/String)");
    }
  }
  out.push("}");
  return out;
}

fn emit_test_main(test_funcs: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("int main(int argc, char** argv) {");
  out.push("  vox__argc = argc;");
  out.push("  vox__argv = argv;");
  out.push("  if (argc < 2 || !argv[1]) { vox_host_panic(\"missing test name\"); }");
  out.push("  const char* name = argv[1];");
  let mut i: i32 = 0;
  while i < test_funcs.len() {
    let n: String = test_funcs.get(i);
    out.push("  if (strcmp(name, \"".concat(n).concat("\") == 0) { ").concat(c_fn_name(n)).concat("(); return 0; }"));
    i = i + 1;
  }
  out.push("  { char buf[256]; snprintf(buf, sizeof(buf), \"unknown test: %s\", name); vox_host_panic(buf); }");
  out.push("}");
  return out;
}

pub fn emit_c(p: ir.Program, opts: EmitOptions) -> String {
  let pool: ir.TyPool = p.pool;
  let mut out: Vec[String] = emit_header_lines();
  out = append_lines(out, emit_runtime_lines());
  out = append_lines(out, emit_nominal_types(pool, p));
  out = append_lines(out, emit_nominal_eq_lines(pool, p));

  let mut fi: i32 = 0;
  while fi < p.ffi_imports.len() {
    let tgt: String = p.ffi_imports.get(fi).target;
    if tgt != "c" && tgt != "wasm" {
      panic("c backend does not support ffi_import target: ".concat(tgt));
    }
    fi = fi + 1;
  }
  let mut fe: i32 = 0;
  while fe < p.ffi_exports.len() {
    let tgt: String = p.ffi_exports.get(fe).target;
    if tgt != "c" && tgt != "wasm" {
      panic("c backend does not support ffi_export target: ".concat(tgt));
    }
    fe = fe + 1;
  }

  // Static variables.
  if p.statics.len() != 0 {
    let mut sti: i32 = 0;
    while sti < p.statics.len() {
      let sv: ir.StaticVarDecl = p.statics.get(sti);
      let c_ty: String = c_type(pool, sv.ty);
      let c_name: String = c_static_name(sv.name);
      let init_str: String = static_init_value(pool, sv);
      out.push("static ".concat(c_ty).concat(" ").concat(c_name).concat(" = ").concat(init_str).concat(";"));
      sti = sti + 1;
    }
    out.push("");
  }

  // Forward decls (ffi imports first, then internal funcs).
  let mut ii: i32 = 0;
  while ii < p.ffi_imports.len() {
    out.push(emit_ffi_import_decl(pool, p.ffi_imports.get(ii)));
    ii = ii + 1;
  }
  if p.ffi_imports.len() != 0 { out.push(""); }

  let mut i: i32 = 0;
  while i < p.funcs.len() {
    out.push(emit_forward_decl(pool, p.funcs.get(i)));
    i = i + 1;
  }
  out.push("");

  // Func defs
  let mut j: i32 = 0;
  while j < p.funcs.len() {
    out = append_lines(out, emit_func(pool, p, p.funcs.get(j)));
    out.push("");
    j = j + 1;
  }

  // C exports wrappers.
  let mut exi: i32 = 0;
  while exi < p.ffi_exports.len() {
    out = append_lines(out, emit_ffi_export_wrapper(pool, p, p.ffi_exports.get(exi)));
    out.push("");
    exi = exi + 1;
  }

  if opts.emit_driver_main && opts.emit_test_main {
    panic("cannot emit both driver main and test main");
  }

  if opts.emit_driver_main {
    let mr: MainResult = find_main(p);
    if !mr.found { panic("missing function main"); }
    out = append_lines(out, emit_driver_main(pool, mr.f, opts.driver_main_kind, p.statics));
  }
  if opts.emit_test_main {
    out = append_lines(out, emit_test_main(opts.test_funcs));
  }

  return out.join("\n").concat("\n");
}
