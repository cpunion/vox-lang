// Stability: Experimental module API (vox/codegen).
// Migration: API may change between minor releases; backend options/runtime ABI may evolve.

import "vox/ir" as ir

pub enum DriverMainKind { User, Tool }

pub struct EmitOptions {
  pub emit_driver_main: bool,
  pub driver_main_kind: DriverMainKind,
  pub emit_test_main: bool,
  pub test_funcs: Vec[String], // qualified IR names
  pub c_sources: Vec[String], // .c file contents to embed
}

fn append_lines(out0: Vec[String], lines: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = out0;
  let mut i: i32 = 0;
  while i < lines.len() {
    out.push(lines.get(i));
    i = i + 1;
  }
  return out;
}

fn emit_forward_decl(pool: ir.TyPool, f: ir.Func) -> String {
  let is_main: bool = f.name == "main";
  let mut s: String = "static ".concat(c_ret_type(pool, f.ret)).concat(" ").concat(c_fn_name(f.name)).concat("(");
  if is_main {
    s = s.concat("int32_t vox_p_argc, intptr_t vox_p_argv");
    if f.params.len() != 0 { s = s.concat(", "); }
  }
  let mut i: i32 = 0;
  while i < f.params.len() {
    if i != 0 { s = s.concat(", "); }
    let pa: ir.Param = f.params.get(i);
    s = s.concat(c_type(pool, pa.ty)).concat(" ").concat(c_param_name(i));
    i = i + 1;
  }
  return s.concat(");");
}

fn emit_ffi_import_params(pool: ir.TyPool, f: ir.FfiImportDecl) -> String {
  let mut s: String = "(";
  let mut i: i32 = 0;
  while i < f.params.len() {
    if i != 0 { s = s.concat(", "); }
    let pa: ir.Param = f.params.get(i);
    let ty_str: String = c_type(pool, pa.ty);
    s = s.concat(ty_str).concat(" ").concat(c_param_name(i));
    i = i + 1;
  }
  if f.has_variadic {
    if f.params.len() != 0 { s = s.concat(", "); }
    s = s.concat("...");
  }
  return s.concat(");");
}

fn emit_ffi_import_decl(pool: ir.TyPool, f: ir.FfiImportDecl) -> Vec[String] {
  if f.target != "c" && f.target != "wasm" { panic("c backend does not support ffi_import target: ".concat(f.target)); }
  let mut pre: String = "extern ";
  let mut cname: String = f.symbol;
  if f.target == "wasm" {
    let q: String = "\"";
    pre = pre
      .concat("__attribute__((import_module(")
      .concat(q)
      .concat(f.module)
      .concat(q)
      .concat("), import_name(")
      .concat(q)
      .concat(f.symbol)
      .concat(q)
      .concat("))) ");
    cname = c_ffi_import_name(f.func);
  }

  let params: String = emit_ffi_import_params(pool, f);
  let ret: String = c_ret_type(pool, f.ret);
  let mut out: Vec[String] = Vec();

  if f.calling_convention == "system" {
    out.push("#ifdef _WIN32");
    out.push(pre.concat(ret).concat(" __stdcall ").concat(cname).concat(params));
    out.push("#else");
    out.push(pre.concat(ret).concat(" ").concat(cname).concat(params));
    out.push("#endif");
  } else {
    out.push(pre.concat(ret).concat(" ").concat(cname).concat(params));
  }
  return out;
}

fn static_init_value(pool: ir.TyPool, sv: ir.StaticVarDecl) -> String {
  // init_kind: 1=int, 2=bool, 3=str, 4=float
  if sv.init_kind == 2 {
    return if sv.init_bv { "true" } else { "false" };
  }
  if sv.init_kind == 3 {
    return "\"".concat(sv.init_sv.escape_c()).concat("\"");
  }
  if sv.init_kind == 4 {
    return sv.init_sv;
  }
  // Default: integer init (kind 1 or 0).
  let t: ir.Ty = ir.ty_pool_get(pool, sv.ty);
  let rk: ir.TyKind = t.kind;
  let is_string: bool = match rk { ir.TyKind.String => true, _ => false };
  if is_string { return "\"\""; }
  let is_rawptr: bool = match rk { ir.TyKind.RawPtr => true, _ => false };
  if is_rawptr { return "(void*)0"; }
  return sv.init_iv.to_string();
}

struct FindFuncByNameResult { found: bool, f: ir.Func }

fn find_func_by_name(p: ir.Program, name: String) -> FindFuncByNameResult {
  let mut i: i32 = 0;
  while i < p.funcs.len() {
    let f: ir.Func = p.funcs.get(i);
    if f.name == name { return FindFuncByNameResult { found: true, f: f }; }
    i = i + 1;
  }
  return FindFuncByNameResult { found: false, f: ir.Func { name: "", params: Vec(), ret: -1, blocks: Vec() } };
}

fn emit_ffi_export_wrapper(pool: ir.TyPool, p: ir.Program, ex: ir.FfiExportDecl) -> Vec[String] {
  if ex.target != "c" && ex.target != "wasm" { panic("c backend does not support ffi_export target: ".concat(ex.target)); }
  let fr: FindFuncByNameResult = find_func_by_name(p, ex.func);
  if !fr.found { panic("ffi export function not found"); }

  let f: ir.Func = fr.f;
  let mut out: Vec[String] = Vec();
  let mut sig: String = "";
  let mut cname: String = ex.symbol;
  if ex.target == "wasm" {
    let q: String = "\"";
    sig = "__attribute__((export_name("
      .concat(q)
      .concat(ex.symbol)
      .concat(q)
      .concat("))) ");
    cname = c_ffi_export_wasm_name(ex.func, ex.symbol);
  }
  sig = sig.concat(c_ret_type(pool, f.ret)).concat(" ").concat(cname).concat("(");
  let mut i: i32 = 0;
  while i < f.params.len() {
    if i != 0 { sig = sig.concat(", "); }
    let pa: ir.Param = f.params.get(i);
    sig = sig.concat(c_type(pool, pa.ty)).concat(" ").concat(c_param_name(i));
    i = i + 1;
  }
  sig = sig.concat(") {");
  out.push(sig);

  let mut call: String = c_fn_name(f.name).concat("(");
  i = 0;
  while i < f.params.len() {
    if i != 0 { call = call.concat(", "); }
    call = call.concat(c_param_name(i));
    i = i + 1;
  }
  call = call.concat(")");

  let rk: ir.TyKind = main_ret_kind(pool, f.ret);
  if rk == ir.TyKind.Unit {
    out.push("  ".concat(call).concat(";"));
    out.push("  return;");
  } else {
    out.push("  return ".concat(call).concat(";"));
  }
  out.push("}");
  return out;
}

fn find_main(p: ir.Program) -> MainResult {
  let mut i: i32 = 0;
  while i < p.funcs.len() {
    let f: ir.Func = p.funcs.get(i);
    if f.name == "main" { return MainResult { found: true, f: f }; }
    i = i + 1;
  }
  return MainResult { found: false, f: ir.Func { name: "", params: Vec(), ret: -1, blocks: Vec() } };
}

struct MainResult { found: bool, f: ir.Func }

fn main_ret_kind(pool: ir.TyPool, ty0: i32) -> ir.TyKind {
  let mut cur: i32 = ty0;
  while true {
    let t: ir.Ty = ir.ty_pool_get(pool, cur);
    if t.kind == ir.TyKind.Range || t.kind == ir.TyKind.Verified || t.kind == ir.TyKind.Ref {
      cur = t.elem;
      continue;
    }
    return t.kind;
  }
  return ir.TyKind.Bad;
}

fn emit_driver_main(pool: ir.TyPool, main_fn: ir.Func, kind: DriverMainKind, statics: Vec[ir.StaticVarDecl]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("int main(int argc, char** argv) {");
  // Propagate argc/argv to Vox statics if std/sys declares them.
  let mut si: i32 = 0;
  while si < statics.len() {
    let sv: ir.StaticVarDecl = statics.get(si);
    if sv.name == "std/sys::g_argc" {
      out.push("  ".concat(c_static_name(sv.name)).concat(" = (int32_t)argc;"));
    }
    if sv.name == "std/sys::g_argv" {
      out.push("  ".concat(c_static_name(sv.name)).concat(" = (intptr_t)argv;"));
    }
    si = si + 1;
  }
  let rk: ir.TyKind = main_ret_kind(pool, main_fn.ret);
  if kind == DriverMainKind.User {
    if rk == ir.TyKind.Unit {
      out.push("  ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
    } else if rk == ir.TyKind.Bool {
      out.push("  bool v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%s\\n\", v ? \"true\" : \"false\");");
    } else if rk == ir.TyKind.I8 {
      out.push("  int8_t v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%\" PRId8 \"\\n\", v);");
    } else if rk == ir.TyKind.U8 {
      out.push("  uint8_t v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%\" PRIu8 \"\\n\", v);");
    } else if rk == ir.TyKind.I16 {
      out.push("  int16_t v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%\" PRId16 \"\\n\", v);");
    } else if rk == ir.TyKind.U16 {
      out.push("  uint16_t v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%\" PRIu16 \"\\n\", v);");
    } else if rk == ir.TyKind.I32 {
      out.push("  int32_t v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%\" PRId32 \"\\n\", v);");
    } else if rk == ir.TyKind.U32 {
      out.push("  uint32_t v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%\" PRIu32 \"\\n\", v);");
    } else if rk == ir.TyKind.I64 {
      out.push("  int64_t v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%\" PRId64 \"\\n\", v);");
    } else if rk == ir.TyKind.ISize {
      out.push("  intptr_t v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%\" PRIdPTR \"\\n\", v);");
    } else if rk == ir.TyKind.U64 {
      out.push("  uint64_t v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%\" PRIu64 \"\\n\", v);");
    } else if rk == ir.TyKind.USize {
      out.push("  uintptr_t v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%\" PRIuPTR \"\\n\", v);");
    } else if rk == ir.TyKind.F32 {
      out.push("  float v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%.9g\\n\", (double)v);");
    } else if rk == ir.TyKind.F64 {
      out.push("  double v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%.17g\\n\", v);");
    } else if rk == ir.TyKind.String {
      out.push("  const char* v = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%s\\n\", v ? v : \"\");");
    } else {
      panic("unsupported main return type in driver");
    }
    out.push("  return 0;");
  } else {
    if rk == ir.TyKind.Unit {
      out.push("  ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return 0;");
    } else if rk == ir.TyKind.Bool {
      out.push("  bool rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return rc ? 0 : 1;");
    } else if rk == ir.TyKind.I8 {
      out.push("  int8_t rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.U8 {
      out.push("  uint8_t rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.I16 {
      out.push("  int16_t rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.U16 {
      out.push("  uint16_t rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.I32 {
      out.push("  int32_t rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.U32 {
      out.push("  uint32_t rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.I64 {
      out.push("  int64_t rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.ISize {
      out.push("  intptr_t rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.U64 {
      out.push("  uint64_t rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.USize {
      out.push("  uintptr_t rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.F32 {
      out.push("  float rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.F64 {
      out.push("  double rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  return (int)rc;");
    } else if rk == ir.TyKind.String {
      out.push("  const char* rc = ".concat(c_fn_name("main")).concat("((int32_t)argc, (intptr_t)argv);"));
      out.push("  printf(\"%s\\n\", rc ? rc : \"\");");
      out.push("  return 0;");
    } else {
      panic("unsupported main return type in tool driver (expected ()/bool/<int>/<float>/String)");
    }
  }
  out.push("}");
  return out;
}

fn emit_test_main(test_funcs: Vec[String], statics: Vec[ir.StaticVarDecl]) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("int main(int argc, char** argv) {");
  // Propagate argc/argv to Vox statics if std/sys declares them.
  let mut si: i32 = 0;
  while si < statics.len() {
    let sv: ir.StaticVarDecl = statics.get(si);
    if sv.name == "std/sys::g_argc" {
      out.push("  ".concat(c_static_name(sv.name)).concat(" = (int32_t)argc;"));
    }
    if sv.name == "std/sys::g_argv" {
      out.push("  ".concat(c_static_name(sv.name)).concat(" = (intptr_t)argv;"));
    }
    si = si + 1;
  }
  out.push("  if (argc < 2 || !argv[1]) { vox_host_panic(\"missing test name\"); }");
  out.push("  const char* name = argv[1];");
  let mut i: i32 = 0;
  while i < test_funcs.len() {
    let n: String = test_funcs.get(i);
    out.push("  if (strcmp(name, \"".concat(n).concat("\") == 0) { ").concat(c_fn_name(n)).concat("(); return 0; }"));
    i = i + 1;
  }
  out.push("  { char buf[256]; snprintf(buf, sizeof(buf), \"unknown test: %s\", name); vox_host_panic(buf); }");
  out.push("}");
  return out;
}

fn emit_runtime_core(out0: Vec[String]) -> Vec[String] {
  let mut out: Vec[String] = out0;
  out.push("#ifndef VOX_RUNTIME_CORE");
  out.push("#define VOX_RUNTIME_CORE");
  // Platform headers.
  out.push("#if defined(_WIN32)");
  out.push("extern int _write(int, const void*, unsigned int);");
  out.push("#if defined(_MSC_VER)");
  out.push("#pragma comment(lib, \"ws2_32.lib\")");
  out.push("#endif");
  out.push("#else");
  out.push("#include <errno.h>");
  out.push("#include <unistd.h>");
  out.push("#include <sched.h>");
  out.push("#endif");
  out.push("");
  // VOX_NORETURN macro.
  out.push("#if defined(_MSC_VER)");
  out.push("#  define VOX_NORETURN __declspec(noreturn)");
  out.push("#elif defined(__GNUC__) || defined(__clang__)");
  out.push("#  define VOX_NORETURN __attribute__((noreturn))");
  out.push("#else");
  out.push("#  define VOX_NORETURN");
  out.push("#endif");
  out.push("");
  // vox_host_panic.
  out.push("static VOX_NORETURN void vox_host_panic(const char* msg) {");
  out.push("  if (!msg) msg = \"\";");
  out.push("  size_t n = strlen(msg);");
  out.push("#ifdef _WIN32");
  out.push("  _write(2, msg, (unsigned int)n);");
  out.push("  _write(2, \"\\n\", 1);");
  out.push("#else");
  out.push("  write(2, msg, n);");
  out.push("  write(2, \"\\n\", 1);");
  out.push("#endif");
  out.push("  exit(1);");
  out.push("}");
  out.push("");
  // Type definitions.
  out.push("typedef uint8_t vox_unit;");
  out.push("typedef struct { uint8_t* data; int32_t cap; int32_t elem_size; } vox_vec_data;");
  out.push("typedef struct { vox_vec_data* h; int32_t len; } vox_vec;");
  out.push("");
  // Simplified allocator (no tracking).
  out.push("static void* vox_impl_malloc(size_t n) {");
  out.push("  if (n == 0) n = 1;");
  out.push("  void* p = malloc(n);");
  out.push("  if (!p) { vox_host_panic(\"out of memory\"); }");
  out.push("  return p;");
  out.push("}");
  out.push("static void* vox_impl_realloc(void* old_ptr, size_t n) {");
  out.push("  if (!old_ptr) return vox_impl_malloc(n);");
  out.push("  if (n == 0) n = 1;");
  out.push("  void* p = realloc(old_ptr, n);");
  out.push("  if (!p) { vox_host_panic(\"out of memory\"); }");
  out.push("  return p;");
  out.push("}");
  out.push("static void vox_impl_free(void* p) {");
  out.push("  if (!p) return;");
  out.push("  free(p);");
  out.push("}");
  out.push("");
  // Vec functions.
  out.push("static vox_vec_data* vox_vec_data_new(int32_t elem_size) {");
  out.push("  vox_vec_data* h = (vox_vec_data*)vox_impl_malloc(sizeof(vox_vec_data));");
  out.push("  if (!h) { vox_host_panic(\"out of memory\"); }");
  out.push("  h->data = NULL;");
  out.push("  h->cap = 0;");
  out.push("  h->elem_size = elem_size;");
  out.push("  return h;");
  out.push("}");
  out.push("static vox_vec vox_vec_new(int32_t elem_size) {");
  out.push("  vox_vec v; v.h = vox_vec_data_new(elem_size); v.len = 0; return v;");
  out.push("}");
  out.push("static void vox_vec_grow(vox_vec* v, int32_t new_cap) {");
  out.push("  if (!v || !v->h) { vox_host_panic(\"vec grow invalid vec\"); }");
  out.push("  if (new_cap <= v->h->cap) return;");
  out.push("  if (new_cap < 4) new_cap = 4;");
  out.push("  size_t bytes = (size_t)new_cap * (size_t)v->h->elem_size;");
  out.push("  uint8_t* p = (uint8_t*)vox_impl_realloc(v->h->data, bytes);");
  out.push("  if (!p) { vox_host_panic(\"out of memory\"); }");
  out.push("  v->h->data = p;");
  out.push("  v->h->cap = new_cap;");
  out.push("}");
  out.push("static void vox_vec_push(vox_vec* v, const void* elem) {");
  out.push("  if (!v || !v->h || !elem) { vox_host_panic(\"vec push invalid args\"); }");
  out.push("  if (v->len == v->h->cap) { int32_t nc = v->h->cap == 0 ? 4 : v->h->cap * 2; vox_vec_grow(v, nc); }");
  out.push("  memcpy(v->h->data + (size_t)v->len * (size_t)v->h->elem_size, elem, (size_t)v->h->elem_size);");
  out.push("  v->len++;");
  out.push("}");
  out.push("static void vox_vec_insert(vox_vec* v, int32_t idx, const void* elem) {");
  out.push("  if (!v || !v->h || !elem) { vox_host_panic(\"vec insert invalid args\"); }");
  out.push("  if (idx < 0 || idx > v->len) { char buf[96]; snprintf(buf, sizeof(buf), \"vec insert index out of bounds: idx=%\" PRId32 \" len=%\" PRId32, idx, v->len); vox_host_panic(buf); }");
  out.push("  if (v->len == v->h->cap) { int32_t nc = v->h->cap == 0 ? 4 : v->h->cap * 2; vox_vec_grow(v, nc); }");
  out.push("  uint8_t* ptr = v->h->data + (size_t)idx * (size_t)v->h->elem_size;");
  out.push("  int32_t tail = v->len - idx;");
  out.push("  if (tail > 0) {");
  out.push("    memmove(ptr + (size_t)v->h->elem_size, ptr, (size_t)tail * (size_t)v->h->elem_size);");
  out.push("  }");
  out.push("  memcpy(ptr, elem, (size_t)v->h->elem_size);");
  out.push("  v->len++;");
  out.push("}");
  out.push("static void vox_vec_set(vox_vec* v, int32_t idx, const void* elem) {");
  out.push("  if (!v || !v->h || !elem) { vox_host_panic(\"vec set invalid args\"); }");
  out.push("  if (idx < 0 || idx >= v->len) { char buf[96]; snprintf(buf, sizeof(buf), \"vec set index out of bounds: idx=%\" PRId32 \" len=%\" PRId32, idx, v->len); vox_host_panic(buf); }");
  out.push("  memcpy(v->h->data + (size_t)idx * (size_t)v->h->elem_size, elem, (size_t)v->h->elem_size);");
  out.push("}");
  out.push("static void vox_vec_clear(vox_vec* v) {");
  out.push("  if (!v) return;");
  out.push("  v->len = 0;");
  out.push("}");
  out.push("static void vox_vec_extend(vox_vec* v, const vox_vec* other) {");
  out.push("  if (!v || !v->h || !other || !other->h) return;");
  out.push("  if (other->len <= 0) return;");
  out.push("  if (v->h->elem_size != other->h->elem_size) { vox_host_panic(\"vec extend elem_size mismatch\"); }");
  out.push("  int64_t need64 = (int64_t)v->len + (int64_t)other->len;");
  out.push("  if (need64 > INT32_MAX) { vox_host_panic(\"vec too large\"); }");
  out.push("  int32_t need = (int32_t)need64;");
  out.push("  if (need > v->h->cap) {");
  out.push("    int32_t nc = v->h->cap == 0 ? 4 : v->h->cap;");
  out.push("    while (nc < need) {");
  out.push("      if (nc > INT32_MAX / 2) { nc = need; break; }");
  out.push("      nc = nc * 2;");
  out.push("    }");
  out.push("    vox_vec_grow(v, nc);");
  out.push("  }");
  out.push("  memcpy(v->h->data + (size_t)v->len * (size_t)v->h->elem_size, other->h->data, (size_t)other->len * (size_t)other->h->elem_size);");
  out.push("  v->len = need;");
  out.push("}");
  out.push("static void vox_vec_pop(vox_vec* v, void* out) {");
  out.push("  if (!v || !v->h || !out) { vox_host_panic(\"vec pop invalid args\"); }");
  out.push("  if (v->len <= 0) { vox_host_panic(\"vec pop on empty vector\"); }");
  out.push("  int32_t idx = v->len - 1;");
  out.push("  memcpy(out, v->h->data + (size_t)idx * (size_t)v->h->elem_size, (size_t)v->h->elem_size);");
  out.push("  v->len = idx;");
  out.push("}");
  out.push("static void vox_vec_remove(vox_vec* v, int32_t idx, void* out) {");
  out.push("  if (!v || !v->h || !out) { vox_host_panic(\"vec remove invalid args\"); }");
  out.push("  if (idx < 0 || idx >= v->len) { char buf[96]; snprintf(buf, sizeof(buf), \"vec remove index out of bounds: idx=%\" PRId32 \" len=%\" PRId32, idx, v->len); vox_host_panic(buf); }");
  out.push("  uint8_t* ptr = v->h->data + (size_t)idx * (size_t)v->h->elem_size;");
  out.push("  memcpy(out, ptr, (size_t)v->h->elem_size);");
  out.push("  int32_t tail = v->len - idx - 1;");
  out.push("  if (tail > 0) {");
  out.push("    memmove(ptr, ptr + (size_t)v->h->elem_size, (size_t)tail * (size_t)v->h->elem_size);");
  out.push("  }");
  out.push("  v->len = v->len - 1;");
  out.push("}");
  out.push("static int32_t vox_vec_len(const vox_vec* v) { return v ? v->len : 0; }");
  out.push("static bool vox_vec_eq(const vox_vec* a, const vox_vec* b) {");
  out.push("  if (!a || !b) return false;");
  out.push("  if (a->len != b->len) return false;");
  out.push("  if (!a->h || !b->h) return a->len == 0 && b->len == 0;");
  out.push("  if (a->h->elem_size != b->h->elem_size) return false;");
  out.push("  size_t bytes = (size_t)a->len * (size_t)a->h->elem_size;");
  out.push("  if (bytes == 0) return true;");
  out.push("  return memcmp(a->h->data, b->h->data, bytes) == 0;");
  out.push("}");
  out.push("static void vox_vec_get(const vox_vec* v, int32_t idx, void* out) {");
  out.push("  if (!v || !v->h || !out) { vox_host_panic(\"vec get invalid args\"); }");
  out.push("  if (idx < 0 || idx >= v->len) { char buf[96]; snprintf(buf, sizeof(buf), \"vec index out of bounds: idx=%\" PRId32 \" len=%\" PRId32, idx, v->len); vox_host_panic(buf); }");
  out.push("  memcpy(out, v->h->data + (size_t)idx * (size_t)v->h->elem_size, (size_t)v->h->elem_size);");
  out.push("}");
  out.push("");
  // String functions.
  out.push("static int32_t vox_str_len(const char* s) {");
  out.push("  if (!s) return 0;");
  out.push("  size_t n = strlen(s);");
  out.push("  if (n > INT32_MAX) { vox_host_panic(\"string too long\"); }");
  out.push("  return (int32_t)n;");
  out.push("}");
  out.push("static int32_t vox_str_byte_at(const char* s, int32_t idx) {");
  out.push("  int32_t n = vox_str_len(s);");
  out.push("  if (idx < 0 || idx >= n) { vox_host_panic(\"string index out of bounds\"); }");
  out.push("  return (int32_t)(uint8_t)s[idx];");
  out.push("}");
  out.push("");
  out.push("static const char* vox_str_slice(const char* s, int32_t start, int32_t end) {");
  out.push("  int32_t n = vox_str_len(s);");
  out.push("  if (start < 0 || end < start || end > n) { vox_host_panic(\"string slice out of bounds\"); }");
  out.push("  int32_t m = end - start;");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)m + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, s + start, (size_t)m);");
  out.push("  out[m] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_str_concat(const char* a, const char* b) {");
  out.push("  if (!a) a = \"\";");
  out.push("  if (!b) b = \"\";");
  out.push("  size_t na = strlen(a);");
  out.push("  size_t nb = strlen(b);");
  out.push("  if (na + nb + 1 > SIZE_MAX) { vox_host_panic(\"string too long\"); }");
  out.push("  char* out = (char*)vox_impl_malloc(na + nb + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, a, na);");
  out.push("  memcpy(out + na, b, nb);");
  out.push("  out[na + nb] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static bool vox_str_starts_with(const char* s, const char* pre) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!pre) pre = \"\";");
  out.push("  size_t ns = strlen(s);");
  out.push("  size_t np = strlen(pre);");
  out.push("  if (np > ns) return false;");
  out.push("  return memcmp(s, pre, np) == 0;");
  out.push("}");
  out.push("");
  out.push("static bool vox_str_ends_with(const char* s, const char* suf) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!suf) suf = \"\";");
  out.push("  size_t ns = strlen(s);");
  out.push("  size_t nf = strlen(suf);");
  out.push("  if (nf > ns) return false;");
  out.push("  return memcmp(s + (ns - nf), suf, nf) == 0;");
  out.push("}");
  out.push("");
  out.push("static bool vox_str_contains(const char* s, const char* needle) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!needle) needle = \"\";");
  out.push("  return strstr(s, needle) != NULL;");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_str_index_of(const char* s, const char* needle) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!needle) needle = \"\";");
  out.push("  if (needle[0] == '\\0') return 0;");
  out.push("  const char* p = strstr(s, needle);");
  out.push("  if (!p) return -1;");
  out.push("  size_t idx = (size_t)(p - s);");
  out.push("  if (idx > (size_t)INT32_MAX) { vox_host_panic(\"string index overflow\"); }");
  out.push("  return (int32_t)idx;");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_str_last_index_of(const char* s, const char* needle) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!needle) needle = \"\";");
  out.push("  int32_t ns = vox_str_len(s);");
  out.push("  int32_t nn = vox_str_len(needle);");
  out.push("  if (nn == 0) return ns;");
  out.push("  if (ns < nn) return -1;");
  out.push("  int32_t last = -1;");
  out.push("  for (int32_t i = 0; i <= ns - nn; i++) {");
  out.push("    if (memcmp(s + i, needle, (size_t)nn) == 0) last = i;");
  out.push("  }");
  out.push("  return last;");
  out.push("}");
  out.push("");
  // to_string functions.
  out.push("static const char* vox_i32_to_string(int32_t v) {");
  out.push("  char buf[32];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%\" PRId32, v);");
  out.push("  if (n < 0 || (size_t)n >= sizeof(buf)) { vox_host_panic(\"format failed or buffer too small\"); }");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)n + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_i64_to_string(int64_t v) {");
  out.push("  char buf[32];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%\" PRId64, v);");
  out.push("  if (n < 0 || (size_t)n >= sizeof(buf)) { vox_host_panic(\"format failed or buffer too small\"); }");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)n + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_u64_to_string(uint64_t v) {");
  out.push("  char buf[32];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%\" PRIu64, v);");
  out.push("  if (n < 0 || (size_t)n >= sizeof(buf)) { vox_host_panic(\"format failed or buffer too small\"); }");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)n + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_isize_to_string(intptr_t v) {");
  out.push("  char buf[32];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%\" PRIdPTR, v);");
  out.push("  if (n < 0 || (size_t)n >= sizeof(buf)) { vox_host_panic(\"format failed or buffer too small\"); }");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)n + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_usize_to_string(uintptr_t v) {");
  out.push("  char buf[32];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%\" PRIuPTR, v);");
  out.push("  if (n < 0 || (size_t)n >= sizeof(buf)) { vox_host_panic(\"format failed or buffer too small\"); }");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)n + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_f32_to_string(float v) {");
  out.push("  char buf[64];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%.9g\", (double)v);");
  out.push("  if (n < 0 || (size_t)n >= sizeof(buf)) { vox_host_panic(\"format failed or buffer too small\"); }");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)n + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_f64_to_string(double v) {");
  out.push("  char buf[64];");
  out.push("  int n = snprintf(buf, sizeof(buf), \"%.17g\", v);");
  out.push("  if (n < 0 || (size_t)n >= sizeof(buf)) { vox_host_panic(\"format failed or buffer too small\"); }");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)n + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_bool_to_string(bool v) {");
  out.push("  return v ? \"true\" : \"false\";");
  out.push("}");
  out.push("");
  // vox_str_escape_c.
  out.push("static const char* vox_str_escape_c(const char* s) {");
  out.push("  if (!s) s = \"\";");
  out.push("  size_t n = strlen(s);");
  out.push("  size_t out_n = 0;");
  out.push("  for (size_t i = 0; i < n; i++) {");
  out.push("    unsigned char ch = (unsigned char)s[i];");
  out.push("    switch (ch) {");
  out.push("    case '\\\\':");
  out.push("    case '\"':");
  out.push("    case '\\n':");
  out.push("    case '\\r':");
  out.push("    case '\\t':");
  out.push("      out_n += 2;");
  out.push("      break;");
  out.push("    default:");
  out.push("      if (ch >= 0x20 && ch <= 0x7e) out_n += 1; else out_n += 4;");
  out.push("      break;");
  out.push("    }");
  out.push("  }");
  out.push("  char* out = (char*)vox_impl_malloc(out_n + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  size_t j = 0;");
  out.push("  for (size_t i = 0; i < n; i++) {");
  out.push("    unsigned char ch = (unsigned char)s[i];");
  out.push("    switch (ch) {");
  out.push("    case '\\\\': out[j++] = '\\\\'; out[j++] = '\\\\'; break;");
  out.push("    case '\"': out[j++] = '\\\\'; out[j++] = '\"'; break;");
  out.push("    case '\\n': out[j++] = '\\\\'; out[j++] = 'n'; break;");
  out.push("    case '\\r': out[j++] = '\\\\'; out[j++] = 'r'; break;");
  out.push("    case '\\t': out[j++] = '\\\\'; out[j++] = 't'; break;");
  out.push("    default:");
  out.push("      if (ch >= 0x20 && ch <= 0x7e) { out[j++] = (char)ch; }");
  out.push("      else {");
  out.push("        static const char* hex = \"0123456789abcdef\";");
  out.push("        out[j++] = '\\\\'; out[j++] = 'x';");
  out.push("        out[j++] = hex[(ch >> 4) & 0xf];");
  out.push("        out[j++] = hex[ch & 0xf];");
  out.push("      }");
  out.push("      break;");
  out.push("    }");
  out.push("  }");
  out.push("  out[j] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  // vox_vec_str_join.
  out.push("static const char* vox_vec_str_join(const vox_vec* v, const char* sep) {");
  out.push("  if (!sep) sep = \"\";");
  out.push("  if (!v || !v->h || v->h->elem_size != (int32_t)sizeof(const char*)) { vox_host_panic(\"vec_str_join expects Vec[String]\"); }");
  out.push("  int32_t n = v->len;");
  out.push("  const char* const* items = (const char* const*)v->h->data;");
  out.push("  size_t sep_n = strlen(sep);");
  out.push("  size_t total = 0;");
  out.push("  for (int32_t i = 0; i < n; i++) {");
  out.push("    const char* s = items[i];");
  out.push("    if (!s) s = \"\";");
  out.push("    total += strlen(s);");
  out.push("    if (i + 1 < n) total += sep_n;");
  out.push("  }");
  out.push("  if (total + 1 > SIZE_MAX) { vox_host_panic(\"string too long\"); }");
  out.push("  char* out = (char*)vox_impl_malloc(total + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  size_t j = 0;");
  out.push("  for (int32_t i = 0; i < n; i++) {");
  out.push("    const char* s = items[i];");
  out.push("    if (!s) s = \"\";");
  out.push("    size_t m = strlen(s);");
  out.push("    memcpy(out + j, s, m);");
  out.push("    j += m;");
  out.push("    if (i + 1 < n && sep_n != 0) {");
  out.push("      memcpy(out + j, sep, sep_n);");
  out.push("      j += sep_n;");
  out.push("    }");
  out.push("  }");
  out.push("  out[j] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("#endif /* VOX_RUNTIME_CORE */");
  out.push("");

  // Atomic helper functions â€” exposed as non-static so @ffi_import can reference them.
  // These use C11 <stdatomic.h> (included via _preamble.c).
  out.push("int32_t rt_atomic_i32_load(void* p) { return atomic_load_explicit((_Atomic int32_t*)p, memory_order_seq_cst); }");
  out.push("void rt_atomic_i32_store(void* p, int32_t v) { atomic_store_explicit((_Atomic int32_t*)p, v, memory_order_seq_cst); }");
  out.push("bool rt_atomic_i32_cas(void* p, int32_t expected, int32_t desired) { return atomic_compare_exchange_strong_explicit((_Atomic int32_t*)p, &expected, desired, memory_order_seq_cst, memory_order_seq_cst); }");
  out.push("int32_t rt_atomic_i32_fetch_add(void* p, int32_t delta) { return atomic_fetch_add_explicit((_Atomic int32_t*)p, delta, memory_order_seq_cst); }");
  out.push("int64_t rt_atomic_i64_load(void* p) { return atomic_load_explicit((_Atomic int64_t*)p, memory_order_seq_cst); }");
  out.push("void rt_atomic_i64_store(void* p, int64_t v) { atomic_store_explicit((_Atomic int64_t*)p, v, memory_order_seq_cst); }");
  out.push("bool rt_atomic_i64_cas(void* p, int64_t expected, int64_t desired) { return atomic_compare_exchange_strong_explicit((_Atomic int64_t*)p, &expected, desired, memory_order_seq_cst, memory_order_seq_cst); }");
  out.push("int64_t rt_atomic_i64_fetch_add(void* p, int64_t delta) { return atomic_fetch_add_explicit((_Atomic int64_t*)p, delta, memory_order_seq_cst); }");
  out.push("");

  return out;
}

pub fn emit_c(p: ir.Program, opts: EmitOptions) -> String {
  let pool: ir.TyPool = p.pool;
  let mut out: Vec[String] = emit_c_sources(opts.c_sources);
  out = emit_runtime_core(out);
  out = append_lines(out, emit_nominal_types(pool, p));
  out = append_lines(out, emit_nominal_eq_lines(pool, p));

  let mut fi: i32 = 0;
  while fi < p.ffi_imports.len() {
    let tgt: String = p.ffi_imports.get(fi).target;
    if tgt != "c" && tgt != "wasm" {
      panic("c backend does not support ffi_import target: ".concat(tgt));
    }
    fi = fi + 1;
  }
  let mut fe: i32 = 0;
  while fe < p.ffi_exports.len() {
    let tgt: String = p.ffi_exports.get(fe).target;
    if tgt != "c" && tgt != "wasm" {
      panic("c backend does not support ffi_export target: ".concat(tgt));
    }
    fe = fe + 1;
  }

  // Static variables.
  if p.statics.len() != 0 {
    let mut sti: i32 = 0;
    while sti < p.statics.len() {
      let sv: ir.StaticVarDecl = p.statics.get(sti);
      let c_ty: String = c_type(pool, sv.ty);
      let c_name: String = c_static_name(sv.name);
      let init_str: String = static_init_value(pool, sv);
      out.push("static ".concat(c_ty).concat(" ").concat(c_name).concat(" = ").concat(init_str).concat(";"));
      sti = sti + 1;
    }
    out.push("");
  }

  // Forward decls (ffi imports first, then internal funcs).
  let mut ii: i32 = 0;
  while ii < p.ffi_imports.len() {
    out = append_lines(out, emit_ffi_import_decl(pool, p.ffi_imports.get(ii)));
    ii = ii + 1;
  }
  if p.ffi_imports.len() != 0 { out.push(""); }

  let mut i: i32 = 0;
  while i < p.funcs.len() {
    out.push(emit_forward_decl(pool, p.funcs.get(i)));
    i = i + 1;
  }
  out.push("");

  // Func defs
  let mut j: i32 = 0;
  while j < p.funcs.len() {
    out = append_lines(out, emit_func(pool, p, p.funcs.get(j)));
    out.push("");
    j = j + 1;
  }

  // C exports wrappers.
  let mut exi: i32 = 0;
  while exi < p.ffi_exports.len() {
    out = append_lines(out, emit_ffi_export_wrapper(pool, p, p.ffi_exports.get(exi)));
    out.push("");
    exi = exi + 1;
  }

  if opts.emit_driver_main && opts.emit_test_main {
    panic("cannot emit both driver main and test main");
  }

  if opts.emit_driver_main {
    let mr: MainResult = find_main(p);
    if !mr.found { panic("missing function main"); }
    out = append_lines(out, emit_driver_main(pool, mr.f, opts.driver_main_kind, p.statics));
  }
  if opts.emit_test_main {
    out = append_lines(out, emit_test_main(opts.test_funcs, p.statics));
  }

  return out.join("\n").concat("\n");
}
