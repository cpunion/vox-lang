import "vox/ir" as ir

struct IdTy { id: i32, ty: String }

fn idty_has(v: Vec[IdTy], id: i32) -> bool {
  let mut i: i32 = 0;
  while i < v.len() {
    if v.get(i).id == id { return true; }
    i = i + 1;
  }
  return false;
}

fn idty_get(v: Vec[IdTy], id: i32) -> String {
  let mut i: i32 = 0;
  while i < v.len() {
    let it: IdTy = v.get(i);
    if it.id == id { return it.ty; }
    i = i + 1;
  }
  return "";
}

fn idty_add(v0: Vec[IdTy], id: i32, ty: String) -> Vec[IdTy] {
  if idty_has(v0, id) { return v0; }
  let mut v: Vec[IdTy] = v0;
  v.push(IdTy { id: id, ty: ty });
  return v;
}

fn c_value(v: ir.Value) -> String {
  return match v {
    ir.Value.Param(i) => c_param_name(i),
    ir.Value.Temp(i) => c_temp_name(i),
    ir.Value.Slot(i) => c_slot_name(i),
    ir.Value.Int(n) => n.to_string(),
    ir.Value.Float(text) => text,
    ir.Value.Bool(b) => if b { "true" } else { "false" },
    ir.Value.Str(s) => "\"".concat(s.escape_c()).concat("\""),
  };
}

fn c_binop(op: ir.BinOpKind) -> String {
  return match op {
    ir.BinOpKind.Add => "+",
    ir.BinOpKind.Sub => "-",
    ir.BinOpKind.Mul => "*",
    ir.BinOpKind.Div => "/",
    ir.BinOpKind.Mod => "%",
    ir.BinOpKind.BitAnd => "&",
    ir.BinOpKind.BitOr => "|",
    ir.BinOpKind.BitXor => "^",
    ir.BinOpKind.Shl => "<<",
    ir.BinOpKind.Shr => ">>",
  };
}

fn c_cmpop(op: ir.CmpKind) -> String {
  return match op {
    ir.CmpKind.Lt => "<",
    ir.CmpKind.Le => "<=",
    ir.CmpKind.Gt => ">",
    ir.CmpKind.Ge => ">=",
    ir.CmpKind.Eq => "==",
    ir.CmpKind.Ne => "!=",
  };
}

fn c_str_lit(s: String) -> String {
  return "\"".concat(s.escape_c()).concat("\"");
}

fn atomic_type_suffix(pool: ir.TyPool, elem_ty: i32) -> String {
  let t: ir.Ty = ir.ty_pool_get(pool, elem_ty);
  return match t.kind {
    ir.TyKind.I32 => "i32",
    ir.TyKind.I64 => "i64",
    ir.TyKind.ISize => "i64",
    _ => "i64",
  };
}

fn c_atomic_c_type(pool: ir.TyPool, elem_ty: i32) -> String {
  let t: ir.Ty = ir.ty_pool_get(pool, elem_ty);
  return match t.kind {
    ir.TyKind.I32 => "_Atomic int32_t",
    ir.TyKind.I64 => "_Atomic int64_t",
    ir.TyKind.ISize => "_Atomic intptr_t",
    _ => "_Atomic int64_t",
  };
}

fn c_atomic_val_c_type(pool: ir.TyPool, elem_ty: i32) -> String {
  let t: ir.Ty = ir.ty_pool_get(pool, elem_ty);
  return match t.kind {
    ir.TyKind.I32 => "int32_t",
    ir.TyKind.I64 => "int64_t",
    ir.TyKind.ISize => "intptr_t",
    _ => "int64_t",
  };
}

fn emit_instr_atomic_new(pool: ir.TyPool, tid: i32, elem_ty: i32, val: ir.Value) -> Vec[String] {
  let at: String = c_atomic_c_type(pool, elem_ty);
  let tmp: String = "_at_".concat(tid.to_string());
  let mut out: Vec[String] = Vec();
  out.push("  ".concat(at).concat("* ").concat(tmp).concat(" = (").concat(at).concat("*)vox_impl_malloc(sizeof(").concat(at).concat("));"));
  out.push("  atomic_init(".concat(tmp).concat(", ").concat(c_value(val)).concat(");"));
  out.push("  ".concat(c_temp_name(tid)).concat(" = (intptr_t)").concat(tmp).concat(";"));
  return out;
}

fn emit_instr_atomic_cas(pool: ir.TyPool, tid: i32, elem_ty: i32, h: ir.Value, expected: ir.Value, desired: ir.Value) -> Vec[String] {
  let at: String = c_atomic_c_type(pool, elem_ty);
  let vt: String = c_atomic_val_c_type(pool, elem_ty);
  let tmp: String = "_cas_".concat(tid.to_string());
  let mut out: Vec[String] = Vec();
  out.push("  ".concat(vt).concat(" ").concat(tmp).concat(" = ").concat(c_value(expected)).concat(";"));
  out.push("  ".concat(c_temp_name(tid)).concat(" = atomic_compare_exchange_strong_explicit((").concat(at).concat("*)").concat(c_value(h)).concat(", &").concat(tmp).concat(", ").concat(c_value(desired)).concat(", memory_order_seq_cst, memory_order_seq_cst);"));
  return out;
}

fn is_int_scalar_kind(k: ir.TyKind) -> bool {
  return match k {
    ir.TyKind.I8 => true,
    ir.TyKind.U8 => true,
    ir.TyKind.I16 => true,
    ir.TyKind.U16 => true,
    ir.TyKind.I32 => true,
    ir.TyKind.U32 => true,
    ir.TyKind.I64 => true,
    ir.TyKind.U64 => true,
    ir.TyKind.ISize => true,
    ir.TyKind.USize => true,
    _ => false,
  };
}

fn is_signed_int_kind(k: ir.TyKind) -> bool {
  return match k { ir.TyKind.I8 => true, ir.TyKind.I16 => true, ir.TyKind.I32 => true, ir.TyKind.I64 => true, ir.TyKind.ISize => true, _ => false };
}

fn is_unsigned_int_kind(k: ir.TyKind) -> bool {
  return match k { ir.TyKind.U8 => true, ir.TyKind.U16 => true, ir.TyKind.U32 => true, ir.TyKind.U64 => true, ir.TyKind.USize => true, _ => false };
}

fn int_bits(k: ir.TyKind) -> i32 {
  return match k {
    ir.TyKind.I8 => 8,
    ir.TyKind.U8 => 8,
    ir.TyKind.I16 => 16,
    ir.TyKind.U16 => 16,
    ir.TyKind.I32 => 32,
    ir.TyKind.U32 => 32,
    ir.TyKind.I64 => 64,
    ir.TyKind.U64 => 64,
    ir.TyKind.ISize => 0,
    ir.TyKind.USize => 0,
    _ => 0,
  };
}

fn int_bits_expr(k: ir.TyKind) -> String {
  if k == ir.TyKind.ISize || k == ir.TyKind.USize {
    return "((int32_t)(sizeof(uintptr_t) * 8))";
  }
  let b: i32 = int_bits(k);
  return b.to_string();
}

fn int_sign_high_bit_expr(k: ir.TyKind) -> String {
  if k == ir.TyKind.ISize {
    return "(((uintptr_t)1) << (((int32_t)(sizeof(uintptr_t) * 8)) - 1))";
  }
  let b: i32 = int_bits(k);
  return "(((".concat(unsigned_peer_c_type(k)).concat(")1) << ").concat((b - 1).to_string()).concat(")");
}

fn int_cast_needs_runtime_check(dst: ir.TyKind, src: ir.TyKind) -> bool {
  if !is_int_scalar_kind(dst) || !is_int_scalar_kind(src) { return true; }
  if dst == ir.TyKind.ISize || dst == ir.TyKind.USize || src == ir.TyKind.ISize || src == ir.TyKind.USize {
    // Pointer-width ints depend on target ABI; keep checks to preserve correctness across targets.
    return true;
  }
  let db: i32 = int_bits(dst);
  let sb: i32 = int_bits(src);
  if db == 0 || sb == 0 { return true; }

  let du: bool = is_unsigned_int_kind(dst);
  let su: bool = is_unsigned_int_kind(src);
  if du && !su { return true; } // signed -> unsigned always needs non-negative check
  if !du && su { return db <= sb; } // unsigned -> signed: only wider destination is always safe
  return db < sb; // same signedness: narrowing only
}

fn unsigned_peer_c_type(k: ir.TyKind) -> String {
  return match k {
    ir.TyKind.I8 => "uint8_t",
    ir.TyKind.U8 => "uint8_t",
    ir.TyKind.I16 => "uint16_t",
    ir.TyKind.U16 => "uint16_t",
    ir.TyKind.I32 => "uint32_t",
    ir.TyKind.U32 => "uint32_t",
    ir.TyKind.I64 => "uint64_t",
    ir.TyKind.U64 => "uint64_t",
    ir.TyKind.ISize => "uintptr_t",
    ir.TyKind.USize => "uintptr_t",
    _ => "uint64_t",
  };
}

fn signed_min_macro(k: ir.TyKind) -> String {
  return match k {
    ir.TyKind.I8 => "INT8_MIN",
    ir.TyKind.I16 => "INT16_MIN",
    ir.TyKind.I32 => "INT32_MIN",
    ir.TyKind.I64 => "INT64_MIN",
    ir.TyKind.ISize => "INTPTR_MIN",
    _ => "",
  };
}

fn signed_max_macro(k: ir.TyKind) -> String {
  return match k {
    ir.TyKind.I8 => "INT8_MAX",
    ir.TyKind.I16 => "INT16_MAX",
    ir.TyKind.I32 => "INT32_MAX",
    ir.TyKind.I64 => "INT64_MAX",
    ir.TyKind.ISize => "INTPTR_MAX",
    _ => "",
  };
}

struct LocalsResult { slots: Vec[IdTy], temps: Vec[IdTy], max_slot: i32, max_temp: i32 }

fn locals0() -> LocalsResult { return LocalsResult { slots: Vec(), temps: Vec(), max_slot: -1, max_temp: -1 }; }

fn locals_add_slot(l0: LocalsResult, sid: i32, ty: String) -> LocalsResult {
  let mut l: LocalsResult = l0;
  l.slots = idty_add(l.slots, sid, ty);
  if sid > l.max_slot { l.max_slot = sid; }
  return l;
}

fn locals_add_temp(l0: LocalsResult, tid: i32, ty: String) -> LocalsResult {
  let mut l: LocalsResult = l0;
  l.temps = idty_add(l.temps, tid, ty);
  if tid > l.max_temp { l.max_temp = tid; }
  return l;
}

fn locals_add_call(pool: ir.TyPool, l0: LocalsResult, has_dst: bool, tid: i32, ret_ty: i32) -> LocalsResult {
  if !has_dst { return l0; }
  return locals_add_temp(l0, tid, c_type(pool, ret_ty));
}

fn locals_add_instr(pool: ir.TyPool, l0: LocalsResult, ins: ir.Instr) -> LocalsResult {
  return match ins {
    ir.Instr.SlotDecl(sid, ty) => locals_add_slot(l0, sid, c_type(pool, ty)),
    ir.Instr.Const(tid, ty, _v) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.BinOp(tid, _op, ty, _a, _b) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.Cmp(tid, _op, _oty, _a, _b) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.And(tid, _a, _b) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.Or(tid, _a, _b) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.Not(tid, _a) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.IntCast(tid, dst_ty, _src_ty, _v) => locals_add_temp(l0, tid, c_type(pool, dst_ty)),
    ir.Instr.IntCastChecked(tid, dst_ty, _src_ty, _v) => locals_add_temp(l0, tid, c_type(pool, dst_ty)),
    ir.Instr.FloatCast(tid, dst_ty, _src_ty, _v) => locals_add_temp(l0, tid, c_type(pool, dst_ty)),
    ir.Instr.Load(tid, ty, _sid) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.GlobalLoad(tid, ty, _name) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.GlobalStore(_ty, _name, _v) => l0,
    ir.Instr.AddrOfSlot(tid, ty, _sid) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.AddrOfFieldChain(tid, ty, _sid, _fs) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.RefLoad(tid, ty, _recv) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.PtrRead(tid, ty, _ptr) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.PtrWrite(_ty, _ptr, _v) => l0,
    ir.Instr.PtrOffset(tid, _ptr, _off) => locals_add_temp(l0, tid, "void*"),
    ir.Instr.StructInit(tid, ty, _fs) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.FieldGet(tid, ty, _r, _f) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.EnumInit(tid, ty, _v, _ps) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.EnumTag(tid, _r) => locals_add_temp(l0, tid, "int32_t"),
    ir.Instr.EnumPayload(tid, ty, _r, _v, _i) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.VecNew(tid, ty, _elem) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.VecInsert(_sid, _elem, _idx, _v) => l0,
    ir.Instr.VecSet(_sid, _elem, _idx, _v) => l0,
    ir.Instr.VecClear(_sid) => l0,
    ir.Instr.VecExtend(_sid, _other_sid) => l0,
    ir.Instr.VecPop(tid, ty, _sid) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.VecRemove(tid, ty, _sid, _idx) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.VecLen(tid, _sid) => locals_add_temp(l0, tid, "int32_t"),
    ir.Instr.VecGet(tid, ty, _sid, _idx) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.VecStrJoin(tid, _sid, _sep) => locals_add_temp(l0, tid, "const char*"),
    ir.Instr.AtomicNew(tid, _elem_ty, _val) => locals_add_temp(l0, tid, "intptr_t"),
    ir.Instr.AtomicLoad(tid, elem_ty, _h) => locals_add_temp(l0, tid, c_type(pool, elem_ty)),
    ir.Instr.AtomicStore(_elem_ty, _h, _val) => l0,
    ir.Instr.AtomicFetchAdd(tid, elem_ty, _h, _delta) => locals_add_temp(l0, tid, c_type(pool, elem_ty)),
    ir.Instr.AtomicSwap(tid, elem_ty, _h, _val) => locals_add_temp(l0, tid, c_type(pool, elem_ty)),
    ir.Instr.AtomicCAS(tid, _ety, _h, _expected, _desired) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.AtomicDrop(_ety, _h) => l0,
    ir.Instr.StrLen(tid, _r) => locals_add_temp(l0, tid, "int32_t"),
    ir.Instr.StrByteAt(tid, _r, _idx) => locals_add_temp(l0, tid, "int32_t"),
    ir.Instr.StrSlice(tid, _r, _s, _e) => locals_add_temp(l0, tid, "const char*"),
    ir.Instr.StrConcat(tid, _a, _b) => locals_add_temp(l0, tid, "const char*"),
    ir.Instr.StrEscapeC(tid, _r) => locals_add_temp(l0, tid, "const char*"),
    ir.Instr.StrStartsWith(tid, _r, _pre) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.StrEndsWith(tid, _r, _suf) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.StrContains(tid, _r, _needle) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.StrIndexOf(tid, _r, _needle) => locals_add_temp(l0, tid, "int32_t"),
    ir.Instr.StrLastIndexOf(tid, _r, _needle) => locals_add_temp(l0, tid, "int32_t"),
    ir.Instr.I32ToStr(tid, _v) => locals_add_temp(l0, tid, "const char*"),
    ir.Instr.I64ToStr(tid, _v) => locals_add_temp(l0, tid, "const char*"),
    ir.Instr.U64ToStr(tid, _v) => locals_add_temp(l0, tid, "const char*"),
    ir.Instr.ISizeToStr(tid, _v) => locals_add_temp(l0, tid, "const char*"),
    ir.Instr.USizeToStr(tid, _v) => locals_add_temp(l0, tid, "const char*"),
    ir.Instr.F32ToStr(tid, _v) => locals_add_temp(l0, tid, "const char*"),
    ir.Instr.F64ToStr(tid, _v) => locals_add_temp(l0, tid, "const char*"),
    ir.Instr.BoolToStr(tid, _v) => locals_add_temp(l0, tid, "const char*"),
    ir.Instr.Call(has_dst, tid, ret_ty, _name, _args) => locals_add_call(pool, l0, has_dst, tid, ret_ty),
    _ => l0,
  };
}

fn collect_locals(pool: ir.TyPool, f: ir.Func) -> LocalsResult {
  let mut l: LocalsResult = locals0();
  let mut bi: i32 = 0;
  while bi < f.blocks.len() {
    let b: ir.Block = f.blocks.get(bi);
    let mut ii: i32 = 0;
    while ii < b.instrs.len() {
      l = locals_add_instr(pool, l, b.instrs.get(ii));
      ii = ii + 1;
    }
    bi = bi + 1;
  }
  return l;
}

fn vec0() -> Vec[String] { return Vec(); }

fn vec1(s: String) -> Vec[String] { let mut v: Vec[String] = Vec(); v.push(s); return v; }

fn c_field_chain(fields: Vec[String]) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < fields.len() {
    out = out.concat(".").concat(c_ident(fields.get(i)));
    i = i + 1;
  }
  return out;
}

fn emit_instr_cmp(pool: ir.TyPool, tid: i32, op: ir.CmpKind, oty: i32, a: ir.Value, b: ir.Value) -> Vec[String] {
  let t: ir.Ty = ir.ty_pool_get(pool, oty);
  if t.kind == ir.TyKind.Range || t.kind == ir.TyKind.Verified || t.kind == ir.TyKind.Ref {
    return emit_instr_cmp(pool, tid, op, t.elem, a, b);
  }
  if t.kind == ir.TyKind.String {
    let cmpop: String = c_cmpop(op);
    return vec1("  ".concat(c_temp_name(tid)).concat(" = (strcmp(").concat(c_value(a)).concat(", ").concat(c_value(b)).concat(") ").concat(cmpop).concat(" 0);"));
  }
  if t.kind == ir.TyKind.Enum {
    if op != ir.CmpKind.Eq && op != ir.CmpKind.Ne { panic("unsupported enum comparison"); }
    let cal: String = c_enum_eq_fn_name(ty_qname(t)).concat("(").concat(c_value(a)).concat(", ").concat(c_value(b)).concat(")");
    if op == ir.CmpKind.Eq {
      return vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(cal).concat(";"));
    }
    return vec1("  ".concat(c_temp_name(tid)).concat(" = (!").concat(cal).concat(");"));
  }
  if t.kind == ir.TyKind.Struct {
    if op != ir.CmpKind.Eq && op != ir.CmpKind.Ne { panic("unsupported struct comparison"); }
    let cal: String = c_struct_eq_fn_name(ty_qname(t)).concat("(").concat(c_value(a)).concat(", ").concat(c_value(b)).concat(")");
    if op == ir.CmpKind.Eq {
      return vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(cal).concat(";"));
    }
    return vec1("  ".concat(c_temp_name(tid)).concat(" = (!").concat(cal).concat(");"));
  }
  return vec1("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_value(a)).concat(" ").concat(c_cmpop(op)).concat(" ").concat(c_value(b)).concat(");"));
}

fn emit_instr_int_cast_checked(pool: ir.TyPool, tid: i32, dst_ty: i32, src_ty: i32, v: ir.Value) -> Vec[String] {
  let dst: ir.Ty = ir.ty_pool_get(pool, dst_ty);
  let src: ir.Ty = ir.ty_pool_get(pool, src_ty);

  let src_name: String = match src.kind {
    ir.TyKind.I8 => "i8",
    ir.TyKind.U8 => "u8",
    ir.TyKind.I16 => "i16",
    ir.TyKind.U16 => "u16",
    ir.TyKind.I32 => "i32",
    ir.TyKind.U32 => "u32",
    ir.TyKind.I64 => "i64",
    ir.TyKind.U64 => "u64",
    ir.TyKind.ISize => "isize",
    ir.TyKind.USize => "usize",
    _ => "?",
  };
  let dst_name: String = match dst.kind {
    ir.TyKind.I8 => "i8",
    ir.TyKind.U8 => "u8",
    ir.TyKind.I16 => "i16",
    ir.TyKind.U16 => "u16",
    ir.TyKind.I32 => "i32",
    ir.TyKind.U32 => "u32",
    ir.TyKind.I64 => "i64",
    ir.TyKind.U64 => "u64",
    ir.TyKind.ISize => "isize",
    ir.TyKind.USize => "usize",
    _ => "?",
  };
  let msg: String = src_name.concat(" to ").concat(dst_name).concat(" overflow");

  let dst_max: String =
    match dst.kind {
      ir.TyKind.I8 => "INT8_MAX",
      ir.TyKind.U8 => "UINT8_MAX",
      ir.TyKind.I16 => "INT16_MAX",
      ir.TyKind.U16 => "UINT16_MAX",
      ir.TyKind.I32 => "INT32_MAX",
      ir.TyKind.U32 => "UINT32_MAX",
      ir.TyKind.I64 => "INT64_MAX",
      ir.TyKind.U64 => "UINT64_MAX",
      ir.TyKind.ISize => "INTPTR_MAX",
      ir.TyKind.USize => "UINTPTR_MAX",
      _ => "",
    };
  if dst_max.len() == 0 { panic("int_cast_checked dst must be int"); }
  let dst_min: String =
    match dst.kind {
      ir.TyKind.I8 => "INT8_MIN",
      ir.TyKind.I16 => "INT16_MIN",
      ir.TyKind.I32 => "INT32_MIN",
      ir.TyKind.I64 => "INT64_MIN",
      ir.TyKind.ISize => "INTPTR_MIN",
      _ => "0",
    };

  let dst_is_unsigned: bool = is_unsigned_int_kind(dst.kind);
  let src_is_unsigned: bool = is_unsigned_int_kind(src.kind);
  let src_is_float: bool = src.kind == ir.TyKind.F32 || src.kind == ir.TyKind.F64;

  let mut out: Vec[String] = Vec();
  if !src_is_float && !int_cast_needs_runtime_check(dst.kind, src.kind) {
    out.push("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_type(pool, dst_ty)).concat(")").concat(c_value(v)).concat(";"));
    return out;
  }
  if src_is_float {
    if dst_is_unsigned {
      let line0: String = "  if (!isfinite((double)".concat(c_value(v))
        .concat(") || (double)")
        .concat(c_value(v))
        .concat(" < 0.0 || (long double)")
        .concat(c_value(v))
        .concat(" > (long double)")
        .concat(dst_max)
        .concat(") { vox_host_panic(")
        .concat(c_str_lit(msg))
        .concat("); }");
      out.push(line0);
    } else {
      let line1: String = "  if (!isfinite((double)".concat(c_value(v))
        .concat(") || (long double)")
        .concat(c_value(v))
        .concat(" < (long double)")
        .concat(dst_min)
        .concat(" || (long double)")
        .concat(c_value(v))
        .concat(" > (long double)")
        .concat(dst_max)
        .concat(") { vox_host_panic(")
        .concat(c_str_lit(msg))
        .concat("); }");
      out.push(line1);
    }
  } else {
    if dst_is_unsigned {
      if src_is_unsigned {
        out.push("  if ((uint64_t)".concat(c_value(v)).concat(" > (uint64_t)").concat(dst_max).concat(") { vox_host_panic(").concat(c_str_lit(msg)).concat("); }"));
      } else {
        out.push("  if (".concat(c_value(v)).concat(" < 0 || (uint64_t)").concat(c_value(v)).concat(" > (uint64_t)").concat(dst_max).concat(") { vox_host_panic(").concat(c_str_lit(msg)).concat("); }"));
      }
    } else {
      if src_is_unsigned {
        out.push("  if ((uint64_t)".concat(c_value(v)).concat(" > (uint64_t)").concat(dst_max).concat(") { vox_host_panic(").concat(c_str_lit(msg)).concat("); }"));
      } else {
        out.push("  if (".concat(c_value(v)).concat(" < ").concat(dst_min).concat(" || ").concat(c_value(v)).concat(" > ").concat(dst_max).concat(") { vox_host_panic(").concat(c_str_lit(msg)).concat("); }"));
      }
    }
  }
  out.push("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_type(pool, dst_ty)).concat(")").concat(c_value(v)).concat(";"));
  return out;
}

fn emit_instr_struct_init(pool: ir.TyPool, tid: i32, ty: i32, fs: Vec[ir.StructInitField]) -> Vec[String] {
  let mut s: String = "  ".concat(c_temp_name(tid)).concat(" = (").concat(c_type(pool, ty)).concat("){");
  let mut i: i32 = 0;
  while i < fs.len() {
    let f: ir.StructInitField = fs.get(i);
    if i != 0 { s = s.concat(", "); }
    s = s.concat(".").concat(c_ident(f.name)).concat(" = ").concat(c_value(f.val));
    i = i + 1;
  }
  s = s.concat("};");
  return vec1(s);
}

fn emit_instr_enum_init(pool: ir.TyPool, p: ir.Program, tid: i32, ty: i32, variant: String, payload: Vec[ir.Value]) -> Vec[String] {
  let en: ir.EnumDecl = find_enum_decl(p, ty_qname(ir.ty_pool_get(pool, ty)));
  let tag: i32 = enum_variant_tag(en, variant);
  let mut s: String = "  ".concat(c_temp_name(tid)).concat(" = (").concat(c_type(pool, ty)).concat("){.tag = ").concat(tag.to_string());
  if enum_has_payload(en) {
    s = s.concat(", .payload.").concat(c_ident(variant)).concat(" = {");
    if payload.len() != 0 {
      let mut pi: i32 = 0;
      while pi < payload.len() {
        if pi != 0 { s = s.concat(", "); }
        s = s.concat("._").concat(pi.to_string()).concat(" = ").concat(c_value(payload.get(pi)));
        pi = pi + 1;
      }
    } else {
      s = s.concat("._ = 0");
    }
    s = s.concat("}");
  }
  s = s.concat("};");
  return vec1(s);
}

fn emit_instr_binop_int(pool: ir.TyPool, tid: i32, op: ir.BinOpKind, ty: i32, a: ir.Value, b: ir.Value) -> Vec[String] {
  let t: ir.Ty = ir.ty_pool_get(pool, ty);
  if !is_int_scalar_kind(t.kind) { panic("binop int helper expects int type"); }
  let dst_cty: String = c_type(pool, ty);

  // + - * and bitwise ops: wrap on integer bit width. Avoid signed overflow UB by operating on unsigned peers.
  let is_mul: bool = match op { ir.BinOpKind.Mul => true, _ => false };
  let is_add: bool = match op { ir.BinOpKind.Add => true, _ => false };
  let is_sub: bool = match op { ir.BinOpKind.Sub => true, _ => false };
  let is_bit: bool = match op { ir.BinOpKind.BitAnd => true, ir.BinOpKind.BitOr => true, ir.BinOpKind.BitXor => true, _ => false };
  if is_add || is_sub || is_mul || is_bit {
    if !is_signed_int_kind(t.kind) {
      // Unsigned arithmetic is well-defined modulo 2^N.
      let u64expr: String = "((uint64_t)".concat(c_value(a)).concat(") ").concat(c_binop(op)).concat(" ((uint64_t)").concat(c_value(b)).concat(")");
      return vec1("  ".concat(c_temp_name(tid)).concat(" = (").concat(dst_cty).concat(")").concat(u64expr).concat(";"));
    }
    let uty: String = unsigned_peer_c_type(t.kind);
    let tmp_name: String = "vox_tmp_".concat(c_temp_name(tid));
    let mut out: Vec[String] = Vec();
    out.push("  {");
    out.push("    ".concat(uty).concat(" ua = (").concat(uty).concat(")").concat(c_value(a)).concat(";"));
    out.push("    ".concat(uty).concat(" ub = (").concat(uty).concat(")").concat(c_value(b)).concat(";"));
    out.push("    ".concat(uty).concat(" ur = (").concat(uty).concat(")(ua ").concat(c_binop(op)).concat(" ub);"));
    out.push("    ".concat(dst_cty).concat(" ").concat(tmp_name).concat("; memcpy(&").concat(tmp_name).concat(", &ur, sizeof(").concat(tmp_name).concat("));"));
    out.push("    ".concat(c_temp_name(tid)).concat(" = ").concat(tmp_name).concat(";"));
    out.push("  }");
    return out;
  }

  // << >> panics on invalid shift counts; right shift on signed types is arithmetic.
  let is_shl: bool = match op { ir.BinOpKind.Shl => true, _ => false };
  let is_shr: bool = match op { ir.BinOpKind.Shr => true, _ => false };
  if is_shl || is_shr {
    let bits_expr: String = int_bits_expr(t.kind);
    let uty: String = unsigned_peer_c_type(t.kind);
    let tmp_name: String = "vox_tmp_".concat(c_temp_name(tid));
    let mut out3: Vec[String] = Vec();
    out3.push("  {");
    out3.push("    ".concat(uty).concat(" ua = (").concat(uty).concat(")").concat(c_value(a)).concat(";"));
    if is_signed_int_kind(t.kind) {
      out3.push("    int64_t sh = (int64_t)".concat(c_value(b)).concat(";"));
      let lchk: String = "    if (sh < 0 || sh >= (int64_t)".concat(bits_expr).concat(") { vox_host_panic(\"shift count out of range\"); }");
      out3.push(lchk);
      out3.push("    uint64_t n = (uint64_t)sh;");
    } else {
      out3.push("    uint64_t n = (uint64_t)".concat(c_value(b)).concat(";"));
      let lchk2: String = "    if (n >= (uint64_t)".concat(bits_expr).concat(") { vox_host_panic(\"shift count out of range\"); }");
      out3.push(lchk2);
    }
    if is_shl {
      out3.push("    ".concat(uty).concat(" ur = (").concat(uty).concat(")(ua << n);"));
    } else if is_signed_int_kind(t.kind) {
      out3.push("    ".concat(uty).concat(" ur;"));
      out3.push("    if (n == 0) {");
      out3.push("      ur = ua;");
      let lsign: String = "    } else if ((ua & ".concat(int_sign_high_bit_expr(t.kind)).concat(") != 0) {");
      out3.push(lsign);
      out3.push("      ".concat(uty).concat(" m = ~(((").concat(uty).concat(")~(").concat(uty).concat(")0) >> n);"));
      out3.push("      ur = (".concat(uty).concat(")((ua >> n) | m);"));
      out3.push("    } else {");
      out3.push("      ur = (".concat(uty).concat(")(ua >> n);"));
      out3.push("    }");
    } else {
      out3.push("    ".concat(uty).concat(" ur = (").concat(uty).concat(")(ua >> n);"));
    }
    out3.push("    ".concat(dst_cty).concat(" ").concat(tmp_name).concat("; memcpy(&").concat(tmp_name).concat(", &ur, sizeof(").concat(tmp_name).concat("));"));
    out3.push("    ".concat(c_temp_name(tid)).concat(" = ").concat(tmp_name).concat(";"));
    out3.push("  }");
    return out3;
  }

  // / % panics on division by zero; signed also panics on MIN/-1 overflow.
  let is_div: bool = match op { ir.BinOpKind.Div => true, _ => false };
  let is_mod: bool = match op { ir.BinOpKind.Mod => true, _ => false };
  if is_div || is_mod {
    let mut out2: Vec[String] = Vec();
    out2.push("  if (".concat(c_value(b)).concat(" == (").concat(dst_cty).concat(")0) { vox_host_panic(\"division by zero\"); }"));
    if is_signed_int_kind(t.kind) {
      let minm: String = signed_min_macro(t.kind);
      let maxm: String = signed_max_macro(t.kind);
      if minm.len() == 0 || maxm.len() == 0 { panic("missing signed min/max macro"); }
      out2.push("  if (".concat(c_value(a)).concat(" == ").concat(minm).concat(" && ").concat(c_value(b)).concat(" == (").concat(dst_cty).concat(")-1) { vox_host_panic(\"division overflow\"); }"));
    }
    out2.push("  ".concat(c_temp_name(tid)).concat(" = (").concat(dst_cty).concat(")(").concat(c_value(a)).concat(" ").concat(c_binop(op)).concat(" ").concat(c_value(b)).concat(");"));
    return out2;
  }

  panic("unknown binop");
}

fn ffi_import_symbol_for_call(p: ir.Program, name: String) -> String {
  let mut i: i32 = 0;
  while i < p.ffi_imports.len() {
    let im: ir.FfiImportDecl = p.ffi_imports.get(i);
    if im.func == name {
      if im.target != "c" && im.target != "wasm" {
        panic("c backend does not support ffi_import target in calls: ".concat(im.target));
      }
      if im.target == "wasm" { return c_ffi_import_name(im.func); }
      return im.symbol;
    }
    i = i + 1;
  }
  return "";
}

fn c_call_name(p: ir.Program, name: String) -> String {
  let sym: String = ffi_import_symbol_for_call(p, name);
  if sym != "" { return sym; }
  return c_fn_name(name);
}

fn emit_instr_call(p: ir.Program, has_dst: bool, tid: i32, ret_ty: i32, name: String, args: Vec[ir.Value]) -> Vec[String] {
  if name == "panic" {
    if args.len() != 1 { panic("panic expects 1 arg"); }
    return vec1("  vox_host_panic(".concat(c_value(args.get(0))).concat(");"));
  }
  let mut s: String = "  ";
  if has_dst && ret_ty != -1 { s = s.concat(c_temp_name(tid)).concat(" = "); }
  s = s.concat(c_call_name(p, name)).concat("(");
  let mut i: i32 = 0;
  while i < args.len() {
    if i != 0 { s = s.concat(", "); }
    s = s.concat(c_value(args.get(i)));
    i = i + 1;
  }
  s = s.concat(");");
  return vec1(s);
}

fn emit_instr(pool: ir.TyPool, p: ir.Program, ins: ir.Instr) -> Vec[String] {
  return match ins {
    ir.Instr.SlotDecl(_sid, _ty) => vec0(),

    ir.Instr.Const(tid, _ty, v) => vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_value(v)).concat(";")),
    ir.Instr.BinOp(tid, op, ty, a, b) => {
      let bt: ir.Ty = ir.ty_pool_get(pool, ty);
      if is_int_scalar_kind(bt.kind) { emit_instr_binop_int(pool, tid, op, ty, a, b) }
      else if op == ir.BinOpKind.Mod && bt.kind == ir.TyKind.F32 {
        vec1("  ".concat(c_temp_name(tid)).concat(" = fmodf(").concat(c_value(a)).concat(", ").concat(c_value(b)).concat(");"))
      } else if op == ir.BinOpKind.Mod && bt.kind == ir.TyKind.F64 {
        vec1("  ".concat(c_temp_name(tid)).concat(" = fmod(").concat(c_value(a)).concat(", ").concat(c_value(b)).concat(");"))
      } else {
        vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_value(a)).concat(" ").concat(c_binop(op)).concat(" ").concat(c_value(b)).concat(";"))
      }
    },
    ir.Instr.Cmp(tid, op, oty, a, b) => emit_instr_cmp(pool, tid, op, oty, a, b),
    ir.Instr.And(tid, a, b) => vec1("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_value(a)).concat(" && ").concat(c_value(b)).concat(");")),
    ir.Instr.Or(tid, a, b) => vec1("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_value(a)).concat(" || ").concat(c_value(b)).concat(");")),
    ir.Instr.Not(tid, a) => vec1("  ".concat(c_temp_name(tid)).concat(" = (!").concat(c_value(a)).concat(");")),

    ir.Instr.IntCast(tid, dst_ty, _src_ty, v) =>
      vec1("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_type(pool, dst_ty)).concat(")").concat(c_value(v)).concat(";")),
    ir.Instr.IntCastChecked(tid, dst_ty, src_ty, v) => emit_instr_int_cast_checked(pool, tid, dst_ty, src_ty, v),
    ir.Instr.FloatCast(tid, dst_ty, _src_ty, v) =>
      vec1("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_type(pool, dst_ty)).concat(")").concat(c_value(v)).concat(";")),
    ir.Instr.RangeCheck(ty, v, lo, hi) => vec1(
      "  if (".concat(c_value(v)).concat(" < (").concat(c_type(pool, ty)).concat(")").concat(lo.to_string())
        .concat(" || ").concat(c_value(v)).concat(" > (").concat(c_type(pool, ty)).concat(")").concat(hi.to_string())
        .concat(") { vox_host_panic(\"range check failed\"); }"),
    ),

    ir.Instr.Store(sid, v) => vec1("  ".concat(c_slot_name(sid)).concat(" = ").concat(c_value(v)).concat(";")),
    ir.Instr.Load(tid, _ty, sid) => vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_slot_name(sid)).concat(";")),
    ir.Instr.GlobalLoad(tid, _ty, name) => vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_static_name(name)).concat(";")),
    ir.Instr.GlobalStore(_ty, name, v) => vec1("  ".concat(c_static_name(name)).concat(" = ").concat(c_value(v)).concat(";")),
    ir.Instr.AddrOfSlot(tid, _ty, sid) => vec1("  ".concat(c_temp_name(tid)).concat(" = &").concat(c_slot_name(sid)).concat(";")),
    ir.Instr.AddrOfFieldChain(tid, _ty, sid, fields) => vec1("  ".concat(c_temp_name(tid)).concat(" = &").concat(c_slot_name(sid)).concat(c_field_chain(fields)).concat(";")),
    ir.Instr.RefLoad(tid, _ty, recv) => vec1("  ".concat(c_temp_name(tid)).concat(" = (*").concat(c_value(recv)).concat(");")),
    ir.Instr.RefStore(_ty, recv, v) => vec1("  (*".concat(c_value(recv)).concat(") = ").concat(c_value(v)).concat(";")),

    ir.Instr.PtrRead(tid, ty, ptr) => vec1("  ".concat(c_temp_name(tid)).concat(" = *(").concat(c_type(pool, ty)).concat("*)").concat(c_value(ptr)).concat(";")),
    ir.Instr.PtrWrite(ty, ptr, v) => vec1("  *((".concat(c_type(pool, ty)).concat("*)").concat(c_value(ptr)).concat(") = ").concat(c_value(v)).concat(";")),
    ir.Instr.PtrOffset(tid, ptr, off) => vec1("  ".concat(c_temp_name(tid)).concat(" = (void*)((char*)").concat(c_value(ptr)).concat(" + ").concat(c_value(off)).concat(");")),

    ir.Instr.StructInit(tid, ty, fs) => emit_instr_struct_init(pool, tid, ty, fs),
    ir.Instr.FieldGet(tid, _ty, recv, field) => vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_value(recv)).concat(".").concat(c_ident(field)).concat(";")),
    ir.Instr.StoreField(sid, field, v) => vec1("  ".concat(c_slot_name(sid)).concat(".").concat(c_ident(field)).concat(" = ").concat(c_value(v)).concat(";")),

    ir.Instr.EnumInit(tid, ty, variant, payload) => emit_instr_enum_init(pool, p, tid, ty, variant, payload),
    ir.Instr.EnumTag(tid, recv) => vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_value(recv)).concat(".tag;")),
    ir.Instr.EnumPayload(tid, _ty, recv, variant, idx) =>
      vec1("  "
        .concat(c_temp_name(tid))
        .concat(" = ")
        .concat(c_value(recv))
        .concat(".payload.")
        .concat(c_ident(variant))
        .concat("._")
        .concat(idx.to_string())
        .concat(";")),

    ir.Instr.VecNew(tid, _vty, elem) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_vec_new((int32_t)sizeof(").concat(c_type(pool, elem)).concat("));")),
    ir.Instr.VecPush(recv_slot, _elem, v) => vec1("  vox_vec_push(&".concat(c_slot_name(recv_slot)).concat(", &").concat(c_value(v)).concat(");")),
    ir.Instr.VecInsert(recv_slot, _elem, idx, v) => vec1("  vox_vec_insert(&".concat(c_slot_name(recv_slot)).concat(", ").concat(c_value(idx)).concat(", &").concat(c_value(v)).concat(");")),
    ir.Instr.VecSet(recv_slot, _elem, idx, v) => vec1("  vox_vec_set(&".concat(c_slot_name(recv_slot)).concat(", ").concat(c_value(idx)).concat(", &").concat(c_value(v)).concat(");")),
    ir.Instr.VecClear(recv_slot) => vec1("  vox_vec_clear(&".concat(c_slot_name(recv_slot)).concat(");")),
    ir.Instr.VecExtend(recv_slot, other_slot) => vec1("  vox_vec_extend(&".concat(c_slot_name(recv_slot)).concat(", &").concat(c_slot_name(other_slot)).concat(");")),
    ir.Instr.VecPop(tid, _elem, recv_slot) => vec1("  vox_vec_pop(&".concat(c_slot_name(recv_slot)).concat(", &").concat(c_temp_name(tid)).concat(");")),
    ir.Instr.VecRemove(tid, _elem, recv_slot, idx) => vec1("  vox_vec_remove(&".concat(c_slot_name(recv_slot)).concat(", ").concat(c_value(idx)).concat(", &").concat(c_temp_name(tid)).concat(");")),
    ir.Instr.VecLen(tid, recv_slot) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_vec_len(&").concat(c_slot_name(recv_slot)).concat(");")),
    ir.Instr.VecGet(tid, _elem, recv_slot, idx) => vec1("  vox_vec_get(&".concat(c_slot_name(recv_slot)).concat(", ").concat(c_value(idx)).concat(", &").concat(c_temp_name(tid)).concat(");")),
    ir.Instr.VecStrJoin(tid, recv_slot, sep) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_vec_str_join(&").concat(c_slot_name(recv_slot)).concat(", ").concat(c_value(sep)).concat(");")),

    ir.Instr.AtomicNew(tid, elem_ty, val) => emit_instr_atomic_new(pool, tid, elem_ty, val),
    ir.Instr.AtomicLoad(tid, elem_ty, h) => vec1("  ".concat(c_temp_name(tid)).concat(" = atomic_load_explicit((").concat(c_atomic_c_type(pool, elem_ty)).concat("*)").concat(c_value(h)).concat(", memory_order_seq_cst);")),
    ir.Instr.AtomicStore(elem_ty, h, val) => vec1("  atomic_store_explicit((".concat(c_atomic_c_type(pool, elem_ty)).concat("*)").concat(c_value(h)).concat(", ").concat(c_value(val)).concat(", memory_order_seq_cst);")),
    ir.Instr.AtomicFetchAdd(tid, elem_ty, h, delta) => vec1("  ".concat(c_temp_name(tid)).concat(" = atomic_fetch_add_explicit((").concat(c_atomic_c_type(pool, elem_ty)).concat("*)").concat(c_value(h)).concat(", ").concat(c_value(delta)).concat(", memory_order_seq_cst);")),
    ir.Instr.AtomicSwap(tid, elem_ty, h, val) => vec1("  ".concat(c_temp_name(tid)).concat(" = atomic_exchange_explicit((").concat(c_atomic_c_type(pool, elem_ty)).concat("*)").concat(c_value(h)).concat(", ").concat(c_value(val)).concat(", memory_order_seq_cst);")),
    ir.Instr.AtomicCAS(tid, elem_ty, h, expected, desired) => emit_instr_atomic_cas(pool, tid, elem_ty, h, expected, desired),
    ir.Instr.AtomicDrop(_elem_ty, h) => vec1("  vox_impl_free((void*)".concat(c_value(h)).concat(");")),

    ir.Instr.StrLen(tid, recv) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_str_len(").concat(c_value(recv)).concat(");")),
    ir.Instr.StrByteAt(tid, recv, idx) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_str_byte_at(").concat(c_value(recv)).concat(", ").concat(c_value(idx)).concat(");")),
    ir.Instr.StrSlice(tid, recv, start, end) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_str_slice(").concat(c_value(recv)).concat(", ").concat(c_value(start)).concat(", ").concat(c_value(end)).concat(");")),
    ir.Instr.StrConcat(tid, a, b) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_str_concat(").concat(c_value(a)).concat(", ").concat(c_value(b)).concat(");")),
    ir.Instr.StrEscapeC(tid, recv) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_str_escape_c(").concat(c_value(recv)).concat(");")),
    ir.Instr.StrStartsWith(tid, recv, pre) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_str_starts_with(").concat(c_value(recv)).concat(", ").concat(c_value(pre)).concat(");")),
    ir.Instr.StrEndsWith(tid, recv, suf) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_str_ends_with(").concat(c_value(recv)).concat(", ").concat(c_value(suf)).concat(");")),
    ir.Instr.StrContains(tid, recv, needle) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_str_contains(").concat(c_value(recv)).concat(", ").concat(c_value(needle)).concat(");")),
    ir.Instr.StrIndexOf(tid, recv, needle) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_str_index_of(").concat(c_value(recv)).concat(", ").concat(c_value(needle)).concat(");")),
    ir.Instr.StrLastIndexOf(tid, recv, needle) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_str_last_index_of(").concat(c_value(recv)).concat(", ").concat(c_value(needle)).concat(");")),

    ir.Instr.I32ToStr(tid, v) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_i32_to_string(").concat(c_value(v)).concat(");")),
    ir.Instr.I64ToStr(tid, v) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_i64_to_string(").concat(c_value(v)).concat(");")),
    ir.Instr.U64ToStr(tid, v) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_u64_to_string(").concat(c_value(v)).concat(");")),
    ir.Instr.ISizeToStr(tid, v) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_isize_to_string(").concat(c_value(v)).concat(");")),
    ir.Instr.USizeToStr(tid, v) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_usize_to_string(").concat(c_value(v)).concat(");")),
    ir.Instr.F32ToStr(tid, v) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_f32_to_string(").concat(c_value(v)).concat(");")),
    ir.Instr.F64ToStr(tid, v) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_f64_to_string(").concat(c_value(v)).concat(");")),
    ir.Instr.BoolToStr(tid, v) => vec1("  ".concat(c_temp_name(tid)).concat(" = vox_bool_to_string(").concat(c_value(v)).concat(");")),

    ir.Instr.Call(has_dst, tid, ret_ty, name, args) => emit_instr_call(p, has_dst, tid, ret_ty, name, args),
  };
}

fn emit_term_ret(has: bool, v: ir.Value) -> Vec[String] {
  if has { return vec1("  return ".concat(c_value(v)).concat(";")); }
  return vec1("  return;");
}

fn emit_term(t: ir.Term) -> Vec[String] {
  return match t {
    ir.Term.Ret(has, v) => emit_term_ret(has, v),
    ir.Term.Br(target) => vec1("  goto ".concat(c_label_name(target)).concat(";")),
    ir.Term.CondBr(cond, t, e) => vec1("  if (".concat(c_value(cond)).concat(") goto ").concat(c_label_name(t)).concat("; else goto ").concat(c_label_name(e)).concat(";")),
    ir.Term.Panic(msg) => vec1("  vox_host_panic(".concat(c_value(msg)).concat(");")),
  };
}

fn find_enum_decl(p: ir.Program, name: String) -> ir.EnumDecl {
  let mut i: i32 = 0;
  while i < p.enums.len() {
    let en: ir.EnumDecl = p.enums.get(i);
    if en.name == name { return en; }
    i = i + 1;
  }
  panic("unknown enum in codegen");
  return ir.EnumDecl { name: "", variants: Vec() };
}

fn enum_variant_tag(en: ir.EnumDecl, variant: String) -> i32 {
  let mut i: i32 = 0;
  while i < en.variants.len() {
    if en.variants.get(i).name == variant { return i; }
    i = i + 1;
  }
  panic("unknown enum variant in codegen");
  return -1;
}

pub fn emit_func(pool: ir.TyPool, p: ir.Program, f: ir.Func) -> Vec[String] {
  let locals: LocalsResult = collect_locals(pool, f);
  let mut out: Vec[String] = Vec();

  // Signature
  let is_main: bool = f.name == "main";
  let mut sig: String = "static ".concat(c_ret_type(pool, f.ret)).concat(" ").concat(c_fn_name(f.name)).concat("(");
  if is_main {
    sig = sig.concat("int32_t vox_p_argc, intptr_t vox_p_argv");
    if f.params.len() != 0 { sig = sig.concat(", "); }
  }
  let mut i: i32 = 0;
  while i < f.params.len() {
    if i != 0 { sig = sig.concat(", "); }
    let pa: ir.Param = f.params.get(i);
    sig = sig.concat(c_type(pool, pa.ty)).concat(" ").concat(c_param_name(i));
    i = i + 1;
  }
  sig = sig.concat(") {");
  out.push(sig);

  // Slots
  let mut sid: i32 = 0;
  while sid <= locals.max_slot {
    let ty: String = idty_get(locals.slots, sid);
    if ty != "" { out.push("  ".concat(ty).concat(" ").concat(c_slot_name(sid)).concat(";")); }
    sid = sid + 1;
  }

  // Temps
  let mut tid: i32 = 0;
  while tid <= locals.max_temp {
    let ty: String = idty_get(locals.temps, tid);
    if ty != "" { out.push("  ".concat(ty).concat(" ").concat(c_temp_name(tid)).concat(";")); }
    tid = tid + 1;
  }
  if locals.max_slot != -1 || locals.max_temp != -1 { out.push(""); }

  // Blocks
  let mut bi: i32 = 0;
  while bi < f.blocks.len() {
    let b: ir.Block = f.blocks.get(bi);
    out.push(c_label_name(b.name).concat(":"));
    let mut ii: i32 = 0;
    while ii < b.instrs.len() {
      let lines: Vec[String] = emit_instr(pool, p, b.instrs.get(ii));
      let mut li: i32 = 0;
      while li < lines.len() { out.push(lines.get(li)); li = li + 1; }
      ii = ii + 1;
    }
    if !b.has_term { panic("block missing terminator"); }
    let term_lines: Vec[String] = emit_term(b.term);
    let mut ti: i32 = 0;
    while ti < term_lines.len() { out.push(term_lines.get(ti)); ti = ti + 1; }
    out.push("");
    bi = bi + 1;
  }

  out.push("}");
  return out;
}
