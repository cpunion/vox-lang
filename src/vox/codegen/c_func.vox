import "vox/ir" as ir

struct IdTy { id: i32, ty: String }

fn idty_has(v: Vec[IdTy], id: i32) -> bool {
  let mut i: i32 = 0;
  while i < v.len() {
    if v.get(i).id == id { return true; }
    i = i + 1;
  }
  return false;
}

fn idty_get(v: Vec[IdTy], id: i32) -> String {
  let mut i: i32 = 0;
  while i < v.len() {
    let it: IdTy = v.get(i);
    if it.id == id { return it.ty; }
    i = i + 1;
  }
  return "";
}

fn idty_add(v0: Vec[IdTy], id: i32, ty: String) -> Vec[IdTy] {
  if idty_has(v0, id) { return v0; }
  let mut v: Vec[IdTy] = v0;
  v.push(IdTy { id: id, ty: ty });
  return v;
}

fn c_value(v: ir.Value) -> String {
  return match v {
    ir.Value.Param(i) => c_param_name(i),
    ir.Value.Temp(i) => c_temp_name(i),
    ir.Value.Slot(i) => c_slot_name(i),
    ir.Value.Int(n) => n.to_string(),
    ir.Value.Float(text) => text,
    ir.Value.Bool(b) => if b { "true" } else { "false" },
    ir.Value.Str(s) => "\"".concat(s.escape_c()).concat("\""),
  };
}

fn c_binop(op: ir.BinOpKind) -> String {
  return match op {
    ir.BinOpKind.Add => "+",
    ir.BinOpKind.Sub => "-",
    ir.BinOpKind.Mul => "*",
    ir.BinOpKind.Div => "/",
    ir.BinOpKind.Mod => "%",
    ir.BinOpKind.BitAnd => "&",
    ir.BinOpKind.BitOr => "|",
    ir.BinOpKind.BitXor => "^",
    ir.BinOpKind.Shl => "<<",
    ir.BinOpKind.Shr => ">>",
  };
}

fn c_cmpop(op: ir.CmpKind) -> String {
  return match op {
    ir.CmpKind.Lt => "<",
    ir.CmpKind.Le => "<=",
    ir.CmpKind.Gt => ">",
    ir.CmpKind.Ge => ">=",
    ir.CmpKind.Eq => "==",
    ir.CmpKind.Ne => "!=",
  };
}

fn c_str_lit(s: String) -> String {
  return "\"".concat(s.escape_c()).concat("\"");
}

fn atomic_type_suffix(pool: ir.TyPool, elem_ty: i32) -> String {
  let t: ir.Ty = ir.ty_pool_get(pool, elem_ty);
  return match t.kind {
    ir.TyKind.I32 => "i32",
    ir.TyKind.I64 => "i64",
    ir.TyKind.ISize => "i64",
    _ => "i64",
  };
}

fn c_atomic_c_type(pool: ir.TyPool, elem_ty: i32) -> String {
  let t: ir.Ty = ir.ty_pool_get(pool, elem_ty);
  return match t.kind {
    ir.TyKind.I32 => "_Atomic int32_t",
    ir.TyKind.I64 => "_Atomic int64_t",
    ir.TyKind.ISize => "_Atomic intptr_t",
    _ => "_Atomic int64_t",
  };
}

fn c_atomic_val_c_type(pool: ir.TyPool, elem_ty: i32) -> String {
  let t: ir.Ty = ir.ty_pool_get(pool, elem_ty);
  return match t.kind {
    ir.TyKind.I32 => "int32_t",
    ir.TyKind.I64 => "int64_t",
    ir.TyKind.ISize => "intptr_t",
    _ => "int64_t",
  };
}

fn emit_instr_atomic_new(pool: ir.TyPool, tid: i32, elem_ty: i32, val: ir.Value) -> Vec[String] {
  let at: String = c_atomic_c_type(pool, elem_ty);
  let tmp: String = "_at_".concat(tid.to_string());
  let mut out: Vec[String] = Vec();
  out.push("  ".concat(at).concat("* ").concat(tmp).concat(" = (").concat(at).concat("*)malloc(sizeof(").concat(at).concat("));"));
  out.push("  if (!".concat(tmp).concat(") { vox_host_panic(\"out of memory\"); }"));
  out.push("  atomic_init(".concat(tmp).concat(", ").concat(c_value(val)).concat(");"));
  out.push("  ".concat(c_temp_name(tid)).concat(" = (intptr_t)").concat(tmp).concat(";"));
  return out;
}

fn emit_instr_atomic_cas(pool: ir.TyPool, tid: i32, elem_ty: i32, h: ir.Value, expected: ir.Value, desired: ir.Value) -> Vec[String] {
  let at: String = c_atomic_c_type(pool, elem_ty);
  let vt: String = c_atomic_val_c_type(pool, elem_ty);
  let tmp: String = "_cas_".concat(tid.to_string());
  let mut out: Vec[String] = Vec();
  out.push("  ".concat(vt).concat(" ").concat(tmp).concat(" = ").concat(c_value(expected)).concat(";"));
  out.push("  ".concat(c_temp_name(tid)).concat(" = atomic_compare_exchange_strong_explicit((").concat(at).concat("*)").concat(c_value(h)).concat(", &").concat(tmp).concat(", ").concat(c_value(desired)).concat(", memory_order_seq_cst, memory_order_seq_cst);"));
  return out;
}

fn is_int_scalar_kind(k: ir.TyKind) -> bool {
  return match k {
    ir.TyKind.I8 => true,
    ir.TyKind.U8 => true,
    ir.TyKind.I16 => true,
    ir.TyKind.U16 => true,
    ir.TyKind.I32 => true,
    ir.TyKind.U32 => true,
    ir.TyKind.I64 => true,
    ir.TyKind.U64 => true,
    ir.TyKind.ISize => true,
    ir.TyKind.USize => true,
    _ => false,
  };
}

fn is_signed_int_kind(k: ir.TyKind) -> bool {
  return match k { ir.TyKind.I8 => true, ir.TyKind.I16 => true, ir.TyKind.I32 => true, ir.TyKind.I64 => true, ir.TyKind.ISize => true, _ => false };
}

fn is_unsigned_int_kind(k: ir.TyKind) -> bool {
  return match k { ir.TyKind.U8 => true, ir.TyKind.U16 => true, ir.TyKind.U32 => true, ir.TyKind.U64 => true, ir.TyKind.USize => true, _ => false };
}

fn int_bits(k: ir.TyKind) -> i32 {
  return match k {
    ir.TyKind.I8 => 8,
    ir.TyKind.U8 => 8,
    ir.TyKind.I16 => 16,
    ir.TyKind.U16 => 16,
    ir.TyKind.I32 => 32,
    ir.TyKind.U32 => 32,
    ir.TyKind.I64 => 64,
    ir.TyKind.U64 => 64,
    ir.TyKind.ISize => 0,
    ir.TyKind.USize => 0,
    _ => 0,
  };
}

fn int_bits_expr(k: ir.TyKind) -> String {
  if k == ir.TyKind.ISize || k == ir.TyKind.USize {
    return "((int32_t)(sizeof(uintptr_t) * 8))";
  }
  let b: i32 = int_bits(k);
  return b.to_string();
}

fn ptr_bits_lt_64_expr() -> String {
  return "(((int32_t)(sizeof(uintptr_t) * 8)) < 64)";
}

fn int_sign_high_bit_expr(k: ir.TyKind) -> String {
  if k == ir.TyKind.ISize {
    return "(((uintptr_t)1) << (((int32_t)(sizeof(uintptr_t) * 8)) - 1))";
  }
  let b: i32 = int_bits(k);
  return "(((".concat(unsigned_peer_c_type(k)).concat(")1) << ").concat((b - 1).to_string()).concat(")");
}

fn int_bits_min(k: ir.TyKind) -> i32 {
  if k == ir.TyKind.ISize || k == ir.TyKind.USize { return 32; }
  return int_bits(k);
}

fn int_bits_max(k: ir.TyKind) -> i32 {
  if k == ir.TyKind.ISize || k == ir.TyKind.USize { return 64; }
  return int_bits(k);
}

fn int_cast_needs_runtime_check(dst: ir.TyKind, src: ir.TyKind) -> bool {
  if !is_int_scalar_kind(dst) || !is_int_scalar_kind(src) { return true; }
  if dst == src { return false; }
  let dmin: i32 = int_bits_min(dst);
  let smax: i32 = int_bits_max(src);
  if dmin == 0 || smax == 0 { return true; }

  let du: bool = is_unsigned_int_kind(dst);
  let su: bool = is_unsigned_int_kind(src);
  if du && !su { return true; } // signed -> unsigned always needs non-negative check
  if !du && su { return dmin <= smax; } // unsigned -> signed needs at least one extra sign bit
  return dmin < smax; // same signedness: destination must hold full source range
}

fn int_cast_signed_to_unsigned_needs_upper_check(dst: ir.TyKind, src: ir.TyKind) -> bool {
  if !is_unsigned_int_kind(dst) || !is_signed_int_kind(src) { return true; }
  // isize -> usize is width-equal by definition on every target.
  if src == ir.TyKind.ISize && dst == ir.TyKind.USize { return false; }
  let dmin: i32 = int_bits_min(dst);
  let smax: i32 = int_bits_max(src);
  if dmin == 0 || smax == 0 { return true; }
  // Signed src max is 2^(s-1)-1; any unsigned destination with at least s bits always fits it.
  return dmin < smax;
}

fn unsigned_peer_c_type(k: ir.TyKind) -> String {
  return match k {
    ir.TyKind.I8 => "uint8_t",
    ir.TyKind.U8 => "uint8_t",
    ir.TyKind.I16 => "uint16_t",
    ir.TyKind.U16 => "uint16_t",
    ir.TyKind.I32 => "uint32_t",
    ir.TyKind.U32 => "uint32_t",
    ir.TyKind.I64 => "uint64_t",
    ir.TyKind.U64 => "uint64_t",
    ir.TyKind.ISize => "uintptr_t",
    ir.TyKind.USize => "uintptr_t",
    _ => "uint64_t",
  };
}

fn signed_from_unsigned_bitcast_fn(k: ir.TyKind) -> String {
  return match k {
    ir.TyKind.I8 => "vox_bitcast_u8_i8",
    ir.TyKind.I16 => "vox_bitcast_u16_i16",
    ir.TyKind.I32 => "vox_bitcast_u32_i32",
    ir.TyKind.I64 => "vox_bitcast_u64_i64",
    ir.TyKind.ISize => "vox_bitcast_uptr_iptr",
    _ => "",
  };
}

fn signed_min_macro(k: ir.TyKind) -> String {
  return match k {
    ir.TyKind.I8 => "INT8_MIN",
    ir.TyKind.I16 => "INT16_MIN",
    ir.TyKind.I32 => "INT32_MIN",
    ir.TyKind.I64 => "INT64_MIN",
    ir.TyKind.ISize => "INTPTR_MIN",
    _ => "",
  };
}

fn signed_max_macro(k: ir.TyKind) -> String {
  return match k {
    ir.TyKind.I8 => "INT8_MAX",
    ir.TyKind.I16 => "INT16_MAX",
    ir.TyKind.I32 => "INT32_MAX",
    ir.TyKind.I64 => "INT64_MAX",
    ir.TyKind.ISize => "INTPTR_MAX",
    _ => "",
  };
}

struct LocalsResult { slots: Vec[IdTy], temps: Vec[IdTy], max_slot: i32, max_temp: i32 }

fn locals0() -> LocalsResult { return LocalsResult { slots: Vec(), temps: Vec(), max_slot: -1, max_temp: -1 }; }

fn temp_flags_new(max_temp: i32) -> Vec[bool] {
  let mut flags: Vec[bool] = Vec();
  let mut i: i32 = 0;
  while i <= max_temp {
    flags.push(false);
    i = i + 1;
  }
  return flags;
}

fn temp_flag_get(flags: Vec[bool], tid: i32) -> bool {
  if tid < 0 || tid >= flags.len() { return false; }
  return flags.get(tid);
}

fn temp_flag_set(flags0: Vec[bool], tid: i32) -> Vec[bool] {
  if tid < 0 || tid >= flags0.len() { return flags0; }
  let mut flags: Vec[bool] = flags0;
  if !flags.get(tid) { flags.set(tid, true); }
  return flags;
}

fn slot_flags_new(max_slot: i32) -> Vec[bool] {
  let mut flags: Vec[bool] = Vec();
  let mut i: i32 = 0;
  while i <= max_slot {
    flags.push(false);
    i = i + 1;
  }
  return flags;
}

fn slot_flag_get(flags: Vec[bool], sid: i32) -> bool {
  if sid < 0 || sid >= flags.len() { return false; }
  return flags.get(sid);
}

fn slot_flag_set(flags0: Vec[bool], sid: i32) -> Vec[bool] {
  if sid < 0 || sid >= flags0.len() { return flags0; }
  let mut flags: Vec[bool] = flags0;
  if !flags.get(sid) { flags.set(sid, true); }
  return flags;
}

fn mark_live_slot_value(flags0: Vec[bool], v: ir.Value) -> Vec[bool] {
  return match v {
    ir.Value.Slot(sid) => slot_flag_set(flags0, sid),
    _ => flags0,
  };
}

fn mark_live_slot_values(flags0: Vec[bool], vals: Vec[ir.Value]) -> Vec[bool] {
  let mut flags: Vec[bool] = flags0;
  let mut i: i32 = 0;
  while i < vals.len() {
    flags = mark_live_slot_value(flags, vals.get(i));
    i = i + 1;
  }
  return flags;
}

fn mark_live_slot_reads(flags0: Vec[bool], ins: ir.Instr) -> Vec[bool] {
  return match ins {
    ir.Instr.Load(_tid, _ty, sid) => slot_flag_set(flags0, sid),
    ir.Instr.AddrOfSlot(_tid, _ty, sid) => slot_flag_set(flags0, sid),
    ir.Instr.AddrOfFieldChain(_tid, _ty, sid, _fields) => slot_flag_set(flags0, sid),
    ir.Instr.StoreField(sid, _field, _v) => slot_flag_set(flags0, sid),
    ir.Instr.VecPush(sid, _elem, _v) => slot_flag_set(flags0, sid),
    ir.Instr.VecInsert(sid, _elem, _idx, _v) => slot_flag_set(flags0, sid),
    ir.Instr.VecSet(sid, _elem, _idx, _v) => slot_flag_set(flags0, sid),
    ir.Instr.VecClear(sid) => slot_flag_set(flags0, sid),
    ir.Instr.VecExtend(sid, other_sid) => slot_flag_set(slot_flag_set(flags0, sid), other_sid),
    ir.Instr.VecPop(_tid, _elem, sid) => slot_flag_set(flags0, sid),
    ir.Instr.VecRemove(_tid, _elem, sid, _idx) => slot_flag_set(flags0, sid),
    ir.Instr.VecLen(_tid, sid) => slot_flag_set(flags0, sid),
    ir.Instr.VecGet(_tid, _elem, sid, _idx) => slot_flag_set(flags0, sid),
    _ => flags0,
  };
}

fn mark_live_slot_values_from_instr(flags0: Vec[bool], ins: ir.Instr) -> Vec[bool] {
  return match ins {
    ir.Instr.Const(_tid, _ty, v) => mark_live_slot_value(flags0, v),
    ir.Instr.BinOp(_tid, _op, _ty, a, b) => mark_live_slot_value(mark_live_slot_value(flags0, a), b),
    ir.Instr.Cmp(_tid, _op, _oty, a, b) => mark_live_slot_value(mark_live_slot_value(flags0, a), b),
    ir.Instr.And(_tid, a, b) => mark_live_slot_value(mark_live_slot_value(flags0, a), b),
    ir.Instr.Or(_tid, a, b) => mark_live_slot_value(mark_live_slot_value(flags0, a), b),
    ir.Instr.Not(_tid, a) => mark_live_slot_value(flags0, a),
    ir.Instr.IntCast(_tid, _dst_ty, _src_ty, v) => mark_live_slot_value(flags0, v),
    ir.Instr.IntCastChecked(_tid, _dst_ty, _src_ty, v) => mark_live_slot_value(flags0, v),
    ir.Instr.FloatCast(_tid, _dst_ty, _src_ty, v) => mark_live_slot_value(flags0, v),
    ir.Instr.RangeCheck(_ty, v, _lo, _hi) => mark_live_slot_value(flags0, v),
    ir.Instr.SlotDecl(_sid, _ty) => flags0,
    ir.Instr.Store(_sid, v) => mark_live_slot_value(flags0, v),
    ir.Instr.Load(_tid, _ty, _sid) => flags0,
    ir.Instr.GlobalLoad(_tid, _ty, _name) => flags0,
    ir.Instr.GlobalStore(_ty, _name, v) => mark_live_slot_value(flags0, v),
    ir.Instr.AddrOfSlot(_tid, _ty, _sid) => flags0,
    ir.Instr.AddrOfFieldChain(_tid, _ty, _sid, _fields) => flags0,
    ir.Instr.RefLoad(_tid, _ty, recv) => mark_live_slot_value(flags0, recv),
    ir.Instr.RefStore(_ty, recv, v) => mark_live_slot_value(mark_live_slot_value(flags0, recv), v),
    ir.Instr.PtrRead(_tid, _ty, ptr) => mark_live_slot_value(flags0, ptr),
    ir.Instr.PtrWrite(_ty, ptr, v) => mark_live_slot_value(mark_live_slot_value(flags0, ptr), v),
    ir.Instr.PtrOffset(_tid, ptr, off) => mark_live_slot_value(mark_live_slot_value(flags0, ptr), off),
    ir.Instr.StructInit(_tid, _ty, fields) => {
      let mut flags: Vec[bool] = flags0;
      let mut i: i32 = 0;
      while i < fields.len() {
        flags = mark_live_slot_value(flags, fields.get(i).val);
        i = i + 1;
      }
      flags
    },
    ir.Instr.FieldGet(_tid, _ty, recv, _field) => mark_live_slot_value(flags0, recv),
    ir.Instr.StoreField(_sid, _field, v) => mark_live_slot_value(flags0, v),
    ir.Instr.EnumInit(_tid, _ty, _variant, payload) => mark_live_slot_values(flags0, payload),
    ir.Instr.EnumTag(_tid, recv) => mark_live_slot_value(flags0, recv),
    ir.Instr.EnumPayload(_tid, _ty, recv, _variant, _idx) => mark_live_slot_value(flags0, recv),
    ir.Instr.VecNew(_tid, _vty, _elem) => flags0,
    ir.Instr.VecPush(_recv_slot, _elem, v) => mark_live_slot_value(flags0, v),
    ir.Instr.VecInsert(_recv_slot, _elem, idx, v) => mark_live_slot_value(mark_live_slot_value(flags0, idx), v),
    ir.Instr.VecSet(_recv_slot, _elem, idx, v) => mark_live_slot_value(mark_live_slot_value(flags0, idx), v),
    ir.Instr.VecClear(_recv_slot) => flags0,
    ir.Instr.VecExtend(_recv_slot, _other_slot) => flags0,
    ir.Instr.VecPop(_tid, _elem, _recv_slot) => flags0,
    ir.Instr.VecRemove(_tid, _elem, _recv_slot, idx) => mark_live_slot_value(flags0, idx),
    ir.Instr.VecLen(_tid, _recv_slot) => flags0,
    ir.Instr.VecGet(_tid, _elem, _recv_slot, idx) => mark_live_slot_value(flags0, idx),
    ir.Instr.AtomicNew(_tid, _elem_ty, val) => mark_live_slot_value(flags0, val),
    ir.Instr.AtomicLoad(_tid, _elem_ty, h) => mark_live_slot_value(flags0, h),
    ir.Instr.AtomicStore(_elem_ty, h, val) => mark_live_slot_value(mark_live_slot_value(flags0, h), val),
    ir.Instr.AtomicFetchAdd(_tid, _elem_ty, h, delta) => mark_live_slot_value(mark_live_slot_value(flags0, h), delta),
    ir.Instr.AtomicSwap(_tid, _elem_ty, h, val) => mark_live_slot_value(mark_live_slot_value(flags0, h), val),
    ir.Instr.AtomicCAS(_tid, _elem_ty, h, expected, desired) => mark_live_slot_value(mark_live_slot_value(mark_live_slot_value(flags0, h), expected), desired),
    ir.Instr.AtomicDrop(_elem_ty, h) => mark_live_slot_value(flags0, h),
    ir.Instr.Call(_has_dst, _tid, _ret_ty, _name, args) => mark_live_slot_values(flags0, args),
  };
}

fn mark_live_slot_values_from_term(flags0: Vec[bool], t: ir.Term) -> Vec[bool] {
  return match t {
    ir.Term.Ret(has, v) => if has { mark_live_slot_value(flags0, v) } else { flags0 },
    ir.Term.Br(_target) => flags0,
    ir.Term.CondBr(cond, _then_block, _else_block) => mark_live_slot_value(flags0, cond),
    ir.Term.Panic(msg) => mark_live_slot_value(flags0, msg),
  };
}

fn collect_live_slots_all_reads(f: ir.Func, max_slot: i32) -> Vec[bool] {
  let mut live: Vec[bool] = slot_flags_new(max_slot);
  let mut bi: i32 = 0;
  while bi < f.blocks.len() {
    let b: ir.Block = f.blocks.get(bi);
    let mut ii: i32 = 0;
    while ii < b.instrs.len() {
      let ins: ir.Instr = b.instrs.get(ii);
      live = mark_live_slot_reads(live, ins);
      live = mark_live_slot_values_from_instr(live, ins);
      ii = ii + 1;
    }
    if b.has_term { live = mark_live_slot_values_from_term(live, b.term); }
    bi = bi + 1;
  }
  return live;
}

fn collect_live_slots_filtered(pool: ir.TyPool, f: ir.Func, max_slot: i32, live_temps: Vec[bool], live_slots0: Vec[bool]) -> Vec[bool] {
  let mut live: Vec[bool] = slot_flags_new(max_slot);
  let mut bi: i32 = 0;
  while bi < f.blocks.len() {
    let b: ir.Block = f.blocks.get(bi);
    let mut ii: i32 = 0;
    while ii < b.instrs.len() {
      let ins: ir.Instr = b.instrs.get(ii);
      if !instr_is_dead_temp(pool, ins, live_temps) && !instr_is_dead_slot_instr(ins, live_slots0) {
        live = mark_live_slot_reads(live, ins);
        live = mark_live_slot_values_from_instr(live, ins);
      }
      ii = ii + 1;
    }
    if b.has_term { live = mark_live_slot_values_from_term(live, b.term); }
    bi = bi + 1;
  }
  return live;
}

fn instr_is_dead_slot_decl(ins: ir.Instr, live_slots: Vec[bool]) -> bool {
  return match ins {
    ir.Instr.SlotDecl(sid, _ty) => !slot_flag_get(live_slots, sid),
    _ => false,
  };
}

fn instr_is_dead_slot_store(ins: ir.Instr, live_slots: Vec[bool]) -> bool {
  return match ins {
    ir.Instr.Store(sid, _v) => !slot_flag_get(live_slots, sid),
    _ => false,
  };
}

fn instr_is_dead_slot_instr(ins: ir.Instr, live_slots: Vec[bool]) -> bool {
  return instr_is_dead_slot_decl(ins, live_slots) || instr_is_dead_slot_store(ins, live_slots);
}

fn mark_live_value(flags0: Vec[bool], v: ir.Value) -> Vec[bool] {
  return match v {
    ir.Value.Temp(tid) => temp_flag_set(flags0, tid),
    _ => flags0,
  };
}

fn mark_live_values(flags0: Vec[bool], vals: Vec[ir.Value]) -> Vec[bool] {
  let mut flags: Vec[bool] = flags0;
  let mut i: i32 = 0;
  while i < vals.len() {
    flags = mark_live_value(flags, vals.get(i));
    i = i + 1;
  }
  return flags;
}

fn instr_dst_temp_id(ins: ir.Instr) -> i32 {
  return match ins {
    ir.Instr.Const(tid, _ty, _v) => tid,
    ir.Instr.BinOp(tid, _op, _ty, _a, _b) => tid,
    ir.Instr.Cmp(tid, _op, _oty, _a, _b) => tid,
    ir.Instr.And(tid, _a, _b) => tid,
    ir.Instr.Or(tid, _a, _b) => tid,
    ir.Instr.Not(tid, _a) => tid,
    ir.Instr.IntCast(tid, _dst_ty, _src_ty, _v) => tid,
    ir.Instr.IntCastChecked(tid, _dst_ty, _src_ty, _v) => tid,
    ir.Instr.FloatCast(tid, _dst_ty, _src_ty, _v) => tid,
    ir.Instr.Load(tid, _ty, _sid) => tid,
    ir.Instr.GlobalLoad(tid, _ty, _name) => tid,
    ir.Instr.AddrOfSlot(tid, _ty, _sid) => tid,
    ir.Instr.AddrOfFieldChain(tid, _ty, _sid, _fields) => tid,
    ir.Instr.RefLoad(tid, _ty, _recv) => tid,
    ir.Instr.PtrRead(tid, _ty, _ptr) => tid,
    ir.Instr.PtrOffset(tid, _ptr, _off) => tid,
    ir.Instr.StructInit(tid, _ty, _fields) => tid,
    ir.Instr.FieldGet(tid, _ty, _recv, _field) => tid,
    ir.Instr.EnumInit(tid, _ty, _variant, _payload) => tid,
    ir.Instr.EnumTag(tid, _recv) => tid,
    ir.Instr.EnumPayload(tid, _ty, _recv, _variant, _idx) => tid,
    ir.Instr.VecNew(tid, _vty, _elem) => tid,
    ir.Instr.VecPop(tid, _elem, _recv_slot) => tid,
    ir.Instr.VecRemove(tid, _elem, _recv_slot, _idx) => tid,
    ir.Instr.VecLen(tid, _recv_slot) => tid,
    ir.Instr.VecGet(tid, _elem, _recv_slot, _idx) => tid,
    ir.Instr.AtomicNew(tid, _elem_ty, _val) => tid,
    ir.Instr.AtomicLoad(tid, _elem_ty, _h) => tid,
    ir.Instr.AtomicFetchAdd(tid, _elem_ty, _h, _delta) => tid,
    ir.Instr.AtomicSwap(tid, _elem_ty, _h, _val) => tid,
    ir.Instr.AtomicCAS(tid, _elem_ty, _h, _expected, _desired) => tid,
    ir.Instr.Call(has_dst, tid, _ret_ty, _name, _args) => if has_dst { tid } else { -1 },
    _ => -1,
  };
}

fn binop_can_panic(pool: ir.TyPool, op: ir.BinOpKind, ty: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(pool, ty);
  if !is_int_scalar_kind(t.kind) { return false; }
  return match op {
    ir.BinOpKind.Div => true,
    ir.BinOpKind.Mod => true,
    ir.BinOpKind.Shl => true,
    ir.BinOpKind.Shr => true,
    _ => false,
  };
}

fn instr_can_drop_when_dead(pool: ir.TyPool, ins: ir.Instr) -> bool {
  return match ins {
    ir.Instr.Const(_tid, _ty, _v) => true,
    ir.Instr.BinOp(_tid, op, ty, _a, _b) => !binop_can_panic(pool, op, ty),
    ir.Instr.Cmp(_tid, _op, _oty, _a, _b) => true,
    ir.Instr.And(_tid, _a, _b) => true,
    ir.Instr.Or(_tid, _a, _b) => true,
    ir.Instr.Not(_tid, _a) => true,
    ir.Instr.IntCast(_tid, _dst_ty, _src_ty, _v) => true,
    ir.Instr.FloatCast(_tid, _dst_ty, _src_ty, _v) => true,
    ir.Instr.Load(_tid, _ty, _sid) => true,
    ir.Instr.GlobalLoad(_tid, _ty, _name) => true,
    ir.Instr.AddrOfSlot(_tid, _ty, _sid) => true,
    ir.Instr.AddrOfFieldChain(_tid, _ty, _sid, _fields) => true,
    ir.Instr.PtrOffset(_tid, _ptr, _off) => true,
    ir.Instr.StructInit(_tid, _ty, _fields) => true,
    ir.Instr.FieldGet(_tid, _ty, _recv, _field) => true,
    ir.Instr.EnumInit(_tid, _ty, _variant, _payload) => true,
    ir.Instr.EnumTag(_tid, _recv) => true,
    ir.Instr.EnumPayload(_tid, _ty, _recv, _variant, _idx) => true,
    ir.Instr.VecLen(_tid, _recv_slot) => true,
    _ => false,
  };
}

fn mark_live_from_instr_operands(flags0: Vec[bool], ins: ir.Instr) -> Vec[bool] {
  return match ins {
    ir.Instr.Const(_tid, _ty, _v) => flags0,
    ir.Instr.BinOp(_tid, _op, _ty, a, b) => mark_live_value(mark_live_value(flags0, a), b),
    ir.Instr.Cmp(_tid, _op, _oty, a, b) => mark_live_value(mark_live_value(flags0, a), b),
    ir.Instr.And(_tid, a, b) => mark_live_value(mark_live_value(flags0, a), b),
    ir.Instr.Or(_tid, a, b) => mark_live_value(mark_live_value(flags0, a), b),
    ir.Instr.Not(_tid, a) => mark_live_value(flags0, a),
    ir.Instr.IntCast(_tid, _dst_ty, _src_ty, v) => mark_live_value(flags0, v),
    ir.Instr.IntCastChecked(_tid, _dst_ty, _src_ty, v) => mark_live_value(flags0, v),
    ir.Instr.FloatCast(_tid, _dst_ty, _src_ty, v) => mark_live_value(flags0, v),
    ir.Instr.RangeCheck(_ty, v, _lo, _hi) => mark_live_value(flags0, v),
    ir.Instr.SlotDecl(_sid, _ty) => flags0,
    ir.Instr.Store(_sid, v) => mark_live_value(flags0, v),
    ir.Instr.Load(_tid, _ty, _sid) => flags0,
    ir.Instr.GlobalLoad(_tid, _ty, _name) => flags0,
    ir.Instr.GlobalStore(_ty, _name, v) => mark_live_value(flags0, v),
    ir.Instr.AddrOfSlot(_tid, _ty, _sid) => flags0,
    ir.Instr.AddrOfFieldChain(_tid, _ty, _sid, _fields) => flags0,
    ir.Instr.RefLoad(_tid, _ty, recv) => mark_live_value(flags0, recv),
    ir.Instr.RefStore(_ty, recv, v) => mark_live_value(mark_live_value(flags0, recv), v),
    ir.Instr.PtrRead(_tid, _ty, ptr) => mark_live_value(flags0, ptr),
    ir.Instr.PtrWrite(_ty, ptr, v) => mark_live_value(mark_live_value(flags0, ptr), v),
    ir.Instr.PtrOffset(_tid, ptr, off) => mark_live_value(mark_live_value(flags0, ptr), off),
    ir.Instr.StructInit(_tid, _ty, fields) => {
      let mut flags: Vec[bool] = flags0;
      let mut i: i32 = 0;
      while i < fields.len() {
        flags = mark_live_value(flags, fields.get(i).val);
        i = i + 1;
      }
      flags
    },
    ir.Instr.FieldGet(_tid, _ty, recv, _field) => mark_live_value(flags0, recv),
    ir.Instr.StoreField(_sid, _field, v) => mark_live_value(flags0, v),
    ir.Instr.EnumInit(_tid, _ty, _variant, payload) => mark_live_values(flags0, payload),
    ir.Instr.EnumTag(_tid, recv) => mark_live_value(flags0, recv),
    ir.Instr.EnumPayload(_tid, _ty, recv, _variant, _idx) => mark_live_value(flags0, recv),
    ir.Instr.VecNew(_tid, _vty, _elem) => flags0,
    ir.Instr.VecPush(_recv_slot, _elem, v) => mark_live_value(flags0, v),
    ir.Instr.VecInsert(_recv_slot, _elem, idx, v) => mark_live_value(mark_live_value(flags0, idx), v),
    ir.Instr.VecSet(_recv_slot, _elem, idx, v) => mark_live_value(mark_live_value(flags0, idx), v),
    ir.Instr.VecClear(_recv_slot) => flags0,
    ir.Instr.VecExtend(_recv_slot, _other_slot) => flags0,
    ir.Instr.VecPop(_tid, _elem, _recv_slot) => flags0,
    ir.Instr.VecRemove(_tid, _elem, _recv_slot, idx) => mark_live_value(flags0, idx),
    ir.Instr.VecLen(_tid, _recv_slot) => flags0,
    ir.Instr.VecGet(_tid, _elem, _recv_slot, idx) => mark_live_value(flags0, idx),
    ir.Instr.AtomicNew(_tid, _elem_ty, val) => mark_live_value(flags0, val),
    ir.Instr.AtomicLoad(_tid, _elem_ty, h) => mark_live_value(flags0, h),
    ir.Instr.AtomicStore(_elem_ty, h, val) => mark_live_value(mark_live_value(flags0, h), val),
    ir.Instr.AtomicFetchAdd(_tid, _elem_ty, h, delta) => mark_live_value(mark_live_value(flags0, h), delta),
    ir.Instr.AtomicSwap(_tid, _elem_ty, h, val) => mark_live_value(mark_live_value(flags0, h), val),
    ir.Instr.AtomicCAS(_tid, _elem_ty, h, expected, desired) => mark_live_value(mark_live_value(mark_live_value(flags0, h), expected), desired),
    ir.Instr.AtomicDrop(_elem_ty, h) => mark_live_value(flags0, h),
    ir.Instr.Call(_has_dst, _tid, _ret_ty, _name, args) => mark_live_values(flags0, args),
  };
}

fn mark_live_from_term(flags0: Vec[bool], t: ir.Term) -> Vec[bool] {
  return match t {
    ir.Term.Ret(has, v) => if has { mark_live_value(flags0, v) } else { flags0 },
    ir.Term.Br(_target) => flags0,
    ir.Term.CondBr(cond, _then_block, _else_block) => mark_live_value(flags0, cond),
    ir.Term.Panic(msg) => mark_live_value(flags0, msg),
  };
}

fn temp_flags_true_count(flags: Vec[bool]) -> i32 {
  let mut n: i32 = 0;
  let mut i: i32 = 0;
  while i < flags.len() {
    if flags.get(i) { n = n + 1; }
    i = i + 1;
  }
  return n;
}

fn collect_live_temps(pool: ir.TyPool, f: ir.Func, max_temp: i32, live_slots: Vec[bool]) -> Vec[bool] {
  // Seed from always-kept instruction operands and terminators.
  let mut live: Vec[bool] = temp_flags_new(max_temp);
  let mut bi: i32 = 0;
  while bi < f.blocks.len() {
    let b: ir.Block = f.blocks.get(bi);
    let mut ii: i32 = 0;
    while ii < b.instrs.len() {
      let ins: ir.Instr = b.instrs.get(ii);
      if !instr_is_dead_slot_instr(ins, live_slots) {
        let dst: i32 = instr_dst_temp_id(ins);
        if dst == -1 || !instr_can_drop_when_dead(pool, ins) {
          live = mark_live_from_instr_operands(live, ins);
        }
      }
      ii = ii + 1;
    }
    if b.has_term { live = mark_live_from_term(live, b.term); }
    bi = bi + 1;
  }

  // Close over temp defs that must be kept because their result is live.
  let mut prev_live_count: i32 = -1;
  let mut live_count: i32 = temp_flags_true_count(live);
  while live_count != prev_live_count {
    prev_live_count = live_count;
    let mut b2: i32 = 0;
    while b2 < f.blocks.len() {
      let bb: ir.Block = f.blocks.get(b2);
      let mut i2: i32 = 0;
      while i2 < bb.instrs.len() {
        let ins2: ir.Instr = bb.instrs.get(i2);
        if !instr_is_dead_slot_instr(ins2, live_slots) {
          let dst2: i32 = instr_dst_temp_id(ins2);
          if dst2 != -1 && temp_flag_get(live, dst2) && instr_can_drop_when_dead(pool, ins2) {
            live = mark_live_from_instr_operands(live, ins2);
          }
        }
        i2 = i2 + 1;
      }
      b2 = b2 + 1;
    }
    live_count = temp_flags_true_count(live);
  }
  return live;
}

fn instr_is_dead_temp(pool: ir.TyPool, ins: ir.Instr, live_temps: Vec[bool]) -> bool {
  let dst: i32 = instr_dst_temp_id(ins);
  if dst == -1 { return false; }
  return !temp_flag_get(live_temps, dst) && instr_can_drop_when_dead(pool, ins);
}

fn locals_add_slot(l0: LocalsResult, sid: i32, ty: String) -> LocalsResult {
  let mut l: LocalsResult = l0;
  l.slots = idty_add(l.slots, sid, ty);
  if sid > l.max_slot { l.max_slot = sid; }
  return l;
}

fn locals_add_temp(l0: LocalsResult, tid: i32, ty: String) -> LocalsResult {
  let mut l: LocalsResult = l0;
  l.temps = idty_add(l.temps, tid, ty);
  if tid > l.max_temp { l.max_temp = tid; }
  return l;
}

fn locals_add_call(pool: ir.TyPool, l0: LocalsResult, has_dst: bool, tid: i32, ret_ty: i32) -> LocalsResult {
  if !has_dst { return l0; }
  return locals_add_temp(l0, tid, c_type(pool, ret_ty));
}

fn locals_add_instr(pool: ir.TyPool, l0: LocalsResult, ins: ir.Instr) -> LocalsResult {
  return match ins {
    ir.Instr.SlotDecl(sid, ty) => locals_add_slot(l0, sid, c_type(pool, ty)),
    ir.Instr.Const(tid, ty, _v) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.BinOp(tid, _op, ty, _a, _b) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.Cmp(tid, _op, _oty, _a, _b) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.And(tid, _a, _b) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.Or(tid, _a, _b) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.Not(tid, _a) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.IntCast(tid, dst_ty, _src_ty, _v) => locals_add_temp(l0, tid, c_type(pool, dst_ty)),
    ir.Instr.IntCastChecked(tid, dst_ty, _src_ty, _v) => locals_add_temp(l0, tid, c_type(pool, dst_ty)),
    ir.Instr.FloatCast(tid, dst_ty, _src_ty, _v) => locals_add_temp(l0, tid, c_type(pool, dst_ty)),
    ir.Instr.Load(tid, ty, _sid) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.GlobalLoad(tid, ty, _name) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.GlobalStore(_ty, _name, _v) => l0,
    ir.Instr.AddrOfSlot(tid, ty, _sid) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.AddrOfFieldChain(tid, ty, _sid, _fs) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.RefLoad(tid, ty, _recv) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.PtrRead(tid, ty, _ptr) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.PtrWrite(_ty, _ptr, _v) => l0,
    ir.Instr.PtrOffset(tid, _ptr, _off) => locals_add_temp(l0, tid, "void*"),
    ir.Instr.StructInit(tid, ty, _fs) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.FieldGet(tid, ty, _r, _f) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.EnumInit(tid, ty, _v, _ps) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.EnumTag(tid, _r) => locals_add_temp(l0, tid, "int32_t"),
    ir.Instr.EnumPayload(tid, ty, _r, _v, _i) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.VecNew(tid, ty, _elem) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.VecInsert(_sid, _elem, _idx, _v) => l0,
    ir.Instr.VecSet(_sid, _elem, _idx, _v) => l0,
    ir.Instr.VecClear(_sid) => l0,
    ir.Instr.VecExtend(_sid, _other_sid) => l0,
    ir.Instr.VecPop(tid, ty, _sid) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.VecRemove(tid, ty, _sid, _idx) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.VecLen(tid, _sid) => locals_add_temp(l0, tid, "int32_t"),
    ir.Instr.VecGet(tid, ty, _sid, _idx) => locals_add_temp(l0, tid, c_type(pool, ty)),
    ir.Instr.AtomicNew(tid, _elem_ty, _val) => locals_add_temp(l0, tid, "intptr_t"),
    ir.Instr.AtomicLoad(tid, elem_ty, _h) => locals_add_temp(l0, tid, c_type(pool, elem_ty)),
    ir.Instr.AtomicStore(_elem_ty, _h, _val) => l0,
    ir.Instr.AtomicFetchAdd(tid, elem_ty, _h, _delta) => locals_add_temp(l0, tid, c_type(pool, elem_ty)),
    ir.Instr.AtomicSwap(tid, elem_ty, _h, _val) => locals_add_temp(l0, tid, c_type(pool, elem_ty)),
    ir.Instr.AtomicCAS(tid, _ety, _h, _expected, _desired) => locals_add_temp(l0, tid, "bool"),
    ir.Instr.AtomicDrop(_ety, _h) => l0,
    ir.Instr.Call(has_dst, tid, ret_ty, _name, _args) => locals_add_call(pool, l0, has_dst, tid, ret_ty),
    _ => l0,
  };
}

fn collect_locals_all(pool: ir.TyPool, f: ir.Func) -> LocalsResult {
  let mut l: LocalsResult = locals0();
  let mut bi: i32 = 0;
  while bi < f.blocks.len() {
    let b: ir.Block = f.blocks.get(bi);
    let mut ii: i32 = 0;
    while ii < b.instrs.len() {
      l = locals_add_instr(pool, l, b.instrs.get(ii));
      ii = ii + 1;
    }
    bi = bi + 1;
  }
  return l;
}

fn collect_locals(pool: ir.TyPool, f: ir.Func, live_temps: Vec[bool], live_slots: Vec[bool]) -> LocalsResult {
  let mut l: LocalsResult = locals0();
  let mut bi: i32 = 0;
  while bi < f.blocks.len() {
    let b: ir.Block = f.blocks.get(bi);
    let mut ii: i32 = 0;
    while ii < b.instrs.len() {
      let ins: ir.Instr = b.instrs.get(ii);
      if !instr_is_dead_temp(pool, ins, live_temps) && !instr_is_dead_slot_instr(ins, live_slots) {
        l = locals_add_instr(pool, l, ins);
      }
      ii = ii + 1;
    }
    bi = bi + 1;
  }
  return l;
}

fn vec0() -> Vec[String] { return Vec(); }

fn vec1(s: String) -> Vec[String] { let mut v: Vec[String] = Vec(); v.push(s); return v; }

fn c_field_chain(fields: Vec[String]) -> String {
  let mut out: String = "";
  let mut i: i32 = 0;
  while i < fields.len() {
    out = out.concat(".").concat(c_ident(fields.get(i)));
    i = i + 1;
  }
  return out;
}

fn emit_instr_cmp(pool: ir.TyPool, tid: i32, op: ir.CmpKind, oty: i32, a: ir.Value, b: ir.Value) -> Vec[String] {
  let t: ir.Ty = ir.ty_pool_get(pool, oty);
  if t.kind == ir.TyKind.Range || t.kind == ir.TyKind.Verified || t.kind == ir.TyKind.Ref {
    return emit_instr_cmp(pool, tid, op, t.elem, a, b);
  }
  if t.kind == ir.TyKind.String {
    let cmpop: String = c_cmpop(op);
    return vec1("  ".concat(c_temp_name(tid)).concat(" = (strcmp(").concat(c_value(a)).concat(", ").concat(c_value(b)).concat(") ").concat(cmpop).concat(" 0);"));
  }
  if t.kind == ir.TyKind.Enum {
    if op != ir.CmpKind.Eq && op != ir.CmpKind.Ne { panic("unsupported enum comparison"); }
    let cal: String = c_enum_eq_fn_name(ty_qname(t)).concat("(").concat(c_value(a)).concat(", ").concat(c_value(b)).concat(")");
    if op == ir.CmpKind.Eq {
      return vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(cal).concat(";"));
    }
    return vec1("  ".concat(c_temp_name(tid)).concat(" = (!").concat(cal).concat(");"));
  }
  if t.kind == ir.TyKind.Struct {
    if op != ir.CmpKind.Eq && op != ir.CmpKind.Ne { panic("unsupported struct comparison"); }
    let cal: String = c_struct_eq_fn_name(ty_qname(t)).concat("(").concat(c_value(a)).concat(", ").concat(c_value(b)).concat(")");
    if op == ir.CmpKind.Eq {
      return vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(cal).concat(";"));
    }
    return vec1("  ".concat(c_temp_name(tid)).concat(" = (!").concat(cal).concat(");"));
  }
  return vec1("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_value(a)).concat(" ").concat(c_cmpop(op)).concat(" ").concat(c_value(b)).concat(");"));
}

fn emit_instr_int_cast_checked(pool: ir.TyPool, tid: i32, dst_ty: i32, src_ty: i32, v: ir.Value) -> Vec[String] {
  let dst: ir.Ty = ir.ty_pool_get(pool, dst_ty);
  let src: ir.Ty = ir.ty_pool_get(pool, src_ty);

  let src_name: String = match src.kind {
    ir.TyKind.I8 => "i8",
    ir.TyKind.U8 => "u8",
    ir.TyKind.I16 => "i16",
    ir.TyKind.U16 => "u16",
    ir.TyKind.I32 => "i32",
    ir.TyKind.U32 => "u32",
    ir.TyKind.I64 => "i64",
    ir.TyKind.U64 => "u64",
    ir.TyKind.ISize => "isize",
    ir.TyKind.USize => "usize",
    _ => "?",
  };
  let dst_name: String = match dst.kind {
    ir.TyKind.I8 => "i8",
    ir.TyKind.U8 => "u8",
    ir.TyKind.I16 => "i16",
    ir.TyKind.U16 => "u16",
    ir.TyKind.I32 => "i32",
    ir.TyKind.U32 => "u32",
    ir.TyKind.I64 => "i64",
    ir.TyKind.U64 => "u64",
    ir.TyKind.ISize => "isize",
    ir.TyKind.USize => "usize",
    _ => "?",
  };
  let msg: String = src_name.concat(" to ").concat(dst_name).concat(" overflow");

  let dst_max: String =
    match dst.kind {
      ir.TyKind.I8 => "INT8_MAX",
      ir.TyKind.U8 => "UINT8_MAX",
      ir.TyKind.I16 => "INT16_MAX",
      ir.TyKind.U16 => "UINT16_MAX",
      ir.TyKind.I32 => "INT32_MAX",
      ir.TyKind.U32 => "UINT32_MAX",
      ir.TyKind.I64 => "INT64_MAX",
      ir.TyKind.U64 => "UINT64_MAX",
      ir.TyKind.ISize => "INTPTR_MAX",
      ir.TyKind.USize => "UINTPTR_MAX",
      _ => "",
    };
  if dst_max.len() == 0 { panic("int_cast_checked dst must be int"); }
  let dst_min: String =
    match dst.kind {
      ir.TyKind.I8 => "INT8_MIN",
      ir.TyKind.I16 => "INT16_MIN",
      ir.TyKind.I32 => "INT32_MIN",
      ir.TyKind.I64 => "INT64_MIN",
      ir.TyKind.ISize => "INTPTR_MIN",
      _ => "0",
    };

  let dst_is_unsigned: bool = is_unsigned_int_kind(dst.kind);
  let src_is_unsigned: bool = is_unsigned_int_kind(src.kind);
  let src_is_float: bool = src.kind == ir.TyKind.F32 || src.kind == ir.TyKind.F64;

  let mut out: Vec[String] = Vec();
  if !src_is_float && !int_cast_needs_runtime_check(dst.kind, src.kind) {
    out.push("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_type(pool, dst_ty)).concat(")").concat(c_value(v)).concat(";"));
    return out;
  }
  if src_is_float {
    if dst_is_unsigned {
      let line0: String = "  if (!isfinite((double)".concat(c_value(v))
        .concat(") || (double)")
        .concat(c_value(v))
        .concat(" < 0.0 || (long double)")
        .concat(c_value(v))
        .concat(" > (long double)")
        .concat(dst_max)
        .concat(") { vox_host_panic(")
        .concat(c_str_lit(msg))
        .concat("); }");
      out.push(line0);
    } else {
      let line1: String = "  if (!isfinite((double)".concat(c_value(v))
        .concat(") || (long double)")
        .concat(c_value(v))
        .concat(" < (long double)")
        .concat(dst_min)
        .concat(" || (long double)")
        .concat(c_value(v))
        .concat(" > (long double)")
        .concat(dst_max)
        .concat(") { vox_host_panic(")
        .concat(c_str_lit(msg))
        .concat("); }");
      out.push(line1);
    }
  } else {
    if dst_is_unsigned {
      if src_is_unsigned {
        if dst.kind == ir.TyKind.USize && src.kind == ir.TyKind.U64 {
          out.push("  if (".concat(ptr_bits_lt_64_expr()).concat(" && (uint64_t)").concat(c_value(v)).concat(" > (uint64_t)").concat(dst_max).concat(") { vox_host_panic(").concat(c_str_lit(msg)).concat("); }"));
        } else {
          out.push("  if ((uint64_t)".concat(c_value(v)).concat(" > (uint64_t)").concat(dst_max).concat(") { vox_host_panic(").concat(c_str_lit(msg)).concat("); }"));
        }
      } else {
        if int_cast_signed_to_unsigned_needs_upper_check(dst.kind, src.kind) {
          if dst.kind == ir.TyKind.USize && src.kind == ir.TyKind.I64 {
            out.push("  if (".concat(c_value(v)).concat(" < 0 || (").concat(ptr_bits_lt_64_expr()).concat(" && (uint64_t)").concat(c_value(v)).concat(" > (uint64_t)").concat(dst_max).concat(")) { vox_host_panic(").concat(c_str_lit(msg)).concat("); }"));
          } else {
            out.push("  if (".concat(c_value(v)).concat(" < 0 || (uint64_t)").concat(c_value(v)).concat(" > (uint64_t)").concat(dst_max).concat(") { vox_host_panic(").concat(c_str_lit(msg)).concat("); }"));
          }
        } else {
          out.push("  if (".concat(c_value(v)).concat(" < 0) { vox_host_panic(").concat(c_str_lit(msg)).concat("); }"));
        }
      }
    } else {
      if src_is_unsigned {
        out.push("  if ((uint64_t)".concat(c_value(v)).concat(" > (uint64_t)").concat(dst_max).concat(") { vox_host_panic(").concat(c_str_lit(msg)).concat("); }"));
      } else {
        if dst.kind == ir.TyKind.ISize && src.kind == ir.TyKind.I64 {
          let line2p: String = "  if (".concat(ptr_bits_lt_64_expr())
            .concat(" && (((int64_t)")
            .concat(c_value(v))
            .concat(" < (int64_t)")
            .concat(dst_min)
            .concat(") || ((int64_t)")
            .concat(c_value(v))
            .concat(" > (int64_t)")
            .concat(dst_max)
            .concat("))) { vox_host_panic(")
            .concat(c_str_lit(msg))
            .concat("); }");
          out.push(line2p);
        } else {
          let line2: String = "  if (((int64_t)".concat(c_value(v))
            .concat(" < (int64_t)")
            .concat(dst_min)
            .concat(") || ((int64_t)")
            .concat(c_value(v))
            .concat(" > (int64_t)")
            .concat(dst_max)
            .concat(")) { vox_host_panic(")
            .concat(c_str_lit(msg))
            .concat("); }");
          out.push(line2);
        }
      }
    }
  }
  out.push("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_type(pool, dst_ty)).concat(")").concat(c_value(v)).concat(";"));
  return out;
}

fn emit_instr_struct_init(pool: ir.TyPool, tid: i32, ty: i32, fs: Vec[ir.StructInitField]) -> Vec[String] {
  let mut s: String = "  ".concat(c_temp_name(tid)).concat(" = (").concat(c_type(pool, ty)).concat("){");
  let mut i: i32 = 0;
  while i < fs.len() {
    let f: ir.StructInitField = fs.get(i);
    if i != 0 { s = s.concat(", "); }
    s = s.concat(".").concat(c_ident(f.name)).concat(" = ").concat(c_value(f.val));
    i = i + 1;
  }
  s = s.concat("};");
  return vec1(s);
}

fn emit_instr_enum_init(pool: ir.TyPool, p: ir.Program, tid: i32, ty: i32, variant: String, payload: Vec[ir.Value]) -> Vec[String] {
  let en: ir.EnumDecl = find_enum_decl(p, ty_qname(ir.ty_pool_get(pool, ty)));
  let tag: i32 = enum_variant_tag(en, variant);
  let mut s: String = "  ".concat(c_temp_name(tid)).concat(" = (").concat(c_type(pool, ty)).concat("){.tag = ").concat(tag.to_string());
  if enum_has_payload(en) {
    s = s.concat(", .payload.").concat(c_ident(variant)).concat(" = {");
    if payload.len() != 0 {
      let mut pi: i32 = 0;
      while pi < payload.len() {
        if pi != 0 { s = s.concat(", "); }
        s = s.concat("._").concat(pi.to_string()).concat(" = ").concat(c_value(payload.get(pi)));
        pi = pi + 1;
      }
    } else {
      s = s.concat("._ = 0");
    }
    s = s.concat("}");
  }
  s = s.concat("};");
  return vec1(s);
}

fn emit_instr_binop_int(pool: ir.TyPool, tid: i32, op: ir.BinOpKind, ty: i32, a: ir.Value, b: ir.Value) -> Vec[String] {
  let t: ir.Ty = ir.ty_pool_get(pool, ty);
  if !is_int_scalar_kind(t.kind) { panic("binop int helper expects int type"); }
  let dst_cty: String = c_type(pool, ty);

  // + - * and bitwise ops: wrap on integer bit width. Avoid signed overflow UB by operating on unsigned peers.
  let is_mul: bool = match op { ir.BinOpKind.Mul => true, _ => false };
  let is_add: bool = match op { ir.BinOpKind.Add => true, _ => false };
  let is_sub: bool = match op { ir.BinOpKind.Sub => true, _ => false };
  let is_bit: bool = match op { ir.BinOpKind.BitAnd => true, ir.BinOpKind.BitOr => true, ir.BinOpKind.BitXor => true, _ => false };
  if is_add || is_sub || is_mul || is_bit {
    if !is_signed_int_kind(t.kind) {
      // Unsigned arithmetic is well-defined modulo 2^N.
      let u64expr: String = "((uint64_t)".concat(c_value(a)).concat(") ").concat(c_binop(op)).concat(" ((uint64_t)").concat(c_value(b)).concat(")");
      return vec1("  ".concat(c_temp_name(tid)).concat(" = (").concat(dst_cty).concat(")").concat(u64expr).concat(";"));
    }
    let uty: String = unsigned_peer_c_type(t.kind);
    let bitcast_fn: String = signed_from_unsigned_bitcast_fn(t.kind);
    if bitcast_fn == "" { panic("missing signed bitcast helper"); }
    let expr: String = bitcast_fn
      .concat("((").concat(uty).concat(")((((").concat(uty).concat(")").concat(c_value(a)).concat(") ")
      .concat(c_binop(op)).concat(" ((").concat(uty).concat(")").concat(c_value(b)).concat("))))");
    return vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(expr).concat(";"));
  }

  // << >> panics on invalid shift counts; right shift on signed types is arithmetic.
  let is_shl: bool = match op { ir.BinOpKind.Shl => true, _ => false };
  let is_shr: bool = match op { ir.BinOpKind.Shr => true, _ => false };
  if is_shl || is_shr {
    let bits_expr: String = int_bits_expr(t.kind);
    let uty: String = unsigned_peer_c_type(t.kind);
    let bitcast_fn: String = signed_from_unsigned_bitcast_fn(t.kind);
    let mut out3: Vec[String] = Vec();
    out3.push("  {");
    out3.push("    ".concat(uty).concat(" ua = (").concat(uty).concat(")").concat(c_value(a)).concat(";"));
    if is_signed_int_kind(t.kind) {
      out3.push("    int64_t sh = (int64_t)".concat(c_value(b)).concat(";"));
      let lchk: String = "    if (sh < 0 || sh >= (int64_t)".concat(bits_expr).concat(") { vox_host_panic(\"shift count out of range\"); }");
      out3.push(lchk);
      out3.push("    uint64_t n = (uint64_t)sh;");
    } else {
      out3.push("    uint64_t n = (uint64_t)".concat(c_value(b)).concat(";"));
      let lchk2: String = "    if (n >= (uint64_t)".concat(bits_expr).concat(") { vox_host_panic(\"shift count out of range\"); }");
      out3.push(lchk2);
    }
    if is_shl {
      out3.push("    ".concat(uty).concat(" ur = (").concat(uty).concat(")(ua << n);"));
    } else if is_signed_int_kind(t.kind) {
      out3.push("    ".concat(uty).concat(" ur;"));
      out3.push("    if (n == 0) {");
      out3.push("      ur = ua;");
      let lsign: String = "    } else if ((ua & ".concat(int_sign_high_bit_expr(t.kind)).concat(") != 0) {");
      out3.push(lsign);
      out3.push("      ".concat(uty).concat(" m = ~(((").concat(uty).concat(")~(").concat(uty).concat(")0) >> n);"));
      out3.push("      ur = (".concat(uty).concat(")((ua >> n) | m);"));
      out3.push("    } else {");
      out3.push("      ur = (".concat(uty).concat(")(ua >> n);"));
      out3.push("    }");
    } else {
      out3.push("    ".concat(uty).concat(" ur = (").concat(uty).concat(")(ua >> n);"));
    }
    if is_signed_int_kind(t.kind) {
      if bitcast_fn == "" { panic("missing signed bitcast helper"); }
      out3.push("    ".concat(c_temp_name(tid)).concat(" = ").concat(bitcast_fn).concat("(ur);"));
    } else {
      out3.push("    ".concat(c_temp_name(tid)).concat(" = (").concat(dst_cty).concat(")ur;"));
    }
    out3.push("  }");
    return out3;
  }

  // / % panics on division by zero; signed also panics on MIN/-1 overflow.
  let is_div: bool = match op { ir.BinOpKind.Div => true, _ => false };
  let is_mod: bool = match op { ir.BinOpKind.Mod => true, _ => false };
  if is_div || is_mod {
    let mut out2: Vec[String] = Vec();
    out2.push("  if (".concat(c_value(b)).concat(" == (").concat(dst_cty).concat(")0) { vox_host_panic(\"division by zero\"); }"));
    if is_signed_int_kind(t.kind) {
      let minm: String = signed_min_macro(t.kind);
      let maxm: String = signed_max_macro(t.kind);
      if minm.len() == 0 || maxm.len() == 0 { panic("missing signed min/max macro"); }
      out2.push("  if (".concat(c_value(a)).concat(" == ").concat(minm).concat(" && ").concat(c_value(b)).concat(" == (").concat(dst_cty).concat(")-1) { vox_host_panic(\"division overflow\"); }"));
    }
    out2.push("  ".concat(c_temp_name(tid)).concat(" = (").concat(dst_cty).concat(")(").concat(c_value(a)).concat(" ").concat(c_binop(op)).concat(" ").concat(c_value(b)).concat(");"));
    return out2;
  }

  panic("unknown binop");
}

fn emit_instr_vec_new(pool: ir.TyPool, tid: i32, elem: i32) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("  {");
  out.push("    vox_vec_data* h = (vox_vec_data*)malloc(sizeof(vox_vec_data));");
  out.push("    if (!h) { vox_host_panic(\"out of memory\"); }");
  out.push("    h->data = NULL;");
  out.push("    h->cap = 0;");
  out.push("    h->elem_size = (int32_t)sizeof(".concat(c_type(pool, elem)).concat(");"));
  out.push("    ".concat(c_temp_name(tid)).concat(" = (vox_vec){ .h = h, .len = 0 };"));
  out.push("  }");
  return out;
}

fn emit_vec_grow_if_needed(out0: Vec[String], vname: String, need_expr: String) -> Vec[String] {
  let mut out: Vec[String] = out0;
  out.push("    if (".concat(need_expr).concat(" > ").concat(vname).concat("->h->cap) {"));
  out.push("      int32_t nc = ".concat(vname).concat("->h->cap == 0 ? 4 : ").concat(vname).concat("->h->cap;"));
  out.push("      while (nc < ".concat(need_expr).concat(") {"));
  out.push("        if (nc > INT32_MAX / 2) { nc = ".concat(need_expr).concat("; break; }"));
  out.push("        nc = nc * 2;");
  out.push("      }");
  out.push("      size_t bytes = (size_t)nc * (size_t)".concat(vname).concat("->h->elem_size;"));
  out.push("      if (bytes == 0) bytes = 1;");
  out.push("      uint8_t* p = (uint8_t*)realloc(".concat(vname).concat("->h->data, bytes);"));
  out.push("      if (!p) { vox_host_panic(\"out of memory\"); }");
  out.push("      ".concat(vname).concat("->h->data = p;"));
  out.push("      ".concat(vname).concat("->h->cap = nc;"));
  out.push("    }");
  return out;
}

fn emit_instr_vec_push(recv_slot: i32, v: ir.Value) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("  {");
  out.push("    vox_vec* vox_v = &".concat(c_slot_name(recv_slot)).concat(";"));
  out.push("    if (!vox_v || !vox_v->h) { vox_host_panic(\"vec push invalid args\"); }");
  out = emit_vec_grow_if_needed(out, "vox_v", "vox_v->len + 1");
  out.push("    memcpy(vox_v->h->data + (size_t)vox_v->len * (size_t)vox_v->h->elem_size, &".concat(c_value(v)).concat(", (size_t)vox_v->h->elem_size);"));
  out.push("    vox_v->len++;");
  out.push("  }");
  return out;
}

fn emit_instr_vec_insert(recv_slot: i32, idx: ir.Value, v: ir.Value) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("  {");
  out.push("    vox_vec* vox_v = &".concat(c_slot_name(recv_slot)).concat(";"));
  out.push("    if (!vox_v || !vox_v->h) { vox_host_panic(\"vec insert invalid args\"); }");
  out.push("    int32_t vox_idx = (int32_t)".concat(c_value(idx)).concat(";"));
  out.push("    if (vox_idx < 0 || vox_idx > vox_v->len) { vox_host_panic(\"vec insert index out of bounds\"); }");
  out = emit_vec_grow_if_needed(out, "vox_v", "vox_v->len + 1");
  out.push("    uint8_t* vox_ptr = vox_v->h->data + (size_t)vox_idx * (size_t)vox_v->h->elem_size;");
  out.push("    int32_t vox_tail = vox_v->len - vox_idx;");
  out.push("    if (vox_tail > 0) {");
  out.push("      memmove(vox_ptr + (size_t)vox_v->h->elem_size, vox_ptr, (size_t)vox_tail * (size_t)vox_v->h->elem_size);");
  out.push("    }");
  out.push("    memcpy(vox_ptr, &".concat(c_value(v)).concat(", (size_t)vox_v->h->elem_size);"));
  out.push("    vox_v->len++;");
  out.push("  }");
  return out;
}

fn emit_instr_vec_set(recv_slot: i32, idx: ir.Value, v: ir.Value) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("  {");
  out.push("    vox_vec* vox_v = &".concat(c_slot_name(recv_slot)).concat(";"));
  out.push("    if (!vox_v || !vox_v->h) { vox_host_panic(\"vec set invalid args\"); }");
  out.push("    int32_t vox_idx = (int32_t)".concat(c_value(idx)).concat(";"));
  out.push("    if (vox_idx < 0 || vox_idx >= vox_v->len) { vox_host_panic(\"vec set index out of bounds\"); }");
  out.push("    memcpy(vox_v->h->data + (size_t)vox_idx * (size_t)vox_v->h->elem_size, &".concat(c_value(v)).concat(", (size_t)vox_v->h->elem_size);"));
  out.push("  }");
  return out;
}

fn emit_instr_vec_clear(recv_slot: i32) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("  {");
  out.push("    vox_vec* vox_v = &".concat(c_slot_name(recv_slot)).concat(";"));
  out.push("    if (vox_v) { vox_v->len = 0; }");
  out.push("  }");
  return out;
}

fn emit_instr_vec_extend(recv_slot: i32, other_slot: i32) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("  {");
  out.push("    vox_vec* vox_v = &".concat(c_slot_name(recv_slot)).concat(";"));
  out.push("    const vox_vec* vox_other = &".concat(c_slot_name(other_slot)).concat(";"));
  out.push("    if (!vox_v || !vox_v->h || !vox_other || !vox_other->h) {");
  out.push("      /* no-op */");
  out.push("    } else if (vox_other->len > 0) {");
  out.push("      if (vox_v->h->elem_size != vox_other->h->elem_size) { vox_host_panic(\"vec extend elem_size mismatch\"); }");
  out.push("      int64_t vox_need64 = (int64_t)vox_v->len + (int64_t)vox_other->len;");
  out.push("      if (vox_need64 > INT32_MAX) { vox_host_panic(\"vec too large\"); }");
  out.push("      int32_t vox_need = (int32_t)vox_need64;");
  out = emit_vec_grow_if_needed(out, "vox_v", "vox_need");
  out.push("      memcpy(vox_v->h->data + (size_t)vox_v->len * (size_t)vox_v->h->elem_size, vox_other->h->data, (size_t)vox_other->len * (size_t)vox_other->h->elem_size);");
  out.push("      vox_v->len = vox_need;");
  out.push("    }");
  out.push("  }");
  return out;
}

fn emit_instr_vec_pop(tid: i32, recv_slot: i32) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("  {");
  out.push("    vox_vec* vox_v = &".concat(c_slot_name(recv_slot)).concat(";"));
  out.push("    if (!vox_v || !vox_v->h) { vox_host_panic(\"vec pop invalid args\"); }");
  out.push("    if (vox_v->len <= 0) { vox_host_panic(\"vec pop on empty vector\"); }");
  out.push("    int32_t vox_idx = vox_v->len - 1;");
  out.push("    memcpy(&".concat(c_temp_name(tid)).concat(", vox_v->h->data + (size_t)vox_idx * (size_t)vox_v->h->elem_size, (size_t)vox_v->h->elem_size);"));
  out.push("    vox_v->len = vox_idx;");
  out.push("  }");
  return out;
}

fn emit_instr_vec_remove(tid: i32, recv_slot: i32, idx: ir.Value) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("  {");
  out.push("    vox_vec* vox_v = &".concat(c_slot_name(recv_slot)).concat(";"));
  out.push("    if (!vox_v || !vox_v->h) { vox_host_panic(\"vec remove invalid args\"); }");
  out.push("    int32_t vox_idx = (int32_t)".concat(c_value(idx)).concat(";"));
  out.push("    if (vox_idx < 0 || vox_idx >= vox_v->len) { vox_host_panic(\"vec remove index out of bounds\"); }");
  out.push("    uint8_t* vox_ptr = vox_v->h->data + (size_t)vox_idx * (size_t)vox_v->h->elem_size;");
  out.push("    memcpy(&".concat(c_temp_name(tid)).concat(", vox_ptr, (size_t)vox_v->h->elem_size);"));
  out.push("    int32_t vox_tail = vox_v->len - vox_idx - 1;");
  out.push("    if (vox_tail > 0) {");
  out.push("      memmove(vox_ptr, vox_ptr + (size_t)vox_v->h->elem_size, (size_t)vox_tail * (size_t)vox_v->h->elem_size);");
  out.push("    }");
  out.push("    vox_v->len = vox_v->len - 1;");
  out.push("  }");
  return out;
}

fn emit_instr_vec_len(tid: i32, recv_slot: i32) -> Vec[String] {
  return vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_slot_name(recv_slot)).concat(".len;"));
}

fn emit_instr_vec_get(tid: i32, recv_slot: i32, idx: ir.Value) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("  {");
  out.push("    const vox_vec* vox_v = &".concat(c_slot_name(recv_slot)).concat(";"));
  out.push("    if (!vox_v || !vox_v->h) { vox_host_panic(\"vec get invalid args\"); }");
  out.push("    int32_t vox_idx = (int32_t)".concat(c_value(idx)).concat(";"));
  out.push("    if (vox_idx < 0 || vox_idx >= vox_v->len) { vox_host_panic(\"vec index out of bounds\"); }");
  out.push("    memcpy(&".concat(c_temp_name(tid)).concat(", vox_v->h->data + (size_t)vox_idx * (size_t)vox_v->h->elem_size, (size_t)vox_v->h->elem_size);"));
  out.push("  }");
  return out;
}

fn ffi_import_symbol_for_call(p: ir.Program, name: String) -> String {
  let mut i: i32 = 0;
  while i < p.ffi_imports.len() {
    let im: ir.FfiImportDecl = p.ffi_imports.get(i);
    if im.func == name {
      if im.target != "c" && im.target != "wasm" {
        panic("c backend does not support ffi_import target in calls: ".concat(im.target));
      }
      if im.target == "wasm" { return c_ffi_import_name(im.func); }
      return im.symbol;
    }
    i = i + 1;
  }
  return "";
}

fn c_call_name(p: ir.Program, name: String) -> String {
  let sym: String = ffi_import_symbol_for_call(p, name);
  if sym != "" { return sym; }
  return c_fn_name(name);
}

fn emit_instr_call(p: ir.Program, has_dst: bool, tid: i32, ret_ty: i32, name: String, args: Vec[ir.Value]) -> Vec[String] {
  if name == "panic" {
    if args.len() != 1 { panic("panic expects 1 arg"); }
    return vec1("  vox_host_panic(".concat(c_value(args.get(0))).concat(");"));
  }
  let mut s: String = "  ";
  if has_dst && ret_ty != -1 { s = s.concat(c_temp_name(tid)).concat(" = "); }
  s = s.concat(c_call_name(p, name)).concat("(");
  let mut i: i32 = 0;
  while i < args.len() {
    if i != 0 { s = s.concat(", "); }
    s = s.concat(c_value(args.get(i)));
    i = i + 1;
  }
  s = s.concat(");");
  return vec1(s);
}

fn emit_instr(pool: ir.TyPool, p: ir.Program, ins: ir.Instr) -> Vec[String] {
  return match ins {
    ir.Instr.SlotDecl(_sid, _ty) => vec0(),

    ir.Instr.Const(tid, _ty, v) => vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_value(v)).concat(";")),
    ir.Instr.BinOp(tid, op, ty, a, b) => {
      let bt: ir.Ty = ir.ty_pool_get(pool, ty);
      if is_int_scalar_kind(bt.kind) { emit_instr_binop_int(pool, tid, op, ty, a, b) }
      else if op == ir.BinOpKind.Mod && bt.kind == ir.TyKind.F32 {
        vec1("  ".concat(c_temp_name(tid)).concat(" = fmodf(").concat(c_value(a)).concat(", ").concat(c_value(b)).concat(");"))
      } else if op == ir.BinOpKind.Mod && bt.kind == ir.TyKind.F64 {
        vec1("  ".concat(c_temp_name(tid)).concat(" = fmod(").concat(c_value(a)).concat(", ").concat(c_value(b)).concat(");"))
      } else {
        vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_value(a)).concat(" ").concat(c_binop(op)).concat(" ").concat(c_value(b)).concat(";"))
      }
    },
    ir.Instr.Cmp(tid, op, oty, a, b) => emit_instr_cmp(pool, tid, op, oty, a, b),
    ir.Instr.And(tid, a, b) => vec1("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_value(a)).concat(" && ").concat(c_value(b)).concat(");")),
    ir.Instr.Or(tid, a, b) => vec1("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_value(a)).concat(" || ").concat(c_value(b)).concat(");")),
    ir.Instr.Not(tid, a) => vec1("  ".concat(c_temp_name(tid)).concat(" = (!").concat(c_value(a)).concat(");")),

    ir.Instr.IntCast(tid, dst_ty, _src_ty, v) =>
      vec1("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_type(pool, dst_ty)).concat(")").concat(c_value(v)).concat(";")),
    ir.Instr.IntCastChecked(tid, dst_ty, src_ty, v) => emit_instr_int_cast_checked(pool, tid, dst_ty, src_ty, v),
    ir.Instr.FloatCast(tid, dst_ty, _src_ty, v) =>
      vec1("  ".concat(c_temp_name(tid)).concat(" = (").concat(c_type(pool, dst_ty)).concat(")").concat(c_value(v)).concat(";")),
    ir.Instr.RangeCheck(ty, v, lo, hi) => vec1(
      "  if (".concat(c_value(v)).concat(" < (").concat(c_type(pool, ty)).concat(")").concat(lo.to_string())
        .concat(" || ").concat(c_value(v)).concat(" > (").concat(c_type(pool, ty)).concat(")").concat(hi.to_string())
        .concat(") { vox_host_panic(\"range check failed\"); }"),
    ),

    ir.Instr.Store(sid, v) => vec1("  ".concat(c_slot_name(sid)).concat(" = ").concat(c_value(v)).concat(";")),
    ir.Instr.Load(tid, _ty, sid) => vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_slot_name(sid)).concat(";")),
    ir.Instr.GlobalLoad(tid, _ty, name) => vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_static_name(name)).concat(";")),
    ir.Instr.GlobalStore(_ty, name, v) => vec1("  ".concat(c_static_name(name)).concat(" = ").concat(c_value(v)).concat(";")),
    ir.Instr.AddrOfSlot(tid, _ty, sid) => vec1("  ".concat(c_temp_name(tid)).concat(" = &").concat(c_slot_name(sid)).concat(";")),
    ir.Instr.AddrOfFieldChain(tid, _ty, sid, fields) => vec1("  ".concat(c_temp_name(tid)).concat(" = &").concat(c_slot_name(sid)).concat(c_field_chain(fields)).concat(";")),
    ir.Instr.RefLoad(tid, _ty, recv) => vec1("  ".concat(c_temp_name(tid)).concat(" = (*").concat(c_value(recv)).concat(");")),
    ir.Instr.RefStore(_ty, recv, v) => vec1("  (*".concat(c_value(recv)).concat(") = ").concat(c_value(v)).concat(";")),

    ir.Instr.PtrRead(tid, ty, ptr) => vec1("  ".concat(c_temp_name(tid)).concat(" = *(").concat(c_type(pool, ty)).concat("*)").concat(c_value(ptr)).concat(";")),
    ir.Instr.PtrWrite(ty, ptr, v) => vec1("  *((".concat(c_type(pool, ty)).concat("*)").concat(c_value(ptr)).concat(") = ").concat(c_value(v)).concat(";")),
    ir.Instr.PtrOffset(tid, ptr, off) => vec1("  ".concat(c_temp_name(tid)).concat(" = (void*)((char*)").concat(c_value(ptr)).concat(" + ").concat(c_value(off)).concat(");")),

    ir.Instr.StructInit(tid, ty, fs) => emit_instr_struct_init(pool, tid, ty, fs),
    ir.Instr.FieldGet(tid, _ty, recv, field) => vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_value(recv)).concat(".").concat(c_ident(field)).concat(";")),
    ir.Instr.StoreField(sid, field, v) => vec1("  ".concat(c_slot_name(sid)).concat(".").concat(c_ident(field)).concat(" = ").concat(c_value(v)).concat(";")),

    ir.Instr.EnumInit(tid, ty, variant, payload) => emit_instr_enum_init(pool, p, tid, ty, variant, payload),
    ir.Instr.EnumTag(tid, recv) => vec1("  ".concat(c_temp_name(tid)).concat(" = ").concat(c_value(recv)).concat(".tag;")),
    ir.Instr.EnumPayload(tid, _ty, recv, variant, idx) =>
      vec1("  "
        .concat(c_temp_name(tid))
        .concat(" = ")
        .concat(c_value(recv))
        .concat(".payload.")
        .concat(c_ident(variant))
        .concat("._")
        .concat(idx.to_string())
        .concat(";")),

    ir.Instr.VecNew(tid, _vty, elem) => emit_instr_vec_new(pool, tid, elem),
    ir.Instr.VecPush(recv_slot, _elem, v) => emit_instr_vec_push(recv_slot, v),
    ir.Instr.VecInsert(recv_slot, _elem, idx, v) => emit_instr_vec_insert(recv_slot, idx, v),
    ir.Instr.VecSet(recv_slot, _elem, idx, v) => emit_instr_vec_set(recv_slot, idx, v),
    ir.Instr.VecClear(recv_slot) => emit_instr_vec_clear(recv_slot),
    ir.Instr.VecExtend(recv_slot, other_slot) => emit_instr_vec_extend(recv_slot, other_slot),
    ir.Instr.VecPop(tid, _elem, recv_slot) => emit_instr_vec_pop(tid, recv_slot),
    ir.Instr.VecRemove(tid, _elem, recv_slot, idx) => emit_instr_vec_remove(tid, recv_slot, idx),
    ir.Instr.VecLen(tid, recv_slot) => emit_instr_vec_len(tid, recv_slot),
    ir.Instr.VecGet(tid, _elem, recv_slot, idx) => emit_instr_vec_get(tid, recv_slot, idx),

    ir.Instr.AtomicNew(tid, elem_ty, val) => emit_instr_atomic_new(pool, tid, elem_ty, val),
    ir.Instr.AtomicLoad(tid, elem_ty, h) => vec1("  ".concat(c_temp_name(tid)).concat(" = atomic_load_explicit((").concat(c_atomic_c_type(pool, elem_ty)).concat("*)").concat(c_value(h)).concat(", memory_order_seq_cst);")),
    ir.Instr.AtomicStore(elem_ty, h, val) => vec1("  atomic_store_explicit((".concat(c_atomic_c_type(pool, elem_ty)).concat("*)").concat(c_value(h)).concat(", ").concat(c_value(val)).concat(", memory_order_seq_cst);")),
    ir.Instr.AtomicFetchAdd(tid, elem_ty, h, delta) => vec1("  ".concat(c_temp_name(tid)).concat(" = atomic_fetch_add_explicit((").concat(c_atomic_c_type(pool, elem_ty)).concat("*)").concat(c_value(h)).concat(", ").concat(c_value(delta)).concat(", memory_order_seq_cst);")),
    ir.Instr.AtomicSwap(tid, elem_ty, h, val) => vec1("  ".concat(c_temp_name(tid)).concat(" = atomic_exchange_explicit((").concat(c_atomic_c_type(pool, elem_ty)).concat("*)").concat(c_value(h)).concat(", ").concat(c_value(val)).concat(", memory_order_seq_cst);")),
    ir.Instr.AtomicCAS(tid, elem_ty, h, expected, desired) => emit_instr_atomic_cas(pool, tid, elem_ty, h, expected, desired),
    ir.Instr.AtomicDrop(_elem_ty, h) => vec1("  free((void*)".concat(c_value(h)).concat(");")),

    ir.Instr.Call(has_dst, tid, ret_ty, name, args) => emit_instr_call(p, has_dst, tid, ret_ty, name, args),
  };
}

fn emit_term_ret(has: bool, v: ir.Value) -> Vec[String] {
  if has { return vec1("  return ".concat(c_value(v)).concat(";")); }
  return vec1("  return;");
}

fn emit_term(t: ir.Term) -> Vec[String] {
  return match t {
    ir.Term.Ret(has, v) => emit_term_ret(has, v),
    ir.Term.Br(target) => vec1("  goto ".concat(c_label_name(target)).concat(";")),
    ir.Term.CondBr(cond, t, e) => vec1("  if (".concat(c_value(cond)).concat(") goto ").concat(c_label_name(t)).concat("; else goto ").concat(c_label_name(e)).concat(";")),
    ir.Term.Panic(msg) => vec1("  vox_host_panic(".concat(c_value(msg)).concat(");")),
  };
}

fn block_is_jump_target(blocks: Vec[ir.Block], name: String) -> bool {
  let mut i: i32 = 0;
  while i < blocks.len() {
    let b: ir.Block = blocks.get(i);
    if b.has_term {
      let hit: bool =
        match b.term {
          ir.Term.Br(target) => target == name,
          ir.Term.CondBr(_cond, t, e) => t == name || e == name,
          _ => false,
        };
      if hit {
        return true;
      }
    }
    i = i + 1;
  }
  return false;
}

fn find_enum_decl(p: ir.Program, name: String) -> ir.EnumDecl {
  let mut i: i32 = 0;
  while i < p.enums.len() {
    let en: ir.EnumDecl = p.enums.get(i);
    if en.name == name { return en; }
    i = i + 1;
  }
  panic("unknown enum in codegen");
  return ir.EnumDecl { name: "", variants: Vec() };
}

fn enum_variant_tag(en: ir.EnumDecl, variant: String) -> i32 {
  let mut i: i32 = 0;
  while i < en.variants.len() {
    if en.variants.get(i).name == variant { return i; }
    i = i + 1;
  }
  panic("unknown enum variant in codegen");
  return -1;
}

pub fn emit_func(pool: ir.TyPool, p: ir.Program, f: ir.Func) -> Vec[String] {
  let all_locals: LocalsResult = collect_locals_all(pool, f);
  let seed_slots: Vec[bool] = collect_live_slots_all_reads(f, all_locals.max_slot);
  let live_temps0: Vec[bool] = collect_live_temps(pool, f, all_locals.max_temp, seed_slots);
  let live_slots: Vec[bool] = collect_live_slots_filtered(pool, f, all_locals.max_slot, live_temps0, seed_slots);
  let live_temps: Vec[bool] = collect_live_temps(pool, f, all_locals.max_temp, live_slots);
  let locals: LocalsResult = collect_locals(pool, f, live_temps, live_slots);
  let mut out: Vec[String] = Vec();

  // Signature
  let is_main: bool = f.name == "main";
  let mut sig: String = "static ".concat(c_ret_type(pool, f.ret)).concat(" ").concat(c_fn_name(f.name)).concat("(");
  if is_main {
    sig = sig.concat("int32_t vox_p_argc, intptr_t vox_p_argv");
    if f.params.len() != 0 { sig = sig.concat(", "); }
  }
  let mut i: i32 = 0;
  while i < f.params.len() {
    if i != 0 { sig = sig.concat(", "); }
    let pa: ir.Param = f.params.get(i);
    sig = sig.concat(c_type(pool, pa.ty)).concat(" ").concat(c_param_name(i));
    i = i + 1;
  }
  sig = sig.concat(") {");
  out.push(sig);

  // Slots
  let mut sid: i32 = 0;
  while sid <= locals.max_slot {
    let ty: String = idty_get(locals.slots, sid);
    if ty != "" { out.push("  ".concat(ty).concat(" ").concat(c_slot_name(sid)).concat(";")); }
    sid = sid + 1;
  }

  // Temps
  let mut tid: i32 = 0;
  while tid <= locals.max_temp {
    let ty: String = idty_get(locals.temps, tid);
    if ty != "" { out.push("  ".concat(ty).concat(" ").concat(c_temp_name(tid)).concat(";")); }
    tid = tid + 1;
  }
  if locals.max_slot != -1 || locals.max_temp != -1 { out.push(""); }

  // Blocks
  let mut bi: i32 = 0;
  while bi < f.blocks.len() {
    let b: ir.Block = f.blocks.get(bi);
    // Emit labels only for real jump targets.
    let emit_label: bool = block_is_jump_target(f.blocks, b.name);
    if emit_label { out.push(c_label_name(b.name).concat(":")); }
    let mut ii: i32 = 0;
    while ii < b.instrs.len() {
      let ins: ir.Instr = b.instrs.get(ii);
      if !instr_is_dead_temp(pool, ins, live_temps) && !instr_is_dead_slot_instr(ins, live_slots) {
        let lines: Vec[String] = emit_instr(pool, p, ins);
        let mut li: i32 = 0;
        while li < lines.len() { out.push(lines.get(li)); li = li + 1; }
      }
      ii = ii + 1;
    }
    if !b.has_term { panic("block missing terminator"); }
    let term_lines: Vec[String] = emit_term(b.term);
    let mut ti: i32 = 0;
    while ti < term_lines.len() { out.push(term_lines.get(ti)); ti = ti + 1; }
    out.push("");
    bi = bi + 1;
  }

  out.push("}");
  return out;
}
