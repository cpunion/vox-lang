import "std/testing" as t
import "vox/parse" as p
import "vox/typecheck" as tc
import "vox/irgen" as irgen
import "vox/codegen" as cg

fn contains(hay: String, needle: String) -> bool {
  if needle.len() == 0 { return true; }
  if hay.len() < needle.len() { return false; }
  let mut i: i32 = 0;
  while i <= hay.len() - needle.len() {
    if hay.slice(i, i + needle.len()) == needle { return true; }
    i = i + 1;
  }
  return false;
}

fn add_string_prelude(w0: tc.World) -> tc.World {
  let prelude_r: p.ParseResult = p.parse_text("impl String { fn len(s: String) -> i32 { return 0; } fn is_empty(s: String) -> bool { return true; } fn byte_at(s: String, idx: i32) -> i32 { return 0; } fn slice(s: String, start: i32, end: i32) -> String { return \"\"; } fn concat(s: String, other: String) -> String { return \"\"; } fn starts_with(s: String, pre: String) -> bool { return false; } fn ends_with(s: String, suf: String) -> bool { return false; } fn contains(s: String, needle: String) -> bool { return false; } fn index_of(s: String, needle: String) -> i32 { return 0; } fn last_index_of(s: String, needle: String) -> i32 { return 0; } fn escape_c(s: String) -> String { return \"\"; } fn to_string(s: String) -> String { return s; } }\nimpl bool { fn to_string(v: bool) -> String { return \"\"; } }\nimpl i8 { fn to_string(v: i8) -> String { return \"\"; } }\nimpl u8 { fn to_string(v: u8) -> String { return \"\"; } }\nimpl i16 { fn to_string(v: i16) -> String { return \"\"; } }\nimpl u16 { fn to_string(v: u16) -> String { return \"\"; } }\nimpl i32 { fn to_string(v: i32) -> String { return \"\"; } }\nimpl u32 { fn to_string(v: u32) -> String { return \"\"; } }\nimpl i64 { fn to_string(v: i64) -> String { return \"\"; } }\nimpl u64 { fn to_string(v: u64) -> String { return \"\"; } }\nimpl isize { fn to_string(v: isize) -> String { return \"\"; } }\nimpl usize { fn to_string(v: usize) -> String { return \"\"; } }\nimpl f32 { fn to_string(v: f32) -> String { return \"\"; } }\nimpl f64 { fn to_string(v: f64) -> String { return \"\"; } }");
  t.assert(prelude_r.err == p.ParseError.None);
  return tc.world_add(w0, "std/prelude", prelude_r.prog);
}

fn compile_to_c(src: String) -> String {
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  let prelude_r: p.ParseResult = p.parse_text("""
    @ffi_import("c", "puts")
    fn c_puts(msg: String) -> i32;
    pub fn print(msg: String) -> () { c_puts(msg); return; }
    impl String {
      fn len(s: String) -> i32 { return 0; }
      fn is_empty(s: String) -> bool { return true; }
      fn byte_at(s: String, idx: i32) -> i32 { return 0; }
      fn slice(s: String, start: i32, end: i32) -> String { return ""; }
      fn concat(s: String, other: String) -> String { return ""; }
      fn starts_with(s: String, pre: String) -> bool { return false; }
      fn ends_with(s: String, suf: String) -> bool { return false; }
      fn contains(s: String, needle: String) -> bool { return false; }
      fn index_of(s: String, needle: String) -> i32 { return 0; }
      fn last_index_of(s: String, needle: String) -> i32 { return 0; }
      fn escape_c(s: String) -> String { return ""; }
      fn to_string(s: String) -> String { return s; }
    }
    impl bool { fn to_string(v: bool) -> String { return ""; } }
    impl i8 { fn to_string(v: i8) -> String { return ""; } }
    impl u8 { fn to_string(v: u8) -> String { return ""; } }
    impl i16 { fn to_string(v: i16) -> String { return ""; } }
    impl u16 { fn to_string(v: u16) -> String { return ""; } }
    impl i32 { fn to_string(v: i32) -> String { return ""; } }
    impl u32 { fn to_string(v: u32) -> String { return ""; } }
    impl i64 { fn to_string(v: i64) -> String { return ""; } }
    impl u64 { fn to_string(v: u64) -> String { return ""; } }
    impl isize { fn to_string(v: isize) -> String { return ""; } }
    impl usize { fn to_string(v: usize) -> String { return ""; } }
    impl f32 { fn to_string(v: f32) -> String { return ""; } }
    impl f64 { fn to_string(v: f64) -> String { return ""; } }
  """);
  t.assert(prelude_r.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "std/prelude", prelude_r.prog);
  w = tc.world_add(w, "main", r.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert_with(gr.ok, gr.err);
  return cg.emit_c(gr.prog, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
}

fn test_codegen_smoke_main_i32() -> () {
  let c: String = compile_to_c("fn main() -> i32 { return 0; }");
  t.assert(contains(c, "int main(int argc, char** argv) {"));
  t.assert(contains(c, "int32_t v = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
}

fn test_codegen_smoke_main_i8() -> () {
  let c: String = compile_to_c("fn main() -> i8 { return -5; }");
  t.assert(contains(c, "int main(int argc, char** argv) {"));
  t.assert(contains(c, "int8_t v = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
}

fn test_codegen_smoke_main_u32() -> () {
  let c: String = compile_to_c("fn main() -> u32 { return 5; }");
  t.assert(contains(c, "int main(int argc, char** argv) {"));
  t.assert(contains(c, "uint32_t v = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
  t.assert(contains(c, "PRIu32"));
}

fn test_codegen_smoke_main_u64() -> () {
  let c: String = compile_to_c("fn main() -> u64 { return 5; }");
  t.assert(contains(c, "int main(int argc, char** argv) {"));
  t.assert(contains(c, "uint64_t v = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
  t.assert(contains(c, "PRIu64"));
}

fn test_codegen_smoke_main_f32() -> () {
  let c: String = compile_to_c("fn main() -> f32 { return 1.5; }");
  t.assert(contains(c, "int main(int argc, char** argv) {"));
  t.assert(contains(c, "float v = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
  t.assert(contains(c, "printf(\"%.9g\\n\", (double)v);"));
}

fn test_codegen_smoke_main_f64() -> () {
  let c: String = compile_to_c("fn main() -> f64 { return 1.5; }");
  t.assert(contains(c, "int main(int argc, char** argv) {"));
  t.assert(contains(c, "double v = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
  t.assert(contains(c, "printf(\"%.17g\\n\", v);"));
}

fn test_codegen_smoke_main_isize() -> () {
  let c: String = compile_to_c("fn main() -> isize { return -5; }");
  t.assert(contains(c, "int main(int argc, char** argv) {"));
  t.assert(contains(c, "intptr_t v = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
  t.assert(contains(c, "PRIdPTR"));
}

fn test_codegen_smoke_main_usize() -> () {
  let c: String = compile_to_c("fn main() -> usize { return 5; }");
  t.assert(contains(c, "int main(int argc, char** argv) {"));
  t.assert(contains(c, "uintptr_t v = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
  t.assert(contains(c, "PRIuPTR"));
}

fn test_codegen_prelude_print_ffi() -> () {
  let c: String = compile_to_c("fn main() -> i32 { print(\"hi\"); return 0; }");
  t.assert(contains(c, "puts("));
}

fn test_codegen_intrinsic_abi_helpers_smoke() -> () {
  let src: String = """
    fn f() -> bool { return true; }
  """;
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "std/runtime", r.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert_with(gr.ok, gr.err);
  let c: String = cg.emit_c(gr.prog, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert(!contains(c, "vox_host_intrinsic_abi"));
  t.assert(!contains(c, "vox_host_has_intrinsic"));
}

fn test_codegen_runtime_core_emits_headers() -> () {
  let c: String = compile_to_c("fn main() -> i32 { return 0; }");
  t.assert(contains(c, "#include <stdio.h>"));
  t.assert(contains(c, "#include <stdatomic.h>"));
  t.assert(contains(c, "extern void* malloc(size_t);"));
}

fn test_codegen_yield_now_intrinsic_uses_sys_ffi() -> () {
  let src: String = """
    @ffi_import("c", "sched_yield")
    fn rt_yield_now_raw() -> i32;
    fn f() -> () { let _rc: i32 = rt_yield_now_raw(); _rc; return; }
  """;
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = tc.world_add(w, "std/time", r.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert_with(gr.ok, gr.err);
  let c: String = cg.emit_c(gr.prog, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  t.assert(contains(c, "extern int32_t sched_yield("));
  t.assert(contains(c, "sched_yield();"));
  t.assert(!contains(c, "vox_impl_yield_now("));
}

fn test_codegen_event_loop_uses_runtime_helpers() -> () {
  let src: String = """
    @ffi_import("c", "vox_impl_el_init")
    fn el_init() -> ();
    @ffi_import("c", "vox_impl_el_poller_wake")
    fn el_wake() -> ();
    @ffi_import("c", "vox_impl_el_poller_wait")
    fn el_wait(timeout_ms: i32) -> ();
    fn f() -> () {
      el_init();
      el_wake();
      el_wait(100);
      return;
    }
  """;
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = add_string_prelude(w);
  w = tc.world_add(w, "std/async", r.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert_with(gr.ok, gr.err);
  let c: String = cg.emit_c(gr.prog, cg.EmitOptions {
    emit_driver_main: false,
    driver_main_kind: cg.DriverMainKind.User,
    emit_test_main: false,
    test_funcs: Vec(),
    c_sources: Vec(),
  });
  // Event loop infrastructure must be present in generated C.
  t.assert(contains(c, "#define VOX_EL_SLOTS 256"));
  t.assert(contains(c, "static intptr_t vox_el_token_h[VOX_EL_SLOTS];"));
  t.assert(contains(c, "static intptr_t vox_el_pending_h[VOX_EL_SLOTS];"));
  t.assert(contains(c, "void vox_impl_el_init(void) {"));
  t.assert(contains(c, "void vox_impl_el_poller_wake(void) {"));
  t.assert(contains(c, "void vox_impl_el_poller_wait(int32_t timeout_ms) {"));
  t.assert(contains(c, "int32_t vox_impl_el_n_slots(void)"));
  t.assert(contains(c, "intptr_t vox_impl_el_token_handle(int32_t i)"));
  t.assert(contains(c, "intptr_t vox_impl_el_pending_handle(int32_t i)"));
  // Old wake infrastructure must not be present.
  t.assert(!contains(c, "vox_wake_slots["));
  t.assert(!contains(c, "vox_impl_wake_notify("));
  t.assert(!contains(c, "vox_impl_wake_wait("));
  // Platform init branches in event loop.
  t.assert(contains(c, "#if defined(__linux__)"));
  t.assert(contains(c, "eventfd(0, VOX_EFD_NONBLOCK | VOX_EFD_CLOEXEC)"));
  t.assert(contains(c, "vox_kev_set(ev, 1, VOX_EVFILT_USER,"));
  t.assert(contains(c, "vox_impl_el_init("));
  t.assert(contains(c, "vox_impl_el_poller_wake("));
  t.assert(contains(c, "vox_impl_el_poller_wait("));
}

fn test_codegen_sync_drop_intrinsics_use_runtime_helpers() -> () {
  let src: String = """
    @ffi_import("c", "vox_impl_atomic_i32_new")
    fn rt_atomic_i32_new(v: i32) -> isize;
    @ffi_import("c", "vox_impl_atomic_i32_load")
    fn rt_atomic_i32_load(h: isize) -> i32;
    @ffi_import("c", "vox_impl_atomic_i32_store")
    fn rt_atomic_i32_store(h: isize, v: i32) -> ();
    @ffi_import("c", "vox_impl_atomic_i32_drop")
    fn rt_atomic_i32_drop(h: isize) -> ();
    @ffi_import("c", "vox_impl_atomic_i64_new")
    fn rt_atomic_i64_new(v: i64) -> isize;
    @ffi_import("c", "vox_impl_atomic_i64_load")
    fn rt_atomic_i64_load(h: isize) -> i64;
    @ffi_import("c", "vox_impl_atomic_i64_store")
    fn rt_atomic_i64_store(h: isize, v: i64) -> ();
    @ffi_import("c", "vox_impl_atomic_i64_drop")
    fn rt_atomic_i64_drop(h: isize) -> ();
    fn main() -> i32 {
      let m: isize = rt_atomic_i32_new(1);
      let v: i32 = rt_atomic_i32_load(m);
      rt_atomic_i32_store(m, v + 1);
      rt_atomic_i32_drop(m);
      rt_atomic_i32_drop(m);
      let a: isize = rt_atomic_i64_new(2 as i64);
      let x: i64 = rt_atomic_i64_load(a);
      rt_atomic_i64_store(a, x + (1 as i64));
      rt_atomic_i64_drop(a);
      rt_atomic_i64_drop(a);
      return 0;
    }
  """;
  let r: p.ParseResult = p.parse_text(src);
  t.assert(r.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = add_string_prelude(w);
  w = tc.world_add(w, "std/sync", r.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert_with(gr.ok, gr.err);
  t.assert(gr.ok);
  let c: String = cg.emit_c(gr.prog, cg.EmitOptions { emit_driver_main: false, driver_main_kind: cg.DriverMainKind.User, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(contains(c, "static void vox_sync_handle_add(intptr_t h)"));
  t.assert(contains(c, "static bool vox_sync_handle_live(intptr_t h)"));
  t.assert(contains(c, "static bool vox_sync_handle_remove(intptr_t h)"));
  t.assert(contains(c, "vox_sync_handle_node* n = (vox_sync_handle_node*)malloc(sizeof(vox_sync_handle_node));"));
  t.assert(contains(c, "free(n);"));
  t.assert(contains(c, "if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }"));
  t.assert(contains(c, "if (!vox_sync_handle_remove(h)) return;"));
  t.assert(contains(c, "vox_impl_atomic_i32_drop("));
  t.assert(contains(c, "vox_impl_atomic_i64_drop("));
}

fn test_codegen_vec_is_empty_uses_runtime_len() -> () {
  let src: String = """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      if v.is_empty() { v.push(1); }
      return if !v.is_empty() && v.len() == 1 { 1 } else { 0 };
    }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "vox_v->len++;"));
  t.assert(contains(c, ".len;"));
}

fn test_codegen_vec_clear_is_inlined() -> () {
  let src: String = """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.clear();
      return v.len();
    }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "vox_v->len = 0;"));
}

fn test_codegen_vec_extend_is_inlined() -> () {
  let src: String = """
    fn main() -> i32 {
      let mut a: Vec[i32] = Vec();
      a.push(1);
      let mut b: Vec[i32] = Vec();
      b.push(2);
      a.extend(b);
      return a.len();
    }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "vec extend elem_size mismatch"));
}

fn test_codegen_vec_pop_is_inlined() -> () {
  let src: String = """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      let x: i32 = v.pop();
      return x;
    }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "vec pop on empty vector"));
}

fn test_codegen_vec_remove_is_inlined() -> () {
  let src: String = """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.push(2);
      let x: i32 = v.remove(0);
      return x + v.len();
    }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "vec remove index out of bounds"));
}

fn test_codegen_vec_insert_is_inlined() -> () {
  let src: String = """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.insert(0, 9);
      return v.get(0);
    }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "vec insert index out of bounds"));
}

fn test_codegen_vec_set_is_inlined() -> () {
  let src: String = """
    fn main() -> i32 {
      let mut v: Vec[i32] = Vec();
      v.push(1);
      v.set(0, 9);
      return v.get(0);
    }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "vec set index out of bounds"));
}

fn test_codegen_vec_runtime_uses_shared_storage_realloc() -> () {
  let c: String = compile_to_c("fn main() -> i32 { let mut v: Vec[i32] = Vec(); v.push(1); return v.len(); }");
  t.assert(contains(c, "typedef struct { uint8_t* data; int32_t cap; int32_t elem_size; } vox_vec_data;"));
  t.assert(contains(c, "typedef struct { vox_vec_data* h; int32_t len; } vox_vec;"));
  t.assert(contains(c, "realloc(v->h->data"));
}

fn test_codegen_runtime_has_simplified_allocator() -> () {
  let c: String = compile_to_c("fn main() -> i32 { let a: String = \"a\"; let b: String = a.concat(\"b\"); return b.len(); }");
  // Allocator surface uses libc directly.
  t.assert(contains(c, "extern void* malloc(size_t);"));
  t.assert(contains(c, "extern void* realloc(void*, size_t);"));
  t.assert(contains(c, "extern void free(void*);"));
  t.assert(!contains(c, "static void* vox_impl_malloc("));
  t.assert(!contains(c, "static void* vox_impl_realloc("));
  t.assert(!contains(c, "static void vox_impl_free("));
  // Tracking code must be absent.
  t.assert(!contains(c, "vox_alloc_node"));
  t.assert(!contains(c, "atexit("));
  t.assert(!contains(c, "vox_impl_forget"));
  t.assert(!contains(c, "vox_impl_cleanup"));
}

fn test_codegen_enum_payload_equality_uses_helper() -> () {
  let src: String = "enum E { A(i32), B(String) }\nfn main() -> i32 { let a: E = E.B(\"x\"); let b: E = E.B(\"x\"); return if a == b { 1 } else { 0 }; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "vox_enum_eq_"));
  t.assert(contains(c, "strcmp("));
}

fn test_codegen_struct_equality_uses_helper() -> () {
  let src: String = "struct S { a: i32, b: String }\nfn main() -> i32 { let x: S = S { a: 1, b: \"x\" }; let y: S = S { a: 1, b: \"x\" }; return if x == y { 1 } else { 0 }; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "vox_struct_eq_"));
  t.assert(contains(c, "strcmp("));
}

fn test_codegen_tool_driver_main_i32_exits() -> () {
  let pr: p.ParseResult = p.parse_text("fn main() -> i32 { return 7; }");
  t.assert(pr.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = add_string_prelude(w);
  w = tc.world_add(w, "main", pr.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert(gr.ok);
  let c: String = cg.emit_c(gr.prog, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.Tool, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(contains(c, "int32_t rc = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
  t.assert(contains(c, "return (int)rc;"));
}

fn test_codegen_tool_driver_main_u32_exits() -> () {
  let pr: p.ParseResult = p.parse_text("fn main() -> u32 { return 7; }");
  t.assert(pr.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = add_string_prelude(w);
  w = tc.world_add(w, "main", pr.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert(gr.ok);
  let c: String = cg.emit_c(gr.prog, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.Tool, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(contains(c, "uint32_t rc = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
  t.assert(contains(c, "return (int)rc;"));
}

fn test_codegen_tool_driver_main_isize_exits() -> () {
  let pr: p.ParseResult = p.parse_text("fn main() -> isize { return 7; }");
  t.assert(pr.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = add_string_prelude(w);
  w = tc.world_add(w, "main", pr.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert(gr.ok);
  let c: String = cg.emit_c(gr.prog, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.Tool, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(contains(c, "intptr_t rc = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
  t.assert(contains(c, "return (int)rc;"));
}

fn test_codegen_tool_driver_main_f64_exits() -> () {
  let pr: p.ParseResult = p.parse_text("fn main() -> f64 { return 7.0; }");
  t.assert(pr.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = add_string_prelude(w);
  w = tc.world_add(w, "main", pr.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert(gr.ok);
  let c: String = cg.emit_c(gr.prog, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.Tool, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(contains(c, "double rc = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
  t.assert(contains(c, "return (int)rc;"));
}

fn test_codegen_tool_driver_main_bool_exits() -> () {
  let pr: p.ParseResult = p.parse_text("fn main() -> bool { return true; }");
  t.assert(pr.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = add_string_prelude(w);
  w = tc.world_add(w, "main", pr.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert(gr.ok);
  let c: String = cg.emit_c(gr.prog, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.Tool, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(contains(c, "bool rc = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
  t.assert(contains(c, "return rc ? 0 : 1;"));
}

fn test_codegen_tool_driver_main_string_exits() -> () {
  let pr: p.ParseResult = p.parse_text("fn main() -> String { return \"ok\"; }");
  t.assert(pr.err == p.ParseError.None);
  let mut w: tc.World = tc.world();
  w = add_string_prelude(w);
  w = tc.world_add(w, "main", pr.prog);
  let gr: irgen.GenResult = irgen.generate_world(w);
  t.assert(gr.ok);
  let c: String = cg.emit_c(gr.prog, cg.EmitOptions { emit_driver_main: true, driver_main_kind: cg.DriverMainKind.Tool, emit_test_main: false, test_funcs: Vec(), c_sources: Vec() });
  t.assert(contains(c, "const char* rc = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
  t.assert(contains(c, "printf(\"%s\\n\", rc ? rc : \"\");"));
  t.assert(contains(c, "return 0;"));
}

fn test_codegen_i64_to_i32_checked_cast_emits_bounds_check() -> () {
  let c: String = compile_to_c("fn main() -> i32 { let x: i64 = 1; return x as i32; }");
  t.assert(contains(c, "INT32_MIN"));
  t.assert(contains(c, "INT32_MAX"));
  t.assert(contains(c, "i64 to i32 overflow"));
}

fn test_codegen_i32_to_i64_cast_skips_bounds_check() -> () {
  let c: String = compile_to_c("fn main(x: i32) -> i64 { return x as i64; }");
  t.assert(!contains(c, "i32 to i64 overflow"));
}

fn test_codegen_range_cast_emits_bounds_check() -> () {
  let src: String = "type Tiny = @range(0..=3) i32\nfn main() -> i32 { let x: i32 = 1; let y: Tiny = x as Tiny; return y as i32; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "range check failed"));
  t.assert(contains(c, "(int32_t)0"));
  t.assert(contains(c, "(int32_t)3"));
}

fn test_codegen_range_cast_emits_bounds_check_i8() -> () {
  let src: String = "type Tiny = @range(0..=3) i8\nfn main() -> i8 { let x: i8 = 1; let y: Tiny = x as Tiny; return y as i8; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "range check failed"));
  t.assert(contains(c, "(int8_t)0"));
  t.assert(contains(c, "(int8_t)3"));
}

fn test_codegen_range_cast_emits_bounds_check_u32() -> () {
  let src: String = "type Tiny = @range(0..=3) u32\nfn main() -> u32 { let x: u32 = 1; let y: Tiny = x as Tiny; return y as u32; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "range check failed"));
  t.assert(contains(c, "(uint32_t)0"));
  t.assert(contains(c, "(uint32_t)3"));
}

fn test_codegen_range_cast_emits_bounds_check_u8() -> () {
  let src: String = "type Tiny = @range(0..=3) u8\nfn main() -> u8 { let x: u8 = 1; let y: Tiny = x as Tiny; return y as u8; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "range check failed"));
  t.assert(contains(c, "(uint8_t)0"));
  t.assert(contains(c, "(uint8_t)3"));
}

fn test_codegen_range_cast_emits_bounds_check_u64() -> () {
  let src: String = "type Tiny = @range(0..=3) u64\nfn main() -> u64 { let x: u64 = 1; let y: Tiny = x as Tiny; return y as u64; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "range check failed"));
  t.assert(contains(c, "(uint64_t)0"));
  t.assert(contains(c, "(uint64_t)3"));
}

fn test_codegen_range_cast_emits_bounds_check_char_literal_bounds() -> () {
  let src: String = "type Lower = @range('a'..='z') char\nfn main() -> u32 { let x: char = 'm'; let y: Lower = x as Lower; return y as u32; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "range check failed"));
  t.assert(contains(c, "(uint32_t)97"));
  t.assert(contains(c, "(uint32_t)122"));
}

fn test_codegen_range_cast_emits_bounds_check_usize() -> () {
  // Transitional check: usize remains pointer-width in emitted C type mapping.
  let c: String = compile_to_c("fn main() -> usize { return 1; }");
  t.assert(contains(c, "uintptr_t v = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
}

fn test_codegen_int_cast_checked_uses_ptr_bounds_for_isize_usize() -> () {
  let src: String = """
    fn main() -> i32 {
      let a: i64 = 7;
      let b: isize = a as isize;
      let c: usize = b as usize;
      return c as i32;
    }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "INTPTR_MAX"));
  t.assert(contains(c, "INTPTR_MIN"));
  t.assert(contains(c, "UINTPTR_MAX"));
}

fn test_codegen_int_div_emits_div0_check() -> () {
  let c: String = compile_to_c("fn main() -> i32 { let a: i32 = 1; let b: i32 = 0; return a / b; }");
  t.assert(contains(c, "division by zero"));
}

fn test_codegen_int_mod_emits_div0_check_unsigned() -> () {
  let src: String = "fn main() -> i32 { let a: u32 = 1; let b: u32 = 0; let c: u32 = a % b; return c as i32; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "division by zero"));
}

fn test_codegen_int_add_avoids_signed_overflow_ub() -> () {
  let c: String = compile_to_c("fn main() -> i32 { let a: i32 = 1; let b: i32 = 2; return a + b; }");
  // Signed overflow is UB in C; backend must not rely on it.
  t.assert(contains(c, "memcpy(&"));
}

fn test_codegen_bit_ops_and_shift_checks() -> () {
  let src: String = "fn main() -> i32 {\n  let a: i32 = 6 & 3;\n  let b: i32 = 1 << 4;\n  let c: i32 = b >> 2;\n  let _d: i32 = 1 << 32;\n  return (a | c) ^ 1;\n}";
  let c: String = compile_to_c(src);
  t.assert(contains(c, " & "));
  t.assert(contains(c, " | "));
  t.assert(contains(c, " ^ "));
  t.assert(contains(c, "<<"));
  t.assert(contains(c, ">>"));
  t.assert(contains(c, "shift count out of range"));
}

fn test_codegen_runtime_allocator_surface_smoke() -> () {
  let c: String = compile_to_c("fn main() -> i32 { return 0; }");
  t.assert(contains(c, "extern void* realloc(void*, size_t);"));
  t.assert(contains(c, "extern void* malloc(size_t);"));
  t.assert(contains(c, "extern void free(void*);"));
}

fn test_codegen_ref_str_cmp_uses_strcmp() -> () {
  let src: String = "fn eq(a: &str, b: &str) -> bool { return a == b; }\nfn main() -> i32 { return if eq(\"x\", \"x\") { 1 } else { 0 }; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "strcmp("));
}

fn test_codegen_driver_main_ref_static_str_return_smoke() -> () {
  let c: String = compile_to_c("fn main() -> &'static str { return \"vox\"; }");
  t.assert(contains(c, "const char* v = vox_fn_mmain((int32_t)argc, (intptr_t)argv);"));
}
