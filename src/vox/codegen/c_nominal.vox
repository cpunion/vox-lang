import "vox/ir" as ir

struct NomInfo { name: String, kind: i32 } // 0=struct, 1=enum

fn ty_idx_has_param(pool: ir.TyPool, ty: i32) -> bool {
  let t: ir.Ty = ir.ty_pool_get(pool, ty);
  if t.kind == ir.TyKind.Param { return true; }
  if t.kind == ir.TyKind.Vec || t.kind == ir.TyKind.Range || t.kind == ir.TyKind.Verified || t.kind == ir.TyKind.Ref {
    return ty_idx_has_param(pool, t.elem);
  }
  return false;
}

fn struct_has_param_field(pool: ir.TyPool, st: ir.StructDecl) -> bool {
  let mut i: i32 = 0;
  while i < st.fields.len() {
    if ty_idx_has_param(pool, st.fields.get(i).ty) { return true; }
    i = i + 1;
  }
  return false;
}

fn enum_has_param_field(pool: ir.TyPool, en: ir.EnumDecl) -> bool {
  let mut vi: i32 = 0;
  while vi < en.variants.len() {
    let v: ir.EnumVariant = en.variants.get(vi);
    let mut fi: i32 = 0;
    while fi < v.fields.len() {
      if ty_idx_has_param(pool, v.fields.get(fi)) { return true; }
      fi = fi + 1;
    }
    vi = vi + 1;
  }
  return false;
}

fn emitted_has(emitted: Vec[String], name: String) -> bool {
  let mut i: i32 = 0;
  while i < emitted.len() {
    if emitted.get(i) == name { return true; }
    i = i + 1;
  }
  return false;
}

fn emit_struct_typedef(pool: ir.TyPool, st: ir.StructDecl) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  if st.packed_align > 0 {
    out.push("#pragma pack(push, ".concat(st.packed_align.to_string()).concat(")"));
  }
  out.push("typedef struct {");
  let mut i: i32 = 0;
  while i < st.fields.len() {
    let f: ir.StructField = st.fields.get(i);
    out.push("  ".concat(c_type(pool, f.ty)).concat(" ").concat(c_ident(f.name)).concat(";"));
    i = i + 1;
  }
  out.push("} ".concat(c_struct_type_name(st.name)).concat(";"));
  if st.packed_align > 0 {
    out.push("#pragma pack(pop)");
  }
  return out;
}

fn enum_has_payload(en: ir.EnumDecl) -> bool {
  let mut vi: i32 = 0;
  while vi < en.variants.len() {
    if en.variants.get(vi).fields.len() != 0 { return true; }
    vi = vi + 1;
  }
  return false;
}

fn emit_enum_typedef(pool: ir.TyPool, en: ir.EnumDecl) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  let has_payload: bool = enum_has_payload(en);
  out.push("typedef struct {");
  out.push("  int32_t tag;");
  if has_payload {
    out.push("  union {");
    let mut vi: i32 = 0;
    while vi < en.variants.len() {
      let v: ir.EnumVariant = en.variants.get(vi);
      out.push("    struct {");
      if v.fields.len() != 0 {
        let mut fi: i32 = 0;
        while fi < v.fields.len() {
          out.push("      ".concat(c_type(pool, v.fields.get(fi))).concat(" _").concat(fi.to_string()).concat(";"));
          fi = fi + 1;
        }
      } else {
        out.push("      uint8_t _;");
      }
      out.push("    } ".concat(c_ident(v.name)).concat(";"));
      vi = vi + 1;
    }
    out.push("  } payload;");
  }
  out.push("} ".concat(c_enum_type_name(en.name)).concat(";"));
  return out;
}

fn deps_satisfied(pool: ir.TyPool, p: ir.Program, info: NomInfo, emitted: Vec[String]) -> bool {
  if info.kind == 0 {
    let st: ir.StructDecl = find_struct(p, info.name);
    let mut i: i32 = 0;
    while i < st.fields.len() {
      let f: ir.StructField = st.fields.get(i);
      let t: ir.Ty = ir.ty_pool_get(pool, f.ty);
      if t.kind == ir.TyKind.Struct || t.kind == ir.TyKind.Enum {
        if !emitted_has(emitted, ty_qname(t)) { return false; }
      }
      i = i + 1;
    }
    return true;
  }

  let en: ir.EnumDecl = find_enum(p, info.name);
  let mut vi: i32 = 0;
  while vi < en.variants.len() {
    let v: ir.EnumVariant = en.variants.get(vi);
    let mut fi: i32 = 0;
    while fi < v.fields.len() {
      let t: ir.Ty = ir.ty_pool_get(pool, v.fields.get(fi));
      if t.kind == ir.TyKind.Struct || t.kind == ir.TyKind.Enum {
        if !emitted_has(emitted, ty_qname(t)) { return false; }
      }
      fi = fi + 1;
    }
    vi = vi + 1;
  }
  return true;
}

fn find_struct(p: ir.Program, name: String) -> ir.StructDecl {
  let mut i: i32 = 0;
  while i < p.structs.len() {
    let st: ir.StructDecl = p.structs.get(i);
    if st.name == name { return st; }
    i = i + 1;
  }
  panic("unknown struct in codegen");
  return ir.StructDecl { name: "", repr_c: false, packed_align: 0, fields: Vec() };
}

fn find_enum(p: ir.Program, name: String) -> ir.EnumDecl {
  let mut i: i32 = 0;
  while i < p.enums.len() {
    let en: ir.EnumDecl = p.enums.get(i);
    if en.name == name { return en; }
    i = i + 1;
  }
  panic("unknown enum in codegen");
  return ir.EnumDecl { name: "", variants: Vec() };
}

pub fn emit_nominal_types(pool: ir.TyPool, p: ir.Program) -> Vec[String] {
  let mut infos: Vec[NomInfo] = Vec();
  let mut si: i32 = 0;
  while si < p.structs.len() {
    let st: ir.StructDecl = p.structs.get(si);
    if !struct_has_param_field(pool, st) {
      infos.push(NomInfo { name: st.name, kind: 0 });
    }
    si = si + 1;
  }
  let mut ei: i32 = 0;
  while ei < p.enums.len() {
    let en: ir.EnumDecl = p.enums.get(ei);
    if !enum_has_param_field(pool, en) {
      infos.push(NomInfo { name: en.name, kind: 1 });
    }
    ei = ei + 1;
  }

  let mut out: Vec[String] = Vec();
  let mut emitted: Vec[String] = Vec();
  while emitted.len() < infos.len() {
    let mut progress: bool = false;
    let mut i: i32 = 0;
    while i < infos.len() {
      let info: NomInfo = infos.get(i);
      if emitted_has(emitted, info.name) { i = i + 1; continue; }
      if !deps_satisfied(pool, p, info, emitted) { i = i + 1; continue; }

      let lines: Vec[String] = if info.kind == 0 { emit_struct_typedef(pool, find_struct(p, info.name)) } else { emit_enum_typedef(pool, find_enum(p, info.name)) };
      let mut li: i32 = 0;
      while li < lines.len() { out.push(lines.get(li)); li = li + 1; }
      out.push("");
      emitted.push(info.name);
      progress = true;
      i = i + 1;
    }
    if !progress {
      panic("cyclic nominal types by-value dependency");
    }
  }
  return out;
}
