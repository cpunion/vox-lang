import "vox/ir" as ir

fn is_alpha_num(ch: i32) -> bool {
  return (ch >= 97 && ch <= 122) || (ch >= 65 && ch <= 90) || (ch >= 48 && ch <= 57);
}

fn is_ident_char(ch: i32) -> bool {
  return is_alpha_num(ch) || ch == 95; // '_'
}

fn hex_digit(n: i32) -> String {
  if n == 0 { return "0"; }
  if n == 1 { return "1"; }
  if n == 2 { return "2"; }
  if n == 3 { return "3"; }
  if n == 4 { return "4"; }
  if n == 5 { return "5"; }
  if n == 6 { return "6"; }
  if n == 7 { return "7"; }
  if n == 8 { return "8"; }
  if n == 9 { return "9"; }
  if n == 10 { return "a"; }
  if n == 11 { return "b"; }
  if n == 12 { return "c"; }
  if n == 13 { return "d"; }
  if n == 14 { return "e"; }
  if n == 15 { return "f"; }
  return "0";
}

fn hex2(ch: i32) -> String {
  // `byte_at` returns 0..255 (stage0), so plain division/mod is enough.
  let b: i32 = ch;
  let hi: i32 = b / 16;
  let lo: i32 = b % 16;
  return hex_digit(hi).concat(hex_digit(lo));
}

pub fn c_ident(s: String) -> String {
  // Best-effort sanitization: keep [A-Za-z0-9_], map others to '_'.
  let n: i32 = s.len();
  if n == 0 { return "_"; }
  let mut parts: Vec[String] = Vec();
  let mut i: i32 = 0;
  while i < n {
    let ch: i32 = s.byte_at(i);
    if !is_ident_char(ch) {
      parts.push("_");
      i = i + 1;
      continue;
    }
    let start: i32 = i;
    i = i + 1;
    while i < n && is_ident_char(s.byte_at(i)) {
      i = i + 1;
    }
    let seg: String = s.slice(start, i);
    if start == 0 {
      let head: i32 = seg.byte_at(0);
      if head >= 48 && head <= 57 { parts.push("_"); }
    }
    parts.push(seg);
  }
  let out: String = parts.join("");
  if out == "" { return "_"; }
  return out;
}

pub fn c_mangle(s: String) -> String {
  // Collision-free mangling for qualified names.
  // Keep [A-Za-z0-9] as-is, hex-escape everything else (including '_').
  let mut parts: Vec[String] = Vec();
  parts.push("m");
  let n: i32 = s.len();
  let mut i: i32 = 0;
  while i < n {
    let ch: i32 = s.byte_at(i);
    if is_alpha_num(ch) {
      let start: i32 = i;
      i = i + 1;
      while i < n && is_alpha_num(s.byte_at(i)) {
        i = i + 1;
      }
      parts.push(s.slice(start, i));
    } else {
      parts.push("_");
      parts.push(hex2(ch));
      i = i + 1;
    }
  }
  return parts.join("");
}

pub fn c_fn_name(name: String) -> String { return "vox_fn_".concat(c_mangle(name)); }

pub fn c_static_name(name: String) -> String { return "vox_st_".concat(c_mangle(name)); }

pub fn c_ffi_import_name(func_name: String) -> String { return "vox_imp_".concat(c_mangle(func_name)); }

pub fn c_ffi_export_wasm_name(func_name: String, symbol: String) -> String { return "vox_exp_".concat(c_mangle(func_name.concat("::").concat(symbol))); }

pub fn c_label_name(name: String) -> String { return "vox_blk_".concat(c_ident(name)); }

pub fn c_struct_type_name(name: String) -> String { return "vox_struct_".concat(c_mangle(name)); }

pub fn c_enum_type_name(name: String) -> String { return "vox_enum_".concat(c_mangle(name)); }

pub fn c_param_name(i: i32) -> String { return "p".concat(i.to_string()); }

pub fn c_temp_name(id: i32) -> String { return "t".concat(id.to_string()); }

pub fn c_slot_name(id: i32) -> String { return "v".concat(id.to_string()); }

pub fn ty_qname(t: ir.Ty) -> String {
  if t.mod_path == "" || t.mod_path == "main" { return t.name; }
  let s: String = t.mod_path;
  let n: i32 = s.len();
  let mut parts: Vec[String] = Vec();
  let mut start: i32 = 0;
  let mut i: i32 = 0;
  while i < n {
    if s.byte_at(i) == 47 { // '/'
      parts.push(s.slice(start, i));
      parts.push(".");
      start = i + 1;
    }
    i = i + 1;
  }
  if start < n {
    parts.push(s.slice(start, n));
  }
  return parts.join("").concat("::").concat(t.name);
}
