import "std/testing" as t

fn test_codegen_ffi_import_emits_extern_decl_and_direct_call() -> () {
  let src: String = "@ffi_import(\"c\", \"puts\")\nfn puts(msg: String) -> i32;\nfn main() -> i32 { return puts(\"ok\"); }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "extern int32_t puts("));
  t.assert(contains(c, "puts("));
  t.assert(!contains(c, "vox_fn_mputs("));
}

fn test_codegen_ffi_export_emits_wrapper() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_add\")\npub fn add(a: i32, b: i32) -> i32 { return a + b; }\nfn main() -> i32 { return add(1, 2); }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "int32_t vox_add(int32_t p0, int32_t p1) {"));
  t.assert(contains(c, "return vox_fn_madd(p0, p1);"));
}

fn test_codegen_ffi_import_return_value_used_in_expr() -> () {
  let src: String = "@ffi_import(\"c\", \"strcmp\")\nfn strcmp(a: String, b: String) -> i32;\nfn main() -> i32 { return if strcmp(\"vox\", \"vox\") == 0 { 7 } else { 9 }; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "extern int32_t strcmp("));
  t.assert(contains(c, "strcmp("));
  t.assert(!contains(c, "vox_fn_mstrcmp("));
}

fn test_codegen_ffi_import_rawptr_maps_to_void_ptr() -> () {
  let src: String = """
    @ffi_import("c", "malloc")
    fn c_malloc(n: usize) -> rawptr;
    @ffi_import("c", "free")
    fn c_free(p: rawptr) -> ();
    fn main() -> i32 {
      let p: rawptr = c_malloc(8);
      c_free(p);
      return 0;
    }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "extern void* malloc(uintptr_t p0);"));
  t.assert(contains(c, "extern void free(void* p0);"));
}

fn test_codegen_ffi_import_wasm_emits_import_attrs() -> () {
  let src: String = "@ffi_import(\"wasm\", \"env\", \"log_i32\")\nfn wasm_log(v: i32) -> ();\nfn main() -> i32 { wasm_log(7); return 0; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "import_module(\"env\"), import_name(\"log_i32\")"));
  t.assert(contains(c, "void vox_imp_"));
  t.assert(contains(c, "vox_imp_mwasm_5flog("));
  t.assert(!contains(c, "vox_fn_mwasm_log("));
}

fn test_codegen_ffi_export_wasm_emits_export_name_attr() -> () {
  let src: String = "@ffi_export(\"wasm\", \"vox_add\")\npub fn add(a: i32, b: i32) -> i32 { return a + b; }\nfn main() -> i32 { return add(1, 2); }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "__attribute__((export_name(\"vox_add\"))) int32_t vox_exp_"));
  t.assert(contains(c, "return vox_fn_madd(p0, p1);"));
}
