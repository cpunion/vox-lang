import "std/testing" as t

fn test_codegen_ffi_import_emits_extern_decl_and_direct_call() -> () {
  let src: String = "@ffi_import(\"c\", \"puts\")\nfn puts(msg: String) -> i32;\nfn main() -> i32 { return puts(\"ok\"); }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "extern int32_t puts("));
  t.assert(contains(c, "puts("));
  t.assert(!contains(c, "vox_fn_mputs("));
}

fn test_codegen_ffi_export_emits_wrapper() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_add\")\npub fn add(a: i32, b: i32) -> i32 { return a + b; }\nfn main() -> i32 { return add(1, 2); }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "int32_t vox_add(int32_t p0, int32_t p1) {"));
  t.assert(contains(c, "return vox_fn_madd(p0, p1);"));
}

fn test_codegen_ffi_import_return_value_used_in_expr() -> () {
  let src: String = "@ffi_import(\"c\", \"strcmp\")\nfn strcmp(a: String, b: String) -> i32;\nfn main() -> i32 { return if strcmp(\"vox\", \"vox\") == 0 { 7 } else { 9 }; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "extern int32_t strcmp("));
  t.assert(contains(c, "strcmp("));
  t.assert(!contains(c, "vox_fn_mstrcmp("));
}

fn test_codegen_ffi_import_rawptr_maps_to_void_ptr() -> () {
  let src: String = """
    @ffi_import("c", "malloc")
    fn c_malloc(n: usize) -> rawptr;
    @ffi_import("c", "free")
    fn c_free(p: rawptr) -> ();
    fn main() -> i32 {
      let p: rawptr = c_malloc(8);
      c_free(p);
      return 0;
    }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "extern void* malloc(uintptr_t p0);"));
  t.assert(contains(c, "extern void free(void* p0);"));
}

fn test_codegen_ffi_import_const_rawptr_maps_to_const_void_ptr() -> () {
  let src: String = """
    @ffi_import("c", "write")
    fn c_write(fd: i32, p: const rawptr, n: usize) -> isize;
    fn main() -> i32 { return c_write(1, "ok" as const rawptr, 2 as usize) as i32; }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "extern intptr_t write(int32_t p0, const void* p1, uintptr_t p2);"));
}

fn test_codegen_ffi_import_mut_ref_scalar_maps_to_pointer() -> () {
  let src: String = """
    @ffi_import("c", "_sopen_s")
    fn c_sopen_s(fd_out: &mut i32, path: String, flags: i32, shflag: i32, mode: i32) -> i32;
    fn main() -> i32 {
      let mut fd: i32 = -1;
      let rc: i32 = c_sopen_s(fd, "x", 0, 64, 0);
      if rc != 0 { return -1; }
      return fd;
    }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "extern int32_t _sopen_s(int32_t* p0, const char* p1, int32_t p2, int32_t p3, int32_t p4);"));
  t.assert(contains(c, "_sopen_s("));
}

fn test_codegen_ffi_import_wasm_emits_import_attrs() -> () {
  let src: String = "@ffi_import(\"wasm\", \"env\", \"log_i32\")\nfn wasm_log(v: i32) -> ();\nfn main() -> i32 { wasm_log(7); return 0; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "import_module(\"env\"), import_name(\"log_i32\")"));
  t.assert(contains(c, "void vox_imp_"));
  t.assert(contains(c, "vox_imp_mwasm_5flog("));
  t.assert(!contains(c, "vox_fn_mwasm_log("));
}

fn test_codegen_ffi_export_wasm_emits_export_name_attr() -> () {
  let src: String = "@ffi_export(\"wasm\", \"vox_add\")\npub fn add(a: i32, b: i32) -> i32 { return a + b; }\nfn main() -> i32 { return add(1, 2); }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "__attribute__((export_name(\"vox_add\"))) int32_t vox_exp_"));
  t.assert(contains(c, "return vox_fn_madd(p0, p1);"));
}
