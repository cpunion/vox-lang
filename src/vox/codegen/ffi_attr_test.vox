import "std/testing" as t

fn test_codegen_ffi_import_emits_extern_decl_and_direct_call() -> () {
  let src: String = "@ffi_import(\"c\", \"puts\")\nfn puts(msg: String) -> i32;\nfn main() -> i32 { return puts(\"ok\"); }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "extern int32_t puts("));
  t.assert(contains(c, "puts("));
  t.assert(!contains(c, "vox_fn_mputs("));
}

fn test_codegen_ffi_export_emits_wrapper() -> () {
  let src: String = "@ffi_export(\"c\", \"vox_add\")\npub fn add(a: i32, b: i32) -> i32 { return a + b; }\nfn main() -> i32 { return add(1, 2); }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "int32_t vox_add(int32_t p0, int32_t p1) {"));
  t.assert(contains(c, "return vox_fn_madd(p0, p1);"));
}

fn test_codegen_ffi_import_return_value_used_in_expr() -> () {
  let src: String = "@ffi_import(\"c\", \"strcmp\")\nfn strcmp(a: String, b: String) -> i32;\nfn main() -> i32 { return if strcmp(\"vox\", \"vox\") == 0 { 7 } else { 9 }; }";
  let c: String = compile_to_c(src);
  t.assert(contains(c, "extern int32_t strcmp("));
  t.assert(contains(c, "strcmp("));
  t.assert(!contains(c, "vox_fn_mstrcmp("));
}
