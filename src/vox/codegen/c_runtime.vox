fn append_lines(dst0: Vec[String], xs: Vec[String]) -> Vec[String] {
  let mut dst: Vec[String] = dst0;
  let mut i: i32 = 0;
  while i < xs.len() {
    dst.push(xs.get(i));
    i = i + 1;
  }
  return dst;
}

fn append_block_lines(dst0: Vec[String], block: String) -> Vec[String] {
  let mut dst: Vec[String] = dst0;
  let n: i32 = block.len();
  if n == 0 { return dst; }
  let mut start: i32 = 0;
  let mut i: i32 = 0;
  while i < n {
    if block.byte_at(i) == 10 {
      dst.push(block.slice(start, i));
      start = i + 1;
    }
    i = i + 1;
  }
  if start < n {
    dst.push(block.slice(start, n));
  }
  return dst;
}

fn emit_runtime_to_string_fn(
  name: String,
  cty: String,
  fmt_expr: String,
  arg_expr: String,
  buf_size: i32,
) -> Vec[String] {
  let mut out: Vec[String] = Vec();
  out.push("static const char* ".concat(name).concat("(").concat(cty).concat(" v) {"));
  out.push("  char buf[".concat(buf_size.to_string()).concat("];"));
  out.push("  int n = snprintf(buf, sizeof(buf), ".concat(fmt_expr).concat(", ").concat(arg_expr).concat(");"));
  out.push("  if (n < 0 || (size_t)n >= sizeof(buf)) { fprintf(stderr, \"format failed or buffer too small\\n\"); exit(1); }");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, buf, (size_t)n + 1);");
  out.push("  return out;");
  out.push("}");
  out.push("");
  return out;
}

pub fn emit_runtime_lines() -> Vec[String] {
  let mut out: Vec[String] = Vec();

  // Unit value representation (cannot use `void` for locals/fields in C).
  out.push("typedef uint8_t vox_unit;");

  // Stage1/Stage2 converged Vec runtime:
  // - per-value logical len
  // - shared backing storage handle (copy-safe under realloc)
  out.push("typedef struct { uint8_t* data; int32_t cap; int32_t elem_size; } vox_vec_data;");
  out.push("typedef struct { vox_vec_data* h; int32_t len; } vox_vec;");
  out.push("typedef struct vox_alloc_node { void* ptr; struct vox_alloc_node* next; } vox_alloc_node;");
  out.push("static vox_alloc_node* vox_alloc_head = NULL;");
  out.push("static bool vox_alloc_cleanup_registered = false;");
  out.push("static void vox_impl_cleanup(void) {");
  out.push("  vox_alloc_node* cur = vox_alloc_head;");
  out.push("  vox_alloc_head = NULL;");
  out.push("  while (cur) {");
  out.push("    vox_alloc_node* next = cur->next;");
  out.push("    if (cur->ptr) free(cur->ptr);");
  out.push("    free(cur);");
  out.push("    cur = next;");
  out.push("  }");
  out.push("}");
  out.push("static void vox_impl_register_cleanup(void) {");
  out.push("  if (vox_alloc_cleanup_registered) return;");
  out.push("  if (atexit(vox_impl_cleanup) != 0) { fprintf(stderr, \"register atexit cleanup failed\\n\"); exit(1); }");
  out.push("  vox_alloc_cleanup_registered = true;");
  out.push("}");
  out.push("static void* vox_impl_malloc(size_t n) {");
  out.push("  if (n == 0) n = 1;");
  out.push("  void* p = malloc(n);");
  out.push("  if (!p) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  vox_impl_register_cleanup();");
  out.push("  vox_alloc_node* node = (vox_alloc_node*)malloc(sizeof(vox_alloc_node));");
  out.push("  if (!node) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  node->ptr = p;");
  out.push("  node->next = vox_alloc_head;");
  out.push("  vox_alloc_head = node;");
  out.push("  return p;");
  out.push("}");
  out.push("static void* vox_impl_realloc(void* old_ptr, size_t n) {");
  out.push("  if (!old_ptr) return vox_impl_malloc(n);");
  out.push("  if (n == 0) n = 1;");
  out.push("  void* p = realloc(old_ptr, n);");
  out.push("  if (!p) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  vox_alloc_node* cur = vox_alloc_head;");
  out.push("  while (cur) {");
  out.push("    if (cur->ptr == old_ptr) {");
  out.push("      cur->ptr = p;");
  out.push("      return p;");
  out.push("    }");
  out.push("    cur = cur->next;");
  out.push("  }");
  out.push("  vox_impl_register_cleanup();");
  out.push("  vox_alloc_node* node = (vox_alloc_node*)malloc(sizeof(vox_alloc_node));");
  out.push("  if (!node) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  node->ptr = p;");
  out.push("  node->next = vox_alloc_head;");
  out.push("  vox_alloc_head = node;");
  out.push("  return p;");
  out.push("}");
  out.push("static bool vox_impl_forget(void* p) {");
  out.push("  if (!p) return false;");
  out.push("  vox_alloc_node** cur = &vox_alloc_head;");
  out.push("  while (*cur) {");
  out.push("    vox_alloc_node* node = *cur;");
  out.push("    if (node->ptr == p) {");
  out.push("      *cur = node->next;");
  out.push("      free(node);");
  out.push("      return true;");
  out.push("    }");
  out.push("    cur = &node->next;");
  out.push("  }");
  out.push("  return false;");
  out.push("}");
  out.push("static void vox_impl_free(void* p) {");
  out.push("  if (!p) return;");
  out.push("  bool tracked = vox_impl_forget(p);");
  out.push("  if (!tracked) return;");
  out.push("  free(p);");
  out.push("}");
  out.push("static vox_vec_data* vox_vec_data_new(int32_t elem_size) {");
  out.push("  vox_vec_data* h = (vox_vec_data*)vox_impl_malloc(sizeof(vox_vec_data));");
  out.push("  if (!h) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  h->data = NULL;");
  out.push("  h->cap = 0;");
  out.push("  h->elem_size = elem_size;");
  out.push("  return h;");
  out.push("}");
  out.push("static vox_vec vox_vec_new(int32_t elem_size) {");
  out.push("  vox_vec v; v.h = vox_vec_data_new(elem_size); v.len = 0; return v;");
  out.push("}");
  out.push("static void vox_vec_grow(vox_vec* v, int32_t new_cap) {");
  out.push("  if (!v || !v->h) { fprintf(stderr, \"vec grow invalid vec\\n\"); exit(1); }");
  out.push("  if (new_cap <= v->h->cap) return;");
  out.push("  if (new_cap < 4) new_cap = 4;");
  out.push("  size_t bytes = (size_t)new_cap * (size_t)v->h->elem_size;");
  out.push("  uint8_t* p = (uint8_t*)vox_impl_realloc(v->h->data, bytes);");
  out.push("  if (!p) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  v->h->data = p;");
  out.push("  v->h->cap = new_cap;");
  out.push("}");
  out.push("static void vox_vec_push(vox_vec* v, const void* elem) {");
  out.push("  if (!v || !v->h || !elem) { fprintf(stderr, \"vec push invalid args\\n\"); exit(1); }");
  out.push("  if (v->len == v->h->cap) { int32_t nc = v->h->cap == 0 ? 4 : v->h->cap * 2; vox_vec_grow(v, nc); }");
  out.push("  memcpy(v->h->data + (size_t)v->len * (size_t)v->h->elem_size, elem, (size_t)v->h->elem_size);");
  out.push("  v->len++;");
  out.push("}");
  out.push("static void vox_vec_insert(vox_vec* v, int32_t idx, const void* elem) {");
  out.push("  if (!v || !v->h || !elem) { fprintf(stderr, \"vec insert invalid args\\n\"); exit(1); }");
  out.push("  if (idx < 0 || idx > v->len) { fprintf(stderr, \"vec insert index out of bounds: idx=%\" PRId32 \" len=%\" PRId32 \"\\n\", idx, v->len); exit(1); }");
  out.push("  if (v->len == v->h->cap) { int32_t nc = v->h->cap == 0 ? 4 : v->h->cap * 2; vox_vec_grow(v, nc); }");
  out.push("  uint8_t* ptr = v->h->data + (size_t)idx * (size_t)v->h->elem_size;");
  out.push("  int32_t tail = v->len - idx;");
  out.push("  if (tail > 0) {");
  out.push("    memmove(ptr + (size_t)v->h->elem_size, ptr, (size_t)tail * (size_t)v->h->elem_size);");
  out.push("  }");
  out.push("  memcpy(ptr, elem, (size_t)v->h->elem_size);");
  out.push("  v->len++;");
  out.push("}");
  out.push("static void vox_vec_set(vox_vec* v, int32_t idx, const void* elem) {");
  out.push("  if (!v || !v->h || !elem) { fprintf(stderr, \"vec set invalid args\\n\"); exit(1); }");
  out.push("  if (idx < 0 || idx >= v->len) { fprintf(stderr, \"vec set index out of bounds: idx=%\" PRId32 \" len=%\" PRId32 \"\\n\", idx, v->len); exit(1); }");
  out.push("  memcpy(v->h->data + (size_t)idx * (size_t)v->h->elem_size, elem, (size_t)v->h->elem_size);");
  out.push("}");
  out.push("static void vox_vec_clear(vox_vec* v) {");
  out.push("  if (!v) return;");
  out.push("  v->len = 0;");
  out.push("}");
  out.push("static void vox_vec_extend(vox_vec* v, const vox_vec* other) {");
  out.push("  if (!v || !v->h || !other || !other->h) return;");
  out.push("  if (other->len <= 0) return;");
  out.push("  if (v->h->elem_size != other->h->elem_size) { fprintf(stderr, \"vec extend elem_size mismatch\\n\"); exit(1); }");
  out.push("  int64_t need64 = (int64_t)v->len + (int64_t)other->len;");
  out.push("  if (need64 > INT32_MAX) { fprintf(stderr, \"vec too large\\n\"); exit(1); }");
  out.push("  int32_t need = (int32_t)need64;");
  out.push("  if (need > v->h->cap) {");
  out.push("    int32_t nc = v->h->cap == 0 ? 4 : v->h->cap;");
  out.push("    while (nc < need) {");
  out.push("      if (nc > INT32_MAX / 2) { nc = need; break; }");
  out.push("      nc = nc * 2;");
  out.push("    }");
  out.push("    vox_vec_grow(v, nc);");
  out.push("  }");
  out.push("  memcpy(v->h->data + (size_t)v->len * (size_t)v->h->elem_size, other->h->data, (size_t)other->len * (size_t)other->h->elem_size);");
  out.push("  v->len = need;");
  out.push("}");
  out.push("static void vox_vec_pop(vox_vec* v, void* out) {");
  out.push("  if (!v || !v->h || !out) { fprintf(stderr, \"vec pop invalid args\\n\"); exit(1); }");
  out.push("  if (v->len <= 0) { fprintf(stderr, \"vec pop on empty vector\\n\"); exit(1); }");
  out.push("  int32_t idx = v->len - 1;");
  out.push("  memcpy(out, v->h->data + (size_t)idx * (size_t)v->h->elem_size, (size_t)v->h->elem_size);");
  out.push("  v->len = idx;");
  out.push("}");
  out.push("static void vox_vec_remove(vox_vec* v, int32_t idx, void* out) {");
  out.push("  if (!v || !v->h || !out) { fprintf(stderr, \"vec remove invalid args\\n\"); exit(1); }");
  out.push("  if (idx < 0 || idx >= v->len) { fprintf(stderr, \"vec remove index out of bounds: idx=%\" PRId32 \" len=%\" PRId32 \"\\n\", idx, v->len); exit(1); }");
  out.push("  uint8_t* ptr = v->h->data + (size_t)idx * (size_t)v->h->elem_size;");
  out.push("  memcpy(out, ptr, (size_t)v->h->elem_size);");
  out.push("  int32_t tail = v->len - idx - 1;");
  out.push("  if (tail > 0) {");
  out.push("    memmove(ptr, ptr + (size_t)v->h->elem_size, (size_t)tail * (size_t)v->h->elem_size);");
  out.push("  }");
  out.push("  v->len = v->len - 1;");
  out.push("}");
  out.push("static int32_t vox_vec_len(const vox_vec* v) { return v ? v->len : 0; }");
  out.push("static bool vox_vec_eq(const vox_vec* a, const vox_vec* b) {");
  out.push("  if (!a || !b) return false;");
  out.push("  if (a->len != b->len) return false;");
  out.push("  if (!a->h || !b->h) return a->len == 0 && b->len == 0;");
  out.push("  if (a->h->elem_size != b->h->elem_size) return false;");
  out.push("  size_t bytes = (size_t)a->len * (size_t)a->h->elem_size;");
  out.push("  if (bytes == 0) return true;");
  out.push("  return memcmp(a->h->data, b->h->data, bytes) == 0;");
  out.push("}");
  out.push("static void vox_vec_get(const vox_vec* v, int32_t idx, void* out) {");
  out.push("  if (!v || !v->h || !out) { fprintf(stderr, \"vec get invalid args\\n\"); exit(1); }");
  out.push("  if (idx < 0 || idx >= v->len) { fprintf(stderr, \"vec index out of bounds: idx=%\" PRId32 \" len=%\" PRId32 \"\\n\", idx, v->len); exit(1); }");
  out.push("  memcpy(out, v->h->data + (size_t)idx * (size_t)v->h->elem_size, (size_t)v->h->elem_size);");
  out.push("}");
  out.push("");

  // Minimal string runtime helpers (stage0).
  out.push("static int32_t vox_str_len(const char* s) {");
  out.push("  if (!s) return 0;");
  out.push("  size_t n = strlen(s);");
  out.push("  if (n > INT32_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }");
  out.push("  return (int32_t)n;");
  out.push("}");
  out.push("static int32_t vox_str_byte_at(const char* s, int32_t idx) {");
  out.push("  int32_t n = vox_str_len(s);");
  out.push("  if (idx < 0 || idx >= n) { fprintf(stderr, \"string index out of bounds\\n\"); exit(1); }");
  out.push("  return (int32_t)(uint8_t)s[idx];");
  out.push("}");
  out.push("");
  out.push("static const char* vox_str_slice(const char* s, int32_t start, int32_t end) {");
  out.push("  int32_t n = vox_str_len(s);");
  out.push("  if (start < 0 || end < start || end > n) { fprintf(stderr, \"string slice out of bounds\\n\"); exit(1); }");
  out.push("  int32_t m = end - start;");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)m + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, s + start, (size_t)m);");
  out.push("  out[m] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_str_concat(const char* a, const char* b) {");
  out.push("  if (!a) a = \"\";");
  out.push("  if (!b) b = \"\";");
  out.push("  size_t na = strlen(a);");
  out.push("  size_t nb = strlen(b);");
  out.push("  if (na + nb + 1 > SIZE_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }");
  out.push("  char* out = (char*)vox_impl_malloc(na + nb + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, a, na);");
  out.push("  memcpy(out + na, b, nb);");
  out.push("  out[na + nb] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static bool vox_str_starts_with(const char* s, const char* pre) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!pre) pre = \"\";");
  out.push("  size_t ns = strlen(s);");
  out.push("  size_t np = strlen(pre);");
  out.push("  if (np > ns) return false;");
  out.push("  return memcmp(s, pre, np) == 0;");
  out.push("}");
  out.push("");
  out.push("static bool vox_str_ends_with(const char* s, const char* suf) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!suf) suf = \"\";");
  out.push("  size_t ns = strlen(s);");
  out.push("  size_t nf = strlen(suf);");
  out.push("  if (nf > ns) return false;");
  out.push("  return memcmp(s + (ns - nf), suf, nf) == 0;");
  out.push("}");
  out.push("");
  out.push("static bool vox_str_contains(const char* s, const char* needle) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!needle) needle = \"\";");
  out.push("  return strstr(s, needle) != NULL;");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_str_index_of(const char* s, const char* needle) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!needle) needle = \"\";");
  out.push("  if (needle[0] == '\\0') return 0;");
  out.push("  const char* p = strstr(s, needle);");
  out.push("  if (!p) return -1;");
  out.push("  size_t idx = (size_t)(p - s);");
  out.push("  if (idx > (size_t)INT32_MAX) { fprintf(stderr, \"string index overflow\\n\"); exit(1); }");
  out.push("  return (int32_t)idx;");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_str_last_index_of(const char* s, const char* needle) {");
  out.push("  if (!s) s = \"\";");
  out.push("  if (!needle) needle = \"\";");
  out.push("  int32_t ns = vox_str_len(s);");
  out.push("  int32_t nn = vox_str_len(needle);");
  out.push("  if (nn == 0) return ns;");
  out.push("  if (ns < nn) return -1;");
  out.push("  int32_t last = -1;");
  out.push("  for (int32_t i = 0; i <= ns - nn; i++) {");
  out.push("    if (memcmp(s + i, needle, (size_t)nn) == 0) last = i;");
  out.push("  }");
  out.push("  return last;");
  out.push("}");
  out.push("");
  out = append_lines(out, emit_runtime_to_string_fn("vox_i32_to_string", "int32_t", "\"%\" PRId32", "v", 32));
  out = append_lines(out, emit_runtime_to_string_fn("vox_i64_to_string", "int64_t", "\"%\" PRId64", "v", 32));
  out = append_lines(out, emit_runtime_to_string_fn("vox_u64_to_string", "uint64_t", "\"%\" PRIu64", "v", 32));
  out = append_lines(out, emit_runtime_to_string_fn("vox_isize_to_string", "intptr_t", "\"%\" PRIdPTR", "v", 32));
  out = append_lines(out, emit_runtime_to_string_fn("vox_usize_to_string", "uintptr_t", "\"%\" PRIuPTR", "v", 32));
  out = append_lines(out, emit_runtime_to_string_fn("vox_f32_to_string", "float", "\"%.9g\"", "(double)v", 64));
  out = append_lines(out, emit_runtime_to_string_fn("vox_f64_to_string", "double", "\"%.17g\"", "v", 64));
  out.push("static const char* vox_bool_to_string(bool v) {");
  out.push("  return v ? \"true\" : \"false\";");
  out.push("}");
  out.push("");
  out.push("static const char* vox_str_escape_c(const char* s) {");
  out.push("  if (!s) s = \"\";");
  out.push("  size_t n = strlen(s);");
  out.push("  // First pass: compute output length.");
  out.push("  size_t out_n = 0;");
  out.push("  for (size_t i = 0; i < n; i++) {");
  out.push("    unsigned char ch = (unsigned char)s[i];");
  out.push("    switch (ch) {");
  out.push("    case '\\\\':");
  out.push("    case '\"':");
  out.push("    case '\\n':");
  out.push("    case '\\r':");
  out.push("    case '\\t':");
  out.push("      out_n += 2;");
  out.push("      break;");
  out.push("    default:");
  out.push("      if (ch >= 0x20 && ch <= 0x7e) out_n += 1; else out_n += 4; // \\\\xHH");
  out.push("      break;");
  out.push("    }");
  out.push("  }");
  out.push("  char* out = (char*)vox_impl_malloc(out_n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  size_t j = 0;");
  out.push("  for (size_t i = 0; i < n; i++) {");
  out.push("    unsigned char ch = (unsigned char)s[i];");
  out.push("    switch (ch) {");
  out.push("    case '\\\\': out[j++] = '\\\\'; out[j++] = '\\\\'; break;");
  out.push("    case '\"': out[j++] = '\\\\'; out[j++] = '\"'; break;");
  out.push("    case '\\n': out[j++] = '\\\\'; out[j++] = 'n'; break;");
  out.push("    case '\\r': out[j++] = '\\\\'; out[j++] = 'r'; break;");
  out.push("    case '\\t': out[j++] = '\\\\'; out[j++] = 't'; break;");
  out.push("    default:");
  out.push("      if (ch >= 0x20 && ch <= 0x7e) { out[j++] = (char)ch; }");
  out.push("      else {");
  out.push("        static const char* hex = \"0123456789abcdef\";");
  out.push("        out[j++] = '\\\\'; out[j++] = 'x';");
  out.push("        out[j++] = hex[(ch >> 4) & 0xf];");
  out.push("        out[j++] = hex[ch & 0xf];");
  out.push("      }");
  out.push("      break;");
  out.push("    }");
  out.push("  }");
  out.push("  out[j] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static const char* vox_vec_str_join(const vox_vec* v, const char* sep) {");
  out.push("  if (!sep) sep = \"\";");
  out.push("  if (!v || !v->h || v->h->elem_size != (int32_t)sizeof(const char*)) { fprintf(stderr, \"vec_str_join expects Vec[String]\\n\"); exit(1); }");
  out.push("  int32_t n = v->len;");
  out.push("  const char* const* items = (const char* const*)v->h->data;");
  out.push("  size_t sep_n = strlen(sep);");
  out.push("  size_t total = 0;");
  out.push("  for (int32_t i = 0; i < n; i++) {");
  out.push("    const char* s = items[i];");
  out.push("    if (!s) s = \"\";");
  out.push("    total += strlen(s);");
  out.push("    if (i + 1 < n) total += sep_n;");
  out.push("  }");
  out.push("  if (total + 1 > SIZE_MAX) { fprintf(stderr, \"string too long\\n\"); exit(1); }");
  out.push("  char* out = (char*)vox_impl_malloc(total + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  size_t j = 0;");
  out.push("  for (int32_t i = 0; i < n; i++) {");
  out.push("    const char* s = items[i];");
  out.push("    if (!s) s = \"\";");
  out.push("    size_t m = strlen(s);");
  out.push("    memcpy(out + j, s, m);");
  out.push("    j += m;");
  out.push("    if (i + 1 < n && sep_n != 0) {");
  out.push("      memcpy(out + j, sep, sep_n);");
  out.push("      j += sep_n;");
  out.push("    }");
  out.push("  }");
  out.push("  out[j] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");

  // Runtime builtins
  out.push("static int vox__argc = 0;");
  out.push("static char** vox__argv = NULL;");
  out.push("");
  out.push("#if defined(_MSC_VER)");
  out.push("#  define VOX_NORETURN __declspec(noreturn)");
  out.push("#elif defined(__GNUC__) || defined(__clang__)");
  out.push("#  define VOX_NORETURN __attribute__((noreturn))");
  out.push("#else");
  out.push("#  define VOX_NORETURN");
  out.push("#endif");
  out.push("");
  out.push("static VOX_NORETURN void vox_host_panic(const char* msg) {");
  out.push("  if (!msg) msg = \"\";");
  out.push("  fprintf(stderr, \"%s\\n\", msg);");
  out.push("  exit(1);");
  out.push("}");
  out.push("");
  out.push("static void vox_host_print(const char* msg) {");
  out.push("  if (!msg) msg = \"\";");
  out.push("  fputs(msg, stdout);");
  out.push("  fflush(stdout);");
  out.push("}");
  out.push("");
  out.push("void vox_impl_print(const char* msg) {");
  out.push("  vox_host_print(msg);");
  out.push("}");
  out.push("");
  out.push("vox_vec vox_impl_args(void) {");
  out.push("  vox_vec v = vox_vec_new((int32_t)sizeof(const char*));");
  out.push("  for (int i = 1; i < vox__argc; i++) {");
  out.push("    const char* s = vox__argv[i];");
  out.push("    vox_vec_push(&v, &s);");
  out.push("  }");
  out.push("  return v;");
  out.push("}");
  out.push("");
  out.push("const char* vox_impl_exe_path(void) {");
  out.push("  if (!vox__argv || vox__argc <= 0 || !vox__argv[0]) return \"\";");
  out.push("  return vox__argv[0];");
  out.push("}");
  out.push("");
  out.push("const char* vox_impl_getenv(const char* key) {");
  out.push("  if (!key) key = \"\";");
  out.push("  const char* v = getenv(key);");
  out.push("  if (!v) return \"\";");
  out.push("  return v;");
  out.push("}");
  out.push("");
  out.push("int64_t vox_impl_now_ns(void) {");
  out.push("#if defined(_WIN32)");
  out.push("  return (int64_t)GetTickCount64() * (int64_t)1000000;");
  out.push("#elif defined(__EMSCRIPTEN__)");
  out.push("  clock_t c = clock();");
  out.push("  if (c == (clock_t)-1) return 0;");
  out.push("  return (int64_t)c * (int64_t)1000000000 / (int64_t)CLOCKS_PER_SEC;");
  out.push("#else");
  out.push("  struct timespec ts;");
  out.push("  if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0) {");
  out.push("    if (timespec_get(&ts, TIME_UTC) == 0) return 0;");
  out.push("  }");
  out.push("  return (int64_t)ts.tv_sec * (int64_t)1000000000 + (int64_t)ts.tv_nsec;");
  out.push("#endif");
  out.push("}");
  out.push("");
  out.push("void vox_impl_yield_now(void) {");
  out.push("#if defined(_WIN32)");
  out.push("  Sleep(0);");
  out.push("#elif defined(__EMSCRIPTEN__)");
  out.push("  sched_yield();");
  out.push("#else");
  out.push("  sched_yield();");
  out.push("#endif");
  out.push("}");
  out.push("");
  out.push("#define VOX_WAKE_SLOTS 256");
  out.push("typedef struct vox_wake_slot {");
  out.push("  _Atomic int64_t token;");
  out.push("  _Atomic int32_t pending;");
  out.push("} vox_wake_slot;");
  out.push("static vox_wake_slot vox_wake_slots[VOX_WAKE_SLOTS];");
  out.push("");
  out.push("static void vox_wake_platform_notify(void);");
  out.push("static void vox_wake_platform_wait_once(int32_t timeout_ms);");
  out.push("");
  out.push("#if defined(__linux__)");
  out.push("static bool vox_wake_linux_ready = false;");
  out.push("static int vox_wake_epoll_fd = -1;");
  out.push("static int vox_wake_event_fd = -1;");
  out.push("");
  out.push("static void vox_wake_linux_init(void) {");
  out.push("  if (vox_wake_linux_ready) return;");
  out.push("  vox_wake_event_fd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);");
  out.push("  if (vox_wake_event_fd < 0) { fprintf(stderr, \"wake eventfd init failed\\n\"); exit(1); }");
  out.push("  vox_wake_epoll_fd = epoll_create1(EPOLL_CLOEXEC);");
  out.push("  if (vox_wake_epoll_fd < 0) { fprintf(stderr, \"wake epoll init failed\\n\"); exit(1); }");
  out.push("  struct epoll_event ev;");
  out.push("  memset(&ev, 0, sizeof(ev));");
  out.push("  ev.events = EPOLLIN;");
  out.push("  ev.data.fd = vox_wake_event_fd;");
  out.push("  if (epoll_ctl(vox_wake_epoll_fd, EPOLL_CTL_ADD, vox_wake_event_fd, &ev) != 0) {");
  out.push("    fprintf(stderr, \"wake epoll_ctl failed\\n\");");
  out.push("    exit(1);");
  out.push("  }");
  out.push("  vox_wake_linux_ready = true;");
  out.push("}");
  out.push("");
  out.push("static void vox_wake_linux_drain(void) {");
  out.push("  uint64_t v = 0;");
  out.push("  while (read(vox_wake_event_fd, &v, sizeof(v)) > 0) {}");
  out.push("}");
  out.push("#endif");
  out.push("");
  out.push("#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)");
  out.push("static bool vox_wake_kqueue_ready = false;");
  out.push("static int vox_wake_kqueue_fd = -1;");
  out.push("");
  out.push("static void vox_wake_kqueue_init(void) {");
  out.push("  if (vox_wake_kqueue_ready) return;");
  out.push("  vox_wake_kqueue_fd = kqueue();");
  out.push("  if (vox_wake_kqueue_fd < 0) { fprintf(stderr, \"wake kqueue init failed\\n\"); exit(1); }");
  out.push("  struct kevent ev;");
  out.push("  EV_SET(&ev, 1, EVFILT_USER, EV_ADD | EV_CLEAR, 0, 0, NULL);");
  out.push("  if (kevent(vox_wake_kqueue_fd, &ev, 1, NULL, 0, NULL) != 0) {");
  out.push("    fprintf(stderr, \"wake kqueue register failed\\n\");");
  out.push("    exit(1);");
  out.push("  }");
  out.push("  vox_wake_kqueue_ready = true;");
  out.push("}");
  out.push("#endif");
  out.push("");
  out.push("#if defined(_WIN32)");
  out.push("static bool vox_wake_iocp_ready = false;");
  out.push("static HANDLE vox_wake_iocp = NULL;");
  out.push("");
  out.push("static void vox_wake_iocp_init(void) {");
  out.push("  if (vox_wake_iocp_ready) return;");
  out.push("  vox_wake_iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);");
  out.push("  if (!vox_wake_iocp) { fprintf(stderr, \"wake iocp init failed\\n\"); exit(1); }");
  out.push("  vox_wake_iocp_ready = true;");
  out.push("}");
  out.push("#endif");
  out.push("");
  out.push("static int32_t vox_wake_slot_index(int64_t token) {");
  out.push("  uint64_t base = (uint64_t)token;");
  out.push("  for (int32_t n = 0; n < VOX_WAKE_SLOTS; n++) {");
  out.push("    int32_t idx = (int32_t)((base + (uint64_t)n) % (uint64_t)VOX_WAKE_SLOTS);");
  out.push("    int64_t seen = atomic_load(&vox_wake_slots[idx].token);");
  out.push("    if (seen == token) return idx;");
  out.push("    if (seen == 0) {");
  out.push("      int64_t expect = 0;");
  out.push("      if (atomic_compare_exchange_strong(&vox_wake_slots[idx].token, &expect, token)) return idx;");
  out.push("      if (expect == token) return idx;");
  out.push("    }");
  out.push("  }");
  out.push("  return -1;");
  out.push("}");
  out.push("");
  out.push("static bool vox_wake_try_consume(int32_t idx) {");
  out.push("  while (idx >= 0) {");
  out.push("    int32_t cur = atomic_load(&vox_wake_slots[idx].pending);");
  out.push("    if (cur <= 0) return false;");
  out.push("    if (atomic_compare_exchange_strong(&vox_wake_slots[idx].pending, &cur, cur - 1)) return true;");
  out.push("  }");
  out.push("  return false;");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_wake_scan_tokens_once(const vox_vec* tokens) {");
  out.push("  if (!tokens) return -1;");
  out.push("  int32_t n = vox_vec_len(tokens);");
  out.push("  for (int32_t i = 0; i < n; i++) {");
  out.push("    int64_t tok = 0;");
  out.push("    vox_vec_get(tokens, i, &tok);");
  out.push("    int32_t idx = vox_wake_slot_index(tok);");
  out.push("    if (idx < 0) continue;");
  out.push("    if (vox_wake_try_consume(idx)) return i;");
  out.push("  }");
  out.push("  return -1;");
  out.push("}");
  out.push("");
  out.push("static void vox_wake_platform_notify(void) {");
  out.push("#if defined(__linux__)");
  out.push("  vox_wake_linux_init();");
  out.push("  uint64_t one = 1;");
  out.push("  ssize_t n = write(vox_wake_event_fd, &one, sizeof(one));");
  out.push("  if (n < 0 && errno != EAGAIN) { fprintf(stderr, \"wake eventfd write failed\\n\"); exit(1); }");
  out.push("#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)");
  out.push("  vox_wake_kqueue_init();");
  out.push("  struct kevent ev;");
  out.push("  EV_SET(&ev, 1, EVFILT_USER, 0, NOTE_TRIGGER, 0, NULL);");
  out.push("  if (kevent(vox_wake_kqueue_fd, &ev, 1, NULL, 0, NULL) != 0) { fprintf(stderr, \"wake kqueue trigger failed\\n\"); exit(1); }");
  out.push("#elif defined(_WIN32)");
  out.push("  vox_wake_iocp_init();");
  out.push("  if (!PostQueuedCompletionStatus(vox_wake_iocp, 1, (ULONG_PTR)1, NULL)) { fprintf(stderr, \"wake iocp post failed\\n\"); exit(1); }");
  out.push("#endif");
  out.push("}");
  out.push("");
  out.push("static void vox_wake_platform_wait_once(int32_t timeout_ms) {");
  out.push("  if (timeout_ms < 0) timeout_ms = 0;");
  out.push("#if defined(__linux__)");
  out.push("  vox_wake_linux_init();");
  out.push("  struct epoll_event ev;");
  out.push("  int n = epoll_wait(vox_wake_epoll_fd, &ev, 1, timeout_ms);");
  out.push("  if (n > 0) { vox_wake_linux_drain(); return; }");
  out.push("  if (n < 0 && errno != EINTR) return;");
  out.push("#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)");
  out.push("  vox_wake_kqueue_init();");
  out.push("  struct timespec ts;");
  out.push("  ts.tv_sec = timeout_ms / 1000;");
  out.push("  ts.tv_nsec = (long)(timeout_ms % 1000) * 1000000L;");
  out.push("  struct kevent ev;");
  out.push("  int n = kevent(vox_wake_kqueue_fd, NULL, 0, &ev, 1, &ts);");
  out.push("  if (n > 0) return;");
  out.push("  if (n < 0 && errno != EINTR) return;");
  out.push("#elif defined(_WIN32)");
  out.push("  vox_wake_iocp_init();");
  out.push("  DWORD bytes = 0;");
  out.push("  ULONG_PTR key = 0;");
  out.push("  OVERLAPPED* ov = NULL;");
  out.push("  GetQueuedCompletionStatus(vox_wake_iocp, &bytes, &key, &ov, (DWORD)timeout_ms);");
  out.push("#elif defined(__EMSCRIPTEN__)");
  out.push("  sched_yield();");
  out.push("#else");
  out.push("  struct timespec ts;");
  out.push("  ts.tv_sec = timeout_ms / 1000;");
  out.push("  ts.tv_nsec = (long)(timeout_ms % 1000) * 1000000L;");
  out.push("  nanosleep(&ts, NULL);");
  out.push("#endif");
  out.push("}");
  out.push("");
  out.push("void vox_impl_wake_notify(int64_t token) {");
  out.push("  int32_t idx = vox_wake_slot_index(token);");
  out.push("  if (idx < 0) return;");
  out.push("  atomic_fetch_add(&vox_wake_slots[idx].pending, 1);");
  out.push("  vox_wake_platform_notify();");
  out.push("}");
  out.push("");
  out.push("bool vox_impl_wake_wait(int64_t token, int32_t timeout_ms) {");
  out.push("  int32_t idx = vox_wake_slot_index(token);");
  out.push("  if (idx < 0) return false;");
  out.push("  if (vox_wake_try_consume(idx)) return true;");
  out.push("  if (timeout_ms < 0) timeout_ms = 0;");
  out.push("  int64_t deadline_ns = vox_impl_now_ns() + ((int64_t)timeout_ms * (int64_t)1000000);");
  out.push("  while (true) {");
  out.push("    if (vox_wake_try_consume(idx)) return true;");
  out.push("    int64_t rem_ns = deadline_ns - vox_impl_now_ns();");
  out.push("    if (rem_ns <= 0) break;");
  out.push("    int32_t rem_ms = (int32_t)(rem_ns / 1000000);");
  out.push("    if (rem_ms <= 0) rem_ms = 1;");
  out.push("    vox_wake_platform_wait_once(rem_ms);");
  out.push("  }");
  out.push("  return vox_wake_try_consume(idx);");
  out.push("}");
  out.push("");
  out.push("static int32_t vox_impl_wake_wait_any(vox_vec tokens, int32_t timeout_ms) {");
  out.push("  int32_t hit = vox_wake_scan_tokens_once(&tokens);");
  out.push("  if (hit >= 0) return hit;");
  out.push("  if (timeout_ms < 0) timeout_ms = 0;");
  out.push("  if (timeout_ms == 0) return -1;");
  out.push("  int64_t deadline_ns = vox_impl_now_ns() + ((int64_t)timeout_ms * (int64_t)1000000);");
  out.push("  while (true) {");
  out.push("    int64_t rem_ns = deadline_ns - vox_impl_now_ns();");
  out.push("    if (rem_ns <= 0) break;");
  out.push("    int32_t rem_ms = (int32_t)(rem_ns / 1000000);");
  out.push("    if (rem_ms <= 0) rem_ms = 1;");
  out.push("    vox_wake_platform_wait_once(rem_ms);");
  out.push("    hit = vox_wake_scan_tokens_once(&tokens);");
  out.push("    if (hit >= 0) return hit;");
  out.push("  }");
  out.push("  return vox_wake_scan_tokens_once(&tokens);");
  out.push("}");
  out.push("");
  out.push("const char* vox_impl_read_file(const char* path) {");
  out.push("  if (!path) path = \"\";");
  out.push("  FILE* f = fopen(path, \"rb\");");
  out.push("  if (!f) { fprintf(stderr, \"read_file failed: %s\\n\", path); exit(1); }");
  out.push("  if (fseek(f, 0, SEEK_END) != 0) { fprintf(stderr, \"read_file fseek failed: %s\\n\", path); exit(1); }");
  out.push("  long n = ftell(f);");
  out.push("  if (n < 0) { fprintf(stderr, \"read_file ftell failed: %s\\n\", path); exit(1); }");
  out.push("  if (fseek(f, 0, SEEK_SET) != 0) { fprintf(stderr, \"read_file fseek failed: %s\\n\", path); exit(1); }");
  out.push("  char* out = (char*)vox_impl_malloc((size_t)n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  size_t got = fread(out, 1, (size_t)n, f);");
  out.push("  if (got != (size_t)n) { fprintf(stderr, \"read_file fread failed: %s\\n\", path); exit(1); }");
  out.push("  out[n] = '\\0';");
  out.push("  fclose(f);");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("void vox_impl_write_file(const char* path, const char* text) {");
  out.push("  if (!path) path = \"\";");
  out.push("  if (!text) text = \"\";");
  out.push("  FILE* f = fopen(path, \"wb\");");
  out.push("  if (!f) { fprintf(stderr, \"write_file failed: %s\\n\", path); exit(1); }");
  out.push("  size_t n = strlen(text);");
  out.push("  if (n != 0) {");
  out.push("    size_t put = fwrite(text, 1, n, f);");
  out.push("    if (put != n) { fprintf(stderr, \"write_file fwrite failed: %s\\n\", path); exit(1); }");
  out.push("  }");
  out.push("  fclose(f);");
  out.push("}");
  out.push("");
  out.push("bool vox_impl_path_exists(const char* path) {");
  out.push("  if (!path || path[0] == '\\0') return false;");
  out.push("  struct stat st;");
  out.push("  return stat(path, &st) == 0;");
  out.push("}");
  out.push("");
  out.push("void vox_impl_mkdir_p(const char* path) {");
  out.push("  if (!path || path[0] == '\\0') return;");
  out.push("  size_t n = strlen(path);");
  out.push("  char* tmp = (char*)vox_impl_malloc(n + 1);");
  out.push("  if (!tmp) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(tmp, path, n + 1);");
  out.push("  for (size_t i = 1; i < n; i++) {");
  out.push("    char ch = tmp[i];");
  out.push("    if (ch != '/' && ch != '\\\\') continue;");
  out.push("    tmp[i] = '\\0';");
  out.push("    if (tmp[0] != '\\0' && !vox_impl_path_exists(tmp)) {");
  out.push("#if defined(_WIN32)");
  out.push("      if (_mkdir(tmp) != 0 && !vox_impl_path_exists(tmp)) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }");
  out.push("#else");
  out.push("      if (mkdir(tmp, 0755) != 0 && !vox_impl_path_exists(tmp)) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }");
  out.push("#endif");
  out.push("    }");
  out.push("    tmp[i] = ch;");
  out.push("  }");
  out.push("  if (!vox_impl_path_exists(tmp)) {");
  out.push("#if defined(_WIN32)");
  out.push("    if (_mkdir(tmp) != 0 && !vox_impl_path_exists(tmp)) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }");
  out.push("#else");
  out.push("    if (mkdir(tmp, 0755) != 0 && !vox_impl_path_exists(tmp)) { fprintf(stderr, \"mkdir_p failed: %s\\n\", tmp); exit(1); }");
  out.push("#endif");
  out.push("  }");
  out.push("  vox_impl_free(tmp);");
  out.push("}");
  out.push("");
  out.push("int32_t vox_impl_exec(const char* cmd) {");
  out.push("  if (!cmd) cmd = \"\";");
  out.push("  int r = system(cmd);");
  out.push("  return (int32_t)r;");
  out.push("}");
  out.push("");
  out.push("static bool vox_str_has_suffix(const char* s, const char* suf) {");
  out.push("  if (!s || !suf) return false;");
  out.push("  size_t n = strlen(s);");
  out.push("  size_t m = strlen(suf);");
  out.push("  if (m > n) return false;");
  out.push("  return memcmp(s + (n - m), suf, m) == 0;");
  out.push("}");
  out.push("");
  out.push("static char* vox_path_join2(const char* a, const char* b) {");
  out.push("  if (!a) a = \"\";");
  out.push("  if (!b) b = \"\";");
  out.push("  size_t na = strlen(a);");
  out.push("  size_t nb = strlen(b);");
  out.push("  bool slash = (na != 0 && a[na - 1] != '/');");
  out.push("  size_t n = na + (slash ? 1 : 0) + nb;");
  out.push("  char* out = (char*)vox_impl_malloc(n + 1);");
  out.push("  if (!out) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  memcpy(out, a, na);");
  out.push("  size_t j = na;");
  out.push("  if (slash) out[j++] = '/';");
  out.push("  memcpy(out + j, b, nb);");
  out.push("  out[n] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static void vox_walk_dir(vox_vec* out, const char* root, const char* rel) {");
  out.push("  char* full = rel && rel[0] ? vox_path_join2(root, rel) : vox_path_join2(root, \"\");");
  out.push("  DIR* d = opendir(full);");
  out.push("  if (!d) { vox_impl_free(full); return; }");
  out.push("  struct dirent* ent;");
  out.push("  while ((ent = readdir(d)) != NULL) {");
  out.push("    const char* name = ent->d_name;");
  out.push("    if (!name || name[0] == '\\0') continue;");
  out.push("    if (strcmp(name, \".\") == 0 || strcmp(name, \"..\") == 0) continue;");
  out.push("    char* child_rel = rel && rel[0] ? vox_path_join2(rel, name) : vox_path_join2(\"\", name);");
  out.push("    char* child_full = vox_path_join2(root, child_rel);");
  out.push("    struct stat st;");
  out.push("    if (stat(child_full, &st) == 0 && S_ISDIR(st.st_mode)) {");
  out.push("      vox_walk_dir(out, root, child_rel);");
  out.push("      vox_impl_free(child_full);");
  out.push("      vox_impl_free(child_rel);");
  out.push("      continue;");
  out.push("    }");
  out.push("    if (vox_str_has_suffix(child_rel, \".vox\")) {");
  out.push("      const char* s = child_rel;");
  out.push("      vox_vec_push(out, &s);");
  out.push("      vox_impl_free(child_full);");
  out.push("      continue;");
  out.push("    }");
  out.push("    vox_impl_free(child_full);");
  out.push("    vox_impl_free(child_rel);");
  out.push("  }");
  out.push("  closedir(d);");
  out.push("  vox_impl_free(full);");
  out.push("}");
  out.push("");
  out.push("vox_vec vox_impl_walk_vox_files(const char* root) {");
  out.push("  if (!root || root[0] == '\\0') root = \".\";");
  out.push("  vox_vec out = vox_vec_new((int32_t)sizeof(const char*));");
  out.push("  vox_walk_dir(&out, root, \"src\");");
  out.push("  vox_walk_dir(&out, root, \"tests\");");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("intptr_t vox_host_sys_write(int32_t fd, void* buf, uintptr_t n) {");
  out.push("#if defined(_WIN32)");
  out.push("  uint32_t wn = n > (uintptr_t)UINT32_MAX ? UINT32_MAX : (uint32_t)n;");
  out.push("  return (intptr_t)_write(fd, buf, (unsigned int)wn);");
  out.push("#else");
  out.push("  return (intptr_t)write(fd, (const void*)buf, (size_t)n);");
  out.push("#endif");
  out.push("}");
  out.push("");
  out.push("typedef struct vox_sync_handle_node { intptr_t h; struct vox_sync_handle_node* next; } vox_sync_handle_node;");
  out.push("static vox_sync_handle_node* vox_sync_handles = NULL;");
  out.push("static void vox_sync_handle_add(intptr_t h) {");
  out.push("  vox_sync_handle_node* n = (vox_sync_handle_node*)vox_impl_malloc(sizeof(vox_sync_handle_node));");
  out.push("  if (!n) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  n->h = h;");
  out.push("  n->next = vox_sync_handles;");
  out.push("  vox_sync_handles = n;");
  out.push("}");
  out.push("static bool vox_sync_handle_live(intptr_t h) {");
  out.push("  vox_sync_handle_node* n = vox_sync_handles;");
  out.push("  while (n) {");
  out.push("    if (n->h == h) return true;");
  out.push("    n = n->next;");
  out.push("  }");
  out.push("  return false;");
  out.push("}");
  out.push("static bool vox_sync_handle_remove(intptr_t h) {");
  out.push("  vox_sync_handle_node** cur = &vox_sync_handles;");
  out.push("  while (*cur) {");
  out.push("    vox_sync_handle_node* n = *cur;");
  out.push("    if (n->h == h) {");
  out.push("      *cur = n->next;");
  out.push("      vox_impl_free(n);");
  out.push("      return true;");
  out.push("    }");
  out.push("    cur = &n->next;");
  out.push("  }");
  out.push("  return false;");
  out.push("}");
  out.push("");
  out.push("typedef struct { atomic_flag lock; int32_t value; } vox_mutex_i32;");
  out.push("typedef struct { _Atomic int32_t value; } vox_atomic_i32;");
  out.push("");
  out.push("intptr_t vox_impl_mutex_i32_new(int32_t init) {");
  out.push("  vox_mutex_i32* m = (vox_mutex_i32*)vox_impl_malloc(sizeof(vox_mutex_i32));");
  out.push("  if (!m) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  atomic_flag_clear(&m->lock);");
  out.push("  m->value = init;");
  out.push("  intptr_t h = (intptr_t)m;");
  out.push("  vox_sync_handle_add(h);");
  out.push("  return h;");
  out.push("}");
  out.push("");
  out.push("int32_t vox_impl_mutex_i32_load(intptr_t h) {");
  out.push("  vox_mutex_i32* m = (vox_mutex_i32*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped mutex handle\"); }");
  out.push("  while (atomic_flag_test_and_set(&m->lock)) {}");
  out.push("  int32_t v = m->value;");
  out.push("  atomic_flag_clear(&m->lock);");
  out.push("  return v;");
  out.push("}");
  out.push("");
  out.push("void vox_impl_mutex_i32_store(intptr_t h, int32_t v) {");
  out.push("  vox_mutex_i32* m = (vox_mutex_i32*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped mutex handle\"); }");
  out.push("  while (atomic_flag_test_and_set(&m->lock)) {}");
  out.push("  m->value = v;");
  out.push("  atomic_flag_clear(&m->lock);");
  out.push("}");
  out.push("");
  out.push("void vox_impl_mutex_i32_drop(intptr_t h) {");
  out.push("  if (!vox_sync_handle_remove(h)) return;");
  out.push("  vox_mutex_i32* m = (vox_mutex_i32*)(intptr_t)h;");
  out.push("  if (!m) return;");
  out.push("  vox_impl_free(m);");
  out.push("}");
  out.push("");
  out.push("intptr_t vox_impl_atomic_i32_new(int32_t init) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)vox_impl_malloc(sizeof(vox_atomic_i32));");
  out.push("  if (!a) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  atomic_store_explicit(&a->value, init, memory_order_seq_cst);");
  out.push("  intptr_t h = (intptr_t)a;");
  out.push("  vox_sync_handle_add(h);");
  out.push("  return h;");
  out.push("}");
  out.push("");
  out.push("int32_t vox_impl_atomic_i32_load(intptr_t h) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_load_explicit(&a->value, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("void vox_impl_atomic_i32_store(intptr_t h, int32_t v) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  atomic_store_explicit(&a->value, v, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("int32_t vox_impl_atomic_i32_fetch_add(intptr_t h, int32_t delta) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_fetch_add_explicit(&a->value, delta, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("int32_t vox_impl_atomic_i32_swap(intptr_t h, int32_t v) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_exchange_explicit(&a->value, v, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("void vox_impl_atomic_i32_drop(intptr_t h) {");
  out.push("  if (!vox_sync_handle_remove(h)) return;");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!a) return;");
  out.push("  vox_impl_free(a);");
  out.push("}");
  out.push("");
  out.push("typedef struct { atomic_flag lock; int64_t value; } vox_mutex_i64;");
  out.push("typedef struct { _Atomic int64_t value; } vox_atomic_i64;");
  out.push("");
  out.push("intptr_t vox_impl_mutex_i64_new(int64_t init) {");
  out.push("  vox_mutex_i64* m = (vox_mutex_i64*)vox_impl_malloc(sizeof(vox_mutex_i64));");
  out.push("  if (!m) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  atomic_flag_clear(&m->lock);");
  out.push("  m->value = init;");
  out.push("  intptr_t h = (intptr_t)m;");
  out.push("  vox_sync_handle_add(h);");
  out.push("  return h;");
  out.push("}");
  out.push("");
  out.push("int64_t vox_impl_mutex_i64_load(intptr_t h) {");
  out.push("  vox_mutex_i64* m = (vox_mutex_i64*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped mutex handle\"); }");
  out.push("  while (atomic_flag_test_and_set(&m->lock)) {}");
  out.push("  int64_t v = m->value;");
  out.push("  atomic_flag_clear(&m->lock);");
  out.push("  return v;");
  out.push("}");
  out.push("");
  out.push("void vox_impl_mutex_i64_store(intptr_t h, int64_t v) {");
  out.push("  vox_mutex_i64* m = (vox_mutex_i64*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped mutex handle\"); }");
  out.push("  while (atomic_flag_test_and_set(&m->lock)) {}");
  out.push("  m->value = v;");
  out.push("  atomic_flag_clear(&m->lock);");
  out.push("}");
  out.push("");
  out.push("void vox_impl_mutex_i64_drop(intptr_t h) {");
  out.push("  if (!vox_sync_handle_remove(h)) return;");
  out.push("  vox_mutex_i64* m = (vox_mutex_i64*)(intptr_t)h;");
  out.push("  if (!m) return;");
  out.push("  vox_impl_free(m);");
  out.push("}");
  out.push("");
  out.push("intptr_t vox_impl_atomic_i64_new(int64_t init) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)vox_impl_malloc(sizeof(vox_atomic_i64));");
  out.push("  if (!a) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  atomic_store_explicit(&a->value, init, memory_order_seq_cst);");
  out.push("  intptr_t h = (intptr_t)a;");
  out.push("  vox_sync_handle_add(h);");
  out.push("  return h;");
  out.push("}");
  out.push("");
  out.push("int64_t vox_impl_atomic_i64_load(intptr_t h) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_load_explicit(&a->value, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("void vox_impl_atomic_i64_store(intptr_t h, int64_t v) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  atomic_store_explicit(&a->value, v, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("int64_t vox_impl_atomic_i64_fetch_add(intptr_t h, int64_t delta) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_fetch_add_explicit(&a->value, delta, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("int64_t vox_impl_atomic_i64_swap(intptr_t h, int64_t v) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_exchange_explicit(&a->value, v, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("void vox_impl_atomic_i64_drop(intptr_t h) {");
  out.push("  if (!vox_sync_handle_remove(h)) return;");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!a) return;");
  out.push("  vox_impl_free(a);");
  out.push("}");
  out.push("");
  out.push("#if defined(_WIN32)");
  out.push("static bool vox_tcp_wait_iocp_once(SOCKET fd, bool want_write, int32_t timeout_ms) {");
  out.push("  if (fd == INVALID_SOCKET) { vox_host_panic(\"invalid tcp handle\"); }");
  out.push("  if (timeout_ms < 0) timeout_ms = 0;");
  out.push("  HANDLE iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);");
  out.push("  if (!iocp) { vox_host_panic(\"tcp wait iocp create failed\"); }");
  out.push("  if (!CreateIoCompletionPort((HANDLE)fd, iocp, (ULONG_PTR)1, 0)) {");
  out.push("    CloseHandle(iocp);");
  out.push("    vox_host_panic(\"tcp wait iocp bind failed\");");
  out.push("  }");
  out.push("  OVERLAPPED ov;");
  out.push("  memset(&ov, 0, sizeof(ov));");
  out.push("  int rc = 0;");
  out.push("  if (want_write) {");
  out.push("    WSABUF buf;");
  out.push("    buf.buf = NULL;");
  out.push("    buf.len = 0;");
  out.push("    DWORD sent = 0;");
  out.push("    rc = WSASend(fd, &buf, 1, &sent, 0, &ov, NULL);");
  out.push("  } else {");
  out.push("    char ch = 0;");
  out.push("    WSABUF buf;");
  out.push("    buf.buf = &ch;");
  out.push("    buf.len = 1;");
  out.push("    DWORD recvd = 0;");
  out.push("    DWORD flags = MSG_PEEK;");
  out.push("    rc = WSARecv(fd, &buf, 1, &recvd, &flags, &ov, NULL);");
  out.push("  }");
  out.push("  if (rc == 0) {");
  out.push("    CloseHandle(iocp);");
  out.push("    return true;");
  out.push("  }");
  out.push("  int wsa_err = WSAGetLastError();");
  out.push("  if (wsa_err != WSA_IO_PENDING) {");
  out.push("    CloseHandle(iocp);");
  out.push("    if (wsa_err == WSAEWOULDBLOCK) return false;");
  out.push("    vox_host_panic(\"tcp wait iocp op failed\");");
  out.push("  }");
  out.push("  DWORD bytes = 0;");
  out.push("  ULONG_PTR key = 0;");
  out.push("  OVERLAPPED* pov = NULL;");
  out.push("  BOOL ok = GetQueuedCompletionStatus(iocp, &bytes, &key, &pov, (DWORD)timeout_ms);");
  out.push("  if (!ok && pov == NULL) {");
  out.push("    DWORD e = GetLastError();");
  out.push("    if (e == WAIT_TIMEOUT) {");
  out.push("      CancelIoEx((HANDLE)fd, &ov);");
  out.push("      DWORD b2 = 0;");
  out.push("      ULONG_PTR k2 = 0;");
  out.push("      OVERLAPPED* p2 = NULL;");
  out.push("      GetQueuedCompletionStatus(iocp, &b2, &k2, &p2, INFINITE);");
  out.push("      CloseHandle(iocp);");
  out.push("      return false;");
  out.push("    }");
  out.push("    CloseHandle(iocp);");
  out.push("    vox_host_panic(\"tcp wait iocp wait failed\");");
  out.push("  }");
  out.push("  CloseHandle(iocp);");
  out.push("  return true;");
  out.push("}");
  out.push("");
  out.push("bool vox_impl_tcp_wait_read(intptr_t h, int32_t timeout_ms) {");
  out.push("  if (h < 0) { vox_host_panic(\"invalid tcp handle\"); }");
  out.push("  SOCKET fd = (SOCKET)(uintptr_t)h;");
  out.push("  return vox_tcp_wait_iocp_once(fd, false, timeout_ms);");
  out.push("}");
  out.push("");
  out.push("bool vox_impl_tcp_wait_write(intptr_t h, int32_t timeout_ms) {");
  out.push("  if (h < 0) { vox_host_panic(\"invalid tcp handle\"); }");
  out.push("  SOCKET fd = (SOCKET)(uintptr_t)h;");
  out.push("  return vox_tcp_wait_iocp_once(fd, true, timeout_ms);");
  out.push("}");
  out.push("#else");
  out.push("static bool vox_tcp_wait_unix_fd(int fd, bool want_write, int32_t timeout_ms) {");
  out.push("  if (fd < 0) { vox_host_panic(\"invalid tcp handle\"); }");
  out.push("  if (timeout_ms < 0) timeout_ms = 0;");
  out.push("#if defined(__linux__)");
  out.push("  int ep = epoll_create1(EPOLL_CLOEXEC);");
  out.push("  if (ep < 0) { vox_host_panic(\"tcp epoll create failed\"); }");
  out.push("  struct epoll_event ev;");
  out.push("  memset(&ev, 0, sizeof(ev));");
  out.push("  ev.events = want_write ? (EPOLLOUT | EPOLLERR | EPOLLHUP) : (EPOLLIN | EPOLLERR | EPOLLHUP);");
  out.push("  ev.data.u64 = 1;");
  out.push("  if (epoll_ctl(ep, EPOLL_CTL_ADD, fd, &ev) != 0) { close(ep); vox_host_panic(\"tcp epoll ctl failed\"); }");
  out.push("  int n = epoll_wait(ep, &ev, 1, timeout_ms);");
  out.push("  int saved = errno;");
  out.push("  close(ep);");
  out.push("  if (n < 0 && saved != EINTR) { vox_host_panic(\"tcp epoll wait failed\"); }");
  out.push("  return n > 0;");
  out.push("#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)");
  out.push("  int kq = kqueue();");
  out.push("  if (kq < 0) { vox_host_panic(\"tcp kqueue create failed\"); }");
  out.push("  struct kevent ch;");
  out.push("  EV_SET(&ch, (uintptr_t)fd, want_write ? EVFILT_WRITE : EVFILT_READ, EV_ADD | EV_ENABLE | EV_ONESHOT, 0, 0, NULL);");
  out.push("  if (kevent(kq, &ch, 1, NULL, 0, NULL) != 0) { close(kq); vox_host_panic(\"tcp kqueue register failed\"); }");
  out.push("  struct timespec ts;");
  out.push("  ts.tv_sec = timeout_ms / 1000;");
  out.push("  ts.tv_nsec = (long)(timeout_ms % 1000) * 1000000L;");
  out.push("  struct kevent ev;");
  out.push("  int n = kevent(kq, NULL, 0, &ev, 1, &ts);");
  out.push("  int saved = errno;");
  out.push("  close(kq);");
  out.push("  if (n < 0 && saved != EINTR) { vox_host_panic(\"tcp kqueue wait failed\"); }");
  out.push("  return n > 0;");
  out.push("#else");
  out.push("  fd_set rfds;");
  out.push("  fd_set wfds;");
  out.push("  FD_ZERO(&rfds);");
  out.push("  FD_ZERO(&wfds);");
  out.push("  if (want_write) { FD_SET(fd, &wfds); } else { FD_SET(fd, &rfds); }");
  out.push("  struct timeval tv;");
  out.push("  tv.tv_sec = timeout_ms / 1000;");
  out.push("  tv.tv_usec = (timeout_ms % 1000) * 1000;");
  out.push("  int n = select(fd + 1, want_write ? NULL : &rfds, want_write ? &wfds : NULL, NULL, &tv);");
  out.push("  if (n < 0 && errno != EINTR) { vox_host_panic(\"tcp select wait failed\"); }");
  out.push("  return n > 0;");
  out.push("#endif");
  out.push("}");
  out.push("");
  out.push("bool vox_impl_tcp_wait_read(intptr_t h, int32_t timeout_ms) {");
  out.push("  return vox_tcp_wait_unix_fd((int)h, false, timeout_ms);");
  out.push("}");
  out.push("");
  out.push("bool vox_impl_tcp_wait_write(intptr_t h, int32_t timeout_ms) {");
  out.push("  return vox_tcp_wait_unix_fd((int)h, true, timeout_ms);");
  out.push("}");
  out.push("#endif");
  out.push("");
  out.push("#if defined(_WIN32)");
  out.push("static void vox_tcp_win_ensure_init(void) {");
  out.push("  static int inited = 0;");
  out.push("  if (inited) return;");
  out.push("  WSADATA wsa;");
  out.push("  int rc = WSAStartup(MAKEWORD(2, 2), &wsa);");
  out.push("  if (rc != 0) { vox_host_panic(\"tcp wsa startup failed\"); }");
  out.push("  inited = 1;");
  out.push("}");
  out.push("");
  out.push("intptr_t vox_impl_tcp_connect(const char* host, int32_t port) {");
  out.push("  vox_tcp_win_ensure_init();");
  out.push("  if (!host) host = \"\";");
  out.push("  if (port <= 0 || port > 65535) { vox_host_panic(\"invalid tcp port\"); }");
  out.push("  char port_buf[16];");
  out.push("  snprintf(port_buf, sizeof(port_buf), \"%\" PRId32, port);");
  out.push("  struct addrinfo hints;");
  out.push("  memset(&hints, 0, sizeof(hints));");
  out.push("  hints.ai_family = AF_UNSPEC;");
  out.push("  hints.ai_socktype = SOCK_STREAM;");
  out.push("  hints.ai_protocol = IPPROTO_TCP;");
  out.push("  struct addrinfo* res = NULL;");
  out.push("  int rc = getaddrinfo(host, port_buf, &hints, &res);");
  out.push("  if (rc != 0 || !res) { vox_host_panic(\"tcp connect resolve failed\"); }");
  out.push("  SOCKET fd = INVALID_SOCKET;");
  out.push("  for (struct addrinfo* p = res; p != NULL; p = p->ai_next) {");
  out.push("    fd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);");
  out.push("    if (fd == INVALID_SOCKET) continue;");
  out.push("    if (connect(fd, p->ai_addr, (int)p->ai_addrlen) == 0) { break; }");
  out.push("    closesocket(fd);");
  out.push("    fd = INVALID_SOCKET;");
  out.push("  }");
  out.push("  freeaddrinfo(res);");
  out.push("  if (fd == INVALID_SOCKET) { vox_host_panic(\"tcp connect failed\"); }");
  out.push("  return (intptr_t)(uintptr_t)fd;");
  out.push("}");
  out.push("");
  out.push("const char* vox_impl_tcp_recv(intptr_t h, int32_t max_n) {");
  out.push("  if (h < 0) { vox_host_panic(\"invalid tcp handle\"); }");
  out.push("  SOCKET fd = (SOCKET)(uintptr_t)h;");
  out.push("  if (fd == INVALID_SOCKET) { vox_host_panic(\"invalid tcp handle\"); }");
  out.push("  if (max_n <= 0) return \"\";");
  out.push("  char* buf = (char*)vox_impl_malloc((size_t)max_n + 1);");
  out.push("  if (!buf) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  int n = recv(fd, buf, max_n, 0);");
  out.push("  if (n < 0) { vox_host_panic(\"tcp recv failed\"); }");
  out.push("  if (n == 0) { buf[0] = '\\0'; return buf; }");
  out.push("  buf[n] = '\\0';");
  out.push("  return buf;");
  out.push("}");
  out.push("");
  out.push("void vox_impl_tcp_close(intptr_t h) {");
  out.push("  if (h < 0) return;");
  out.push("  SOCKET fd = (SOCKET)(uintptr_t)h;");
  out.push("  if (fd == INVALID_SOCKET) return;");
  out.push("  closesocket(fd);");
  out.push("}");
  out.push("#else");
  out.push("intptr_t vox_impl_tcp_connect(const char* host, int32_t port) {");
  out.push("  if (!host) host = \"\";");
  out.push("  if (port <= 0 || port > 65535) { vox_host_panic(\"invalid tcp port\"); }");
  out.push("  char port_buf[16];");
  out.push("  snprintf(port_buf, sizeof(port_buf), \"%\" PRId32, port);");
  out.push("  struct addrinfo hints;");
  out.push("  memset(&hints, 0, sizeof(hints));");
  out.push("  hints.ai_family = AF_UNSPEC;");
  out.push("  hints.ai_socktype = SOCK_STREAM;");
  out.push("  struct addrinfo* res = NULL;");
  out.push("  int rc = getaddrinfo(host, port_buf, &hints, &res);");
  out.push("  if (rc != 0 || !res) { vox_host_panic(\"tcp connect resolve failed\"); }");
  out.push("  int fd = -1;");
  out.push("  for (struct addrinfo* p = res; p != NULL; p = p->ai_next) {");
  out.push("    fd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);");
  out.push("    if (fd < 0) continue;");
  out.push("    if (connect(fd, p->ai_addr, p->ai_addrlen) == 0) { break; }");
  out.push("    close(fd);");
  out.push("    fd = -1;");
  out.push("  }");
  out.push("  freeaddrinfo(res);");
  out.push("  if (fd < 0) { vox_host_panic(\"tcp connect failed\"); }");
  out.push("  return (intptr_t)fd;");
  out.push("}");
  out.push("");
  out.push("const char* vox_impl_tcp_recv(intptr_t h, int32_t max_n) {");
  out.push("  int fd = (int)h;");
  out.push("  if (fd < 0) { vox_host_panic(\"invalid tcp handle\"); }");
  out.push("  if (max_n <= 0) return \"\";");
  out.push("  char* buf = (char*)vox_impl_malloc((size_t)max_n + 1);");
  out.push("  if (!buf) { fprintf(stderr, \"out of memory\\n\"); exit(1); }");
  out.push("  ssize_t n = recv(fd, buf, (size_t)max_n, 0);");
  out.push("  if (n < 0) { vox_host_panic(\"tcp recv failed\"); }");
  out.push("  if (n == 0) { buf[0] = '\\0'; return buf; }");
  out.push("  buf[n] = '\\0';");
  out.push("  return buf;");
  out.push("}");
  out.push("");
  out.push("void vox_impl_tcp_close(intptr_t h) {");
  out.push("  int fd = (int)h;");
  out.push("  if (fd < 0) return;");
  out.push("  close(fd);");
  out.push("}");
  out.push("#endif");
  out.push("");

  // Compatibility aliases for rolling bootstrap:
  // bootstrap compiler may still emit/expect vox_host_* while newer code
  // expects vox_impl_* (or vice versa). Keep both symbol sets available.
  out.push("vox_vec vox_host_args(void) { return vox_impl_args(); }");
  out.push("const char* vox_host_exe_path(void) { return vox_impl_exe_path(); }");
  out.push("const char* vox_host_getenv(const char* key) { return vox_impl_getenv(key); }");
  out.push("int64_t vox_host_now_ns(void) { return vox_impl_now_ns(); }");
  out.push("void vox_host_yield_now(void) { vox_impl_yield_now(); }");
  out.push("void vox_host_wake_notify(int64_t token) { vox_impl_wake_notify(token); }");
  out.push("bool vox_host_wake_wait(int64_t token, int32_t timeout_ms) { return vox_impl_wake_wait(token, timeout_ms); }");
  out.push("int32_t vox_host_exec(const char* cmd) { return vox_impl_exec(cmd); }");
  out.push("vox_vec vox_host_walk_vox_files(const char* root) { return vox_impl_walk_vox_files(root); }");
  out.push("const char* vox_host_read_file(const char* path) { return vox_impl_read_file(path); }");
  out.push("intptr_t vox_host_tcp_connect(const char* host, int32_t port) { return vox_impl_tcp_connect(host, port); }");
  out.push("const char* vox_host_tcp_recv(intptr_t h, int32_t max_n) { return vox_impl_tcp_recv(h, max_n); }");
  out.push("void vox_host_tcp_close(intptr_t h) { vox_impl_tcp_close(h); }");
  out.push("bool vox_host_tcp_wait_read(intptr_t h, int32_t timeout_ms) { return vox_impl_tcp_wait_read(h, timeout_ms); }");
  out.push("bool vox_host_tcp_wait_write(intptr_t h, int32_t timeout_ms) { return vox_impl_tcp_wait_write(h, timeout_ms); }");
  out.push("intptr_t vox_host_mutex_i32_new(int32_t init) { return vox_impl_mutex_i32_new(init); }");
  out.push("int32_t vox_host_mutex_i32_load(intptr_t h) { return vox_impl_mutex_i32_load(h); }");
  out.push("void vox_host_mutex_i32_store(intptr_t h, int32_t v) { vox_impl_mutex_i32_store(h, v); }");
  out.push("void vox_host_mutex_i32_drop(intptr_t h) { vox_impl_mutex_i32_drop(h); }");
  out.push("intptr_t vox_host_atomic_i32_new(int32_t init) { return vox_impl_atomic_i32_new(init); }");
  out.push("int32_t vox_host_atomic_i32_load(intptr_t h) { return vox_impl_atomic_i32_load(h); }");
  out.push("void vox_host_atomic_i32_store(intptr_t h, int32_t v) { vox_impl_atomic_i32_store(h, v); }");
  out.push("int32_t vox_host_atomic_i32_fetch_add(intptr_t h, int32_t delta) { return vox_impl_atomic_i32_fetch_add(h, delta); }");
  out.push("int32_t vox_host_atomic_i32_swap(intptr_t h, int32_t v) { return vox_impl_atomic_i32_swap(h, v); }");
  out.push("void vox_host_atomic_i32_drop(intptr_t h) { vox_impl_atomic_i32_drop(h); }");
  out.push("intptr_t vox_host_mutex_i64_new(int64_t init) { return vox_impl_mutex_i64_new(init); }");
  out.push("int64_t vox_host_mutex_i64_load(intptr_t h) { return vox_impl_mutex_i64_load(h); }");
  out.push("void vox_host_mutex_i64_store(intptr_t h, int64_t v) { vox_impl_mutex_i64_store(h, v); }");
  out.push("void vox_host_mutex_i64_drop(intptr_t h) { vox_impl_mutex_i64_drop(h); }");
  out.push("intptr_t vox_host_atomic_i64_new(int64_t init) { return vox_impl_atomic_i64_new(init); }");
  out.push("int64_t vox_host_atomic_i64_load(intptr_t h) { return vox_impl_atomic_i64_load(h); }");
  out.push("void vox_host_atomic_i64_store(intptr_t h, int64_t v) { vox_impl_atomic_i64_store(h, v); }");
  out.push("int64_t vox_host_atomic_i64_fetch_add(intptr_t h, int64_t delta) { return vox_impl_atomic_i64_fetch_add(h, delta); }");
  out.push("int64_t vox_host_atomic_i64_swap(intptr_t h, int64_t v) { return vox_impl_atomic_i64_swap(h, v); }");
  out.push("void vox_host_atomic_i64_drop(intptr_t h) { vox_impl_atomic_i64_drop(h); }");
  out.push("");

  return out;
}
