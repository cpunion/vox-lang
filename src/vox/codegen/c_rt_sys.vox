fn emit_rt_sys_lines() -> Vec[String] {
  let mut out: Vec[String] = Vec();

  // Runtime builtins
  out.push("static int vox__argc = 0;");
  out.push("static char** vox__argv = NULL;");
  out.push("");
  out.push("extern char* getenv(const char*);");
  out.push("const char* vox_impl_getenv(const char* key) {");
  out.push("  if (!key) key = \"\";");
  out.push("  const char* v = getenv(key);");
  out.push("  if (!v) return \"\";");
  out.push("  return v;");
  out.push("}");
  out.push("");
  out.push("// === Event loop: Vox-driven wake table + platform poller ===");
  out.push("// Forward declarations for atomic functions used by el_init.");
  out.push("intptr_t vox_impl_atomic_i64_new(int64_t init);");
  out.push("intptr_t vox_impl_atomic_i32_new(int32_t init);");
  out.push("#define VOX_EL_SLOTS 256");
  out.push("static intptr_t vox_el_token_h[VOX_EL_SLOTS];");
  out.push("static intptr_t vox_el_pending_h[VOX_EL_SLOTS];");
  out.push("static bool vox_el_inited = false;");
  out.push("");
  out.push("#if defined(__linux__)");
  out.push("static int vox_el_epfd = -1;");
  out.push("static int vox_el_efd = -1;");
  out.push("#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)");
  out.push("static int vox_el_kq = -1;");
  out.push("#elif defined(_WIN32)");
  out.push("static HANDLE vox_el_iocp = NULL;");
  out.push("#endif");
  out.push("");
  out.push("static void vox_el_init_poller(void) {");
  out.push("#if defined(__linux__)");
  out.push("  if (vox_el_epfd >= 0) return;");
  out.push("  vox_el_efd = eventfd(0, VOX_EFD_NONBLOCK | VOX_EFD_CLOEXEC);");
  out.push("  if (vox_el_efd < 0) { vox_host_panic(\"el: eventfd failed\"); }");
  out.push("  vox_el_epfd = epoll_create1(VOX_EPOLL_CLOEXEC);");
  out.push("  if (vox_el_epfd < 0) { vox_host_panic(\"el: epoll_create1 failed\"); }");
  out.push("  char ev[12]; memset(ev, 0, 12);");
  out.push("  *(uint32_t*)ev = VOX_EPOLLIN;");
  out.push("  *(uint64_t*)(ev + 4) = (uint64_t)(uint32_t)vox_el_efd;");
  out.push("  if (epoll_ctl(vox_el_epfd, VOX_EPOLL_CTL_ADD, vox_el_efd, ev) != 0) {");
  out.push("    vox_host_panic(\"el: epoll_ctl failed\");");
  out.push("  }");
  out.push("#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)");
  out.push("  if (vox_el_kq >= 0) return;");
  out.push("  vox_el_kq = kqueue();");
  out.push("  if (vox_el_kq < 0) { vox_host_panic(\"el: kqueue failed\"); }");
  out.push("  char ev[VOX_KEVENT_SZ];");
  out.push("  vox_kev_set(ev, 1, VOX_EVFILT_USER, VOX_EV_ADD | VOX_EV_CLEAR, 0, 0, NULL);");
  out.push("  if (kevent(vox_el_kq, ev, 1, NULL, 0, NULL) != 0) {");
  out.push("    vox_host_panic(\"el: kqueue register failed\");");
  out.push("  }");
  out.push("#elif defined(_WIN32)");
  out.push("  if (vox_el_iocp) return;");
  out.push("  vox_el_iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);");
  out.push("  if (!vox_el_iocp) { vox_host_panic(\"el: IOCP failed\"); }");
  out.push("#endif");
  out.push("}");
  out.push("");
  out.push("void vox_impl_el_init(void) {");
  out.push("  if (vox_el_inited) return;");
  out.push("  for (int i = 0; i < VOX_EL_SLOTS; i++) {");
  out.push("    vox_el_token_h[i] = vox_impl_atomic_i64_new(0);");
  out.push("    vox_el_pending_h[i] = vox_impl_atomic_i32_new(0);");
  out.push("  }");
  out.push("  vox_el_init_poller();");
  out.push("  vox_el_inited = true;");
  out.push("}");
  out.push("");
  out.push("intptr_t vox_impl_el_token_handle(int32_t i) { return vox_el_token_h[i]; }");
  out.push("intptr_t vox_impl_el_pending_handle(int32_t i) { return vox_el_pending_h[i]; }");
  out.push("");
  out.push("void vox_impl_el_poller_wake(void) {");
  out.push("#if defined(__linux__)");
  out.push("  uint64_t one = 1;");
  out.push("  ssize_t n = write(vox_el_efd, &one, sizeof(one));");
  out.push("  (void)n;");
  out.push("#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)");
  out.push("  char ev[VOX_KEVENT_SZ];");
  out.push("  vox_kev_set(ev, 1, VOX_EVFILT_USER, 0, VOX_NOTE_TRIGGER, 0, NULL);");
  out.push("  kevent(vox_el_kq, ev, 1, NULL, 0, NULL);");
  out.push("#elif defined(_WIN32)");
  out.push("  if (vox_el_iocp) PostQueuedCompletionStatus(vox_el_iocp, 1, (ULONG_PTR)1, NULL);");
  out.push("#endif");
  out.push("}");
  out.push("");
  out.push("void vox_impl_el_poller_wait(int32_t timeout_ms) {");
  out.push("  if (timeout_ms < 0) timeout_ms = 0;");
  out.push("#if defined(__linux__)");
  out.push("  char ev[12];");
  out.push("  int n = epoll_wait(vox_el_epfd, ev, 1, timeout_ms);");
  out.push("  if (n > 0) { uint64_t v = 0; while (read(vox_el_efd, &v, sizeof(v)) > 0) {} }");
  out.push("#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)");
  out.push("  struct timespec ts;");
  out.push("  ts.tv_sec = timeout_ms / 1000;");
  out.push("  ts.tv_nsec = (long)(timeout_ms % 1000) * 1000000L;");
  out.push("  char ev[VOX_KEVENT_SZ];");
  out.push("  kevent(vox_el_kq, NULL, 0, ev, 1, &ts);");
  out.push("#elif defined(_WIN32)");
  out.push("  DWORD bytes = 0; ULONG_PTR key = 0; OVERLAPPED* ov = NULL;");
  out.push("  GetQueuedCompletionStatus(vox_el_iocp, &bytes, &key, &ov, (DWORD)timeout_ms);");
  out.push("#elif defined(__EMSCRIPTEN__)");
  out.push("  sched_yield();");
  out.push("#else");
  out.push("  struct timespec ts;");
  out.push("  ts.tv_sec = timeout_ms / 1000;");
  out.push("  ts.tv_nsec = (long)(timeout_ms % 1000) * 1000000L;");
  out.push("  nanosleep(&ts, NULL);");
  out.push("#endif");
  out.push("}");
  out.push("");
  out.push("// Thin wrappers for Vox std/sys (avoid C type conflicts with system headers).");
  out.push("#if !defined(_WIN32) && !defined(__EMSCRIPTEN__)");
  out.push("int32_t vox_impl_clock_gettime(int32_t clk_id, void* tp) {");
  out.push("  return clock_gettime((clockid_t)clk_id, (struct timespec*)tp);");
  out.push("}");
  out.push("#endif");
  out.push("#if defined(_WIN32)");
  out.push("uint64_t vox_impl_get_tick_count64(void) { return GetTickCount64(); }");
  out.push("#endif");
  out.push("#if defined(__EMSCRIPTEN__)");
  out.push("int64_t vox_impl_wasm_clock(void) {");
  out.push("  clock_t c = clock();");
  out.push("  if (c == (clock_t)-1) return 0;");
  out.push("  return (int64_t)c * (int64_t)1000000000 / (int64_t)CLOCKS_PER_SEC;");
  out.push("}");
  out.push("#endif");
  // vox_impl_get_argc / vox_impl_get_argv / vox_impl_argv_get removed:
  // pure Vox code in sys_common.vox reads g_argc/g_argv directly via
  // pointer arithmetic.
  out.push("");
  out.push("// vox_impl_kevent / vox_impl_epoll_ctl / vox_impl_epoll_wait removed:");
  out.push("// headers replaced with forward declarations (void*), so Vox @ffi_import");
  out.push("// can directly call epoll_ctl / epoll_wait / kevent without conflicts.");
  out.push("");
  // Socket FFI wrappers use forward declarations instead of <sys/socket.h>
  // and <netdb.h> to avoid pulling in <sys/epoll.h> indirectly on Linux,
  // which would conflict with our void* epoll forward declarations.
  out.push("#ifndef _WIN32");
  out.push("struct sockaddr;");
  out.push("struct addrinfo;");
  out.push("extern int connect(int, const struct sockaddr*, unsigned int);");
  out.push("extern int bind(int, const struct sockaddr*, unsigned int);");
  out.push("extern int accept(int, struct sockaddr*, unsigned int*);");
  out.push("extern int getaddrinfo(const char*, const char*, const struct addrinfo*, struct addrinfo**);");
  out.push("extern void freeaddrinfo(struct addrinfo*);");
  out.push("extern int setsockopt(int, int, int, const void*, unsigned int);");
  out.push("extern int fcntl(int, int, ...);");
  out.push("int32_t vox_impl_sock_connect(int32_t fd, void* addr, uint32_t len) {");
  out.push("  return connect(fd, (const struct sockaddr*)addr, len);");
  out.push("}");
  out.push("int32_t vox_impl_sock_bind(int32_t fd, void* addr, uint32_t len) {");
  out.push("  return bind(fd, (const struct sockaddr*)addr, len);");
  out.push("}");
  out.push("int32_t vox_impl_sock_accept(int32_t fd, void* addr, void* len_ptr) {");
  out.push("  return accept(fd, (struct sockaddr*)addr, (unsigned int*)len_ptr);");
  out.push("}");
  out.push("int32_t vox_impl_getaddrinfo(const char* node, const char* service, void* hints, void* res_out) {");
  out.push("  return getaddrinfo(node, service, (const struct addrinfo*)hints, (struct addrinfo**)res_out);");
  out.push("}");
  out.push("void vox_impl_freeaddrinfo(void* res) {");
  out.push("  freeaddrinfo((struct addrinfo*)res);");
  out.push("}");
  out.push("int32_t vox_impl_fcntl3(int32_t fd, int32_t cmd, int32_t arg) {");
  out.push("  return fcntl(fd, cmd, arg);");
  out.push("}");
  out.push("int32_t vox_impl_setsockopt(int32_t fd, int32_t level, int32_t name, void* val, uint32_t len) {");
  out.push("  return setsockopt(fd, level, name, (const void*)val, len);");
  out.push("}");
  out.push("#endif");
  out.push("#ifdef _WIN32");
  out.push("#include <winsock2.h>");
  out.push("#include <ws2tcpip.h>");
  out.push("int32_t vox_impl_sock_connect(int32_t fd, void* addr, uint32_t len) {");
  out.push("  return connect((SOCKET)(intptr_t)fd, (const struct sockaddr*)addr, (int)len);");
  out.push("}");
  out.push("int32_t vox_impl_sock_bind(int32_t fd, void* addr, uint32_t len) {");
  out.push("  return bind((SOCKET)(intptr_t)fd, (const struct sockaddr*)addr, (int)len);");
  out.push("}");
  out.push("int32_t vox_impl_sock_accept(int32_t fd, void* addr, void* len_ptr) {");
  out.push("  return (int32_t)accept((SOCKET)(intptr_t)fd, (struct sockaddr*)addr, (int*)len_ptr);");
  out.push("}");
  out.push("int32_t vox_impl_getaddrinfo(const char* node, const char* service, void* hints, void* res_out) {");
  out.push("  return getaddrinfo(node, service, (const struct addrinfo*)hints, (struct addrinfo**)res_out);");
  out.push("}");
  out.push("void vox_impl_freeaddrinfo(void* res) {");
  out.push("  freeaddrinfo((struct addrinfo*)res);");
  out.push("}");
  out.push("int32_t vox_impl_fcntl3(int32_t fd, int32_t cmd, int32_t arg) {");
  out.push("  unsigned long mode = (unsigned long)arg;");
  out.push("  return ioctlsocket((SOCKET)(intptr_t)fd, (long)cmd, &mode);");
  out.push("}");
  out.push("int32_t vox_impl_setsockopt(int32_t fd, int32_t level, int32_t name, void* val, uint32_t len) {");
  out.push("  return setsockopt((SOCKET)(intptr_t)fd, level, name, (const char*)val, (int)len);");
  out.push("}");
  out.push("#endif");
  out.push("");
  out.push("// Struct manipulation (kevent_set, timespec_set_ms, epoll_event_set,");
  out.push("// eventfd_signal, eventfd_drain) migrated to pure Vox in std/sys/poll_*.vox.");
  out.push("#if defined(_WIN32)");
  out.push("intptr_t vox_impl_create_iocp(intptr_t file, intptr_t existing, uintptr_t key, uint32_t threads) {");
  out.push("  return (intptr_t)CreateIoCompletionPort((HANDLE)file, (HANDLE)existing, (ULONG_PTR)key, (DWORD)threads);");
  out.push("}");
  out.push("int32_t vox_impl_post_iocp(intptr_t iocp, uint32_t bytes, uintptr_t key, void* overlapped) {");
  out.push("  return PostQueuedCompletionStatus((HANDLE)iocp, (DWORD)bytes, (ULONG_PTR)key, (LPOVERLAPPED)overlapped) != 0 ? 1 : 0;");
  out.push("}");
  out.push("int32_t vox_impl_get_iocp(intptr_t iocp, void* bytes, void* key, void* overlapped, uint32_t timeout) {");
  out.push("  return GetQueuedCompletionStatus((HANDLE)iocp, (LPDWORD)bytes, (PULONG_PTR)key, (LPOVERLAPPED*)overlapped, (DWORD)timeout) != 0 ? 1 : 0;");
  out.push("}");
  out.push("int32_t vox_impl_close_handle(intptr_t h) {");
  out.push("  return CloseHandle((HANDLE)h) != 0 ? 1 : 0;");
  out.push("}");
  out.push("bool vox_impl_iocp_wait_ms(intptr_t iocp, int32_t timeout_ms) {");
  out.push("  DWORD bytes = 0;");
  out.push("  ULONG_PTR key = 0;");
  out.push("  OVERLAPPED* ov = NULL;");
  out.push("  return GetQueuedCompletionStatus((HANDLE)iocp, &bytes, &key, &ov, (DWORD)timeout_ms) != 0;");
  out.push("}");
  out.push("int32_t vox_impl_win_socket(int32_t domain, int32_t ty, int32_t proto) {");
  out.push("  return (int32_t)socket(domain, ty, proto);");
  out.push("}");
  out.push("int32_t vox_impl_win_listen(int32_t fd, int32_t backlog) {");
  out.push("  return listen((SOCKET)fd, backlog);");
  out.push("}");
  out.push("#endif");
  out.push("");

  return out;
}
