fn emit_rt_fs_lines() -> Vec[String] {
  let mut out: Vec[String] = Vec();

  out.push("static bool vox_str_has_suffix(const char* s, const char* suf) {");
  out.push("  if (!s || !suf) return false;");
  out.push("  size_t n = strlen(s);");
  out.push("  size_t m = strlen(suf);");
  out.push("  if (m > n) return false;");
  out.push("  return memcmp(s + (n - m), suf, m) == 0;");
  out.push("}");
  out.push("");
  out.push("static char* vox_path_join2(const char* a, const char* b) {");
  out.push("  if (!a) a = \"\";");
  out.push("  if (!b) b = \"\";");
  out.push("  size_t na = strlen(a);");
  out.push("  size_t nb = strlen(b);");
  out.push("  bool slash = (na != 0 && a[na - 1] != '/');");
  out.push("  size_t n = na + (slash ? 1 : 0) + nb;");
  out.push("  char* out = (char*)vox_impl_malloc(n + 1);");
  out.push("  if (!out) { vox_host_panic(\"out of memory\"); }");
  out.push("  memcpy(out, a, na);");
  out.push("  size_t j = na;");
  out.push("  if (slash) out[j++] = '/';");
  out.push("  memcpy(out + j, b, nb);");
  out.push("  out[n] = '\\0';");
  out.push("  return out;");
  out.push("}");
  out.push("");
  out.push("static void vox_walk_dir(vox_vec* out, const char* root, const char* rel) {");
  out.push("  char* full = rel && rel[0] ? vox_path_join2(root, rel) : vox_path_join2(root, \"\");");
  out.push("  DIR* d = opendir(full);");
  out.push("  if (!d) { vox_impl_free(full); return; }");
  out.push("  struct dirent* ent;");
  out.push("  while ((ent = readdir(d)) != NULL) {");
  out.push("    const char* name = ent->d_name;");
  out.push("    if (!name || name[0] == '\\0') continue;");
  out.push("    if (strcmp(name, \".\") == 0 || strcmp(name, \"..\") == 0) continue;");
  out.push("    char* child_rel = rel && rel[0] ? vox_path_join2(rel, name) : vox_path_join2(\"\", name);");
  out.push("    char* child_full = vox_path_join2(root, child_rel);");
  out.push("    struct stat st;");
  out.push("    if (stat(child_full, &st) == 0 && S_ISDIR(st.st_mode)) {");
  out.push("      vox_walk_dir(out, root, child_rel);");
  out.push("      vox_impl_free(child_full);");
  out.push("      vox_impl_free(child_rel);");
  out.push("      continue;");
  out.push("    }");
  out.push("    if (vox_str_has_suffix(child_rel, \".vox\")) {");
  out.push("      const char* s = child_rel;");
  out.push("      vox_vec_push(out, &s);");
  out.push("      vox_impl_free(child_full);");
  out.push("      continue;");
  out.push("    }");
  out.push("    vox_impl_free(child_full);");
  out.push("    vox_impl_free(child_rel);");
  out.push("  }");
  out.push("  closedir(d);");
  out.push("  vox_impl_free(full);");
  out.push("}");
  out.push("");
  out.push("vox_vec vox_impl_walk_vox_files(const char* root) {");
  out.push("  if (!root || root[0] == '\\0') root = \".\";");
  out.push("  vox_vec out = vox_vec_new((int32_t)sizeof(const char*));");
  out.push("  vox_walk_dir(&out, root, \"src\");");
  out.push("  vox_walk_dir(&out, root, \"tests\");");
  out.push("  return out;");
  out.push("}");
  out.push("");

  return out;
}
