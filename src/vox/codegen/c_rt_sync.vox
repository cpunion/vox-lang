fn emit_rt_sync_lines() -> Vec[String] {
  let mut out: Vec[String] = Vec();

  out.push("typedef struct vox_sync_handle_node { intptr_t h; struct vox_sync_handle_node* next; } vox_sync_handle_node;");
  out.push("static vox_sync_handle_node* vox_sync_handles = NULL;");
  out.push("static void vox_sync_handle_add(intptr_t h) {");
  out.push("  vox_sync_handle_node* n = (vox_sync_handle_node*)vox_impl_malloc(sizeof(vox_sync_handle_node));");
  out.push("  if (!n) { vox_host_panic(\"out of memory\"); }");
  out.push("  n->h = h;");
  out.push("  n->next = vox_sync_handles;");
  out.push("  vox_sync_handles = n;");
  out.push("}");
  out.push("static bool vox_sync_handle_live(intptr_t h) {");
  out.push("  vox_sync_handle_node* n = vox_sync_handles;");
  out.push("  while (n) {");
  out.push("    if (n->h == h) return true;");
  out.push("    n = n->next;");
  out.push("  }");
  out.push("  return false;");
  out.push("}");
  out.push("static bool vox_sync_handle_remove(intptr_t h) {");
  out.push("  vox_sync_handle_node** cur = &vox_sync_handles;");
  out.push("  while (*cur) {");
  out.push("    vox_sync_handle_node* n = *cur;");
  out.push("    if (n->h == h) {");
  out.push("      *cur = n->next;");
  out.push("      vox_impl_free(n);");
  out.push("      return true;");
  out.push("    }");
  out.push("    cur = &n->next;");
  out.push("  }");
  out.push("  return false;");
  out.push("}");
  out.push("");
  out.push("typedef struct { _Atomic int32_t value; } vox_atomic_i32;");
  out.push("");
  out.push("intptr_t vox_impl_atomic_i32_new(int32_t init) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)vox_impl_malloc(sizeof(vox_atomic_i32));");
  out.push("  if (!a) { vox_host_panic(\"out of memory\"); }");
  out.push("  atomic_store_explicit(&a->value, init, memory_order_seq_cst);");
  out.push("  intptr_t h = (intptr_t)a;");
  out.push("  vox_sync_handle_add(h);");
  out.push("  return h;");
  out.push("}");
  out.push("");
  out.push("int32_t vox_impl_atomic_i32_load(intptr_t h) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_load_explicit(&a->value, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("void vox_impl_atomic_i32_store(intptr_t h, int32_t v) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  atomic_store_explicit(&a->value, v, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("int32_t vox_impl_atomic_i32_fetch_add(intptr_t h, int32_t delta) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_fetch_add_explicit(&a->value, delta, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("int32_t vox_impl_atomic_i32_swap(intptr_t h, int32_t v) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_exchange_explicit(&a->value, v, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("bool vox_impl_atomic_i32_cas(intptr_t h, int32_t expected, int32_t desired) {");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_compare_exchange_strong_explicit(&a->value, &expected, desired, memory_order_seq_cst, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("void vox_impl_atomic_i32_drop(intptr_t h) {");
  out.push("  if (!vox_sync_handle_remove(h)) return;");
  out.push("  vox_atomic_i32* a = (vox_atomic_i32*)(intptr_t)h;");
  out.push("  if (!a) return;");
  out.push("  vox_impl_free(a);");
  out.push("}");
  out.push("");
  out.push("typedef struct { _Atomic int64_t value; } vox_atomic_i64;");
  out.push("");
  out.push("intptr_t vox_impl_atomic_i64_new(int64_t init) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)vox_impl_malloc(sizeof(vox_atomic_i64));");
  out.push("  if (!a) { vox_host_panic(\"out of memory\"); }");
  out.push("  atomic_store_explicit(&a->value, init, memory_order_seq_cst);");
  out.push("  intptr_t h = (intptr_t)a;");
  out.push("  vox_sync_handle_add(h);");
  out.push("  return h;");
  out.push("}");
  out.push("");
  out.push("int64_t vox_impl_atomic_i64_load(intptr_t h) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_load_explicit(&a->value, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("void vox_impl_atomic_i64_store(intptr_t h, int64_t v) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  atomic_store_explicit(&a->value, v, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("int64_t vox_impl_atomic_i64_fetch_add(intptr_t h, int64_t delta) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_fetch_add_explicit(&a->value, delta, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("int64_t vox_impl_atomic_i64_swap(intptr_t h, int64_t v) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_exchange_explicit(&a->value, v, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("bool vox_impl_atomic_i64_cas(intptr_t h, int64_t expected, int64_t desired) {");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!vox_sync_handle_live(h)) { vox_host_panic(\"invalid or dropped atomic handle\"); }");
  out.push("  return atomic_compare_exchange_strong_explicit(&a->value, &expected, desired, memory_order_seq_cst, memory_order_seq_cst);");
  out.push("}");
  out.push("");
  out.push("void vox_impl_atomic_i64_drop(intptr_t h) {");
  out.push("  if (!vox_sync_handle_remove(h)) return;");
  out.push("  vox_atomic_i64* a = (vox_atomic_i64*)(intptr_t)h;");
  out.push("  if (!a) return;");
  out.push("  vox_impl_free(a);");
  out.push("}");
  out.push("");

  return out;
}
