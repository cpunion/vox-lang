import "vox/ir" as ir

pub fn c_type(pool: ir.TyPool, ty_idx: i32) -> String {
  let t: ir.Ty = ir.ty_pool_get(pool, ty_idx);
  if t.kind == ir.TyKind.Param { panic("unresolved type param in codegen"); }
  // Refinement wrappers are represented as their base type in the C backend.
  if t.kind == ir.TyKind.Range || t.kind == ir.TyKind.Verified { return c_type(pool, t.elem); }
  // Ref wrapper: immutable refs are still erased to their base type, while
  // mutable refs (`&mut`) are represented as an inout pointer.
  if t.kind == ir.TyKind.Ref {
    if ir.ty_ref_is_mut(t) {
      return c_type(pool, t.elem).concat("*");
    }
    return c_type(pool, t.elem);
  }
  return match t.kind {
    ir.TyKind.Unit => "vox_unit",
    ir.TyKind.Bool => "bool",
    ir.TyKind.I8 => "int8_t",
    ir.TyKind.U8 => "uint8_t",
    ir.TyKind.I16 => "int16_t",
    ir.TyKind.U16 => "uint16_t",
    ir.TyKind.I32 => "int32_t",
    ir.TyKind.U32 => "uint32_t",
    ir.TyKind.I64 => "int64_t",
    ir.TyKind.U64 => "uint64_t",
    ir.TyKind.ISize => "intptr_t",
    ir.TyKind.USize => "uintptr_t",
    ir.TyKind.RawPtr => if ir.ty_rawptr_is_const(t) { "const void*" } else { "void*" },
    ir.TyKind.F32 => "float",
    ir.TyKind.F64 => "double",
    ir.TyKind.String => "const char*",
    ir.TyKind.Struct => c_struct_type_name(ty_qname(t)),
    ir.TyKind.Enum => c_enum_type_name(ty_qname(t)),
    ir.TyKind.Vec => "vox_vec",
    ir.TyKind.Atomic => "intptr_t",
    _ => "void",
  };
}

pub fn c_ret_type(pool: ir.TyPool, ty_idx: i32) -> String {
  let mut cur: i32 = ty_idx;
  while true {
    let t: ir.Ty = ir.ty_pool_get(pool, cur);
    if t.kind == ir.TyKind.Range || t.kind == ir.TyKind.Verified {
      cur = t.elem;
      continue;
    }
    if t.kind == ir.TyKind.Ref && !ir.ty_ref_is_mut(t) {
      // `&T` is erased to `T` in the C backend (by-value borrow model).
      cur = t.elem;
      continue;
    }
    if t.kind == ir.TyKind.Unit { return "void"; }
    return c_type(pool, ty_idx);
  }
  return c_type(pool, ty_idx);
}
