import "std/testing" as t

fn test_codegen_nominal_dep_on_generic_struct_does_not_false_cycle() -> () {
  // B[T] only references T through A[T]. Codegen must treat B[T] as generic
  // and avoid emitting a false by-value dependency cycle.
  let src: String = """
    struct A[T] { xs: Vec[T] }
    struct B[T] { a: A[T] }
    fn main() -> i32 { return 0; }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "int main(int argc, char** argv) {"));
}

fn test_codegen_generic_result_hides_param_through_nominal_field_smoke() -> () {
  // Regression for false cycle panic when a generic result struct carries a
  // generic nominal field (`Set[T]`) but no direct `T` field.
  let src: String = """
    struct Set[T: Eq] { items: Vec[T] }
    struct SetAddResult[T] { set: Set[T], inserted: bool }
    fn main() -> i32 { return 0; }
  """;
  let c: String = compile_to_c(src);
  t.assert(contains(c, "int main(int argc, char** argv) {"));
}
