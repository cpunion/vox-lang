// Stage1 IR definitions (initial skeleton).
//
// Design note:
// Stage0 (host compiler) currently has no references/pointers in the language core,
// so we model recursive structures using small indices into arenas.

pub enum TyKind {
  Bad,
  Unit,
  Bool,
  // ints
  I8,
  U8,
  I16,
  U16,
  I32,
  U32,
  I64,
  U64,
  ISize,
  USize, // pointer-sized unsigned int (codegen uses uintptr_t)
  RawPtr, // opaque C pointer type for FFI interop (maps to void* / const void* via lo flag)
  F32,
  F64,
  // others
  String,
  Ref, // borrow wrapper; metadata in lo/hi (lo!=0 => mut, hi!=0 => 'static)
  Param,
  Struct,
  Enum,
  Vec,
  Range,
  Verified,
}

pub struct Ty {
  pub kind: TyKind,
  // For nominal types: module path + type name. Otherwise empty.
  pub mod_path: String,
  pub name: String,
  // For Vec/Range/Ref/Verified: element type index in TyPool, otherwise -1.
  pub elem: i32,
  // For Range: inclusive bounds.
  // For Ref: lo!=0 => mut, hi!=0 => 'static.
  // For RawPtr: lo!=0 => const rawptr.
  // For Verified: lo/hi unused.
  pub lo: i64,
  pub hi: i64,
}

pub struct TyPool {
  pub tys: Vec[Ty],
}

pub struct AddTyResult {
  pub pool: TyPool,
  pub idx: i32,
}

pub fn ty_pool() -> TyPool {
  return TyPool { tys: Vec() };
}

pub fn ty_bad() -> Ty { return Ty { kind: TyKind.Bad, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_unit() -> Ty { return Ty { kind: TyKind.Unit, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_bool() -> Ty { return Ty { kind: TyKind.Bool, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_i8() -> Ty { return Ty { kind: TyKind.I8, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_u8() -> Ty { return Ty { kind: TyKind.U8, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_i16() -> Ty { return Ty { kind: TyKind.I16, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_u16() -> Ty { return Ty { kind: TyKind.U16, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_i32() -> Ty { return Ty { kind: TyKind.I32, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_u32() -> Ty { return Ty { kind: TyKind.U32, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_i64() -> Ty { return Ty { kind: TyKind.I64, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_u64() -> Ty { return Ty { kind: TyKind.U64, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_isize() -> Ty { return Ty { kind: TyKind.ISize, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_usize() -> Ty { return Ty { kind: TyKind.USize, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_rawptr() -> Ty { return Ty { kind: TyKind.RawPtr, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_rawptr_const() -> Ty { return Ty { kind: TyKind.RawPtr, mod_path: "", name: "", elem: -1, lo: 1, hi: 0 }; }

pub fn ty_rawptr_is_const(t: Ty) -> bool { return t.kind == TyKind.RawPtr && t.lo != 0; }

pub fn ty_f32() -> Ty { return Ty { kind: TyKind.F32, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_f64() -> Ty { return Ty { kind: TyKind.F64, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_string() -> Ty { return Ty { kind: TyKind.String, mod_path: "", name: "", elem: -1, lo: 0, hi: 0 }; }

pub fn ty_ref(elem: i32, mut0: bool, static0: bool) -> Ty {
  let mv: i64 = if mut0 { 1 } else { 0 };
  let sv: i64 = if static0 { 1 } else { 0 };
  return Ty { kind: TyKind.Ref, mod_path: "", name: "", elem: elem, lo: mv, hi: sv };
}

pub fn ty_ref_is_mut(t: Ty) -> bool { return t.kind == TyKind.Ref && t.lo != 0; }

pub fn ty_ref_is_static(t: Ty) -> bool { return t.kind == TyKind.Ref && t.hi != 0; }

pub fn ty_param(name: String) -> Ty { return Ty { kind: TyKind.Param, mod_path: "", name: name, elem: -1, lo: 0, hi: 0 }; }

pub fn ty_struct(mod_path: String, name: String) -> Ty { return Ty { kind: TyKind.Struct, mod_path: mod_path, name: name, elem: -1, lo: 0, hi: 0 }; }

pub fn ty_enum(mod_path: String, name: String) -> Ty { return Ty { kind: TyKind.Enum, mod_path: mod_path, name: name, elem: -1, lo: 0, hi: 0 }; }

pub fn ty_vec(elem: i32) -> Ty { return Ty { kind: TyKind.Vec, mod_path: "", name: "", elem: elem, lo: 0, hi: 0 }; }

pub fn ty_range(base: i32, lo: i64, hi: i64) -> Ty { return Ty { kind: TyKind.Range, mod_path: "", name: "", elem: base, lo: lo, hi: hi }; }

pub fn ty_verified(base: i32, pred_mod: String, pred_name: String) -> Ty {
  return Ty { kind: TyKind.Verified, mod_path: pred_mod, name: pred_name, elem: base, lo: 0, hi: 0 };
}

pub fn ty_pool_add(pool: TyPool, ty: Ty) -> AddTyResult {
  let mut p: TyPool = pool;
  let mut v: Vec[Ty] = p.tys;
  v.push(ty);
  let idx: i32 = v.len() - 1;
  p.tys = v;
  return AddTyResult { pool: p, idx: idx };
}

pub fn ty_pool_get(pool: TyPool, idx: i32) -> Ty {
  let v: Vec[Ty] = pool.tys;
  return v.get(idx);
}
