import "std:string" as s
import "openai" as openai
import "genai" as genai

pub struct Client {
  pub provider: String,
  pub model: String,
  pub api_key: String,
  pub api_host: String,
  pub api_path: String,
  pub workspace: String,
}

pub fn new(spec: String) -> Client {
  return new_with_workspace(spec, "target/llm");
}

pub fn new_with_workspace(spec: String, workspace: String) -> Client {
  let parsed: genai.ProviderSpec = genai.parse(spec);
  let key0: String = openai.load_api_key(".env");
  let key1: String = if key0 != "" { key0 } else { openai.load_api_key("../../.env") };

  if parsed.provider == "openai" {
    return Client {
      provider: parsed.provider,
      model: parsed.model,
      api_key: key1,
      api_host: openai.default_host(),
      api_path: openai.default_path(),
      workspace: workspace,
    };
  }

  return Client {
    provider: parsed.provider,
    model: parsed.model,
    api_key: "",
    api_host: "",
    api_path: "",
    workspace: workspace,
  };
}

pub fn has_api_key(c: Client) -> bool {
  return c.api_key != "";
}

pub fn endpoint(c: Client) -> String {
  if c.provider == "openai" {
    return openai.endpoint_url(c.api_host, c.api_path);
  }
  return "";
}

pub fn response_is_error(raw: String) -> bool {
  return s.starts_with(s.view_all(raw), "ERROR:");
}

pub fn complete(c: Client, prompt: String) -> String {
  if c.provider == "openai" {
    if c.api_key == "" {
      return "ERROR: missing OPENAI_API_KEY";
    }
    return openai.chat_complete_text(
      c.api_host,
      c.api_path,
      c.model,
      prompt,
      c.api_key,
      c.workspace,
    );
  }
  return "ERROR: unsupported provider: ".concat(c.provider);
}
