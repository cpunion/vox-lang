fn test_syntax_attributes_and_ffi_forms() -> () {
  // SYNTAX:S701 effect/resource attributes
  // SYNTAX:S702 ffi import/export attributes
  // SYNTAX:S703 track_caller attribute
  let src: String = """
@effect(FsRead)
@resource(read, Fs)
fn read() -> i32 { return 1; }
@ffi_import("c", "puts")
fn puts(s: String) -> i32;
@ffi_export("c", "vox_add")
fn add(a: i32, b: i32) -> i32 { return a + b; }
@track_caller
fn who() -> String { return "ok"; }
fn main() -> i32 { return read() + puts(who()); }
""";
  syntax_assert_parse_ok("S701-S703", src);
}

fn test_syntax_repr_c_on_struct() -> () {
  // SYNTAX:S705 repr(C) attribute on struct
  let src: String = """
@repr(C)
struct Addr { family: i32, port: i32 }
fn main() -> i32 { return 0; }
""";
  syntax_assert_parse_ok("S705", src);
}

fn test_syntax_repr_c_on_fn_fails() -> () {
  // SYNTAX:S706 repr(C) attribute on fn should fail
  let bad: String = """
@repr(C)
fn foo() -> i32 { return 0; }
fn main() -> i32 { return 0; }
""";
  syntax_assert_parse_fail("S706", bad);
}

fn test_syntax_repr_bad_arg_fails() -> () {
  // SYNTAX:S707 repr with bad argument should fail
  let bad: String = """
@repr(bad)
struct Foo { x: i32 }
fn main() -> i32 { return 0; }
""";
  syntax_assert_parse_fail("S707", bad);
}

fn test_syntax_invalid_method_track_caller_fails() -> () {
  // SYNTAX:S704 invalid attribute placement should fail parse
  let bad: String = """
struct I { v: i32 }
impl I {
  @track_caller
  fn f(x: I) -> i32 { return x.v; }
}
fn main() -> i32 { return 0; }
""";
  syntax_assert_parse_fail("S704", bad);
}
