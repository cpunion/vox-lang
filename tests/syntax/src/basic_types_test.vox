fn test_syntax_basic_types_and_literals() -> () {
  // SYNTAX:S001 integer and bool types
  // SYNTAX:S002 char and string literals
  // SYNTAX:S003 borrow/ref types
  // SYNTAX:S004 range-annotated integer type
  // SYNTAX:S021 float types and float literal forms
  let src: String = """
fn f(a: i32, b: bool, c: char, d: String, e: &i32, f: &'static str, g: &str, h: &mut i32, i: &'static mut i32, j: f32, k: f64) -> i32 {
  let x: @range(0..=3) i8 = 2 as @range(0..=3) i8;
  let p: f64 = 1.25;
  let q: f32 = 2.5e-2f32;
  let r: f64 = 1e3;
  if b { return a + (x as i32); }
  return c as i32 + d.len() + e.to_string().len() + f.len() + g.len() + h.to_string().len() + i.to_string().len() + (j as i32) + (k as i32) + (p as i32) + (q as i32) + (r as i32);
}
fn main() -> i32 { return f(1, true, 'x', "ok", 1, "s", "t", 1, 1, 2.0f32, 3.0); }
""";
  syntax_assert_parse_ok("S001-S004", src);
}

fn test_syntax_malformed_literal_fails() -> () {
  // SYNTAX:S005 malformed literal should fail parse
  syntax_assert_parse_fail("S005", "fn main() -> i32 { let x: char = 'ab'; return 0; }");
  // SYNTAX:S022 malformed float literal should fail parse
  syntax_assert_parse_fail("S022", "fn main() -> f64 { let x: f64 = 1e+; return x; }");
}

fn test_syntax_multiline_string_unindent() -> () {
  // SYNTAX:S018 triple-quoted multiline string unindent and first-line newline trim
  let src: String = "fn main() -> i32 { let s: String = \"\"\"\n    line1\n      line2\n    line3\n\"\"\"; return s.len(); }";
  syntax_assert_parse_ok("S018", src);
}

fn test_syntax_multiline_string_tab_indent_fails() -> () {
  // SYNTAX:S018 tab indentation in multiline string is rejected
  let src: String = "fn main() -> i32 { let s: String = \"\"\"\n\tbad\n\"\"\"; return s.len(); }";
  syntax_assert_parse_fail("S018-tab-indent", src);
}
