fn test_syntax_generics_const_where_and_pack() -> () {
  // SYNTAX:S301 generic type params and explicit type args
  // SYNTAX:S302 const generics
  // SYNTAX:S303 where trait bounds
  // SYNTAX:S304 where comptime bounds
  // SYNTAX:S305 impl head where comptime
  // SYNTAX:S306 type pack and variadic params
  let src: String = """
trait Eq { fn eq(a: Self, b: Self) -> bool; }
impl Eq for i32 { fn eq(a: i32, b: i32) -> bool { return a == b; } }
fn id[T](x: T) -> T where T: Eq { return x; }
fn addn[const N: i32](x: i32) -> i32 where comptime N > 0 { return x + N; }
fn sum[T](head: T, tail: T...) -> T { return head; }
fn pick_first[T...](a: T.0, _b: T.1) -> T.0 { return a; }
trait Tag { fn tag(x: Self) -> i32; }
impl[T] Tag for Vec[T] where comptime @size_of(T) <= 16 { fn tag(x: Vec[T]) -> i32 { return 1; } }
fn main() -> i32 {
  let mut v: Vec[i32] = Vec();
  v.push(id[i32](7));
  let f: i32 = pick_first[i32, bool](v.get(0), true);
  return addn[2](sum[i32](f, 1, 2)) + Tag.tag(v);
}
""";
  syntax_assert_parse_ok("S301-S306", src);
}

fn test_syntax_bad_generic_arg_list_fails() -> () {
  // SYNTAX:S307 malformed generic argument list should fail parse
  let src: String = """
fn f[T](x: T) -> T { return x; }
fn main() -> i32 { let _x: i32 = f[i32(1); return 0; }
""";
  syntax_assert_parse_fail("S307", src);
}
