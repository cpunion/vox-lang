fn test_syntax_struct_and_enum_forms() -> () {
  // SYNTAX:S006 struct declaration (fields/pub/generics/where)
  // SYNTAX:S007 enum declaration (variants/generics/where)
  // SYNTAX:S008 struct literal and field access
  // SYNTAX:S009 enum constructor and match pattern
  let src: String = """
pub struct Pair[T] where comptime @size_of(T) <= 16 {
  pub a: T,
  b: T,
}

enum Option[T] where comptime @size_of(T) <= 16 {
  Some(T),
  None,
}

fn main() -> i32 {
  let p: Pair[i32] = Pair[i32] { a: 1, b: 2 };
  let o: Option[i32] = Option[i32].Some(p.a + p.b);
  let v: i32 = match o {
    Option.Some(x) => x,
    Option.None => 0,
  };
  return v;
}
""";
  syntax_assert_parse_ok("S006-S009", src);
}

fn test_syntax_malformed_adt_fails() -> () {
  // SYNTAX:S010 malformed struct/enum declaration should fail parse
  let src_struct: String = """
struct Bad { x i32 }
fn main() -> i32 { return 0; }
""";
  syntax_assert_parse_fail("S010-struct-missing-colon", src_struct);

  let src_enum: String = """
enum Bad { A(i32) B }
fn main() -> i32 { return 0; }
""";
  syntax_assert_parse_fail("S010-enum-missing-comma", src_enum);
}

fn test_syntax_enum_dot_variant_shorthand_forms() -> () {
  // SYNTAX:S020 enum dot-variant shorthand constructor and pattern
  let src: String = """
enum Option[T] { Some(T), None }
fn main(flag: bool) -> i32 {
  let o: Option[i32] = if flag { .Some(7) } else { .None };
  return match o {
    .Some(v) => v,
    .None => 0,
  };
}
""";
  syntax_assert_parse_ok("S020", src);
}
