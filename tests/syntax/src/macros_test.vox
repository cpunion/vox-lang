fn test_syntax_macro_call_forms() -> () {
  // SYNTAX:S901 macro call sugar `name!(...)`
  // SYNTAX:S902 builtin macro calls (`compile!`, `quote expr`, `$x` sugar)
  // SYNTAX:S903 macro call with explicit generic/const args
  let src: String = """
fn id(x: i32) -> i32 { return x; }
fn addn[const N: i32](x: i32) -> i32 { return x + N; }
fn mk_plus1(x: AstExpr) -> AstExpr { return quote expr { $x + 1 }; }
fn main() -> i32 {
  let a: i32 = id!(1);
  let b: i32 = id[i32]!(a);
  let c: i32 = addn[3]!(b);
  return compile!(mk_plus1(c));
}
""";
  syntax_assert_parse_ok("S901-S903", src);
}

fn test_syntax_macro_call_missing_paren_fails() -> () {
  // SYNTAX:S904 malformed macro call should fail parse
  syntax_assert_parse_fail("S904", "fn main() -> i32 { return add1! 1; }");
}

fn test_syntax_builtin_introspection_macro_calls() -> () {
  // SYNTAX:S905 builtin introspection macros (`__file!/__line!/__col!/__module_path!/__func!/__caller!`)
  let src: String = """
@track_caller
fn who() -> Caller { return __caller!(); }
struct Caller { file: String, line: i32, col: i32, module: String, func: String }
fn main() -> i32 {
  let f: String = __file!();
  let l: i32 = __line!();
  let c: i32 = __col!();
  let m: String = __module_path!();
  let n: String = __func!();
  let w: Caller = who!();
  if f.len() + m.len() + n.len() + w.file.len() > 0 && l >= 0 && c >= 0 {}
  return 0;
}
""";
  syntax_assert_parse_ok("S905", src);
}

fn test_syntax_builtin_utility_macro_calls() -> () {
  // SYNTAX:S909 builtin utility macros (`dirname!/panic!/compile_error!/assert!/assert_eq!`)
  let src: String = """
fn main() -> i32 {
  let d: String = dirname!(__file!());
  assert!(d.len() >= 0);
  assert_eq!(1 + 1, 2);
  if false { panic!("boom"); }
  if false { compile_error!("compile-time check"); }
  return 0;
}
""";
  syntax_assert_parse_ok("S909", src);
}
