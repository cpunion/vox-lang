fn test_syntax_macro_call_forms() -> () {
  // SYNTAX:S901 macro call sugar `name!(...)`
  // SYNTAX:S902 builtin macro calls (`compile!`, `quote expr`, `$x` sugar)
  // SYNTAX:S903 macro call with explicit generic/const args
  let src: String = """
fn id(x: i32) -> i32 { return x; }
fn addn[const N: i32](x: i32) -> i32 { return x + N; }
fn mk_plus1(x: AstExpr) -> AstExpr { return quote expr { $x + 1 }; }
fn main() -> i32 {
  let a: i32 = id!(1);
  let b: i32 = id[i32]!(a);
  let c: i32 = addn[3]!(b);
  return compile!(mk_plus1(c));
}
""";
  syntax_assert_parse_ok("S901-S903", src);
}

fn test_syntax_macro_call_missing_paren_fails() -> () {
  // SYNTAX:S904 malformed macro call should fail parse
  syntax_assert_parse_fail("S904", "fn main() -> i32 { return add1! 1; }");
}

fn test_syntax_builtin_introspection_macro_calls() -> () {
  // SYNTAX:S905 builtin introspection macros (`file!/line!/col!/module_path!/func!/caller!`)
  let src: String = """
@track_caller
fn who() -> String { return caller!(); }
fn main() -> i32 {
  let f: String = file!();
  let l: i32 = line!();
  let c: i32 = col!();
  let m: String = module_path!();
  let n: String = func!();
  let w: String = who!();
  if f.len() + m.len() + n.len() + w.len() > 0 && l >= 0 && c >= 0 { return 0; }
  return 0;
}
""";
  syntax_assert_parse_ok("S905", src);
}
